{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110",
    "id": 1870736226,
    "node_id": "PR_kwDOABII585vgSti",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30110",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30110.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30110.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/114a5405c41d25962cb895dbd864452e40af5fcc",
    "number": 30110,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "refactor: TxDownloadManager + fuzzing",
    "user": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Part of #27463.\r\n\r\nThis PR does 2 things:\r\n\r\n(1) It modularizes transaction download logic into a `TxDownloadManager`. Transaction download logic refers to the process of deciding what transactions to request, download, and validate.[1] There should be no behavior changes. Using `--color_moved=dimmed_zebra -w` may help.\r\n(2) It adds unit and fuzz (:magic_wand:) testing for transaction download.\r\n\r\nThere are several benefits to this interface, such as:\r\n- Unit test coverage and fuzzing for logic that currently isn't feasible to test as thoroughly (without lots of overhead) and/or currently only lightly tested through `assert_debug_log` (not good) in functional tests.\r\n- When we add more functionality (e.g. package relay messages, more robust orphan handling), the vast majority of it will be within `TxDownloadManager` instead of `PeerManager`, making it easier to review and test. See #28031 for what this looks like.\r\n- `PeerManager` will no longer know anything about / have access to `TxOrphanage`, `TxRequestTracker` or the rejection caches. Its primary interface with `TxDownloadManager` would be much simpler:\r\n    - Passing on  `ValidationInterface` callbacks\r\n    - Telling `txdownloadman` when a peer {connects, disconnects}\r\n    - Telling `txdownloadman`when a {transaction, package} is {accepted, rejected} from mempool\r\n    - Telling `txdownloadman` when invs, notfounds, and txs are received.\r\n    - Getting instructions on what to download.\r\n    - Getting instructions on what {transactions, packages, orphans} to validate.\r\n    - Get whether a peer `HaveMoreWork` for the `ProessMessages` loop\r\n- (todo) Thread-safety can be handled internally.\r\n\r\n[1]: This module is concerned with tx *download*, not upload. It excludes transaction announcements/gossip which happens after we download/accept a transaction. Txreconciliation (erlay) is excluded from this module, as it only relates to deciding which `inv`s to send or helping the other peer decide which `inv`s to send. It is independent from this logic.",
    "labels": [
      {
        "id": 135961,
        "node_id": "MDU6TGFiZWwxMzU5NjE=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
        "name": "Refactoring",
        "color": "E6F6D6",
        "default": false
      }
    ],
    "created_at": "2024-05-15T09:49:51Z",
    "updated_at": "2024-10-02T13:58:03Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "95f63966fe2ddb69751e25b24dc7a1ae7c5ebad0",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "glozow:2024-05-txdownload",
      "ref": "2024-05-txdownload",
      "sha": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 244262754,
        "node_id": "MDEwOlJlcG9zaXRvcnkyNDQyNjI3NTQ=",
        "name": "bitcoin",
        "full_name": "glozow/bitcoin",
        "owner": {
          "login": "glozow",
          "id": 25183001,
          "node_id": "MDQ6VXNlcjI1MTgzMDAx",
          "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/glozow",
          "html_url": "https://github.com/glozow",
          "followers_url": "https://api.github.com/users/glozow/followers",
          "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
          "organizations_url": "https://api.github.com/users/glozow/orgs",
          "repos_url": "https://api.github.com/users/glozow/repos",
          "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/glozow/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/glozow/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/glozow/bitcoin",
        "archive_url": "https://api.github.com/repos/glozow/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/glozow/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/glozow/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/glozow/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/glozow/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/glozow/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/glozow/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/glozow/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/glozow/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/glozow/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/glozow/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/glozow/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/glozow/bitcoin/events",
        "forks_url": "https://api.github.com/repos/glozow/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/glozow/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/glozow/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/glozow/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/glozow/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/glozow/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/glozow/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/glozow/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/glozow/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/glozow/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/glozow/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/glozow/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/glozow/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/glozow/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/glozow/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/glozow/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:glozow/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/glozow/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/glozow/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/glozow/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/glozow/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/glozow/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/glozow/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/glozow/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/glozow/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/glozow/bitcoin/hooks",
        "svn_url": "https://github.com/glozow/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 4,
        "stargazers_count": 12,
        "watchers_count": 12,
        "size": 260289,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-10-02T01:08:55Z",
        "created_at": "2020-03-02T02:31:56Z",
        "updated_at": "2024-09-27T15:50:39Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "fc642c33ef28829eda0119a0fe39fd9bc4b84051",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36221,
        "stargazers_count": 78675,
        "watchers_count": 78675,
        "size": 269316,
        "default_branch": "master",
        "open_issues_count": 671,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-10-02T10:32:23Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-10-02T13:43:24Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 2272,
    "deletions": 546,
    "changed_files": 11,
    "commits": 29,
    "review_comments": 228,
    "comments": 40
  },
  "events": [
    {
      "event": "labeled",
      "id": 12814520687,
      "node_id": "LE_lADOABII586I73RbzwAAAAL7zhFv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12814520687",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T09:49:51Z",
      "label": {
        "name": "Refactoring",
        "color": "E6F6D6"
      }
    },
    {
      "event": "commented",
      "id": 2112063126,
      "node_id": "IC_kwDOABII585944aW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2112063126",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T09:49:54Z",
      "updated_at": "2024-10-02T13:36:42Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30110).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [l0rinc](https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2320844778) |\n| Approach ACK | [ismaelsadeeq](https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2266000970) |\n| Stale ACK | [theStack](https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2278788723), [instagibbs](https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2388665904) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#30572](https://github.com/bitcoin/bitcoin/pull/30572) (Halt processing of unrequested transactions v2 by ariard)\n* [#30538](https://github.com/bitcoin/bitcoin/pull/30538) (Doc: add a comment referencing past vulnerability next to where it was fixed by darosior)\n* [#30116](https://github.com/bitcoin/bitcoin/pull/30116) (p2p: Fill reconciliation sets (Erlay) attempt 2 by sr-gi)\n* [#29492](https://github.com/bitcoin/bitcoin/pull/29492) (refactor: Remove redundant definitions by Empact)\n* [#27052](https://github.com/bitcoin/bitcoin/pull/27052) (test: rpc: add last block announcement time to getpeerinfo result by LarryRuane)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2112063126",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12815424268,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL729sM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12815424268",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T10:56:42Z"
    },
    {
      "event": "labeled",
      "id": 12815426811,
      "node_id": "LE_lADOABII586I73RbzwAAAAL72-T7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12815426811",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T10:56:47Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2112197018,
      "node_id": "IC_kwDOABII58595ZGa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2112197018",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T10:56:48Z",
      "updated_at": "2024-05-15T10:56:48Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\nðŸš§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/24992798939</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2112197018",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12816213418,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL75-Wq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12816213418",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T11:48:55Z"
    },
    {
      "event": "labeled",
      "id": 12818928839,
      "node_id": "LE_lADOABII586I73RbzwAAAAL8EVTH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12818928839",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T14:29:43Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12820032462,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL8IivO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12820032462",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T15:41:54Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12820339471,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL8JtsP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12820339471",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T16:05:46Z"
    },
    {
      "event": "unlabeled",
      "id": 12820814985,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAL8LhyJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12820814985",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T16:46:41Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12850950471,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL9-fFH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12850950471",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T16:31:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12863629085,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL-u2cd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12863629085",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T09:21:52Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12864617124,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL-ynqk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12864617124",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T10:50:36Z"
    },
    {
      "event": "commented",
      "id": 2120203238,
      "node_id": "IC_kwDOABII585-X7vm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2120203238",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T10:55:50Z",
      "updated_at": "2024-05-20T10:55:50Z",
      "author_association": "MEMBER",
      "body": "Rebased for #29817 and added a \"ensure we can always download a tx as long as we have 1 good outbound peer\" fuzz test",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2120203238",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "reviewed",
      "id": 2066059450,
      "node_id": "PRR_kwDOABII5857JZC6",
      "url": null,
      "actor": null,
      "commit_id": "b1cc0c3006ca608f9ac3af2c50c4728cbbc07714",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2066059450",
      "submitted_at": "2024-05-20T12:32:10Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "unlabeled",
      "id": 12865893706,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAL-3fVK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12865893706",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T12:50:48Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12879661785,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL_sArZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12879661785",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-21T12:44:01Z"
    },
    {
      "event": "labeled",
      "id": 13018644142,
      "node_id": "LE_lADOABII586I73RbzwAAAAMH-L6u",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13018644142",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-03T10:22:44Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13066058978,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAMKzDzi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13066058978",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T12:35:40Z"
    },
    {
      "event": "commented",
      "id": 2152299577,
      "node_id": "IC_kwDOABII586ASXw5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2152299577",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T12:36:07Z",
      "updated_at": "2024-06-06T12:36:07Z",
      "author_association": "MEMBER",
      "body": "rebased",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2152299577",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "unlabeled",
      "id": 13067048338,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAMK21WS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13067048338",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T13:44:06Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 13103488822,
      "node_id": "LE_lADOABII586I73RbzwAAAAMNB182",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13103488822",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-10T15:33:20Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13113775508,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAMNpFWU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13113775508",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T09:28:15Z"
    },
    {
      "event": "unlabeled",
      "id": 13114655329,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAMNscJh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13114655329",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T10:13:00Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2160481789,
      "node_id": "IC_kwDOABII586AxlX9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2160481789",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T11:13:28Z",
      "updated_at": "2024-06-11T11:13:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\nðŸš§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/26067441690</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2160481789",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "labeled",
      "id": 13115463860,
      "node_id": "LE_lADOABII586I73RbzwAAAAMNvhi0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13115463860",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T11:13:28Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13116090985,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAMNx6pp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13116090985",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T12:03:56Z"
    },
    {
      "event": "unlabeled",
      "id": 13118368318,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAMN6mo-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13118368318",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T14:38:23Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 13191777405,
      "node_id": "LE_lADOABII586I73RbzwAAAAMSSox9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13191777405",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-17T21:17:32Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2178131655,
      "node_id": "IC_kwDOABII586B06bH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2178131655",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-19T08:53:23Z",
      "updated_at": "2024-06-19T08:53:23Z",
      "author_association": "MEMBER",
      "body": "Planning to rebase on master along with #30111 when it's merged",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2178131655",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13522454088,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAMmAEZI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13522454088",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-16T14:44:21Z"
    },
    {
      "event": "labeled",
      "id": 13523802304,
      "node_id": "LE_lADOABII586I73RbzwAAAAMmFNjA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13523802304",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-16T16:06:58Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2231313948,
      "node_id": "IC_kwDOABII586E_yYc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2231313948",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-16T16:06:59Z",
      "updated_at": "2024-07-16T16:06:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/27514949081</sub>\n\n<details><summary>Hints</summary>\n\nMake sure to run all tests locally, according to the documentation.\n\nThe failure may happen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2231313948",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "unlabeled",
      "id": 13523893782,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAMmFj4W",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13523893782",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-16T16:14:49Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "referenced",
      "id": 13626848434,
      "node_id": "REFE_lADOABII586I73RbzwAAAAMsOTSy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13626848434",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "96072770322955ebf66fa643a419c3715cc15e35",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96072770322955ebf66fa643a419c3715cc15e35",
      "created_at": "2024-07-24T08:30:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13633560092,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAMsn54c",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13633560092",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-24T16:46:03Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13646084899,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAMtXrsj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13646084899",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T13:47:11Z"
    },
    {
      "event": "ready_for_review",
      "id": 13647909229,
      "node_id": "RFRE_lADOABII586I73RbzwAAAAMtepFt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13647909229",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T15:11:52Z"
    },
    {
      "event": "unlabeled",
      "id": 13651128824,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAMtq7H4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13651128824",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T18:00:09Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2252636668,
      "node_id": "IC_kwDOABII586GRIH8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2252636668",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-26T12:14:28Z",
      "updated_at": "2024-07-26T12:14:28Z",
      "author_association": "MEMBER",
      "body": "Rebased, ready for review.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2252636668",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "labeled",
      "id": 13723240266,
      "node_id": "LE_lADOABII586I73RbzwAAAAMx-AdK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13723240266",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-01T09:49:23Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13725930535,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAMyIRQn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13725930535",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-01T13:14:46Z"
    },
    {
      "event": "commented",
      "id": 2263048941,
      "node_id": "IC_kwDOABII586G42Lt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2263048941",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-01T13:29:12Z",
      "updated_at": "2024-08-01T13:29:12Z",
      "author_association": "MEMBER",
      "body": "Rebased for #30413",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2263048941",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "unlabeled",
      "id": 13726969808,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAMyMO_Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13726969808",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-01T14:14:20Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "renamed",
      "id": 13806837983,
      "node_id": "RTE_lADOABII586I73RbzwAAAAM286Df",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13806837983",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-08T13:18:16Z",
      "rename": {
        "from": "refactor: TxDownloadManager",
        "to": "refactor: TxDownloadManager + fuzzing"
      }
    },
    {
      "event": "reviewed",
      "id": 2230413202,
      "node_id": "PRR_kwDOABII586E8WeS",
      "url": null,
      "actor": null,
      "commit_id": "b03c8c439fd3e93369b07d6d6e8eb44fef34c536",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "Theschorpioen",
        "id": 161136729,
        "node_id": "U_kgDOCZrAWQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/161136729?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Theschorpioen",
        "html_url": "https://github.com/Theschorpioen",
        "followers_url": "https://api.github.com/users/Theschorpioen/followers",
        "following_url": "https://api.github.com/users/Theschorpioen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Theschorpioen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Theschorpioen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Theschorpioen/subscriptions",
        "organizations_url": "https://api.github.com/users/Theschorpioen/orgs",
        "repos_url": "https://api.github.com/users/Theschorpioen/repos",
        "events_url": "https://api.github.com/users/Theschorpioen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Theschorpioen/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2230413202",
      "submitted_at": "2024-08-09T14:52:41Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "reviewed",
      "id": 2236038602,
      "node_id": "PRR_kwDOABII586FRz3K",
      "url": null,
      "actor": null,
      "commit_id": "b03c8c439fd3e93369b07d6d6e8eb44fef34c536",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nLightly reviewed about half of the refactoring commits, left some non-critical stuff and comments on the way below.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2236038602",
      "submitted_at": "2024-08-13T17:43:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13877476818,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAM7KX3S",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13877476818",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-14T09:55:08Z"
    },
    {
      "event": "reviewed",
      "id": 2237602476,
      "node_id": "PRR_kwDOABII586FXxqs",
      "url": null,
      "actor": null,
      "commit_id": "04856ed32c17ce60e9c503d92b21092a0f9ac271",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Thanks @theStack!",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2237602476",
      "submitted_at": "2024-08-14T09:55:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "commented",
      "id": 2288403119,
      "node_id": "IC_kwDOABII586IZkKv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2288403119",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-14T10:32:53Z",
      "updated_at": "2024-08-14T10:32:53Z",
      "author_association": "MEMBER",
      "body": "Would it help if I put the test/fuzz changes in a separate PR from the refactoring changes? It would make the first PR less exciting to review, but perhaps easier to review?",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2288403119",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2288433763,
      "node_id": "IC_kwDOABII586IZrpj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2288433763",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-14T10:50:29Z",
      "updated_at": "2024-08-14T10:50:29Z",
      "author_association": "MEMBER",
      "body": "> Would it help if I put the test/fuzz changes in a separate PR from the refactoring changes? It would make the first PR less exciting to review, but perhaps easier to review?\r\n\r\nUp to you, but there is a small benefit of going with the fuzz tests first (if possible), in that they first run on master (and pass), and then on the refactor changes (and pass as well). For unit tests this can be achieved by just putting them in an early commit and then running the tests for all commits. For fuzz tests, it is a bit more difficult, because fuzz inputs need to exist. (Also, some fuzz task sanitizers are only run in external CI, because they take a long time)",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2288433763",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2288512730,
      "node_id": "IC_kwDOABII586IZ-7a",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2288512730",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-14T11:37:02Z",
      "updated_at": "2024-08-14T11:37:02Z",
      "author_association": "MEMBER",
      "body": "> Up to you, but there is a small benefit of going with the fuzz tests first (if possible)\r\n\r\nIt looks like the tests here mostly operate on the split out modules after the refactoring, as opposed to a implementation agnostic test through the p2p interface (which would be a giant pita to write). So splitting the fuzz test out would be fine as they don't directly assert that no behavior changes are made. It would of course be sad if we split them out and then only the refactoring lands (which has happened before).",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2288512730",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2288577940,
      "node_id": "IC_kwDOABII586IaO2U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2288577940",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-14T12:12:04Z",
      "updated_at": "2024-08-14T12:12:04Z",
      "author_association": "MEMBER",
      "body": "> > to you, but there is a small benefit of going with the fuzz tests first (if possible)\r\n> \r\n> It looks like the tests here mostly operate on the split out modules after the refactoring, as opposed to a implementation agnostic test through the p2p interface (which would be a giant pita to write).\r\n\r\nIndeed, all of these tests require the refactors (on master we'd have to create a chain to fire validation events + construct actual transactions with each type of invalidity).\r\n\r\n> So splitting the fuzz test out would be fine as they don't directly assert that no behavior changes are made. It would of course be sad if we split them out and then only the refactoring lands (which has happened before).\r\n\r\nIf people like the fuzz tests (concept acks would be nice), I'll split them off to make this PR smaller, and keep the unit tests in here. I just don't want to create 2 big PRs that nobody is interested in.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2288577940",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2288892100,
      "node_id": "IC_kwDOABII586IbbjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2288892100",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-14T14:11:41Z",
      "updated_at": "2024-08-14T14:11:41Z",
      "author_association": "MEMBER",
      "body": "personally speaking I'm unsure what is gained by moving the fuzz tests to their own PR since they depend on the refactors. I don't think we want to merge the other commits unless the fuzz harnesses are attached to it. I'm continuing to review either way.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2288892100",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2289016249,
      "node_id": "IC_kwDOABII586Ib525",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2289016249",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-14T14:45:11Z",
      "updated_at": "2024-08-15T10:18:46Z",
      "author_association": "MEMBER",
      "body": "> I don't think we want to merge the other commits unless the fuzz harnesses are attached to it. I'm continuing to review either way.\r\n\r\nOk sounds good, I'll leave as is. Just hoping to make review easier.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2289016249",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "labeled",
      "id": 13908953655,
      "node_id": "LE_lADOABII586I73RbzwAAAAM9Cco3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13908953655",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-16T10:06:47Z",
      "label": {
        "name": "Needs CMake port",
        "color": "0e8a16"
      }
    },
    {
      "event": "reviewed",
      "id": 2245996944,
      "node_id": "PRR_kwDOABII586F3zGQ",
      "url": null,
      "actor": null,
      "commit_id": "04856ed32c17ce60e9c503d92b21092a0f9ac271",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reviewed all refactorings through 388c2f5d7ee5f38cbefaff0c85cf298083127299\r\n\r\nPretty straight forward the whole way through.\r\n\r\ngoing to spend time reviewing/testing the fuzz portions next",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2245996944",
      "submitted_at": "2024-08-20T13:56:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "reviewed",
      "id": 2248150197,
      "node_id": "PRR_kwDOABII586GAAy1",
      "url": null,
      "actor": null,
      "commit_id": "04856ed32c17ce60e9c503d92b21092a0f9ac271",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ok I reviewed the unit and fuzz tests.\r\n\r\nFor the tx_download fuzz target there's a couple issues:\r\n\r\n1) the time could adversarially be moved forward only 1ms at a time, 100k iterations results in 100 seconds. I hacked the target to *only* allow the forced good peer to respond to the getdata. I got a case where the while loop exits when only 100 seconds have passed in simulated time. Stalling peer A refuses to send TX, then after 60 seconds, at the same time, an honest peer and stalling peer connect and offer the same INV. First INV times out, then second stalling peer gets chosen as next CANIDATE_BEST. Runs out of iterations 40 seconds later.\r\n\r\n2) More annoyingly, the case I found had instability. I *think* it's because TxRequests' `PriorityComputer` is not being set to deterministic random even when TxDownloadMan is. So sometimes the case was passing due to the ordering of the candidates based on this randomness.\r\n\r\nIn general I think this last fuzz target should try to target more on the end of \"only one good peer\", at least switch to that with a bool, since I think when allowing all peers to perhaps be somewhat good, it hides potential issues.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2248150197",
      "submitted_at": "2024-08-20T20:48:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13959246557,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANACTLd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13959246557",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-21T11:54:40Z"
    },
    {
      "event": "reviewed",
      "id": 2250344089,
      "node_id": "PRR_kwDOABII586GIYaZ",
      "url": null,
      "actor": null,
      "commit_id": "e6acb19b87473e9aaa9ec59a3f83b02ef06970b4",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Pushed to address the first batch of comments, going to work on test parts next",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2250344089",
      "submitted_at": "2024-08-21T11:55:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "commented",
      "id": 2301983925,
      "node_id": "IC_kwDOABII586JNXy1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2301983925",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-21T12:53:39Z",
      "updated_at": "2024-08-21T12:53:39Z",
      "author_association": "MEMBER",
      "body": "The naming of the files and tests is a bit inconsistent, I would suggest the following:\r\n\r\n* `txdownloadman.h`, `txdownloadman.cpp`, `txdownloadman_impl.h` and `txdownloadman_impl.cpp` with the classes: `TxDownloadManager` and `TxDownloadManagerImpl`\r\n* `fuzz/txdownloadman.cpp`: `txdownloadman` + `txdownloadman_impl`\r\n* `fuzz/txdownloadman_one_honest_peer.cpp`: `txdownloadman_one_honest_peer`\r\n\r\nI don't care about the specific names just the consistency, e.g. don't mix `tx_download` and `txdownload` or `txdownloadman` and `txdownload`. The test names should roughly convey what is being tested as well.\r\n\r\nI'm fuzzing all the harnesses atm, should have coverage reports up by tomorrow.",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2301983925",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "labeled",
      "id": 13960299449,
      "node_id": "LE_lADOABII586I73RbzwAAAANAGUO5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13960299449",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-21T13:12:55Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13961556845,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANALHNt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13961556845",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-21T14:38:57Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13961724534,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANALwJ2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13961724534",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-21T14:49:32Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13963352300,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANAR9js",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13963352300",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-21T16:26:37Z"
    },
    {
      "event": "unlabeled",
      "id": 13964244503,
      "node_id": "UNLE_lADOABII586I73RbzwAAAANAVXYX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13964244503",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-21T17:38:23Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2251681805,
      "node_id": "PRR_kwDOABII586GNfAN",
      "url": null,
      "actor": null,
      "commit_id": "bbec8e261467637ce26ecf551b528d9061cf4ffe",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reviewed through bbec8e261467637ce26ecf551b528d9061cf4ffe\r\n\r\nvia `git range-diff master 388c2f5d7ee5f38cbefaff0c85cf298083127299 bbec8e261467637ce26ecf551b528d9061cf4ffe`\r\n\r\nLGTM aside from waiting on fuzzer coverage results + fixes",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2251681805",
      "submitted_at": "2024-08-21T19:06:33Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "commented",
      "id": 2304631078,
      "node_id": "IC_kwDOABII586JXeEm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2304631078",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-22T13:08:22Z",
      "updated_at": "2024-08-22T13:08:22Z",
      "author_association": "MEMBER",
      "body": "Doesn't look like `ReceivedTx` ever returns a package to validate in any of the fuzz tests (500 CPU hours each):\r\n\r\n* http://bitcoind-fuzz.dergoegge.de:8000/bitcoin-pr30110/harnesses/txdownload_impl/coverage_report/coverage/workdir/bitcoin/src/test/fuzz/txdownloadman.cpp.html#L352\r\n* http://bitcoind-fuzz.dergoegge.de:8000/bitcoin-pr30110/harnesses/txdownloadman/coverage_report/coverage/workdir/bitcoin/src/test/fuzz/txdownloadman.cpp.html#L213\r\n* http://bitcoind-fuzz.dergoegge.de:8000/bitcoin-pr30110/harnesses/tx_download/coverage_report/coverage/workdir/bitcoin/src/test/fuzz/tx_download.cpp.html#L307",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2304631078",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2304734471,
      "node_id": "IC_kwDOABII586JX3UH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2304734471",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-22T13:53:36Z",
      "updated_at": "2024-08-22T13:53:36Z",
      "author_association": "MEMBER",
      "body": "> Doesn't look like ReceivedTx ever returns a package to validate in any of the fuzz tests (500 CPU hours each):\r\n\r\nAt a minimum `TESTED_TX_RESULTS` is missing `TxValidationResult::TX_RECONSIDERABLE`, so nothing is ever failing for the right reason to try a package.\r\n\r\nI restricted the set of possible transactions down to just a parent/child combo in TRANSACTIONS and was able to trigger it quickly, so it's likely reachable with that one change.\r\n",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2304734471",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "reviewed",
      "id": 2254802540,
      "node_id": "PRR_kwDOABII586GZY5s",
      "url": null,
      "actor": null,
      "commit_id": "0de01c034e2977516d11f370efa1495d9b9577b0",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2254802540",
      "submitted_at": "2024-08-22T15:02:42Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "commented",
      "id": 2304916648,
      "node_id": "IC_kwDOABII586JYjyo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2304916648",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-22T15:06:29Z",
      "updated_at": "2024-08-22T15:09:28Z",
      "author_association": "MEMBER",
      "body": "`3yTMzMzMzMzMzMzMzMw2lcV+LVVYVVX//y1maZY/xcWVxX5VWFVVVVUlugr///8tZmlVCg==` for txdownloadman target\r\n\r\nif you add `TX_RECONSIDERABLE` to the end of `TESTED_TX_RESULTS`, this should crash because it found a package to try\r\n\r\n",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2304916648",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13990719826,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANB6XFS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13990719826",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-23T09:32:00Z"
    },
    {
      "event": "commented",
      "id": 2306692234,
      "node_id": "IC_kwDOABII586JfVSK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2306692234",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-23T09:32:44Z",
      "updated_at": "2024-08-23T09:32:44Z",
      "author_association": "MEMBER",
      "body": "> TESTED_TX_RESULTS is missing TxValidationResult::TX_RECONSIDERABLE\r\n\r\nThat's an oversight, I've added that and UNKNOWN now which should mean we see packages.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2306692234",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "reviewed",
      "id": 2257071619,
      "node_id": "PRR_kwDOABII586GiC4D",
      "url": null,
      "actor": null,
      "commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2257071619",
      "submitted_at": "2024-08-23T12:07:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "reviewed",
      "id": 2257097696,
      "node_id": "PRR_kwDOABII586GiJPg",
      "url": null,
      "actor": null,
      "commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2257097696",
      "submitted_at": "2024-08-23T12:20:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "reviewed",
      "id": 2257108313,
      "node_id": "PRR_kwDOABII586GiL1Z",
      "url": null,
      "actor": null,
      "commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2257108313",
      "submitted_at": "2024-08-23T12:26:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "commented",
      "id": 2307077927,
      "node_id": "IC_kwDOABII586Jgzcn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2307077927",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-23T13:17:41Z",
      "updated_at": "2024-08-23T13:17:41Z",
      "author_association": "MEMBER",
      "body": "```\r\n$ FUZZ=txdownload_impl src/test/fuzz/fuzz solution-60b4aafd2c355198b269114d31545a12b9059fd6.txt\r\ntest/fuzz/txdownloadman.cpp:384 operator(): Assertion `!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256())' failed.\r\n```\r\n\r\n[solution-60b4aafd2c355198b269114d31545a12b9059fd6.txt](https://github.com/user-attachments/files/16729173/solution-60b4aafd2c355198b269114d31545a12b9059fd6.txt)",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2307077927",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2307124171,
      "node_id": "IC_kwDOABII586Jg-vL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2307124171",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-23T13:42:09Z",
      "updated_at": "2024-08-23T13:43:58Z",
      "author_association": "MEMBER",
      "body": "> [solution-60b4aafd2c355198b269114d31545a12b9059fd6.txt](https://github.com/user-attachments/files/16729173/solution-60b4aafd2c355198b269114d31545a12b9059fd6.txt)\r\n\r\n`Find1P1CPackage` doesn't actually check the normal reject filter at all with respect to the child, only reconsiderable, so that assertion gets hit. I suspect that's something we don't want it to do, even if it's not possible to hit inside net_processing.\r\n\r\nLGTM modulo existing concerns about the `tx_download_one_honest_peer` harness:\r\n\r\n1) no det rand for tx_request module in downloadman, leading to instability\r\n2) timesteps can be so small that the tx is never downloaded in 100 seconds\r\n3) scenario should flip a bool to *only* allow the good peer to hand over real tx\r\n\r\nreviewed via `git range-diff master bbec8e261467637ce26ecf551b528d9061cf4ffe 6a84ab77f36445fd37d46a08c71bd4373201d300`",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2307124171",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13994597009,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANCJJqR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13994597009",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-23T15:09:18Z"
    },
    {
      "event": "commented",
      "id": 2307287556,
      "node_id": "IC_kwDOABII586JhmoE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2307287556",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-23T15:09:46Z",
      "updated_at": "2024-08-23T15:09:46Z",
      "author_association": "MEMBER",
      "body": "> Find1P1CPackage doesn't actually check the normal reject filter at all with respect to the child, only reconsiderable, so that assertion gets hit. \r\n\r\nI think it might be more that `MempoolRejectedTx` doesn't remember if a tx failed for a different reason before considering an orphan?",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2307287556",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "reviewed",
      "id": 2257590987,
      "node_id": "PRR_kwDOABII586GkBrL",
      "url": null,
      "actor": null,
      "commit_id": "dda6a394fab46adbe5a37a5b93f64daf6f738b34",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Reviewed up to e164614e32010bc8061cc99ed486188235efa780 (i.e. everything modulo fuzz and unit tests in the last 3 commits), lgtm so far.\r\n\r\nSlightly off-topic, but: on some commits like 4e58d84da95d97d64f563b5c3e116769cd9ff89b `--color-moved=dimmed-zebra` didn't detect any lines as move-only for me (with 2-3 exceptions that seem completely arbitrary), any suggestions for advanced git options and/or recommendations for other fancy diff tools that can cope with that? (Or well, maybe I should just try with a newer git version.)",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2257590987",
      "submitted_at": "2024-08-23T16:24:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14027224767,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANEFna_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14027224767",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:45:07Z"
    },
    {
      "event": "commented",
      "id": 2312348384,
      "node_id": "IC_kwDOABII586J06Lg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2312348384",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:49:56Z",
      "updated_at": "2024-08-27T11:49:56Z",
      "author_association": "MEMBER",
      "body": "Thanks @dergoegge @theStack @instagibbs! Addressed all comments.\r\n\r\n> Slightly off-topic, but: on some commits like https://github.com/bitcoin/bitcoin/commit/4e58d84da95d97d64f563b5c3e116769cd9ff89b --color-moved=dimmed-zebra didn't detect any lines as move-only for me (with 2-3 exceptions that seem completely arbitrary), any suggestions for advanced git options and/or recommendations for other fancy diff tools that can cope with that?\r\n\r\nI see that happen too :( very annoying. Sometimes if I see there are indentation changes, adding a `-w` or manually (un)indenting helps the diff display better. Unfortunately I don't have any other tips.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2312348384",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "mentioned",
      "id": 14027288771,
      "node_id": "MEE_lADOABII586I73RbzwAAAANEF3DD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14027288771",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:49:57Z"
    },
    {
      "event": "subscribed",
      "id": 14027288788,
      "node_id": "SE_lADOABII586I73RbzwAAAANEF3DU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14027288788",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:49:57Z"
    },
    {
      "event": "mentioned",
      "id": 14027288811,
      "node_id": "MEE_lADOABII586I73RbzwAAAANEF3Dr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14027288811",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:49:57Z"
    },
    {
      "event": "subscribed",
      "id": 14027288827,
      "node_id": "SE_lADOABII586I73RbzwAAAANEF3D7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14027288827",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:49:58Z"
    },
    {
      "event": "mentioned",
      "id": 14027288843,
      "node_id": "MEE_lADOABII586I73RbzwAAAANEF3EL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14027288843",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:49:58Z"
    },
    {
      "event": "subscribed",
      "id": 14027288857,
      "node_id": "SE_lADOABII586I73RbzwAAAANEF3EZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14027288857",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:49:58Z"
    },
    {
      "event": "commented",
      "id": 2312603309,
      "node_id": "IC_kwDOABII586J14at",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2312603309",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T13:42:58Z",
      "updated_at": "2024-08-27T13:42:58Z",
      "author_association": "MEMBER",
      "body": "ACK 6f6fc1464ad2f2981e7c3ff5d6492f60f89a6504\r\n\r\nAttends to my concerns with the fuzz tests. Now in `txdownloadman_one_honest_peer` no \"non-good\" peer will ever deliver `TX_REAL`, ensuring that the test is actually testing what we want. Determinstic randomness was also given to the member txrequest modules. \r\n\r\nLastly, minimum time skips were increased to 100ms, meaning 100ms*100000=~166 minutes of simulated time. Since there are up to 8+120=128 peers, this means each peer can stall out the node for a full minute and we still have 40 minutes left for the honest peer to succeed in giving the tx.\r\n\r\nIf you touch this again, I might suggest adding some static asserts to the above effect in case people want to modify these values in the future.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2312603309",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "review_requested",
      "id": 14029086971,
      "node_id": "RRE_lADOABII586I73RbzwAAAANEMuD7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14029086971",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T13:43:03Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 2312787737,
      "node_id": "IC_kwDOABII586J2lcZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2312787737",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T14:51:57Z",
      "updated_at": "2024-08-27T14:54:47Z",
      "author_association": "MEMBER",
      "body": "Just posting in case someone else learns something. Not asking for any changes:\r\n\r\n> Lastly, minimum time skips were increased to 100ms, meaning 100ms*100000=~166 minutes of simulated time. Since there are up to 8+120=128 peers, this means each peer can stall out the node for a full minute and we still have 40 minutes left for the honest peer to succeed in giving the tx.\r\n\r\nAfter doing more study, I think this simulation \"only\" needs a little more than 7 minutes minimum time, since the internal PriorityComputer will always select outbounds(prefered) out of the set of `CANDIDATE_READY`s. Incoming connections will be passed over for the good(and outgoing) peer once the good peer sends `INV_REAL` when choosing new CANIDATE_BEST.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2312787737",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "reviewed",
      "id": 2266000970,
      "node_id": "PRR_kwDOABII586HEG5K",
      "url": null,
      "actor": null,
      "commit_id": "6f6fc1464ad2f2981e7c3ff5d6492f60f89a6504",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Approach ACK\r\n\r\n",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2266000970",
      "submitted_at": "2024-08-28T12:57:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14046697772,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANFP5ks",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14046697772",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-28T13:31:09Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14046876232,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANFQlJI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14046876232",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-28T13:42:11Z"
    },
    {
      "event": "commented",
      "id": 2315385164,
      "node_id": "IC_kwDOABII586KAflM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2315385164",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-28T13:53:50Z",
      "updated_at": "2024-08-28T13:53:50Z",
      "author_association": "MEMBER",
      "body": "Rebased for cmake",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2315385164",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "reviewed",
      "id": 2266475743,
      "node_id": "PRR_kwDOABII586HF6zf",
      "url": null,
      "actor": null,
      "commit_id": "2b387a156a1021ad782dc4de2fd34d5b5b81698a",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reACK 2b387a156a1021ad782dc4de2fd34d5b5b81698a\r\n\r\nvia `git range-diff master 6f6fc1464ad2f2981e7c3ff5d6492f60f89a6504 2b387a156a1021ad782dc4de2fd34d5b5b81698a`\r\n\r\nonly non-cmake changes I see were reordering the class renaming, and the added `ConnectedPeer` in unit tests.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2266475743",
      "submitted_at": "2024-08-28T14:34:35Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "review_requested",
      "id": 14047985399,
      "node_id": "RRE_lADOABII586I73RbzwAAAANFUz73",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14047985399",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-28T14:34:40Z",
      "requested_reviewer": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 2316022026,
      "node_id": "IC_kwDOABII586KC7EK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2316022026",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-28T18:40:09Z",
      "updated_at": "2024-08-28T18:40:09Z",
      "author_association": "MEMBER",
      "body": "Interesting proposal to review; note to self to look at why move peer dis(connection) logic.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2316022026",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "unlabeled",
      "id": 14059641724,
      "node_id": "UNLE_lADOABII586I73RbzwAAAANGBRt8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14059641724",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-29T10:43:43Z",
      "label": {
        "name": "Needs CMake port",
        "color": "0e8a16"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14106458095,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANIz3fv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14106458095",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-02T18:35:02Z"
    },
    {
      "event": "commented",
      "id": 2325191289,
      "node_id": "IC_kwDOABII586Kl5p5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2325191289",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-02T18:36:23Z",
      "updated_at": "2024-09-02T18:36:23Z",
      "author_association": "MEMBER",
      "body": "Rebased for autotools removal, and made the txdownloadman_one_honest_peer fuzzer more interesting. Dishonest peers now have a lot of different transactions/invs they can send that can fail for more reasons.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2325191289",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "reviewed",
      "id": 2278214287,
      "node_id": "PRR_kwDOABII586HysqP",
      "url": null,
      "actor": null,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reACK 1d4e33e7f88162cf6fcd6aee0b63973015853591\r\n\r\ndidn't run the new fuzz test iteration though it seems reasonable to me\r\n\r\nvia `git range-diff master 2b387a156a1021ad782dc4de2fd34d5b5b81698a 1d4e33e7f88162cf6fcd6aee0b63973015853591`",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2278214287",
      "submitted_at": "2024-09-03T20:43:40Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "reviewed",
      "id": 2278788723,
      "node_id": "PRR_kwDOABII586H045z",
      "url": null,
      "actor": null,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Light review ACK 1d4e33e7f88162cf6fcd6aee0b63973015853591\r\n\r\nReviewed the refactoring changes and the unit tests thouroughly, but didn't ran or look in-depth at the fuzz tests.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2278788723",
      "submitted_at": "2024-09-05T10:46:44Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "commented",
      "id": 2331616132,
      "node_id": "IC_kwDOABII586K-aOE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2331616132",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-05T12:57:55Z",
      "updated_at": "2024-09-05T12:57:55Z",
      "author_association": "MEMBER",
      "body": "Thanks for the reviews  ðŸ™\r\n\r\nI've created a followups PR #30820\r\n\r\nAfter that will be the second part of #28031 (\"try multiple peers for orphan resolution\"). I'll open a separate PR, since it has 140 comments. After that, I plan to open a PR that moves `m_tx_download_mutex` inside `TxDownloadManagerImpl` (i.e. make it internally thread-safe), which I mention in the PR description here. I had considered making it the next step, but I think waiting a little more is better because\r\n(1) It gives the fuzzers more time to run + test that txdownloadman can handle interleaved calls and stay internally inconsistent.\r\n(2) There is currently a function called from both peerman and within txdownloadman, but that will go away, making the lock changes cleaner.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2331616132",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "review_requested",
      "id": 14161323559,
      "node_id": "RRE_lADOABII586I73RbzwAAAANMFKYn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14161323559",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-06T12:24:39Z",
      "requested_reviewer": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 2307779875,
      "node_id": "PRR_kwDOABII586Jje0j",
      "url": null,
      "actor": null,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2307779875",
      "submitted_at": "2024-09-16T21:27:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDg1ZWRhZjI1NTZjOWNlNTMxNTczZGMzZGVlOGZmZjJmN2I0ZDlhYmY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/85edaf2556c9ce531573dc3dee8fff2f7b4d9abf",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/85edaf2556c9ce531573dc3dee8fff2f7b4d9abf",
      "tree": {
        "sha": "a0ea73897d229797f9fdd0ef90de3201478ed0db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a0ea73897d229797f9fdd0ef90de3201478ed0db"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a74bdeea1b8e27b2335f0f7da78006e87ecfb235",
          "sha": "a74bdeea1b8e27b2335f0f7da78006e87ecfb235",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a74bdeea1b8e27b2335f0f7da78006e87ecfb235"
        }
      ],
      "message": "[refactor] add TxDownloadManager wrapping TxOrphanage, TxRequestTracker, and bloom filters\n\nThis module is going to be responsible for managing everything related\nto transaction download, including txrequest, orphan transactions and\npackage relay. It will be responsible for managing usage of the\nTxOrphanage and instructing PeerManager:\n- what tx or package-related messages to send to which peer\n- whether a tx or package-related message is allowed or useful\n- what transactions are available to try accepting to mempool\n\nFuture commits will consolidate the interface and re-delegate\ninteractions from PeerManager to TxDownloadManager.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-17T00:28:19Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2022-05-01T17:41:53Z"
      },
      "sha": "85edaf2556c9ce531573dc3dee8fff2f7b4d9abf"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14282606458,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANTT0d6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14282606458",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-17T00:32:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14282613141,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANTT2GV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14282613141",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-17T00:33:39Z"
    },
    {
      "event": "commented",
      "id": 2355149293,
      "node_id": "IC_kwDOABII586MYLnt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2355149293",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-17T10:03:51Z",
      "updated_at": "2024-09-17T10:03:51Z",
      "author_association": "CONTRIBUTOR",
      "body": "Ran `txdownloadman_impl` and it crashed on this assertion:\r\n```\r\noperator(): Assertion `!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256())' failed.\r\n```\r\nBase64 of the input: 4d3Myytlcf9a3czLK2UxoFrjzMtlMQBSWt3Myyv//w==\r\n\r\nInput file if it's any easier: \r\n[txdownload_impl_crash.txt](https://github.com/user-attachments/files/17026573/txdownload_impl_crash.txt)\r\n",
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2355149293",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2355865265,
      "node_id": "IC_kwDOABII586Ma6ax",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2355865265",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-17T13:46:25Z",
      "updated_at": "2024-09-17T13:47:08Z",
      "author_association": "MEMBER",
      "body": "@marcofleon Example checks out, it's pretty simple: \r\n1) txA is called with `txdownload_impl.MempoolRejectedTx` and `TX_RECONSIDERABLE`\r\n2) txA is called with `txdownload_impl.MempoolRejectedTx` and `TX_NOT_STANDARD` or any failure that results in entry to reject filter\r\n3) `ReceivedTx` is called with txA, child is found in orphanage, package returned even though txA is in both filters.\r\n\r\nI think it'd make sense for `ReceivedTx` to abort trying to find a package if the parent is in reject filter, even if also in recent reject filter.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2355865265",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "mentioned",
      "id": 14291703706,
      "node_id": "MEE_lADOABII586I73RbzwAAAANT2hea",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14291703706",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-17T13:46:26Z"
    },
    {
      "event": "subscribed",
      "id": 14291703722,
      "node_id": "SE_lADOABII586I73RbzwAAAANT2heq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14291703722",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-17T13:46:26Z"
    },
    {
      "event": "reviewed",
      "id": 2310444165,
      "node_id": "PRR_kwDOABII586JtpSF",
      "url": null,
      "actor": null,
      "commit_id": "5724926a9b2c7b7d35fc5176caf3710d8aa2f098",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2310444165",
      "submitted_at": "2024-09-17T17:52:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14299484355,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANUUNDD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14299484355",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-17T23:45:13Z"
    },
    {
      "event": "commented",
      "id": 2357211750,
      "node_id": "IC_kwDOABII586MgDJm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2357211750",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-17T23:45:26Z",
      "updated_at": "2024-09-17T23:45:26Z",
      "author_association": "MEMBER",
      "body": "> Ran txdownloadman_impl and it crashed on this assertion:\r\n\r\n> I think it'd make sense for ReceivedTx to abort trying to find a package if the parent is in reject filter, even if also in recent reject filter.\r\n\r\nThanks @marcofleon @instagibbs! Was able to reproduce the crash.\r\n\r\nI hadn't noticed that quirk about the nested `if` conditions before - we were kind of expecting that a tx wouldn't have multiple things wrong with it. I agree it makes more sense to quit on anything that's non-reconsiderable `AlreadyHaveTx`, added that as its own commit. The input shouldn't crash anymore.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2357211750",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "mentioned",
      "id": 14299485544,
      "node_id": "MEE_lADOABII586I73RbzwAAAANUUNVo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14299485544",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-17T23:45:27Z"
    },
    {
      "event": "subscribed",
      "id": 14299485553,
      "node_id": "SE_lADOABII586I73RbzwAAAANUUNVx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14299485553",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-17T23:45:27Z"
    },
    {
      "event": "mentioned",
      "id": 14299485565,
      "node_id": "MEE_lADOABII586I73RbzwAAAANUUNV9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14299485565",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-17T23:45:27Z"
    },
    {
      "event": "subscribed",
      "id": 14299485573,
      "node_id": "SE_lADOABII586I73RbzwAAAANUUNWF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14299485573",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-17T23:45:27Z"
    },
    {
      "event": "commented",
      "id": 2358175361,
      "node_id": "IC_kwDOABII586MjuaB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2358175361",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-18T11:07:21Z",
      "updated_at": "2024-09-18T11:20:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "```\r\noperator(): Assertion `!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256())' failed.\r\n```\r\n\r\n```\r\nZT8AAAD/////ZaOjaf/y/////f39/f39odAq0KMAZWU+qOHh4eHdzMsrZTKgWuPMyytlcaBaZWVl\r\nMaBaK8vczGUx/wwAUlrdzMsrZTGgWuPMyytlcaBa2WVl//////8xoFrczMsrZTEAUlrdzMsrZTGg\r\nWuMrZTH/DABS/////w==\r\n```\r\n\r\n[txdownload_impl_crash.txt](https://github.com/user-attachments/files/17042820/txdownload_impl_crash.txt)\r\n\r\nChild is still in reject filter? Still (slowly and steadily) working through the PR as a whole, so I'm not much help for now when it comes to actually addressing the bug...",
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2358175361",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2358480289,
      "node_id": "IC_kwDOABII586Mk42h",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2358480289",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-18T13:30:29Z",
      "updated_at": "2024-09-18T13:30:29Z",
      "author_association": "MEMBER",
      "body": "@glozow could we get a unit test for that specific behavior change :pray: \r\n\r\n@marcofleon I presume it's simply things that \"shouldn't happen\":\r\n0) Parent `MempoolRejectedTx`, put in reconsiderable filter\r\n1) Child`MempoolRejectedTx`, put in orphanage\r\n2) Child `MempoolRejectedTx` for other reason, now in reject filter\r\n3) Parent `ReceivedTx`, found in reconsiderable filter, fetches package with fully rejected child\r\n\r\nI'd feel better if we also simply not return a package we should never consider, even if it \"shouldn't happen\"",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2358480289",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "mentioned",
      "id": 14307785126,
      "node_id": "MEE_lADOABII586I73RbzwAAAANUz3mm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14307785126",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-18T13:30:31Z"
    },
    {
      "event": "subscribed",
      "id": 14307785156,
      "node_id": "SE_lADOABII586I73RbzwAAAANUz3nE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14307785156",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-18T13:30:31Z"
    },
    {
      "event": "mentioned",
      "id": 14307785190,
      "node_id": "MEE_lADOABII586I73RbzwAAAANUz3nm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14307785190",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-18T13:30:31Z"
    },
    {
      "event": "subscribed",
      "id": 14307785205,
      "node_id": "SE_lADOABII586I73RbzwAAAANUz3n1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14307785205",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-18T13:30:31Z"
    },
    {
      "event": "reviewed",
      "id": 2312673209,
      "node_id": "PRR_kwDOABII586J2Je5",
      "url": null,
      "actor": null,
      "commit_id": "8973b72f5f29e0a4789d6e0fd5a2fd6fa4b5efc3",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2312673209",
      "submitted_at": "2024-09-18T13:30:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "commented",
      "id": 2359409218,
      "node_id": "IC_kwDOABII586MobpC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2359409218",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-18T21:09:22Z",
      "updated_at": "2024-09-18T21:09:22Z",
      "author_association": "MEMBER",
      "body": ">     1. Child`MempoolRejectedTx`, put in orphanage\r\n> \r\n>     2. Child `MempoolRejectedTx` for other reason, now in reject filter\r\n\r\nOn first glance that sounds impossible, `MempoolRejectedTx` should have erased it from orphanage? Will look into the error",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2359409218",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2359531099,
      "node_id": "IC_kwDOABII586Mo5Zb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2359531099",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-18T22:26:14Z",
      "updated_at": "2024-09-18T22:26:14Z",
      "author_association": "MEMBER",
      "body": "Ah, I think it was bugs in the if/else logic in `MempoolRejectedTx`. The flow should be:\r\n\r\n```\r\nif (missing inputs) {\r\n  if (first time and not already rejected) {\r\n    consider keeping orphan...\r\n  }\r\n  return\r\n} else if (error A) {\r\n  special A stuff\r\n} else if (error B) {\r\n  special B stuff\r\n} else {\r\n  cache rejections, etc\r\n}\r\n```\r\n\r\nBut we (1) dropped the return early and (2) didn't have nested `if`s, so we started caching orphans in recent rejects. I'll work on writing more unit tests. I also think it would maybe be clearer albeit more verbose to rewrite that function as a big switch statement...",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2359531099",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14314756896,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANVOdsg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14314756896",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-18T22:26:35Z"
    },
    {
      "event": "labeled",
      "id": 14315858042,
      "node_id": "LE_lADOABII586I73RbzwAAAANVSqh6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14315858042",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-19T00:51:33Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14331533294,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANWOdfu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14331533294",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-19T23:48:41Z"
    },
    {
      "event": "unlabeled",
      "id": 14332273916,
      "node_id": "UNLE_lADOABII586I73RbzwAAAANWRST8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14332273916",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-20T01:02:48Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2363454663,
      "node_id": "IC_kwDOABII586M33TH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2363454663",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-20T11:02:31Z",
      "updated_at": "2024-09-20T11:02:31Z",
      "author_association": "MEMBER",
      "body": "Fixed ci",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2363454663",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "reviewed",
      "id": 2318522392,
      "node_id": "PRR_kwDOABII586KMdgY",
      "url": null,
      "actor": null,
      "commit_id": "e9458eb6cea461861857a3e55d3bbc300363faae",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2318522392",
      "submitted_at": "2024-09-20T14:53:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14345783643,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANXE0lb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14345783643",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-20T20:46:05Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14355578964,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANXqMBU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14355578964",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-22T21:19:06Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14355695223,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANXqoZ3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14355695223",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-22T22:23:42Z"
    },
    {
      "event": "labeled",
      "id": 14355695374,
      "node_id": "LE_lADOABII586I73RbzwAAAANXqocO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14355695374",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-22T22:23:47Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2366991204,
      "node_id": "IC_kwDOABII586NFWtk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2366991204",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-22T22:23:48Z",
      "updated_at": "2024-09-22T22:23:48Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/30495116864</sub>\n\n<details><summary>Hints</summary>\n\nMake sure to run all tests locally, according to the documentation.\n\nThe failure may happen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2366991204",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "unlabeled",
      "id": 14355831557,
      "node_id": "UNLE_lADOABII586I73RbzwAAAANXrJsF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14355831557",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-22T23:32:05Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2320844778,
      "node_id": "PRR_kwDOABII586KVUfq",
      "url": null,
      "actor": null,
      "commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nI went over the code a few times and tried to document my immediate observations.\r\nI understand if you think some comments are outside the scope of this PR - I'll provide a higher-level review later, once I understand the problem better. I still need a few iterations to be able to zoom out and comment meaningfully, for now I only left nits about implementation specifics, modernization attempts, potential off-by-one errors, readability suggestions, etc.\r\n\r\n<details>\r\n<summary>Suggestions Patch</summary>\r\n\r\n```patch\r\nIndex: src/node/txdownloadman_impl.h\r\n<+>UTF-8\r\n===================================================================\r\ndiff --git a/src/node/txdownloadman_impl.h b/src/node/txdownloadman_impl.h\r\n--- a/src/node/txdownloadman_impl.h\t(revision b543dc083ddbf43bb172b60ddb90609a600c86b5)\r\n+++ b/src/node/txdownloadman_impl.h\t(date 1727088265499)\r\n@@ -10,14 +10,15 @@\r\n #include <consensus/validation.h>\r\n #include <kernel/chain.h>\r\n #include <net.h>\r\n-#include <primitives/transaction.h>\r\n #include <policy/packages.h>\r\n+#include <primitives/transaction.h>\r\n #include <txorphanage.h>\r\n #include <txrequest.h>\r\n \r\n class CTxMemPool;\r\n namespace node {\r\n-class TxDownloadManagerImpl {\r\n+class TxDownloadManagerImpl\r\n+{\r\n public:\r\n     TxDownloadOptions m_opts;\r\n \r\n@@ -105,7 +106,7 @@\r\n     /*\r\n      * Filter for transactions that have been recently confirmed.\r\n      * We use this to avoid requesting transactions that have already been\r\n-     * confirnmed.\r\n+     * confirmed.\r\n      *\r\n      * Blocks don't typically have more than 4000 transactions, so this should\r\n      * be at least six blocks (~1 hr) worth of transactions that we can store,\r\nIndex: src/node/txdownloadman_impl.cpp\r\n<+>UTF-8\r\n===================================================================\r\ndiff --git a/src/node/txdownloadman_impl.cpp b/src/node/txdownloadman_impl.cpp\r\n--- a/src/node/txdownloadman_impl.cpp\t(revision b543dc083ddbf43bb172b60ddb90609a600c86b5)\r\n+++ b/src/node/txdownloadman_impl.cpp\t(date 1727088443418)\r\n@@ -2,8 +2,8 @@\r\n // Distributed under the MIT software license, see the accompanying\r\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n \r\n-#include <node/txdownloadman_impl.h>\r\n #include <node/txdownloadman.h>\r\n+#include <node/txdownloadman_impl.h>\r\n \r\n #include <chain.h>\r\n #include <consensus/validation.h>\r\n@@ -84,7 +84,8 @@\r\n     return m_impl->CheckIsEmpty(nodeid);\r\n }\r\n \r\n-// TxDownloadManagerImpl\r\n+// ---------\r\n+\r\n void TxDownloadManagerImpl::ActiveTipChange()\r\n {\r\n     RecentRejectsFilter().reset();\r\n@@ -121,30 +122,9 @@\r\n bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\r\n {\r\n     const uint256& hash = gtxid.GetHash();\r\n-\r\n-    if (gtxid.IsWtxid()) {\r\n-        // Normal query by wtxid.\r\n-        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\r\n-    } else {\r\n-        // Never query by txid: it is possible that the transaction in the orphanage has the same\r\n-        // txid but a different witness, which would give us a false positive result. If we decided\r\n-        // not to request the transaction based on this result, an attacker could prevent us from\r\n-        // downloading a transaction by intentionally creating a malleated version of it.  While\r\n-        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\r\n-        // discerning which one that is, so the orphanage can store multiple transactions with the\r\n-        // same txid.\r\n-        //\r\n-        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\r\n-        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\r\n-        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\r\n-        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\r\n-    }\r\n-\r\n-    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\r\n+    if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\r\n \r\n-    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\r\n-\r\n-    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\r\n+    return (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) || RecentConfirmedTransactionsFilter().contains(hash) || RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\r\n }\r\n \r\n void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\r\n@@ -152,7 +132,7 @@\r\n     // If already connected (shouldn't happen in practice), exit early.\r\n     if (m_peer_info.contains(nodeid)) return;\r\n \r\n-    m_peer_info.emplace(nodeid, PeerInfo(info));\r\n+    m_peer_info.try_emplace(nodeid, info);\r\n     if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\r\n }\r\n \r\n@@ -161,9 +141,9 @@\r\n     m_orphanage.EraseForPeer(nodeid);\r\n     m_txrequest.DisconnectedPeer(nodeid);\r\n \r\n-    if (m_peer_info.contains(nodeid)) {\r\n-        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\r\n-        m_peer_info.erase(nodeid);\r\n+    if (auto it = m_peer_info.find(nodeid); it != m_peer_info.end()) {\r\n+        if (it->second.m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\r\n+        m_peer_info.erase(it);\r\n     }\r\n }\r\n \r\n@@ -171,11 +151,12 @@\r\n {\r\n     // If this is an inv received from a peer and we already have it, we can drop it.\r\n     // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\r\n-    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\r\n+    // we *do* want to request parents that are in RecentRejectsReconsiderableFilter, since they can be CPFP'd.\r\n     if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\r\n \r\n-    if (m_peer_info.count(peer) == 0) return false;\r\n-    const auto& info = m_peer_info.at(peer).m_connection_info;\r\n+    auto it = m_peer_info.find(peer);\r\n+    if (it == m_peer_info.end()) return false;\r\n+    const auto& info = it->second.m_connection_info;\r\n     if (!info.m_relay_permissions && m_txrequest.Count(peer) >= MAX_PEER_TX_ANNOUNCEMENTS) {\r\n         // Too many queued announcements for this peer\r\n         return false;\r\n@@ -259,20 +240,14 @@\r\n     //\r\n     // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\r\n     // pairs in which both were provided by the same peer, i.e. delete this step.\r\n-    const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\r\n-\r\n+    auto cpfp_candidates_different_peer = m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid);\r\n     // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\r\n     // create a bias that attackers can use to delay package acceptance.\r\n     //\r\n-    // Create a random permutation of the indices.\r\n-    std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\r\n-    std::iota(tx_indices.begin(), tx_indices.end(), 0);\r\n-    std::shuffle(tx_indices.begin(), tx_indices.end(), m_opts.m_rng);\r\n-\r\n-    for (const auto index : tx_indices) {\r\n+    std::shuffle(cpfp_candidates_different_peer.begin(), cpfp_candidates_different_peer.end(), m_opts.m_rng);\r\n+    for (const auto& [child_tx, child_sender] : cpfp_candidates_different_peer) {\r\n         // If we already tried a package and failed for any reason, the combined hash was\r\n-        // cached in m_lazy_recent_rejects_reconsiderable.\r\n-        const auto [child_tx, child_sender] = cpfp_candidates_different_peer.at(index);\r\n+        // cached in RecentRejectsReconsiderableFilter.\r\n         Package maybe_cpfp_package{ptx, child_tx};\r\n         if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\r\n             return PackageToValidate{ptx, child_tx, nodeid, child_sender};\r\n@@ -300,7 +275,7 @@\r\n     // Whether we should call AddToCompactExtraTransactions at the end\r\n     bool add_extra_compact_tx{first_time_failure};\r\n     // Hashes to pass to AddKnownTx later\r\n-    std::vector<uint256> unique_parents;\r\n+    std::set<uint256> unique_parents;\r\n     // Populated if failure is reconsiderable and eligible package is found.\r\n     std::optional<node::PackageToValidate> package_to_validate;\r\n \r\n@@ -312,16 +287,13 @@\r\n \r\n             // Deduplicate parent txids, so that we don't have to loop over\r\n             // the same parent txid more than once down below.\r\n-            unique_parents.reserve(tx.vin.size());\r\n             for (const CTxIn& txin : tx.vin) {\r\n                 // We start with all parents, and then remove duplicates below.\r\n-                unique_parents.push_back(txin.prevout.hash);\r\n+                unique_parents.insert(txin.prevout.hash);\r\n             }\r\n-            std::sort(unique_parents.begin(), unique_parents.end());\r\n-            unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\r\n \r\n-            // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.\r\n-            // We can tolerate having up to 1 parent in m_lazy_recent_rejects_reconsiderable since we\r\n+            // Distinguish between parents in m_lazy_recent_rejects and RecentRejectsReconsiderableFilter.\r\n+            // We can tolerate having up to 1 parent in RecentRejectsReconsiderableFilter since we\r\n             // submit 1p1c packages. However, fail immediately if any are in m_lazy_recent_rejects.\r\n             std::optional<uint256> rejected_parent_reconsiderable;\r\n             for (const uint256& parent_txid : unique_parents) {\r\n@@ -330,7 +302,7 @@\r\n                     break;\r\n                 } else if (RecentRejectsReconsiderableFilter().contains(parent_txid) &&\r\n                            !m_opts.m_mempool.exists(GenTxid::Txid(parent_txid))) {\r\n-                    // More than 1 parent in m_lazy_recent_rejects_reconsiderable: 1p1c will not be\r\n+                    // More than 1 parent in RecentRejectsReconsiderableFilter: 1p1c will not be\r\n                     // sufficient to accept this package, so just give up here.\r\n                     if (rejected_parent_reconsiderable.has_value()) {\r\n                         fRejectedParents = true;\r\n@@ -349,7 +321,7 @@\r\n                     // Eventually we should replace this with an improved\r\n                     // protocol for getting all unconfirmed parents.\r\n                     const auto gtxid{GenTxid::Txid(parent_txid)};\r\n-                    // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\r\n+                    // Exclude RecentRejectsReconsiderableFilter: the missing parent may have been\r\n                     // previously rejected for being too low feerate. This orphan might CPFP it.\r\n                     if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\r\n                         AddTxAnnouncement(nodeid, gtxid, current_time, /*p2p_inv=*/false);\r\n@@ -405,7 +377,7 @@\r\n         // for concerns around weakening security of unupgraded nodes\r\n         // if we start doing this too early.\r\n         if (state.GetResult() == TxValidationResult::TX_RECONSIDERABLE) {\r\n-            // If the result is TX_RECONSIDERABLE, add it to m_lazy_recent_rejects_reconsiderable\r\n+            // If the result is TX_RECONSIDERABLE, add it to RecentRejectsReconsiderableFilter\r\n             // because we should not download or submit this transaction by itself again, but may\r\n             // submit it as part of a package later.\r\n             RecentRejectsReconsiderableFilter().insert(ptx->GetWitnessHash().ToUint256());\r\n@@ -493,18 +465,18 @@\r\n         // due to node policy (vs. consensus). So we can't blanket penalize a\r\n         // peer simply for relaying a tx that our m_lazy_recent_rejects has caught,\r\n         // regardless of false positives.\r\n-        return std::make_pair(false, std::nullopt);\r\n+        return {false, std::nullopt};\r\n     } else if (RecentRejectsReconsiderableFilter().contains(wtxid)) {\r\n-        // When a transaction is already in m_lazy_recent_rejects_reconsiderable, we shouldn't submit\r\n+        // When a transaction is already in RecentRejectsReconsiderableFilter, we shouldn't submit\r\n         // it by itself again. However, look for a matching child in the orphanage, as it is\r\n         // possible that they succeed as a package.\r\n         LogDebug(BCLog::TXPACKAGES, \"found tx %s (wtxid=%s) in reconsiderable rejects, looking for child in orphanage\\n\",\r\n                  txid.ToString(), wtxid.ToString());\r\n-        return std::make_pair(false, Find1P1CPackage(ptx, nodeid));\r\n+        return {false, Find1P1CPackage(ptx, nodeid)};\r\n     }\r\n \r\n \r\n-    return std::make_pair(true, std::nullopt);\r\n+    return {true, std::nullopt};\r\n }\r\n \r\n bool TxDownloadManagerImpl::HaveMoreWork(NodeId nodeid)\r\nIndex: src/node/txdownloadman.h\r\n<+>UTF-8\r\n===================================================================\r\ndiff --git a/src/node/txdownloadman.h b/src/node/txdownloadman.h\r\n--- a/src/node/txdownloadman.h\t(revision b543dc083ddbf43bb172b60ddb90609a600c86b5)\r\n+++ b/src/node/txdownloadman.h\t(date 1727088479738)\r\n@@ -24,12 +24,12 @@\r\n \r\n /** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\r\n  *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\r\n-static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\r\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT{100};\r\n /** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\r\n  *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\r\n  *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\r\n  *  the actual transaction (from any peer) in response to requests for them. */\r\n-static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\r\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS{5000};\r\n /** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\r\n static constexpr auto TXID_RELAY_DELAY{2s};\r\n /** How long to delay requesting transactions from non-preferred peers */\r\n@@ -68,38 +68,28 @@\r\n         m_senders{parent_sender, child_sender}\r\n     {}\r\n \r\n-    // Move ctor\r\n-    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\r\n-    // Copy ctor\r\n-    PackageToValidate(const PackageToValidate& other) = default;\r\n+    PackageToValidate(PackageToValidate&&) = default;\r\n+    PackageToValidate(const PackageToValidate&) = default;\r\n+    PackageToValidate& operator=(PackageToValidate&&) = default;\r\n \r\n-    // Move assignment\r\n-    PackageToValidate& operator=(PackageToValidate&& other) {\r\n-        this->m_txns = std::move(other.m_txns);\r\n-        this->m_senders = std::move(other.m_senders);\r\n-        return *this;\r\n-    }\r\n-\r\n-    std::string ToString() const {\r\n+    std::string ToString() const\r\n+    {\r\n         Assume(m_txns.size() == 2);\r\n-        return strprintf(\"parent %s (wtxid=%s, sender=%d) + child %s (wtxid=%s, sender=%d)\",\r\n-                         m_txns.front()->GetHash().ToString(),\r\n-                         m_txns.front()->GetWitnessHash().ToString(),\r\n-                         m_senders.front(),\r\n-                         m_txns.back()->GetHash().ToString(),\r\n-                         m_txns.back()->GetWitnessHash().ToString(),\r\n-                         m_senders.back());\r\n+        auto format_tx{[&](const CTransactionRef& tx, NodeId sender) {\r\n+            return strprintf(\"%s (wtxid=%s, sender=%d)\", tx->GetHash().ToString(), tx->GetWitnessHash().ToString(), sender);\r\n+        }};\r\n+        return strprintf(\"parent %s + child %s\", format_tx(m_txns.front(), m_senders.front()), format_tx(m_txns.back(), m_senders.back()));\r\n     }\r\n };\r\n-struct RejectedTxTodo\r\n-{\r\n+struct RejectedTxTodo {\r\n     bool m_should_add_extra_compact_tx;\r\n-    std::vector<uint256> m_unique_parents;\r\n+    std::set<uint256> m_unique_parents;\r\n     std::optional<PackageToValidate> m_package_to_validate;\r\n };\r\n \r\n \r\n-class TxDownloadManager {\r\n+class TxDownloadManager\r\n+{\r\n     const std::unique_ptr<TxDownloadManagerImpl> m_impl;\r\n \r\n public:\r\n@@ -118,7 +108,7 @@\r\n     void DisconnectedPeer(NodeId nodeid);\r\n \r\n     /** New inv has been received. May be added as a candidate to txrequest.\r\n-     * @param[in] p2p_inv     When true, only add this announcement if we don't already have the tx.\r\n+     * @param[in] p2p_inv When true, only add this announcement if we don't already have the tx.\r\n      * Returns true if this was a dropped inv (p2p_inv=true and we already have the tx), false otherwise. */\r\n     bool AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv);\r\n \r\n@@ -153,7 +143,6 @@\r\n \r\n     /** Check that all data structures that track per-peer information have nothing for this peer. */\r\n     void CheckIsEmpty(NodeId nodeid) const;\r\n-\r\n };\r\n } // namespace node\r\n #endif // BITCOIN_NODE_TXDOWNLOADMAN_H\r\nIndex: src/test/fuzz/txdownloadman_one_honest_peer.cpp\r\n<+>UTF-8\r\n===================================================================\r\ndiff --git a/src/test/fuzz/txdownloadman_one_honest_peer.cpp b/src/test/fuzz/txdownloadman_one_honest_peer.cpp\r\n--- a/src/test/fuzz/txdownloadman_one_honest_peer.cpp\t(revision b543dc083ddbf43bb172b60ddb90609a600c86b5)\r\n+++ b/src/test/fuzz/txdownloadman_one_honest_peer.cpp\t(date 1727088723398)\r\n@@ -16,9 +16,9 @@\r\n #include <test/util/script.h>\r\n #include <test/util/setup_common.h>\r\n #include <test/util/txmempool.h>\r\n+#include <txmempool.h>\r\n #include <util/hasher.h>\r\n #include <util/rbf.h>\r\n-#include <txmempool.h>\r\n #include <validation.h>\r\n #include <validationinterface.h>\r\n \r\n@@ -81,7 +81,8 @@\r\n     PossibleResponse::DEFER,\r\n };\r\n \r\n-class TestPeer {\r\n+class TestPeer\r\n+{\r\n public:\r\n     // Queue of getdatas to respond to: process from front, add to back.\r\n     std::deque<GenTxid> m_getdata_queue;\r\n@@ -118,7 +119,8 @@\r\n     // to announce the target transaction. Updates m_sent_inv if this happens.\r\n     // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\r\n     // announced, always return INV_REAL.\r\n-    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\r\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false)\r\n+    {\r\n         if (m_good) {\r\n             // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\r\n             if (!m_sent_inv) {\r\n@@ -138,24 +140,23 @@\r\n \r\n     // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\r\n     // not change, as DEFER may just push it to the back again.\r\n-    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\r\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider)\r\n+    {\r\n         // Nothing to do if no messages to process\r\n         if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\r\n \r\n-        auto request = m_getdata_queue.front();\r\n-        auto response{PossibleResponse::TX_REAL};\r\n-        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\r\n-\r\n-        // If DEFER, pop the request to the back of the queue and return nothing.\r\n-        // This simulates responding out of order and/or stalling.\r\n-        if (response == PossibleResponse::DEFER) {\r\n-            m_getdata_queue.push_back(request);\r\n-            m_getdata_queue.pop_front();\r\n+        auto request{m_getdata_queue.front()};\r\n+        m_getdata_queue.pop_front();\r\n+\r\n+        auto response{m_good ? PossibleResponse::TX_REAL : fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES)};\r\n+        if (response == PossibleResponse::DEFER) {\r\n+            // Move the request from the front to the back of the queue and return nothing.\r\n+            // This simulates responding out of order and/or stalling.\r\n+            m_getdata_queue.emplace_back(std::move(request));\r\n             return {PossibleResponse::NOTHING, std::nullopt};\r\n-        }\r\n-\r\n-        m_getdata_queue.pop_front();\r\n-        return {response, request};\r\n+        } else {\r\n+            return {response, request};\r\n+        }\r\n     }\r\n };\r\n \r\n@@ -236,43 +237,39 @@\r\n         const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\r\n \r\n         // The first tx in the pair needs to match by wtxid.\r\n-        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\r\n-        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\r\n+        TRANSACTIONS.try_emplace(target_wtxid, correct_tx, malleated_tx);\r\n+        TRANSACTIONS.try_emplace(target_txid, correct_tx, correct_tx);\r\n \r\n-        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\r\n+        TRANSACTIONS.try_emplace(malleated_wtxid, malleated_tx, stripped_tx);\r\n     }\r\n }\r\n \r\n static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\r\n {\r\n-    auto tx_it = txmap.find(gtxid.GetHash());\r\n-    if (tx_it != txmap.end()) {\r\n+    if (auto tx_it = txmap.find(gtxid.GetHash()); tx_it != txmap.end()) {\r\n         return tx_it->second.first;\r\n     }\r\n     return nullptr;\r\n }\r\n static CTransactionRef GetStrippedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\r\n {\r\n-    auto tx_it = txmap.find(gtxid.GetHash());\r\n-    if (tx_it != txmap.end()) {\r\n+    if (auto tx_it = txmap.find(gtxid.GetHash()); tx_it != txmap.end()) {\r\n         return StripWitness(tx_it->second.first);\r\n     }\r\n     return nullptr;\r\n }\r\n static CTransactionRef GetMalleatedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\r\n {\r\n-    auto tx_it = txmap.find(gtxid.GetHash());\r\n-    if (tx_it != txmap.end()) {\r\n+    if (auto tx_it = txmap.find(gtxid.GetHash()); tx_it != txmap.end()) {\r\n         return tx_it->second.second;\r\n     }\r\n     return nullptr;\r\n }\r\n static CTransactionRef GetRandomTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, FuzzedDataProvider& fuzzed_data_provider, bool correct_only = false)\r\n {\r\n-    auto it = txmap.begin();\r\n-    // Jump forward a random number of times.\r\n-    for (size_t i = 0; i <= fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1); ++i) it++;\r\n-    if (it == txmap.end()) return nullptr;\r\n+    if (txmap.empty()) return nullptr;\r\n+    size_t rand_index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1);\r\n+    auto it = std::next(txmap.begin(), rand_index);\r\n     return correct_only || fuzzed_data_provider.ConsumeBool() ? it->second.first : it->second.second;\r\n }\r\n \r\n@@ -299,8 +296,8 @@\r\n     // transaction because it can lead to false negatives. This test may mark a same-txid\r\n     // transaction as invalid, and we don't want that to cause rejection of the target tx.\r\n     const auto& target_tx = GetRandomTx(TRANSACTIONS, fuzzed_data_provider, /*correct_only=*/true);\r\n-    Assert(target_tx != nullptr);\r\n-    Assert(target_tx->HasWitness());\r\n+    assert(target_tx != nullptr);\r\n+    assert(target_tx->HasWitness());\r\n \r\n     const auto& target_txid = target_tx->GetHash();\r\n     const auto& target_wtxid = target_tx->GetWitnessHash();\r\n@@ -323,8 +320,7 @@\r\n     }\r\n \r\n     // Indexes for random peer iteration\r\n-    std::vector<size_t> indexes;\r\n-    indexes.resize(all_peers.size());\r\n+    std::vector<size_t> indexes(all_peers.size());\r\n     std::iota(indexes.begin(), indexes.end(), 0);\r\n \r\n     // We are trying to ensure that we always download the tx as long as we have 1 good outbound\r\n@@ -509,7 +505,7 @@\r\n             }\r\n         }\r\n \r\n-        // Skip time by 100-300ms\r\n+        // Skip time by 100-300Î¼s\r\n         time += std::chrono::microseconds(fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(100, 300) * 1000);\r\n     }\r\n     // Disconnect everybody, check that all data structures are empty.\r\nIndex: src/test/txdownload_tests.cpp\r\n<+>UTF-8\r\n===================================================================\r\ndiff --git a/src/test/txdownload_tests.cpp b/src/test/txdownload_tests.cpp\r\n--- a/src/test/txdownload_tests.cpp\t(revision b543dc083ddbf43bb172b60ddb90609a600c86b5)\r\n+++ b/src/test/txdownload_tests.cpp\t(date 1727088836221)\r\n@@ -57,19 +57,20 @@\r\n // Map from failure reason to expected behavior for a segwit tx that fails\r\n // Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\r\n static std::map<TxValidationResult, Behaviors> expected_behaviors{\r\n-    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\r\n-    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\r\n-    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\r\n-    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\r\n-    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\r\n-    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\r\n-    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\r\n-    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\r\n-    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\r\n-    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\r\n-    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\r\n-    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\r\n-    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\r\n+    //                                                txid_rejects, wtxid_rejects, txid_recon, wtxid_recon, keep, txid_inv, wtxid_inv\r\n+    {TxValidationResult::TX_CONSENSUS,               {0,            1,             0,          0,           1,    0,        1}},\r\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {0,            1,             0,          0,           1,    0,        1}},\r\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {1,            1,             0,          0,           1,    1,        1}},\r\n+    {TxValidationResult::TX_NOT_STANDARD,            {0,            1,             0,          0,           1,    0,        1}},\r\n+    {TxValidationResult::TX_MISSING_INPUTS,          {0,            0,             0,          0,           1,    0,        1}},\r\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {0,            1,             0,          0,           1,    0,        1}},\r\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {0,            1,             0,          0,           1,    0,        1}},\r\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {0,            0,             0,          0,           0,    0,        0}},\r\n+    {TxValidationResult::TX_CONFLICT,                {0,            1,             0,          0,           1,    0,        1}},\r\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {0,            1,             0,          0,           1,    0,        1}},\r\n+    {TxValidationResult::TX_NO_MEMPOOL,              {0,            1,             0,          0,           1,    0,        1}},\r\n+    {TxValidationResult::TX_RECONSIDERABLE,          {0,            0,             0,          1,           1,    0,        1}},\r\n+    {TxValidationResult::TX_UNKNOWN,                 {0,            1,             0,          0,           1,    0,        1}},\r\n };\r\n \r\n static bool CheckOrphanBehavior(node::TxDownloadManagerImpl& txdownload_impl, const CTransactionRef& tx, const node::RejectedTxTodo& ret, std::string& err_msg,\r\nIndex: src/test/fuzz/txdownloadman.cpp\r\n<+>UTF-8\r\n===================================================================\r\ndiff --git a/src/test/fuzz/txdownloadman.cpp b/src/test/fuzz/txdownloadman.cpp\r\n--- a/src/test/fuzz/txdownloadman.cpp\t(revision b543dc083ddbf43bb172b60ddb90609a600c86b5)\r\n+++ b/src/test/fuzz/txdownloadman.cpp\t(date 1727088582192)\r\n@@ -16,9 +16,9 @@\r\n #include <test/util/script.h>\r\n #include <test/util/setup_common.h>\r\n #include <test/util/txmempool.h>\r\n+#include <txmempool.h>\r\n #include <util/hasher.h>\r\n #include <util/rbf.h>\r\n-#include <txmempool.h>\r\n #include <validation.h>\r\n #include <validationinterface.h>\r\n \r\n@@ -26,7 +26,7 @@\r\n \r\n const TestingSetup* g_setup;\r\n \r\n-constexpr size_t NUM_COINS{50};\r\n+constexpr uint32_t NUM_COINS{50};\r\n COutPoint COINS[NUM_COINS];\r\n \r\n static TxValidationResult TESTED_TX_RESULTS[] = {\r\n@@ -72,7 +72,7 @@\r\n {\r\n     static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\r\n     g_setup = testing_setup.get();\r\n-    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\r\n+    for (uint32_t i = 0; i < NUM_COINS; ++i) {\r\n         COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\r\n     }\r\n     size_t outpoints_index = 0;\r\n@@ -228,8 +228,8 @@\r\n                 // - Don't validate the tx, package.\r\n                 // - Validate the tx, no package.\r\n                 // The only combination that doesn't make sense is validate both tx and package.\r\n-                Assert(!(should_validate && maybe_package.has_value()));\r\n-                if (maybe_package.has_value()) CheckPackageToValidate(*maybe_package, rand_peer);\r\n+                Assert(!(should_validate && maybe_package));\r\n+                if (maybe_package) CheckPackageToValidate(*maybe_package, rand_peer);\r\n             },\r\n             [&] {\r\n                 txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\r\n@@ -357,7 +357,7 @@\r\n             [&] {\r\n                 const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\r\n                 // TxDownloadManager should not be telling us to request things we already have.\r\n-                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\r\n+                // Exclude RecentRejectsReconsiderableFilter because it may request low-feerate parent of orphan.\r\n                 for (const auto& gtxid : getdata_requests) {\r\n                     Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\r\n                 }\r\n@@ -369,15 +369,15 @@\r\n                 // - Don't validate the tx, package.\r\n                 // - Validate the tx, no package.\r\n                 // The only combination that doesn't make sense is validate both tx and package.\r\n-                Assert(!(should_validate && maybe_package.has_value()));\r\n+                Assert(!(should_validate && maybe_package));\r\n                 if (should_validate) {\r\n                     Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\r\n                 }\r\n-                if (maybe_package.has_value()) {\r\n+                if (maybe_package) {\r\n                     CheckPackageToValidate(*maybe_package, rand_peer);\r\n \r\n                     const auto& package = maybe_package->m_txns;\r\n-                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\r\n+                    // Parent is in RecentRejectsReconsiderableFilter and child is in m_orphanage\r\n                     Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\r\n                     Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\r\n                     // Package has not been rejected\r\nIndex: src/test/fuzz/mini_miner.cpp\r\n<+>UTF-8\r\n===================================================================\r\ndiff --git a/src/test/fuzz/mini_miner.cpp b/src/test/fuzz/mini_miner.cpp\r\n--- a/src/test/fuzz/mini_miner.cpp\t(revision b543dc083ddbf43bb172b60ddb90609a600c86b5)\r\n+++ b/src/test/fuzz/mini_miner.cpp\t(date 1727088265502)\r\n@@ -26,7 +26,7 @@\r\n {\r\n     static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\r\n     g_setup = testing_setup.get();\r\n-    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\r\n+    for (uint32_t i = 0; i < 100; ++i) {\r\n         g_available_coins.emplace_back(Txid::FromUint256(uint256::ZERO), i);\r\n     }\r\n }\r\nIndex: src/net_processing.cpp\r\n<+>UTF-8\r\n===================================================================\r\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\r\n--- a/src/net_processing.cpp\t(revision b543dc083ddbf43bb172b60ddb90609a600c86b5)\r\n+++ b/src/net_processing.cpp\t(date 1727088265570)\r\n@@ -568,12 +568,12 @@\r\n     bool MaybeDiscourageAndDisconnect(CNode& pnode, Peer& peer);\r\n \r\n     /** Handle a transaction whose result was not MempoolAcceptResult::ResultType::VALID.\r\n-     * @param[in]   first_time_failure            Whether we should consider inserting into vExtraTxnForCompact, adding\r\n-     *                                            a new orphan to resolve, or looking for a package to submit.\r\n-     *                                            Set to true for transactions just received over p2p.\r\n-     *                                            Set to false if the tx has already been rejected before,\r\n-     *                                            e.g. is already in the orphanage, to avoid adding duplicate entries.\r\n-     * Updates m_txrequest, m_lazy_recent_rejects, m_lazy_recent_rejects_reconsiderable, m_orphanage, and vExtraTxnForCompact.\r\n+     * @param[in] first_time_failure Whether we should consider inserting into vExtraTxnForCompact, adding\r\n+     *                               a new orphan to resolve, or looking for a package to submit.\r\n+     *                               Set to true for transactions just received over p2p.\r\n+     *                               Set to false if the tx has already been rejected before,\r\n+     *                               e.g. is already in the orphanage, to avoid adding duplicate entries.\r\n+     * Updates m_txrequest, m_lazy_recent_rejects, RecentRejectsReconsiderableFilter, m_orphanage, and vExtraTxnForCompact.\r\n      *\r\n      * @returns a PackageToValidate if this transaction has a reconsiderable failure and an eligible package was found,\r\n      * or std::nullopt otherwise.\r\n@@ -734,8 +734,8 @@\r\n      * Lock invariants:\r\n      * - A txhash (txid or wtxid) in m_txrequest is not also in m_orphanage.\r\n      * - A txhash (txid or wtxid) in m_txrequest is not also in m_lazy_recent_rejects.\r\n-     * - A txhash (txid or wtxid) in m_txrequest is not also in m_lazy_recent_rejects_reconsiderable.\r\n-     * - A txhash (txid or wtxid) in m_txrequest is not also in m_lazy_recent_confirmed_transactions.\r\n+     * - A txhash (txid or wtxid) in m_txrequest is not also in RecentRejectsReconsiderableFilter.\r\n+     * - A txhash (txid or wtxid) in m_txrequest is not also in RecentConfirmedTransactionsFilter.\r\n      * - Each data structure's limits hold (m_orphanage max size, m_txrequest per-peer limits, etc).\r\n      */\r\n     Mutex m_tx_download_mutex ACQUIRED_BEFORE(m_mempool.cs);\r\n@@ -3915,7 +3915,7 @@\r\n \r\n             if (inv.IsMsgBlk()) {\r\n                 const bool fAlreadyHave = AlreadyHaveBlock(inv.hash);\r\n-                LogDebug(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\r\n+                LogDebug(BCLog::NET, \"got inv: %s %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\r\n \r\n                 UpdateBlockAvailability(pfrom.GetId(), inv.hash);\r\n                 if (!fAlreadyHave && !m_chainman.m_blockman.LoadingBlocks() && !IsBlockRequested(inv.hash)) {\r\n@@ -3938,7 +3938,7 @@\r\n \r\n                 if (!m_chainman.IsInitialBlockDownload()) {\r\n                     const bool fAlreadyHave{m_txdownloadman.AddTxAnnouncement(pfrom.GetId(), gtxid, current_time, /*p2p_inv=*/true)};\r\n-                    LogDebug(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\r\n+                    LogDebug(BCLog::NET, \"got inv: %s %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\r\n                 }\r\n             } else {\r\n                 LogDebug(BCLog::NET, \"Unknown inv type \\\"%s\\\" received from peer=%d\\n\", inv.ToString(), pfrom.GetId());\r\n@@ -4256,7 +4256,7 @@\r\n         }\r\n \r\n         // ReceivedTx should not be telling us to validate the tx and a package.\r\n-        Assume(!package_to_validate.has_value());\r\n+        Assume(!package_to_validate);\r\n \r\n         const MempoolAcceptResult result = m_chainman.ProcessTransaction(ptx);\r\n         const TxValidationState& state = result.m_state;\r\n@@ -4871,6 +4871,7 @@\r\n         vRecv >> vInv;\r\n         std::vector<uint256> tx_invs;\r\n         if (vInv.size() <= node::MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\r\n+            tx_invs.reserve(std::ranges::count_if(vInv, &CInv::IsGenTxMsg));\r\n             for (CInv &inv : vInv) {\r\n                 if (inv.IsGenTxMsg()) {\r\n                     // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\r\n@@ -4998,8 +4999,10 @@\r\n         //  by another peer that was already processed; in that case,\r\n         //  the extra work may not be noticed, possibly resulting in an\r\n         //  unnecessary 100ms delay)\r\n-        LOCK(m_tx_download_mutex);\r\n-        if (m_txdownloadman.HaveMoreWork(peer->m_id)) fMoreWork = true;\r\n+        if (!fMoreWork) {\r\n+            LOCK(m_tx_download_mutex);\r\n+            fMoreWork = m_txdownloadman.HaveMoreWork(peer->m_id);\r\n+        }\r\n     } catch (const std::exception& e) {\r\n         LogDebug(BCLog::NET, \"%s(%s, %u bytes): Exception '%s' (%s) caught\\n\", __func__, SanitizeString(msg.m_type), msg.m_message_size, e.what(), typeid(e).name());\r\n     } catch (...) {\r\n@@ -5875,6 +5878,7 @@\r\n                     vToDownload, from_tip,\r\n                     Assert(m_chainman.GetSnapshotBaseBlock()));\r\n             }\r\n+            vGetData.reserve(vToDownload.size());\r\n             for (const CBlockIndex *pindex : vToDownload) {\r\n                 uint32_t nFetchFlags = GetFetchFlags(*peer);\r\n                 vGetData.emplace_back(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash());\r\n@@ -5895,7 +5899,9 @@\r\n         //\r\n         {\r\n             LOCK(m_tx_download_mutex);\r\n-            for (const GenTxid& gtxid : m_txdownloadman.GetRequestsToSend(pto->GetId(), current_time)) {\r\n+            const auto& tx_requests = m_txdownloadman.GetRequestsToSend(pto->GetId(), current_time);\r\n+            vGetData.reserve(vGetData.size() + tx_requests.size());\r\n+            for (const GenTxid& gtxid : tx_requests) {\r\n                 vGetData.emplace_back(gtxid.IsWtxid() ? MSG_WTX : (MSG_TX | GetFetchFlags(*peer)), gtxid.GetHash());\r\n                 if (vGetData.size() >= MAX_GETDATA_SZ) {\r\n                     MakeAndPushMessage(*pto, NetMsgType::GETDATA, vGetData);\r\n```\r\n\r\n\r\n</details>",
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2320844778",
      "submitted_at": "2024-09-23T10:55:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE5YmJhMjcyYWUyMGY0ZWE5ODA4OGMxNDNiMjJlYTFhNjgzZjM4MDk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/19bba272ae20f4ea98088c143b22ea1a683f3809",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/19bba272ae20f4ea98088c143b22ea1a683f3809",
      "tree": {
        "sha": "02ba873135767a50c1e3e01002ef6b934fc248f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/02ba873135767a50c1e3e01002ef6b934fc248f0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/85edaf2556c9ce531573dc3dee8fff2f7b4d9abf",
          "sha": "85edaf2556c9ce531573dc3dee8fff2f7b4d9abf",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/85edaf2556c9ce531573dc3dee8fff2f7b4d9abf"
        }
      ],
      "message": "fix typo in m_lazy_recent_confirmed_transactions doc",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:43Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:43Z"
      },
      "sha": "19bba272ae20f4ea98088c143b22ea1a683f3809"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ0MTBmYTBmNmIwOGZmNWExNjZlYTI3NTVhODhkMzRkOGM4NjIxOGM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4410fa0f6b08ff5a166ea2755a88d34d8c86218c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4410fa0f6b08ff5a166ea2755a88d34d8c86218c",
      "tree": {
        "sha": "e257309f2ea907f5a695eeda21b123cd13c1c2d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e257309f2ea907f5a695eeda21b123cd13c1c2d4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/19bba272ae20f4ea98088c143b22ea1a683f3809",
          "sha": "19bba272ae20f4ea98088c143b22ea1a683f3809",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/19bba272ae20f4ea98088c143b22ea1a683f3809"
        }
      ],
      "message": "[refactor] move ValidationInterface functions to TxDownloadManager\n\nThis is move-only.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T14:31:35Z"
      },
      "sha": "4410fa0f6b08ff5a166ea2755a88d34d8c86218c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGZjNWI2OTFiZjhiYmM3NzgzMDY3ODBmZjczNTk5MDY3Yzg3ZDIxMmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fc5b691bf8bbc778306780ff73599067c87d212a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/fc5b691bf8bbc778306780ff73599067c87d212a",
      "tree": {
        "sha": "76df50465b08c730b690af873dc8e1f176f68caa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/76df50465b08c730b690af873dc8e1f176f68caa"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4410fa0f6b08ff5a166ea2755a88d34d8c86218c",
          "sha": "4410fa0f6b08ff5a166ea2755a88d34d8c86218c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4410fa0f6b08ff5a166ea2755a88d34d8c86218c"
        }
      ],
      "message": "[txdownload] add read-only reference to mempool\n\nThis will become necessary in later commits that query mempool. We also\nintroduce the TxDownloadOptions in this commit to make the later diff\neasier to review.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T16:04:00Z"
      },
      "sha": "fc5b691bf8bbc778306780ff73599067c87d212a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDBlZjZjZGM1YzQ3MWRmYmZhNWViMjkzOGY4YTc1OTg4NGU3ZjdhZjk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0ef6cdc5c471dfbfa5eb2938f8a759884e7f7af9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0ef6cdc5c471dfbfa5eb2938f8a759884e7f7af9",
      "tree": {
        "sha": "c110d2b3b82305b1a1fe251eb53cc0812df40d6c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c110d2b3b82305b1a1fe251eb53cc0812df40d6c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fc5b691bf8bbc778306780ff73599067c87d212a",
          "sha": "fc5b691bf8bbc778306780ff73599067c87d212a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/fc5b691bf8bbc778306780ff73599067c87d212a"
        }
      ],
      "message": "[refactor] move AlreadyHaveTx to TxDownload\n\nThis is move-only.\nAlso delete external RecentConfirmedTransactionsFilter() access since it\nis no longer necessary.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T16:06:56Z"
      },
      "sha": "0ef6cdc5c471dfbfa5eb2938f8a759884e7f7af9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGEwMDk2MGMxMDE5OTE3NjIxYzNkOGE3OGFkODBhMTVhN2U4MGViNjQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a00960c1019917621c3d8a78ad80a15a7e80eb64",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a00960c1019917621c3d8a78ad80a15a7e80eb64",
      "tree": {
        "sha": "06220a50de67d6b3b1fd6b166fdbe542ded6a00f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/06220a50de67d6b3b1fd6b166fdbe542ded6a00f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0ef6cdc5c471dfbfa5eb2938f8a759884e7f7af9",
          "sha": "0ef6cdc5c471dfbfa5eb2938f8a759884e7f7af9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0ef6cdc5c471dfbfa5eb2938f8a759884e7f7af9"
        }
      ],
      "message": "[refactor] move peer (dis)connection logic to TxDownload\n\nThe information stored in TxDownloadConnectionInfo isn't used until the\nnext commit.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T15:46:36Z"
      },
      "sha": "a00960c1019917621c3d8a78ad80a15a7e80eb64"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGZmZjY2ZWY4MjlhYWFmZDQyZjA4N2M5MDY4OTI1NGQxMzQxNDIwY2Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fff66ef829aaafd42f087c90689254d1341420cf",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/fff66ef829aaafd42f087c90689254d1341420cf",
      "tree": {
        "sha": "c74d58d1dbac5ec4c4bb6a277e9069aa16594fb7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c74d58d1dbac5ec4c4bb6a277e9069aa16594fb7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a00960c1019917621c3d8a78ad80a15a7e80eb64",
          "sha": "a00960c1019917621c3d8a78ad80a15a7e80eb64",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a00960c1019917621c3d8a78ad80a15a7e80eb64"
        }
      ],
      "message": "[refactor] rename maybe_add_extra_compact_tx to first_time_failure\n\nThe usage of this bool will increase in scope in the next commit.\nFor this commit, the value of this bool is accurate at each\nProcessInvalidTx callsite:\n- ProcessOrphanTx -> this tx is an orphan i.e. has been rejected before\n- ProcessPackageResult -> 1p1c only, each transaction is either an\n  orphan or in m_lazy_recent_rejects_reconsiderable\n- ProcessMessage -> tx was received over p2p and validated for the first\n  time",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-08-21T10:29:24Z"
      },
      "sha": "fff66ef829aaafd42f087c90689254d1341420cf"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGRkMzE1MzJiMmY3NzFiYjE1MTQwM2NlN2FmZjJlMmEzNTA1YzllMTM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dd31532b2f771bb151403ce7aff2e2a3505c9e13",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/dd31532b2f771bb151403ce7aff2e2a3505c9e13",
      "tree": {
        "sha": "8cff35b3fdaf56435b982cc66acd07eb948dd54c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8cff35b3fdaf56435b982cc66acd07eb948dd54c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fff66ef829aaafd42f087c90689254d1341420cf",
          "sha": "fff66ef829aaafd42f087c90689254d1341420cf",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/fff66ef829aaafd42f087c90689254d1341420cf"
        }
      ],
      "message": "[p2p] don't log tx invs when in IBD\n\nThese invs are ignored anyway, and this allows us to more easily move\nthe inv handling to TxDownloadManager in the next commit.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-08-14T09:33:21Z"
      },
      "sha": "dd31532b2f771bb151403ce7aff2e2a3505c9e13"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZlMGRhMjc3ZGIwOGQwMWFiY2I4MjA2MTIwNmY5MzI1ODA0NjhiYTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6e0da277db08d01abcb82061206f932580468ba5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6e0da277db08d01abcb82061206f932580468ba5",
      "tree": {
        "sha": "ebaeaf8447334a05abad4cc1a4f1e737f350499f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ebaeaf8447334a05abad4cc1a4f1e737f350499f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dd31532b2f771bb151403ce7aff2e2a3505c9e13",
          "sha": "dd31532b2f771bb151403ce7aff2e2a3505c9e13",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/dd31532b2f771bb151403ce7aff2e2a3505c9e13"
        }
      ],
      "message": "[refactor] move tx inv/getdata handling to txdownload",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-25T10:43:04Z"
      },
      "sha": "6e0da277db08d01abcb82061206f932580468ba5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDc1YTk2ZGVjZWMwOGMxMTEzZjRkMDUyM2VkMzUwMTUwMmYyMWRjMDU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/75a96decec08c1113f4d0523ed3501502f21dc05",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/75a96decec08c1113f4d0523ed3501502f21dc05",
      "tree": {
        "sha": "04e58ad5fe3fc256548511fb264d2d4a8f6aabdb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/04e58ad5fe3fc256548511fb264d2d4a8f6aabdb"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6e0da277db08d01abcb82061206f932580468ba5",
          "sha": "6e0da277db08d01abcb82061206f932580468ba5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6e0da277db08d01abcb82061206f932580468ba5"
        }
      ],
      "message": "[refactor] move notfound processing to txdownload",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-25T10:48:43Z"
      },
      "sha": "75a96decec08c1113f4d0523ed3501502f21dc05"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQxYzg3MGM1N2Y1MzVkMzA1NWI1MzM0ODE3NmFjN2JlMWU5Mzc5N2M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d1c870c57f535d3055b53348176ac7be1e93797c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d1c870c57f535d3055b53348176ac7be1e93797c",
      "tree": {
        "sha": "da872763769315c190691962c6e14626ca226d5d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/da872763769315c190691962c6e14626ca226d5d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/75a96decec08c1113f4d0523ed3501502f21dc05",
          "sha": "75a96decec08c1113f4d0523ed3501502f21dc05",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/75a96decec08c1113f4d0523ed3501502f21dc05"
        }
      ],
      "message": "[refactor] move some definitions\n\nProcessInvalidTx will return a PackageToValidate, so it needs to be\ndefined afterward.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-05-15T15:00:32Z"
      },
      "sha": "d1c870c57f535d3055b53348176ac7be1e93797c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDhmMmI5ZjQ0ZTFmZGFhNTIyYzcwN2NkMWYwZjAxZWNiODg0MGE3OTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8f2b9f44e1fdaa522c707cd1f0f01ecb8840a796",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8f2b9f44e1fdaa522c707cd1f0f01ecb8840a796",
      "tree": {
        "sha": "098796fd37e4d8dd9352c66d6270f47d1ab36fb5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/098796fd37e4d8dd9352c66d6270f47d1ab36fb5"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d1c870c57f535d3055b53348176ac7be1e93797c",
          "sha": "d1c870c57f535d3055b53348176ac7be1e93797c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d1c870c57f535d3055b53348176ac7be1e93797c"
        }
      ],
      "message": "[refactor] move new orphan handling to ProcessInvalidTx",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-30T09:54:00Z"
      },
      "sha": "8f2b9f44e1fdaa522c707cd1f0f01ecb8840a796"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDBiZmExYTQ2YzI3MjAxMDg4MzZiOWE3ZTgyYzEyYmVjZTMwNmE3MGM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0bfa1a46c2720108836b9a7e82c12bece306a70c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0bfa1a46c2720108836b9a7e82c12bece306a70c",
      "tree": {
        "sha": "19bcb5e25a18b05a539036b8c7c79ad97eae3447",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/19bcb5e25a18b05a539036b8c7c79ad97eae3447"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8f2b9f44e1fdaa522c707cd1f0f01ecb8840a796",
          "sha": "8f2b9f44e1fdaa522c707cd1f0f01ecb8840a796",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8f2b9f44e1fdaa522c707cd1f0f01ecb8840a796"
        }
      ],
      "message": "move Find1P1CPackage into ProcessInvalidTx",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-05-15T15:10:24Z"
      },
      "sha": "0bfa1a46c2720108836b9a7e82c12bece306a70c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGI5M2Q2NzhkNjAzMjQ4ZWNiZTRiNjRkMzQ4Y2Q5ZjUxNjhlNDZjYWY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b93d678d603248ecbe4b64d348cd9f5168e46caf",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b93d678d603248ecbe4b64d348cd9f5168e46caf",
      "tree": {
        "sha": "0fef5a39fe6d4f4e8849bd278760dff76021325e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0fef5a39fe6d4f4e8849bd278760dff76021325e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0bfa1a46c2720108836b9a7e82c12bece306a70c",
          "sha": "0bfa1a46c2720108836b9a7e82c12bece306a70c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0bfa1a46c2720108836b9a7e82c12bece306a70c"
        }
      ],
      "message": "[refactor] put peerman tasks at the end of ProcessInvalidTx",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-30T12:12:21Z"
      },
      "sha": "b93d678d603248ecbe4b64d348cd9f5168e46caf"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGNmODA4NmEwMGRjOTIwZDUzMGUyNjQ0YWZmZjdhNWRlN2VmNGE4OTE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cf8086a00dc920d530e2644afff7a5de7ef4a891",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/cf8086a00dc920d530e2644afff7a5de7ef4a891",
      "tree": {
        "sha": "18c45b29a1ba369930e85483a60570433a7b28bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/18c45b29a1ba369930e85483a60570433a7b28bb"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b93d678d603248ecbe4b64d348cd9f5168e46caf",
          "sha": "b93d678d603248ecbe4b64d348cd9f5168e46caf",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b93d678d603248ecbe4b64d348cd9f5168e46caf"
        }
      ],
      "message": "[refactor] move Find1P1CPackage to txdownload\n\nMove-only.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-25T10:24:31Z"
      },
      "sha": "cf8086a00dc920d530e2644afff7a5de7ef4a891"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGI2YjEwZjJlNzk2ZTg0Njc3ODVlZjMyYWVmNWQ1ODg0MGFkN2FlN2Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b6b10f2e796e8467785ef32aef5d58840ad7ae7d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b6b10f2e796e8467785ef32aef5d58840ad7ae7d",
      "tree": {
        "sha": "c3f0560a44e03291840e28d8ae601a036b81fbe8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c3f0560a44e03291840e28d8ae601a036b81fbe8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cf8086a00dc920d530e2644afff7a5de7ef4a891",
          "sha": "cf8086a00dc920d530e2644afff7a5de7ef4a891",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/cf8086a00dc920d530e2644afff7a5de7ef4a891"
        }
      ],
      "message": "[refactor] move valid tx processing to TxDownload",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T14:45:33Z"
      },
      "sha": "b6b10f2e796e8467785ef32aef5d58840ad7ae7d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDhkZTEyYzU1NzI1MDQ2OWRjMmEwN2JmYTcyYTkyZWY4OGIxMzVjNGM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8de12c557250469dc2a07bfa72a92ef88b135c4c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8de12c557250469dc2a07bfa72a92ef88b135c4c",
      "tree": {
        "sha": "74c4c44815e2bc0cc0ed19e89a8867b53ec29d53",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/74c4c44815e2bc0cc0ed19e89a8867b53ec29d53"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b6b10f2e796e8467785ef32aef5d58840ad7ae7d",
          "sha": "b6b10f2e796e8467785ef32aef5d58840ad7ae7d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b6b10f2e796e8467785ef32aef5d58840ad7ae7d"
        }
      ],
      "message": "[refactor] move invalid tx processing to TxDownload\n\nMove-only. Also delete external RecentRejectsFilter() access since it is\nno longer necessary.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T14:55:57Z"
      },
      "sha": "8de12c557250469dc2a07bfa72a92ef88b135c4c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDkwM2EzYjg1MWY4NjAzNmE5M2Y3ZDg1NDI1MTM1YzcyZWY2Y2U3NzA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/903a3b851f86036a93f7d85425135c72ef6ce770",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/903a3b851f86036a93f7d85425135c72ef6ce770",
      "tree": {
        "sha": "26acb850bd8e1380d8b91ba17caf87392d7b0f3d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/26acb850bd8e1380d8b91ba17caf87392d7b0f3d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8de12c557250469dc2a07bfa72a92ef88b135c4c",
          "sha": "8de12c557250469dc2a07bfa72a92ef88b135c4c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8de12c557250469dc2a07bfa72a92ef88b135c4c"
        }
      ],
      "message": "[refactor] move invalid package processing to TxDownload",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:46Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T15:35:07Z"
      },
      "sha": "903a3b851f86036a93f7d85425135c72ef6ce770"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQyNGM2MzU1ZjlmYTlhMDA3MGM4NGQwN2U2Mzg1NzIyZmRlNjkxZWI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d24c6355f9fa9a0070c84d07e6385722fde691eb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d24c6355f9fa9a0070c84d07e6385722fde691eb",
      "tree": {
        "sha": "7d40613d0d0fc4cbc622a9e197aa6348aca06730",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7d40613d0d0fc4cbc622a9e197aa6348aca06730"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/903a3b851f86036a93f7d85425135c72ef6ce770",
          "sha": "903a3b851f86036a93f7d85425135c72ef6ce770",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/903a3b851f86036a93f7d85425135c72ef6ce770"
        }
      ],
      "message": "[refactor] move new tx logic to txdownload\n\nAlso delete external RecentRejectsReconsiderableFilter() access since it\nis no longer necessary.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:46Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T15:58:35Z"
      },
      "sha": "d24c6355f9fa9a0070c84d07e6385722fde691eb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDRiOGNiMDBmY2I0Mjk2MzBmNzE3OTU0YjVmMWMzOTdjZTU0YTg0NzU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4b8cb00fcb429630f717954b5f1c397ce54a8475",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4b8cb00fcb429630f717954b5f1c397ce54a8475",
      "tree": {
        "sha": "d5641fd0c5706f95822c9d60a20216dfdd1132f5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d5641fd0c5706f95822c9d60a20216dfdd1132f5"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d24c6355f9fa9a0070c84d07e6385722fde691eb",
          "sha": "d24c6355f9fa9a0070c84d07e6385722fde691eb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d24c6355f9fa9a0070c84d07e6385722fde691eb"
        }
      ],
      "message": "[refactor] make AlreadyHaveTx and Find1P1CPackage private to TxDownloadImpl",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:46Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-05-15T15:57:03Z"
      },
      "sha": "4b8cb00fcb429630f717954b5f1c397ce54a8475"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDczMzExNmU0ZjNkMDcyYjBkM2RlYjkyZDZlYzM2NTFjNmQ2YWJhMTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/733116e4f3d072b0d3deb92d6ec3651c6d6aba16",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/733116e4f3d072b0d3deb92d6ec3651c6d6aba16",
      "tree": {
        "sha": "5eed336d361078ae5860432342b4d1fe9ea400b6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5eed336d361078ae5860432342b4d1fe9ea400b6"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4b8cb00fcb429630f717954b5f1c397ce54a8475",
          "sha": "4b8cb00fcb429630f717954b5f1c397ce54a8475",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4b8cb00fcb429630f717954b5f1c397ce54a8475"
        }
      ],
      "message": "[refactor] wrap {Have,Get}TxToReconsider in txdownload",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:46Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-26T10:47:47Z"
      },
      "sha": "733116e4f3d072b0d3deb92d6ec3651c6d6aba16"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGFiZmZmOWUxOGI3OTM3OTFiOGI4NDUxNzZmNDU0NDk5MzFlOGNkMTI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/abfff9e18b793791b8b845176f45449931e8cd12",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/abfff9e18b793791b8b845176f45449931e8cd12",
      "tree": {
        "sha": "92db296d0b0354c88bad0faf122f3bfeea2198bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/92db296d0b0354c88bad0faf122f3bfeea2198bf"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/733116e4f3d072b0d3deb92d6ec3651c6d6aba16",
          "sha": "733116e4f3d072b0d3deb92d6ec3651c6d6aba16",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/733116e4f3d072b0d3deb92d6ec3651c6d6aba16"
        }
      ],
      "message": "[refactor] add CheckIsEmpty and remove access to TxDownloadMan internals",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:46Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-26T10:56:24Z"
      },
      "sha": "abfff9e18b793791b8b845176f45449931e8cd12"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGExODMzMDJhYjM0OTJiZDNlNmI0NTg2OWNhMjc0ZmQyZDFhMzQ3MmI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a183302ab3492bd3e6b45869ca274fd2d1a3472b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a183302ab3492bd3e6b45869ca274fd2d1a3472b",
      "tree": {
        "sha": "43df209069a028c2a1d926291b285aed91fb0afa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/43df209069a028c2a1d926291b285aed91fb0afa"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/abfff9e18b793791b8b845176f45449931e8cd12",
          "sha": "abfff9e18b793791b8b845176f45449931e8cd12",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/abfff9e18b793791b8b845176f45449931e8cd12"
        }
      ],
      "message": "[p2p] don't find 1p1cs for reconsiderable txns that are AlreadyHaveTx\n\nThis is a slight behavior change: if a transaction is in both\nreconsiderable rejects and AlreadyHaveTx in another way, we don't try to\nreturn a 1p1c package. This is the correct thing to do, as we don't want\nto reconsider transactions that have multiple things wrong with them.\nFor example, if a transaction is low feerate, and then later found to\nhave a bad signature, we shouldn't try it again in a package.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:46Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-17T23:26:57Z"
      },
      "sha": "a183302ab3492bd3e6b45869ca274fd2d1a3472b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDEyOTEzZGViZDE4MjFjODViOTY3NDlkNGRkNzAwY2U3Y2M2NzllODg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12913debd1821c85b96749d4dd700ce7cc679e88",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/12913debd1821c85b96749d4dd700ce7cc679e88",
      "tree": {
        "sha": "13cdbb74e1299d6ac50e6ca266da8111b34fc375",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/13cdbb74e1299d6ac50e6ca266da8111b34fc375"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a183302ab3492bd3e6b45869ca274fd2d1a3472b",
          "sha": "a183302ab3492bd3e6b45869ca274fd2d1a3472b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a183302ab3492bd3e6b45869ca274fd2d1a3472b"
        }
      ],
      "message": "[p2p] don't process orphan if in recent rejects\n\nThis should never happen normally, but just in case.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-29T14:47:46Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-08-23T15:05:19Z"
      },
      "sha": "12913debd1821c85b96749d4dd700ce7cc679e88"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14445514156,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANdBQ2s",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14445514156",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-29T15:05:12Z"
    },
    {
      "event": "reviewed",
      "id": 2323753194,
      "node_id": "PRR_kwDOABII586Kgajq",
      "url": null,
      "actor": null,
      "commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Thanks for the review @l0rinc. I've gone through them and addressed some of your comments, and marked some as out of scope. As you can see this PR is fairly large, so it is my preference not to add changes to the code that is being moved. Perhaps we can take some into a followup.\r\n\r\n> I'll provide a higher-level review later, once I understand the problem better. I still need a few iterations to be able to zoom out and comment meaningfully, for now I only left nits about implementation specifics, modernization attempts, potential off-by-one errors, readability suggestions, etc.\r\n\r\nAs written in the [contributing guidelines](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review), it is best to do conceptual review before looking at syntax modernization and style. Hopefully it is obvious why this is done on a PR level. But also for individual reviewers, for a few reasons:\r\n\r\n(1) It will help you understand what to pay attention to and look out for. For example,  you've left 40+ review comments, and about 10 of them are suggestions for code that isn't actually introduced in this PR. That's probably not a great use of your time, as it's outside the scope of the PR.\r\n\r\n(2) It's less productive to request minor changes to something if you haven't decided whether it looks good on a macro level. For instance, if you ask for 40 minor changes now, and later realize you think the general approach is unsafe (e.g. actually parts of the interface should look entirely different, or the PR is simply a bad idea), it would have been unproductive for both of us to be using the 500grit sandpaper on a chunk of wood that was going to be discarded anyway.\r\n\r\nI hope this explanation makes sense. I felt it productive to write this up publicly as it's not uncommon to leave surface-level feedback, which is of course better than no review. However, our goal should be to make progress on PRs (towards yes or no). So when you decide to review a PR, I request that you start with conceptual review.\r\n\r\n> I'll provide a higher-level review later, once I understand the problem better. \r\n\r\nPlease do! Let me know if I can answer any questions and thank you very much for your review.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2323753194",
      "submitted_at": "2024-09-29T15:07:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "reviewed",
      "id": 2335892884,
      "node_id": "PRR_kwDOABII586LOuWU",
      "url": null,
      "actor": null,
      "commit_id": "ce205abe10ebccfdbea60adf4c568a8ba61390c3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "> It's less productive to request minor changes to something if you haven't decided whether it looks good on a macro level.\r\n\r\nI had to reduce the scope of the reviews since I'm not yet familiar with this part of the code.\r\nBut I understand it's not what's needed here, so I will let others (having deeper, more holistic experience) do concept reviews.",
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2335892884",
      "submitted_at": "2024-09-29T16:51:06Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "reviewed",
      "id": 2337805760,
      "node_id": "PRR_kwDOABII586LWBXA",
      "url": null,
      "actor": null,
      "commit_id": "ce205abe10ebccfdbea60adf4c568a8ba61390c3",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reACK ce205abe10ebccfdbea60adf4c568a8ba61390c3\r\n\r\nvia `git range-diff master 1d4e33e7f88162cf6fcd6aee0b63973015853591 ce205abe10ebccfdbea60adf4c568a8ba61390c3`\r\n\r\nnew unit test coverage looks superior, and catches the move error previously encountered.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2337805760",
      "submitted_at": "2024-09-30T15:18:21Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "review_requested",
      "id": 14458237463,
      "node_id": "RRE_lADOABII586I73RbzwAAAANdxzIX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14458237463",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-30T15:18:27Z",
      "requested_reviewer": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 14458237641,
      "node_id": "RRE_lADOABII586I73RbzwAAAANdxzLJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14458237641",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-30T15:18:28Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 2337916584,
      "node_id": "PRR_kwDOABII586LWcao",
      "url": null,
      "actor": null,
      "commit_id": "ce205abe10ebccfdbea60adf4c568a8ba61390c3",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2337916584",
      "submitted_at": "2024-09-30T16:00:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "reviewed",
      "id": 2338563165,
      "node_id": "PRR_kwDOABII586LY6Rd",
      "url": null,
      "actor": null,
      "commit_id": "ce205abe10ebccfdbea60adf4c568a8ba61390c3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2338563165",
      "submitted_at": "2024-09-30T21:46:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "review_requested",
      "id": 14462704845,
      "node_id": "RRE_lADOABII586I73RbzwAAAANeC1zN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14462704845",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-30T21:46:16Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 2340935700,
      "node_id": "PRR_kwDOABII586Lh9gU",
      "url": null,
      "actor": null,
      "commit_id": "3c1c9e766ad4fc6defdc9b4814c1e184f6603003",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2340935700",
      "submitted_at": "2024-10-01T17:01:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "review_requested",
      "id": 14476479629,
      "node_id": "RRE_lADOABII586I73RbzwAAAANe3YyN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14476479629",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-01T17:01:57Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI0ZTkzYWYzM2U2ZGUwZWFmNTMxZWIxNzEyMmU1MzI1ZDk2MDFiYTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/24e93af33e6de0eaf531eb17122e5325d9601ba6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/24e93af33e6de0eaf531eb17122e5325d9601ba6",
      "tree": {
        "sha": "ef92c8d6f882f25c8482f8ea5aafafd4ad6c648c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ef92c8d6f882f25c8482f8ea5aafafd4ad6c648c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12913debd1821c85b96749d4dd700ce7cc679e88",
          "sha": "12913debd1821c85b96749d4dd700ce7cc679e88",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/12913debd1821c85b96749d4dd700ce7cc679e88"
        }
      ],
      "message": "Assume state is Invalid in MempoolRejectedTx\n\nThis function should never be called with a non-invalid state.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-10-01T22:06:44Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-10-01T22:06:05Z"
      },
      "sha": "24e93af33e6de0eaf531eb17122e5325d9601ba6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDFhZTMwNWVlYTFhZDI1NDg1YjViZDVjMmZmYjY5OGNhNTFiNTg1MjQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1ae305eea1ad25485b5bd5c2ffb698ca51b58524",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/1ae305eea1ad25485b5bd5c2ffb698ca51b58524",
      "tree": {
        "sha": "35a95322970bd195bbf12cd54d64683eb3255c12",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/35a95322970bd195bbf12cd54d64683eb3255c12"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/24e93af33e6de0eaf531eb17122e5325d9601ba6",
          "sha": "24e93af33e6de0eaf531eb17122e5325d9601ba6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/24e93af33e6de0eaf531eb17122e5325d9601ba6"
        }
      ],
      "message": "add TxDownloadOptions bool to make TxRequestTracker deterministic\n\nForward this bool to the TxRequestTracker ctor. This is needed for\nstablity in TxDownloadManager fuzzers",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-10-01T22:06:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-08-27T11:12:12Z"
      },
      "sha": "1ae305eea1ad25485b5bd5c2ffb698ca51b58524"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZhZTRhY2M1MzcwZDcxM2IwMDJkOGQ5Yzc0NWNiMzVjYzRiM2Q1MTM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6ae4acc5370d713b002d8d9c745cb35cc4b3d513",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6ae4acc5370d713b002d8d9c745cb35cc4b3d513",
      "tree": {
        "sha": "efffabab6a005802abde46d085fd5d9cf81dcb3b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/efffabab6a005802abde46d085fd5d9cf81dcb3b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1ae305eea1ad25485b5bd5c2ffb698ca51b58524",
          "sha": "1ae305eea1ad25485b5bd5c2ffb698ca51b58524",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/1ae305eea1ad25485b5bd5c2ffb698ca51b58524"
        }
      ],
      "message": "[fuzz] txdownloadman and txdownload_impl\n\nThe txdownload_impl is similar but allows us to check specific\ninvariants within its implementation. It will also change a lot more\nthan the external interface (txdownloadman) will, so we will add more to\nthis target later.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-10-01T22:20:58Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2023-09-29T14:43:16Z"
      },
      "sha": "6ae4acc5370d713b002d8d9c745cb35cc4b3d513"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGNmZWY0MGU3ZWM4ZDhlYWY5NjJiZmI2MzcyOWJmNzJmYWI2OGIzYWY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cfef40e7ec8d8eaf962bfb63729bf72fab68b3af",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/cfef40e7ec8d8eaf962bfb63729bf72fab68b3af",
      "tree": {
        "sha": "506f52b2e98f7f5d1c6f8a9c599b33500390e14a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/506f52b2e98f7f5d1c6f8a9c599b33500390e14a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6ae4acc5370d713b002d8d9c745cb35cc4b3d513",
          "sha": "6ae4acc5370d713b002d8d9c745cb35cc4b3d513",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6ae4acc5370d713b002d8d9c745cb35cc4b3d513"
        }
      ],
      "message": "[unit test] MempoolRejectedTx",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-10-01T22:20:58Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-29T10:58:54Z"
      },
      "sha": "cfef40e7ec8d8eaf962bfb63729bf72fab68b3af"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDExNGE1NDA1YzQxZDI1OTYyY2I4OTVkYmQ4NjQ0NTJlNDBhZjVmY2M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/114a5405c41d25962cb895dbd864452e40af5fcc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/114a5405c41d25962cb895dbd864452e40af5fcc",
      "tree": {
        "sha": "3ea77aeb176f548f937282fcb32a83dc2e28ebdd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3ea77aeb176f548f937282fcb32a83dc2e28ebdd"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cfef40e7ec8d8eaf962bfb63729bf72fab68b3af",
          "sha": "cfef40e7ec8d8eaf962bfb63729bf72fab68b3af",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/cfef40e7ec8d8eaf962bfb63729bf72fab68b3af"
        }
      ],
      "message": "[fuzz] tx download succeeds as long as we have 1 good outbound",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-10-01T22:27:09Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-05-17T14:56:52Z"
      },
      "sha": "114a5405c41d25962cb895dbd864452e40af5fcc"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14481434713,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANfKShZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14481434713",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-02T01:08:59Z"
    },
    {
      "event": "commented",
      "id": 2388665904,
      "node_id": "IC_kwDOABII586OYCYw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2388665904",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-02T13:36:37Z",
      "updated_at": "2024-10-02T13:36:37Z",
      "author_association": "MEMBER",
      "body": "reACK ce205abe10ebccfdbea60adf4c568a8ba61390c3\r\n\r\nthanks for picking up on some of those old nits",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2388665904",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1606683947",
      "pull_request_review_id": 2066059450,
      "id": 1606683947,
      "node_id": "PRRC_kwDOABII585fxA0r",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+// Copyright (c) 2022\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_NODE_TXDOWNLOAD_IMPL_H\n+#define BITCOIN_NODE_TXDOWNLOAD_IMPL_H\n+\n+#include <consensus/validation.h>\n+#include <kernel/chain.h>\n+#include <net.h>\n+#include <policy/packages.h>\n+#include <txorphanage.h>\n+#include <txrequest.h>\n+\n+class CTxMemPool;\n+namespace node {\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {",
      "path": "src/node/txdownload_impl.h",
      "position": null,
      "original_position": 32,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b1cc0c3006ca608f9ac3af2c50c4728cbbc07714",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Structs that are part of the public interface should probably go into `txdownloadman.h`. Otherwise one needs to include the impl header, e.g. like `txdownloadman.h` does right now, which defeats the purpose of pimpling to some extend.",
      "created_at": "2024-05-20T11:55:23Z",
      "updated_at": "2024-05-20T12:32:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1606683947",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1606683947"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1606717505",
      "pull_request_review_id": 2066059450,
      "id": 1606717505,
      "node_id": "PRRC_kwDOABII585fxJBB",
      "diff_hunk": "@@ -0,0 +1,455 @@\n+// Copyright (c) 2023\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownload_impl.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+void TxDownloadImpl::UpdatedBlockTipSync()\n+{\n+    // If the chain tip has changed, previously rejected transactions might now be invalid, e.g. due\n+    // to a timelock. Reset the rejection filters to give those transactions another chance if we\n+    // see them again.\n+    m_recent_rejects.reset();\n+    m_recent_rejects_reconsiderable.reset();\n+}\n+\n+void TxDownloadImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        m_recent_confirmed_transactions.insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            m_recent_confirmed_transactions.insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+    }\n+    for (const auto& ptx : pblock->vtx) {\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    m_recent_confirmed_transactions.reset();\n+}\n+\n+bool TxDownloadImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 55,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b1cc0c3006ca608f9ac3af2c50c4728cbbc07714",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Iiuc correctly, clearing the filters here has been removed as we don't want `TxDownloadManager` to depend on `ChainstateManager`.\r\n\r\nAn alternative to the new synchronous validation interface callback could be to preserve the previous behavior (clearing the filters in `AlreadyHaveTx` on a tip change) by introducing an interface for TxDownloadMan to fetch the latest tip hash. For example, `TxDownloadOptions` could be extended to hold a lambda that returns the latest tip hash, which in production simply fetches the hash from the `ChainstateManager` (and for tests it can be mocked). This might be easier to review since it preserves the previous mechanism? Although perhaps also more difficult w.r.t to lock inversion of `cs_main` and `m_tx_download_mutex`.\r\n\r\nAnother alternative could be to directly pass the current block hash as a param into the relevant `TxDownloadManager` methods.",
      "created_at": "2024-05-20T12:29:29Z",
      "updated_at": "2024-05-20T12:32:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1606717505",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1606717505"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1608263692",
      "pull_request_review_id": 2068531687,
      "id": 1608263692,
      "node_id": "PRRC_kwDOABII585f3CgM",
      "diff_hunk": "@@ -0,0 +1,455 @@\n+// Copyright (c) 2023\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownload_impl.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+void TxDownloadImpl::UpdatedBlockTipSync()\n+{\n+    // If the chain tip has changed, previously rejected transactions might now be invalid, e.g. due\n+    // to a timelock. Reset the rejection filters to give those transactions another chance if we\n+    // see them again.\n+    m_recent_rejects.reset();\n+    m_recent_rejects_reconsiderable.reset();\n+}\n+\n+void TxDownloadImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        m_recent_confirmed_transactions.insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            m_recent_confirmed_transactions.insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+    }\n+    for (const auto& ptx : pblock->vtx) {\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    m_recent_confirmed_transactions.reset();\n+}\n+\n+bool TxDownloadImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 55,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b1cc0c3006ca608f9ac3af2c50c4728cbbc07714",
      "in_reply_to_id": 1606717505,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think we'd ever need to make `TxDownloadManager` depend on `ChainstateManager` as we could just pass in the block hash, i.e.\r\n\r\n> Another alternative could be to directly pass the current block hash as a param into the relevant TxDownloadManager methods.\r\n\r\nThis would avoid the addition of `UpdateBlockTipSync` etc, as it's basically what we do now. I find this way of keeping synchronized with the chain tip pretty ugly - we'd need to hold `cs_main` and pass the blockhash to the `TxDownloadManager` all the time, bloating the interface. Subscribing to the validation interface and updating on every chain tip update seems much more sensible.",
      "created_at": "2024-05-21T12:43:55Z",
      "updated_at": "2024-05-21T12:43:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1608263692",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1608263692"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1608272072",
      "pull_request_review_id": 2068544653,
      "id": 1608272072,
      "node_id": "PRRC_kwDOABII585f3EjI",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+// Copyright (c) 2022\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_NODE_TXDOWNLOAD_IMPL_H\n+#define BITCOIN_NODE_TXDOWNLOAD_IMPL_H\n+\n+#include <consensus/validation.h>\n+#include <kernel/chain.h>\n+#include <net.h>\n+#include <policy/packages.h>\n+#include <txorphanage.h>\n+#include <txrequest.h>\n+\n+class CTxMemPool;\n+namespace node {\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {",
      "path": "src/node/txdownload_impl.h",
      "position": null,
      "original_position": 32,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b1cc0c3006ca608f9ac3af2c50c4728cbbc07714",
      "in_reply_to_id": 1606683947,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hm, in the previous setup, we can change any of txdownload_impl.cpp without net_processing.cpp noticing, but yeah maybe less clean to depend on txdownload_impl.h.\r\n\r\nI've updated with a new setup where I've added a txdownloadman.cpp depending on txdownload_impl.h, and txdownloadman.h is included by txdownload_impl.h instead of the other way around. And so net_processing.cpp no longer depends on txdownload_impl.h, which makes sense to me. Had to update `lint-circular-dependencies.py` but I do like that we can change txdownload_impl.h without recompiling everything. lmk if this seems better?",
      "created_at": "2024-05-21T12:49:45Z",
      "updated_at": "2024-05-21T12:49:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1608272072",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1608272072"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715592140",
      "pull_request_review_id": 2236038602,
      "id": 1715592140,
      "node_id": "PRRC_kwDOABII585mQdvM",
      "diff_hunk": "@@ -5,5 +5,45 @@\n #include <node/txdownload_impl.h>\n #include <node/txdownloadman.h>\n \n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n namespace node {\n+void TxDownloadImpl::ActiveTipChange()\n+{\n+    // If the chain tip has changed, previously rejected transactions might now be invalid, e.g. due",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 12,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "41080ff0e92120023d25ba08612b5181f353d1d4",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    // If the chain tip has changed, previously rejected transactions might now be valid, e.g. due\r\n```\r\nalso, this comment now exists both in `PeerManagerImpl::ActiveTipChange` and `TxDownloadImpl::ActiveTipChange`, probably one can be removed",
      "created_at": "2024-08-13T16:28:42Z",
      "updated_at": "2024-08-13T17:43:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1715592140",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715592140"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715600184",
      "pull_request_review_id": 2236038602,
      "id": 1715600184,
      "node_id": "PRRC_kwDOABII585mQfs4",
      "diff_hunk": "@@ -75,4 +76,23 @@ bool TxDownloadImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsider\n \n     return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n }\n+\n+void TxDownloadImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.count(nodeid) > 0) return;",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 16,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "6c70bc621ba14a1ddf3214f89c6367372924a01a",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "slightly-more-modern-nit (here and in `TxDownloadImpl::DisconnectedPeer` below):\r\n```suggestion\r\n    if (m_peer_info.contains(nodeid)) return;\r\n```",
      "created_at": "2024-08-13T16:33:18Z",
      "updated_at": "2024-08-13T17:43:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1715600184",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715600184"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 83,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715622227",
      "pull_request_review_id": 2236038602,
      "id": 1715622227,
      "node_id": "PRRC_kwDOABII585mQlFT",
      "diff_hunk": "@@ -4117,12 +4065,11 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     return;\n                 }\n                 const GenTxid gtxid = ToGenTxid(inv);\n-                const bool fAlreadyHave = m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true);\n-                LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n \n                 AddKnownTx(*peer, inv.hash);\n-                if (!fAlreadyHave && !m_chainman.IsInitialBlockDownload()) {\n-                    AddTxAnnouncement(pfrom, gtxid, current_time);\n+                if (!m_chainman.IsInitialBlockDownload()) {\n+                    const bool fAlreadyHave{m_txdownloadman.AddTxAnnouncement(pfrom.GetId(), gtxid, current_time, /*p2p_inv=*/true)};\n+                    LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n                 }",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 95,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3f5dbd56da1e2434984c554ba3e24452d873bd07",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: strictly speaking this is not a pure refactor, as there is a change in logging behaviour (INV messages received during IBD now don't trigger the \"got inv\" log message any more). seems to make more sense though anyway, so feel free to ignore",
      "created_at": "2024-08-13T16:48:49Z",
      "updated_at": "2024-08-13T17:43:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1715622227",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715622227"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 4120,
      "start_side": "LEFT",
      "line": null,
      "original_line": 3942,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715630850",
      "pull_request_review_id": 2236038602,
      "id": 1715630850,
      "node_id": "PRRC_kwDOABII585mQnMC",
      "diff_hunk": "@@ -4531,7 +4478,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     AddKnownTx(*peer, parent_txid);\n                     // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n                     // previously rejected for being too low feerate. This orphan might CPFP it.\n-                    if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) AddTxAnnouncement(pfrom, gtxid, current_time);\n+                    if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+                        m_txdownloadman.AddTxAnnouncement(pfrom.GetId(), gtxid, current_time, /*p2p_inv=*/false);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 104,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3f5dbd56da1e2434984c554ba3e24452d873bd07",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "small note: with this approach, `AlreadyHaveTx` is now called twice: once in the if condition, and the second time in the `AddTxAnnouncement` method (not sure if that's really a problem though)",
      "created_at": "2024-08-13T16:55:44Z",
      "updated_at": "2024-08-13T17:43:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1715630850",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715630850"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 4481,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 4482,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716582838",
      "pull_request_review_id": 2237602476,
      "id": 1716582838,
      "node_id": "PRRC_kwDOABII585mUPm2",
      "diff_hunk": "@@ -5,5 +5,45 @@\n #include <node/txdownload_impl.h>\n #include <node/txdownloadman.h>\n \n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n namespace node {\n+void TxDownloadImpl::ActiveTipChange()\n+{\n+    // If the chain tip has changed, previously rejected transactions might now be invalid, e.g. due",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 12,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "41080ff0e92120023d25ba08612b5181f353d1d4",
      "in_reply_to_id": 1715592140,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah, that looks like a bad rebase - deleted the comment now, thanks",
      "created_at": "2024-08-14T09:13:54Z",
      "updated_at": "2024-08-14T09:55:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1716582838",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716582838"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716591125",
      "pull_request_review_id": 2237602476,
      "id": 1716591125,
      "node_id": "PRRC_kwDOABII585mURoV",
      "diff_hunk": "@@ -75,4 +76,23 @@ bool TxDownloadImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsider\n \n     return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n }\n+\n+void TxDownloadImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.count(nodeid) > 0) return;",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 16,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "6c70bc621ba14a1ddf3214f89c6367372924a01a",
      "in_reply_to_id": 1715600184,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done :+1: ",
      "created_at": "2024-08-14T09:18:42Z",
      "updated_at": "2024-08-14T09:55:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1716591125",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716591125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 83,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716644034",
      "pull_request_review_id": 2237602476,
      "id": 1716644034,
      "node_id": "PRRC_kwDOABII585mUejC",
      "diff_hunk": "@@ -4117,12 +4065,11 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     return;\n                 }\n                 const GenTxid gtxid = ToGenTxid(inv);\n-                const bool fAlreadyHave = m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true);\n-                LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n \n                 AddKnownTx(*peer, inv.hash);\n-                if (!fAlreadyHave && !m_chainman.IsInitialBlockDownload()) {\n-                    AddTxAnnouncement(pfrom, gtxid, current_time);\n+                if (!m_chainman.IsInitialBlockDownload()) {\n+                    const bool fAlreadyHave{m_txdownloadman.AddTxAnnouncement(pfrom.GetId(), gtxid, current_time, /*p2p_inv=*/true)};\n+                    LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n                 }",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 95,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3f5dbd56da1e2434984c554ba3e24452d873bd07",
      "in_reply_to_id": 1715622227,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right, I don't think it's problematic to not log tx invs during IBD since they are ignored anyway.\r\n\r\nI've moved the logging change to its own commit, to keep the pure refactoring-ness of this commit :+1: ",
      "created_at": "2024-08-14T09:55:25Z",
      "updated_at": "2024-08-14T09:55:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1716644034",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716644034"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 4120,
      "start_side": "LEFT",
      "line": null,
      "original_line": 3942,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716644076",
      "pull_request_review_id": 2237602476,
      "id": 1716644076,
      "node_id": "PRRC_kwDOABII585mUejs",
      "diff_hunk": "@@ -4531,7 +4478,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     AddKnownTx(*peer, parent_txid);\n                     // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n                     // previously rejected for being too low feerate. This orphan might CPFP it.\n-                    if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) AddTxAnnouncement(pfrom, gtxid, current_time);\n+                    if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+                        m_txdownloadman.AddTxAnnouncement(pfrom.GetId(), gtxid, current_time, /*p2p_inv=*/false);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 104,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3f5dbd56da1e2434984c554ba3e24452d873bd07",
      "in_reply_to_id": 1715630850,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah, good observation. I've now gated the `AlreadyHaveTx` check inside of `AddTxAnnouncement` on `p2p_inv` so this is no longer happening.",
      "created_at": "2024-08-14T09:55:27Z",
      "updated_at": "2024-08-14T09:55:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1716644076",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716644076"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 4481,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 4482,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722086417",
      "pull_request_review_id": 2245996944,
      "id": 1722086417,
      "node_id": "PRRC_kwDOABII585mpPQR",
      "diff_hunk": "@@ -44,4 +44,33 @@ void TxDownloadImpl::BlockDisconnected()\n     // should be just after a new block containing it is found.\n     RecentConfirmedTransactionsFilter().reset();\n }\n+\n+bool TxDownloadImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3824d1f81ad9e4ff44ec46d07f4e8f86f27ce643",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "3824d1f81ad9e4ff44ec46d07f4e8f86f27ce643 decent time to rename the function since that's been a previous discussion point?",
      "created_at": "2024-08-19T16:53:28Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1722086417",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722086417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722183824",
      "pull_request_review_id": 2245996944,
      "id": 1722183824,
      "node_id": "PRRC_kwDOABII585mpnCQ",
      "diff_hunk": "@@ -3841,6 +3840,14 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                        tx_relay->m_next_inv_send_time == 0s));\n         }\n \n+        LOCK2(::cs_main, m_tx_download_mutex);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 14,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "af3647050a85e6f33f902b903207043f6f0c023c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "af3647050a85e6f33f902b903207043f6f0c023c preference for this to be inside own scope",
      "created_at": "2024-08-19T18:21:53Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1722183824",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722183824"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3843,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722205151",
      "pull_request_review_id": 2245996944,
      "id": 1722205151,
      "node_id": "PRRC_kwDOABII585mpsPf",
      "diff_hunk": "@@ -4531,7 +4478,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     AddKnownTx(*peer, parent_txid);\n                     // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n                     // previously rejected for being too low feerate. This orphan might CPFP it.\n-                    if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) AddTxAnnouncement(pfrom, gtxid, current_time);\n+                    if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+                        m_txdownloadman.AddTxAnnouncement(pfrom.GetId(), gtxid, current_time, /*p2p_inv=*/false);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 104,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3f5dbd56da1e2434984c554ba3e24452d873bd07",
      "in_reply_to_id": 1715630850,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It may have been an issue since the `AddTxAnnouncement` invocation of AlreadyHaveTx included reconsiderable filter.\r\n\r\nSince there are only two call sites of `AddTxAnnouncement`, and each had a filtering `AlreadyHasTx` call, would it make sense to just do something like this instead?\r\n\r\n```\r\nif (AlreadyHaveTx(gtxid, /*include_reconsiderable=*/p2p_inv)) return true;\r\n```\r\n",
      "created_at": "2024-08-19T18:41:20Z",
      "updated_at": "2024-08-20T13:56:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1722205151",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722205151"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 4481,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 4482,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722268907",
      "pull_request_review_id": 2245996944,
      "id": 1722268907,
      "node_id": "PRRC_kwDOABII585mp7zr",
      "diff_hunk": "@@ -2995,16 +2995,95 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n     AssertLockHeld(g_msgproc_mutex);\n     AssertLockHeld(m_tx_download_mutex);\n \n+    PeerRef peer{GetPeerRef(nodeid)};\n+\n     auto& m_orphanage = m_txdownloadman.GetOrphanageRef();\n     auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n+    const CTransaction& tx{*ptx};\n \n     LogDebug(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n         ptx->GetHash().ToString(),\n         ptx->GetWitnessHash().ToString(),\n         nodeid,\n         state.ToString());\n \n-    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+    // Only process a new orphan if maybe_add_extra_compact_tx, as otherwise it must be either",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 17,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "77560a690ce05697400dcbb73bcb4d89724a9e4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`maybe_add_extra_compact_tx` is starting to creep in usage vs its ostensible usage\r\n\r\nI'm also not quire sure I parse this sentence. I presume it's trying to say this is only used in regular situations when freshly received over p2p.",
      "created_at": "2024-08-19T19:44:39Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1722268907",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722268907"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3010,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722273831",
      "pull_request_review_id": 2245996944,
      "id": 1722273831,
      "node_id": "PRRC_kwDOABII585mp9An",
      "diff_hunk": "@@ -2995,16 +2995,95 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n     AssertLockHeld(g_msgproc_mutex);\n     AssertLockHeld(m_tx_download_mutex);\n \n+    PeerRef peer{GetPeerRef(nodeid)};\n+\n     auto& m_orphanage = m_txdownloadman.GetOrphanageRef();\n     auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n+    const CTransaction& tx{*ptx};\n \n     LogDebug(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n         ptx->GetHash().ToString(),\n         ptx->GetWitnessHash().ToString(),\n         nodeid,\n         state.ToString());\n \n-    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+    // Only process a new orphan if maybe_add_extra_compact_tx, as otherwise it must be either\n+    // already in orphanage or from 1p1c processing.\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS && maybe_add_extra_compact_tx) {\n+        bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+        // Deduplicate parent txids, so that we don't have to loop over\n+        // the same parent txid more than once down below.\n+        std::vector<uint256> unique_parents;\n+        unique_parents.reserve(tx.vin.size());\n+        for (const CTxIn& txin : tx.vin) {\n+            // We start with all parents, and then remove duplicates below.\n+            unique_parents.push_back(txin.prevout.hash);\n+        }\n+        std::sort(unique_parents.begin(), unique_parents.end());\n+        unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+        // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.\n+        // We can tolerate having up to 1 parent in m_lazy_recent_rejects_reconsiderable since we\n+        // submit 1p1c packages. However, fail immediately if any are in m_lazy_recent_rejects.\n+        std::optional<uint256> rejected_parent_reconsiderable;\n+        for (const uint256& parent_txid : unique_parents) {\n+            if (RecentRejectsFilter().contains(parent_txid)) {\n+                fRejectedParents = true;\n+                break;\n+            } else if (RecentRejectsReconsiderableFilter().contains(parent_txid) && !m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                // More than 1 parent in m_lazy_recent_rejects_reconsiderable: 1p1c will not be\n+                // sufficient to accept this package, so just give up here.\n+                if (rejected_parent_reconsiderable.has_value()) {\n+                    fRejectedParents = true;\n+                    break;\n+                }\n+                rejected_parent_reconsiderable = parent_txid;\n+            }\n+        }\n+        if (!fRejectedParents) {\n+            const auto current_time{GetTime<std::chrono::microseconds>()};\n+\n+            for (const uint256& parent_txid : unique_parents) {\n+                // Here, we only have the txid (and not wtxid) of the\n+                // inputs, so we only request in txid mode, even for\n+                // wtxidrelay peers.\n+                // Eventually we should replace this with an improved\n+                // protocol for getting all unconfirmed parents.\n+                const auto gtxid{GenTxid::Txid(parent_txid)};\n+                if (peer) AddKnownTx(*peer, parent_txid);\n+                // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n+                // previously rejected for being too low feerate. This orphan might CPFP it.\n+                if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+                    m_txdownloadman.AddTxAnnouncement(nodeid, gtxid, current_time, /*p2p_inv=*/false);\n+                }\n+            }\n+\n+            if (m_orphanage.AddTx(ptx, nodeid)) {\n+                AddToCompactExtraTransactions(ptx);\n+            }\n+\n+            // Once added to the orphan pool, a tx is considered AlreadyHave, and we shouldn't request it anymore.\n+            m_txrequest.ForgetTxHash(tx.GetHash());\n+            m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+\n+            // DoS prevention: do not allow m_orphanage to grow unbounded (see CVE-2012-3789)\n+            m_orphanage.LimitOrphans(m_opts.max_orphan_txs, m_rng);\n+        } else {\n+            LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s (wtxid=%s)\\n\",\n+                     tx.GetHash().ToString(),\n+                     tx.GetWitnessHash().ToString());\n+            // We will continue to reject this tx since it has rejected\n+            // parents so avoid re-requesting it from other peers.\n+            // Here we add both the txid and the wtxid, as we know that\n+            // regardless of what witness is provided, we will not accept\n+            // this, so we don't need to allow for redownload of this txid\n+            // from any of our non-wtxidrelay peers.\n+            RecentRejectsFilter().insert(tx.GetHash().ToUint256());",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "77560a690ce05697400dcbb73bcb4d89724a9e4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "unrelated to your move-only change, but if txid==wtxid, looks like we're doing two insertions anyways here",
      "created_at": "2024-08-19T19:49:13Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1722273831",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722273831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3082,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722276530",
      "pull_request_review_id": 2245996944,
      "id": 1722276530,
      "node_id": "PRRC_kwDOABII585mp9qy",
      "diff_hunk": "@@ -594,8 +604,8 @@ class PeerManagerImpl final : public PeerManager\n      *                                            Set to false if the tx has already been rejected before,\n      *                                            e.g. is an orphan, to avoid adding duplicate entries.\n      * Updates m_txrequest, m_lazy_recent_rejects, m_lazy_recent_rejects_reconsiderable, m_orphanage, and vExtraTxnForCompact. */\n-    void ProcessInvalidTx(NodeId nodeid, const CTransactionRef& tx, const TxValidationState& result,\n-                          bool maybe_add_extra_compact_tx)\n+    std::optional<PackageToValidate> ProcessInvalidTx(NodeId nodeid, const CTransactionRef& tx, const TxValidationState& result,",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 34,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "d3fb8ca103b32f6071790bf7a9471fe4f80f5479",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "d3fb8ca103b32f6071790bf7a9471fe4f80f5479\r\n\r\nnew ProcessInvalidTx return value needs to be documented",
      "created_at": "2024-08-19T19:51:09Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1722276530",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722276530"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 607,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722277826",
      "pull_request_review_id": 2245996944,
      "id": 1722277826,
      "node_id": "PRRC_kwDOABII585mp9_C",
      "diff_hunk": "@@ -3104,6 +3117,14 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n             // because we should not download or submit this transaction by itself again, but may\n             // submit it as part of a package later.\n             RecentRejectsReconsiderableFilter().insert(ptx->GetWitnessHash().ToUint256());\n+\n+            if (maybe_add_extra_compact_tx) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 72,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "d3fb8ca103b32f6071790bf7a9471fe4f80f5479",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "further definitional drift of `maybe_add_extra_compact_tx`, let's try to find something else to call this?",
      "created_at": "2024-08-19T19:52:39Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1722277826",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722277826"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3121,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723275394",
      "pull_request_review_id": 2245996944,
      "id": 1723275394,
      "node_id": "PRRC_kwDOABII585mtxiC",
      "diff_hunk": "@@ -3129,17 +3129,7 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     AssertLockHeld(g_msgproc_mutex);\n     AssertLockHeld(m_tx_download_mutex);\n \n-    auto& m_orphanage = m_txdownloadman.GetOrphanageRef();\n-    auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n-\n-    // As this version of the transaction was acceptable, we can forget about any requests for it.\n-    // No-op if the tx is not in txrequest.\n-    m_txrequest.ForgetTxHash(tx->GetHash());\n-    m_txrequest.ForgetTxHash(tx->GetWitnessHash());\n-\n-    m_orphanage.AddChildrenToWorkSet(*tx);\n-    // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n-    m_orphanage.EraseTx(tx->GetWitnessHash());\n+    m_txdownloadman.MempoolAcceptedTx(tx);",
      "path": "src/net_processing.cpp",
      "position": 517,
      "original_position": 15,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "65d773feb7384a6893ee7e6a7b24dfa60f2d8d39",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "65d773feb7384a6893ee7e6a7b24dfa60f2d8d39\r\n\r\ncommit message seems grammatically incorrect:\r\n\r\n\"[refactor] move valid and tx processing to TxDownload\"",
      "created_at": "2024-08-20T13:01:52Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723275394",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723275394"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2998,
      "original_line": 2998,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723307535",
      "pull_request_review_id": 2245996944,
      "id": 1723307535,
      "node_id": "PRRC_kwDOABII585mt5YP",
      "diff_hunk": "@@ -4220,24 +4214,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         LOCK2(cs_main, m_tx_download_mutex);\n \n-        auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n-\n-        m_txrequest.ReceivedResponse(pfrom.GetId(), txid);\n-        if (tx.HasWitness()) m_txrequest.ReceivedResponse(pfrom.GetId(), wtxid);\n-\n-        // We do the AlreadyHaveTx() check using wtxid, rather than txid - in the\n-        // absence of witness malleation, this is strictly better, because the\n-        // recent rejects filter may contain the wtxid but rarely contains\n-        // the txid of a segwit transaction that has been rejected.\n-        // In the presence of witness malleation, it's possible that by only\n-        // doing the check with wtxid, we could overlook a transaction which\n-        // was confirmed with a different witness, or exists in our mempool\n-        // with a different witness, but this has limited downside:\n-        // mempool validation does its own lookup of whether we have the txid\n-        // already; and an adversary can already relay us old transactions\n-        // (older than our recency filter) if trying to DoS us, without any need\n-        // for witness malleation.\n-        if (m_txdownloadman.AlreadyHaveTx(GenTxid::Wtxid(wtxid), /*include_reconsiderable=*/true)) {\n+        const auto& [should_validate, package_to_validate] = m_txdownloadman.ReceivedTx(pfrom.GetId(), ptx);\n+        if (!should_validate) {",
      "path": "src/net_processing.cpp",
      "position": 682,
      "original_position": 36,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "ed96f3ef3dfb42fef4564aa5eedc636c2d6d8845",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "should `Assume` that package_to_validate is std::nullopt if `should_validate` is true",
      "created_at": "2024-08-20T13:22:39Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723307535",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723307535"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4234,
      "original_line": 4234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723318351",
      "pull_request_review_id": 2245996944,
      "id": 1723318351,
      "node_id": "PRRC_kwDOABII585mt8BP",
      "diff_hunk": "@@ -371,4 +371,58 @@ void TxDownloadImpl::MempoolRejectedPackage(const Package& package)\n {\n     RecentRejectsReconsiderableFilter().insert(GetPackageHash(package));\n }\n+\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadImpl::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    const uint256& txid = ptx->GetHash();\n+    const uint256& wtxid = ptx->GetWitnessHash();\n+\n+    // Mark that we have received a response\n+    m_txrequest.ReceivedResponse(nodeid, ptx->GetHash());\n+    if (ptx->HasWitness()) m_txrequest.ReceivedResponse(nodeid, ptx->GetWitnessHash());\n+\n+    // First check if we should drop this tx.\n+    // We do the AlreadyHaveTx() check using wtxid, rather than txid - in the\n+    // absence of witness malleation, this is strictly better, because the\n+    // recent rejects filter may contain the wtxid but rarely contains\n+    // the txid of a segwit transaction that has been rejected.\n+    // In the presence of witness malleation, it's possible that by only\n+    // doing the check with wtxid, we could overlook a transaction which\n+    // was confirmed with a different witness, or exists in our mempool\n+    // with a different witness, but this has limited downside:\n+    // mempool validation does its own lookup of whether we have the txid\n+    // already; and an adversary can already relay us old transactions\n+    // (older than our recency filter) if trying to DoS us, without any need\n+    // for witness malleation.\n+    if (AlreadyHaveTx(GenTxid::Wtxid(wtxid), /*include_reconsiderable=*/true)) {\n+\n+        if (RecentRejectsReconsiderableFilter().contains(wtxid)) {\n+            // When a transaction is already in m_lazy_recent_rejects_reconsiderable, we shouldn't submit\n+            // it by itself again. However, look for a matching child in the orphanage, as it is\n+            // possible that they succeed as a package.\n+            LogPrint(BCLog::TXPACKAGES, \"found tx %s (wtxid=%s) in reconsiderable rejects, looking for child in orphanage\\n\",\n+                     txid.ToString(), wtxid.ToString());\n+            return std::make_pair(false, Find1P1CPackage(ptx, nodeid));\n+        }\n+\n+        // If a tx is detected by m_lazy_recent_rejects it is ignored. Because we haven't",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 38,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "ed96f3ef3dfb42fef4564aa5eedc636c2d6d8845",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "just noting this moved comment is extremely verbose/old comment and can probably just have the last paragraph kept?",
      "created_at": "2024-08-20T13:29:21Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723318351",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723318351"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 408,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723349184",
      "pull_request_review_id": 2245996944,
      "id": 1723349184,
      "node_id": "PRRC_kwDOABII585muDjA",
      "diff_hunk": "@@ -425,4 +425,15 @@ std::pair<bool, std::optional<PackageToValidate>> TxDownloadImpl::ReceivedTx(Nod\n \n     return std::make_pair(true, std::nullopt);\n }\n+\n+bool TxDownloadImpl::HaveMoreWork(NodeId nodeid)",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "81f67607e811bcb5040142c401a51634b17bc3a8",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If the wrapper is named `HaveMoreWork`, maybe have `GetTxToReconsider` be called `GetMoreWork`? Otherwise they seem incongruous. ",
      "created_at": "2024-08-20T13:47:31Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723349184",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723349184"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 429,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723352509",
      "pull_request_review_id": 2245996944,
      "id": 1723352509,
      "node_id": "PRRC_kwDOABII585muEW9",
      "diff_hunk": "@@ -436,4 +436,13 @@ CTransactionRef TxDownloadImpl::GetTxToReconsider(NodeId nodeid)\n     return m_orphanage.GetTxToReconsider(nodeid);\n }\n \n+void TxDownloadImpl::CheckIsEmpty(NodeId nodeid)",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 4,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "388c2f5d7ee5f38cbefaff0c85cf298083127299",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "CheckRequestsEmpty?",
      "created_at": "2024-08-20T13:49:29Z",
      "updated_at": "2024-08-20T13:56:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723352509",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723352509"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 439,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723401360",
      "pull_request_review_id": 2248150197,
      "id": 1723401360,
      "node_id": "PRRC_kwDOABII585muQSQ",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 70,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "simplest is a blank CScript",
      "created_at": "2024-08-20T14:17:00Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723401360",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723401360"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723403236",
      "pull_request_review_id": 2248150197,
      "id": 1723403236,
      "node_id": "PRRC_kwDOABII585muQvk",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to\n+    // ensure uniqueness. Here, we want to avoid direct parent/child relationships between transactions.",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 87,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Here, we want to avoid direct parent/child relationships between transacti\r\n\r\ndoesn't a chain mean direct parent/child?",
      "created_at": "2024-08-20T14:18:07Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723403236",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723403236"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723414301",
      "pull_request_review_id": 2248150197,
      "id": 1723414301,
      "node_id": "PRRC_kwDOABII585muTcd",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to\n+    // ensure uniqueness. Here, we want to avoid direct parent/child relationships between transactions.\n+    const auto two_transactions{CreateTransactions(/*num_txns=*/2)};\n+    return two_transactions.back();\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+\n+    TxValidationState state;\n+\n+    for (const auto& [result, expected_behavior] : expected_behaviors) {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+        const auto ptx = GetNewTransaction();",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 101,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ptx/txid/wtxid can just be made once outside the loop since it's the same each time\r\n\r\nas well as nodeid, now",
      "created_at": "2024-08-20T14:24:39Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723414301",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723414301"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723435539",
      "pull_request_review_id": 2248150197,
      "id": 1723435539,
      "node_id": "PRRC_kwDOABII585muYoT",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 86,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "what is this chaining doing? I only see the ultimate tx being used anyways.\r\n\r\nIt might be useful to have the parent tx rejected optionally, to check that `TX_MISSING_INPUTS,` fills out txid and wtxid reject filters properly. ",
      "created_at": "2024-08-20T14:36:49Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723435539",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723435539"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723456852",
      "pull_request_review_id": 2248150197,
      "id": 1723456852,
      "node_id": "PRRC_kwDOABII585mud1U",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 168,
      "original_position": 154,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1 2, 3 4s, 5 6s\r\nwomp womp",
      "created_at": "2024-08-20T14:49:17Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723456852",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723456852"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 168,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723465940",
      "pull_request_review_id": 2248150197,
      "id": 1723465940,
      "node_id": "PRRC_kwDOABII585mugDU",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 177,
      "original_position": 163,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "500 outputs is probably too much unless you think it's gaining some meaningful coverage?",
      "created_at": "2024-08-20T14:54:52Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723465940",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723465940"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 177,
      "original_line": 177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723471572",
      "pull_request_review_id": 2248150197,
      "id": 1723471572,
      "node_id": "PRRC_kwDOABII585muhbU",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 215,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "m_senders.back() should be <= NUM_PEERS",
      "created_at": "2024-08-20T14:58:12Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723471572",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723471572"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723473284",
      "pull_request_review_id": 2248150197,
      "id": 1723473284,
      "node_id": "PRRC_kwDOABII585muh2E",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // If PackageToValidate is returned then should_validate = false.\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(GetPackageHash(package)));\n+                    // Neither is in m_lazy_recent_rejects\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                txdownload_impl.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownload_impl.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownload_impl.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                    Assert(txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(ptx->GetWitnessHash()), /*include_reconsiderable=*/false));\n+                    // Presumably we have validated this tx. Use \"missing inputs\" to keep it in the\n+                    // orphanage longer. Later iterations might call MempoolAcceptedTx or\n+                    // MempoolRejectedTx with a different error.\n+                    TxValidationState state_missing_inputs;\n+                    state_missing_inputs.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                    txdownload_impl.MempoolRejectedTx(ptx, state_missing_inputs, rand_peer, fuzzed_data_provider.ConsumeBool());\n+                }\n+            }\n+        );\n+\n+        // Jump ahead in time",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 433,
      "original_position": 392,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "not just ahead due to negative skips",
      "created_at": "2024-08-20T14:59:13Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723473284",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723473284"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 433,
      "original_line": 433,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723482380",
      "pull_request_review_id": 2248150197,
      "id": 1723482380,
      "node_id": "PRRC_kwDOABII585mukEM",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 336,
      "original_position": 305,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "iterate over all `TRANSACTIONS` and assert this?",
      "created_at": "2024-08-20T15:04:54Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723482380",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723482380"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 336,
      "original_line": 336,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723492507",
      "pull_request_review_id": 2248150197,
      "id": 1723492507,
      "node_id": "PRRC_kwDOABII585mumib",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 292,
      "original_position": 262,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n    }\r\n    txdownload_impl.m_txrequest.SanityCheck();\r\n```",
      "created_at": "2024-08-20T15:11:21Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723492507",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723492507"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 292,
      "original_line": 292,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723496334",
      "pull_request_review_id": 2248150197,
      "id": 1723496334,
      "node_id": "PRRC_kwDOABII585muneO",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 361,
      "original_position": 328,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`MempoolRejectedTx` should probably `Assume` that state is invalid at the top of its definition",
      "created_at": "2024-08-20T15:13:47Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723496334",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723496334"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 361,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723512996",
      "pull_request_review_id": 2248150197,
      "id": 1723512996,
      "node_id": "PRRC_kwDOABII585murik",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // If PackageToValidate is returned then should_validate = false.\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 399,
      "original_position": 358,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(maybe_package->m_txns.back()->GetWitnessHash().ToUint256()));`\r\n\r\nI considered this assertion, is it valid? Can we have something in our orphanage and reconsiderable filter?",
      "created_at": "2024-08-20T15:23:47Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723512996",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723512996"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 399,
      "original_line": 399,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723520777",
      "pull_request_review_id": 2248150197,
      "id": 1723520777,
      "node_id": "PRRC_kwDOABII585mutcJ",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // If PackageToValidate is returned then should_validate = false.\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(GetPackageHash(package)));\n+                    // Neither is in m_lazy_recent_rejects\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                txdownload_impl.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownload_impl.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownload_impl.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 415,
      "original_position": 374,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can you remind me of a case where this happens? Running with an erroneous assertion added and it's not seeming to hit.",
      "created_at": "2024-08-20T15:28:28Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723520777",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723520777"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 415,
      "original_line": 415,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723534366",
      "pull_request_review_id": 2248150197,
      "id": 1723534366,
      "node_id": "PRRC_kwDOABII585muwwe",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        // \"Good\" peers send the inv at most once, and otherwise will not send an unsolicited message.\n+        if (m_good) {\n+            if (!m_sent_inv && (force_announce || fuzzed_data_provider.ConsumeBool())) {\n+                m_sent_inv = true;\n+                return PossibleMessage::INV_REAL;\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // Non-good peers might send anything!\n+        auto message = fuzzed_data_provider.PickValueInArray(ALL_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    PossibleResponse ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return PossibleResponse::NOTHING;\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(ALL_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return PossibleResponse::NOTHING;\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return response;\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = false;\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();",
      "path": "src/test/fuzz/tx_download.cpp",
      "position": null,
      "original_position": 170,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "04856ed32c17ce60e9c503d92b21092a0f9ac271",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "maybe leave a comment why good peers do wtxid relay",
      "created_at": "2024-08-20T15:37:54Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723534366",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723534366"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723610455",
      "pull_request_review_id": 2248150197,
      "id": 1723610455,
      "node_id": "PRRC_kwDOABII585mvDVX",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};",
      "path": "src/test/fuzz/tx_download.cpp",
      "position": null,
      "original_position": 114,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "04856ed32c17ce60e9c503d92b21092a0f9ac271",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "seems to always be false?",
      "created_at": "2024-08-20T16:23:32Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723610455",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723610455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724756834",
      "pull_request_review_id": 2250308845,
      "id": 1724756834,
      "node_id": "PRRC_kwDOABII585mzbNi",
      "diff_hunk": "@@ -436,4 +436,13 @@ CTransactionRef TxDownloadImpl::GetTxToReconsider(NodeId nodeid)\n     return m_orphanage.GetTxToReconsider(nodeid);\n }\n \n+void TxDownloadImpl::CheckIsEmpty(NodeId nodeid)",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 4,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "388c2f5d7ee5f38cbefaff0c85cf298083127299",
      "in_reply_to_id": 1723352509,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`CheckIsEmpty()` seems a bit more future-proof. We'll check\r\n- no requests for this peer\r\n- no pending orphan resolutions for this peer\r\n- no orphans for this peer\r\netc.",
      "created_at": "2024-08-21T09:39:33Z",
      "updated_at": "2024-08-21T09:39:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724756834",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724756834"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 439,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724766037",
      "pull_request_review_id": 2250323920,
      "id": 1724766037,
      "node_id": "PRRC_kwDOABII585mzddV",
      "diff_hunk": "@@ -425,4 +425,15 @@ std::pair<bool, std::optional<PackageToValidate>> TxDownloadImpl::ReceivedTx(Nod\n \n     return std::make_pair(true, std::nullopt);\n }\n+\n+bool TxDownloadImpl::HaveMoreWork(NodeId nodeid)",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "81f67607e811bcb5040142c401a51634b17bc3a8",
      "in_reply_to_id": 1723349184,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I called it `HaveMoreWork` since its purpose is to tell `ThreadMessageHandler()` if there is more work to do (doesn't matter what kind of work):\r\nhttps://github.com/bitcoin/bitcoin/blob/3c0b66c2ece7695ab59f466d7b4d81a4c18ffd76/src/net_processing.cpp#L5083 \r\nhttps://github.com/bitcoin/bitcoin/blob/3c0b66c2ece7695ab59f466d7b4d81a4c18ffd76/src/net.cpp#L2902-L2903\r\n\r\n`GetTxToReconsider`'s user is peerman, in `ProcessOrphanTx`.\r\n\r\nI think scheduled reconsideration work could become more generic in the future, i.e. include packages. But I think  `ProcessOrphanTx` is probably more readable if the function name specifies we're getting 1 transaction to reconsider.",
      "created_at": "2024-08-21T09:46:13Z",
      "updated_at": "2024-08-21T09:46:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724766037",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724766037"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 429,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724778335",
      "pull_request_review_id": 2250344089,
      "id": 1724778335,
      "node_id": "PRRC_kwDOABII585mzgdf",
      "diff_hunk": "@@ -371,4 +371,58 @@ void TxDownloadImpl::MempoolRejectedPackage(const Package& package)\n {\n     RecentRejectsReconsiderableFilter().insert(GetPackageHash(package));\n }\n+\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadImpl::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    const uint256& txid = ptx->GetHash();\n+    const uint256& wtxid = ptx->GetWitnessHash();\n+\n+    // Mark that we have received a response\n+    m_txrequest.ReceivedResponse(nodeid, ptx->GetHash());\n+    if (ptx->HasWitness()) m_txrequest.ReceivedResponse(nodeid, ptx->GetWitnessHash());\n+\n+    // First check if we should drop this tx.\n+    // We do the AlreadyHaveTx() check using wtxid, rather than txid - in the\n+    // absence of witness malleation, this is strictly better, because the\n+    // recent rejects filter may contain the wtxid but rarely contains\n+    // the txid of a segwit transaction that has been rejected.\n+    // In the presence of witness malleation, it's possible that by only\n+    // doing the check with wtxid, we could overlook a transaction which\n+    // was confirmed with a different witness, or exists in our mempool\n+    // with a different witness, but this has limited downside:\n+    // mempool validation does its own lookup of whether we have the txid\n+    // already; and an adversary can already relay us old transactions\n+    // (older than our recency filter) if trying to DoS us, without any need\n+    // for witness malleation.\n+    if (AlreadyHaveTx(GenTxid::Wtxid(wtxid), /*include_reconsiderable=*/true)) {\n+\n+        if (RecentRejectsReconsiderableFilter().contains(wtxid)) {\n+            // When a transaction is already in m_lazy_recent_rejects_reconsiderable, we shouldn't submit\n+            // it by itself again. However, look for a matching child in the orphanage, as it is\n+            // possible that they succeed as a package.\n+            LogPrint(BCLog::TXPACKAGES, \"found tx %s (wtxid=%s) in reconsiderable rejects, looking for child in orphanage\\n\",\n+                     txid.ToString(), wtxid.ToString());\n+            return std::make_pair(false, Find1P1CPackage(ptx, nodeid));\n+        }\n+\n+        // If a tx is detected by m_lazy_recent_rejects it is ignored. Because we haven't",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 38,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "ed96f3ef3dfb42fef4564aa5eedc636c2d6d8845",
      "in_reply_to_id": 1723318351,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Seems fine to do, but won't add it to this PR because I want to limit its scope. Agree just the last paragraph is sufficient.",
      "created_at": "2024-08-21T09:55:18Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724778335",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724778335"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 408,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724779439",
      "pull_request_review_id": 2250344089,
      "id": 1724779439,
      "node_id": "PRRC_kwDOABII585mzguv",
      "diff_hunk": "@@ -44,4 +44,33 @@ void TxDownloadImpl::BlockDisconnected()\n     // should be just after a new block containing it is found.\n     RecentConfirmedTransactionsFilter().reset();\n }\n+\n+bool TxDownloadImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3824d1f81ad9e4ff44ec46d07f4e8f86f27ce643",
      "in_reply_to_id": 1722086417,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What should the new name be?",
      "created_at": "2024-08-21T09:56:02Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724779439",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724779439"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724806868",
      "pull_request_review_id": 2250344089,
      "id": 1724806868,
      "node_id": "PRRC_kwDOABII585mznbU",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to\n+    // ensure uniqueness. Here, we want to avoid direct parent/child relationships between transactions.",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 87,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": 1723403236,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "So the requirements are:\r\n- transactions need to be unique\r\n- they need to appear to not be related (i.e. no direct relationships)\r\n\r\nOne way to do this is to make unique utxos for each tx. But we also know from experience debugging fuzzers that sometimes the random outpoint's txid matches the hash of one of the transactions, which is annoying because it creates \"direct relationships\".\r\n\r\nIronically, since prevouts reference hashes, the easiest way to ensure transactions aren't directly related is to have them all be indirectly related.\r\n\r\nSo my quick and dirty method for creating n transactions is to generate 1 utxo and make 2*n transactions chaining off of it, then use every other tx. I don't need to know n ahead of time - I just make 2 at the bottom whenever I need one. They're guaranteed to be unique (because sha256) and to not look like they're spending each other (because sha256).",
      "created_at": "2024-08-21T10:15:29Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724806868",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724806868"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724818171",
      "pull_request_review_id": 2250344089,
      "id": 1724818171,
      "node_id": "PRRC_kwDOABII585mzqL7",
      "diff_hunk": "@@ -3841,6 +3840,14 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                        tx_relay->m_next_inv_send_time == 0s));\n         }\n \n+        LOCK2(::cs_main, m_tx_download_mutex);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 14,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "af3647050a85e6f33f902b903207043f6f0c023c",
      "in_reply_to_id": 1722183824,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-21T10:24:44Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724818171",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724818171"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3843,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724832923",
      "pull_request_review_id": 2250344089,
      "id": 1724832923,
      "node_id": "PRRC_kwDOABII585mztyb",
      "diff_hunk": "@@ -2995,16 +2995,95 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n     AssertLockHeld(g_msgproc_mutex);\n     AssertLockHeld(m_tx_download_mutex);\n \n+    PeerRef peer{GetPeerRef(nodeid)};\n+\n     auto& m_orphanage = m_txdownloadman.GetOrphanageRef();\n     auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n+    const CTransaction& tx{*ptx};\n \n     LogDebug(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n         ptx->GetHash().ToString(),\n         ptx->GetWitnessHash().ToString(),\n         nodeid,\n         state.ToString());\n \n-    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+    // Only process a new orphan if maybe_add_extra_compact_tx, as otherwise it must be either",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 17,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "77560a690ce05697400dcbb73bcb4d89724a9e4f",
      "in_reply_to_id": 1722268907,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Renamed it to `first_time_failure` in a preceding commit.\r\n\r\nYeah that's correct. Basically, if this is the first time a tx is being rejected from mempool, we consider putting it in `vExtraTxnForCompact`. If it's not the first time, we don't need to do it again, presumably because we don't want duplicates (it's a ring buffer).\r\n\r\nSame thing for adding something as an orphan. If this bool is false, it means the tx is already an orphan or it's the low feerate parent in a package. Either way we don't need to bother with the `unique_parents` and filter checking stuff.",
      "created_at": "2024-08-21T10:37:24Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724832923",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724832923"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3010,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724840174",
      "pull_request_review_id": 2250344089,
      "id": 1724840174,
      "node_id": "PRRC_kwDOABII585mzvju",
      "diff_hunk": "@@ -2995,16 +2995,95 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n     AssertLockHeld(g_msgproc_mutex);\n     AssertLockHeld(m_tx_download_mutex);\n \n+    PeerRef peer{GetPeerRef(nodeid)};\n+\n     auto& m_orphanage = m_txdownloadman.GetOrphanageRef();\n     auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n+    const CTransaction& tx{*ptx};\n \n     LogDebug(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n         ptx->GetHash().ToString(),\n         ptx->GetWitnessHash().ToString(),\n         nodeid,\n         state.ToString());\n \n-    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+    // Only process a new orphan if maybe_add_extra_compact_tx, as otherwise it must be either\n+    // already in orphanage or from 1p1c processing.\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS && maybe_add_extra_compact_tx) {\n+        bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+        // Deduplicate parent txids, so that we don't have to loop over\n+        // the same parent txid more than once down below.\n+        std::vector<uint256> unique_parents;\n+        unique_parents.reserve(tx.vin.size());\n+        for (const CTxIn& txin : tx.vin) {\n+            // We start with all parents, and then remove duplicates below.\n+            unique_parents.push_back(txin.prevout.hash);\n+        }\n+        std::sort(unique_parents.begin(), unique_parents.end());\n+        unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+        // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.\n+        // We can tolerate having up to 1 parent in m_lazy_recent_rejects_reconsiderable since we\n+        // submit 1p1c packages. However, fail immediately if any are in m_lazy_recent_rejects.\n+        std::optional<uint256> rejected_parent_reconsiderable;\n+        for (const uint256& parent_txid : unique_parents) {\n+            if (RecentRejectsFilter().contains(parent_txid)) {\n+                fRejectedParents = true;\n+                break;\n+            } else if (RecentRejectsReconsiderableFilter().contains(parent_txid) && !m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                // More than 1 parent in m_lazy_recent_rejects_reconsiderable: 1p1c will not be\n+                // sufficient to accept this package, so just give up here.\n+                if (rejected_parent_reconsiderable.has_value()) {\n+                    fRejectedParents = true;\n+                    break;\n+                }\n+                rejected_parent_reconsiderable = parent_txid;\n+            }\n+        }\n+        if (!fRejectedParents) {\n+            const auto current_time{GetTime<std::chrono::microseconds>()};\n+\n+            for (const uint256& parent_txid : unique_parents) {\n+                // Here, we only have the txid (and not wtxid) of the\n+                // inputs, so we only request in txid mode, even for\n+                // wtxidrelay peers.\n+                // Eventually we should replace this with an improved\n+                // protocol for getting all unconfirmed parents.\n+                const auto gtxid{GenTxid::Txid(parent_txid)};\n+                if (peer) AddKnownTx(*peer, parent_txid);\n+                // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n+                // previously rejected for being too low feerate. This orphan might CPFP it.\n+                if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+                    m_txdownloadman.AddTxAnnouncement(nodeid, gtxid, current_time, /*p2p_inv=*/false);\n+                }\n+            }\n+\n+            if (m_orphanage.AddTx(ptx, nodeid)) {\n+                AddToCompactExtraTransactions(ptx);\n+            }\n+\n+            // Once added to the orphan pool, a tx is considered AlreadyHave, and we shouldn't request it anymore.\n+            m_txrequest.ForgetTxHash(tx.GetHash());\n+            m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+\n+            // DoS prevention: do not allow m_orphanage to grow unbounded (see CVE-2012-3789)\n+            m_orphanage.LimitOrphans(m_opts.max_orphan_txs, m_rng);\n+        } else {\n+            LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s (wtxid=%s)\\n\",\n+                     tx.GetHash().ToString(),\n+                     tx.GetWitnessHash().ToString());\n+            // We will continue to reject this tx since it has rejected\n+            // parents so avoid re-requesting it from other peers.\n+            // Here we add both the txid and the wtxid, as we know that\n+            // regardless of what witness is provided, we will not accept\n+            // this, so we don't need to allow for redownload of this txid\n+            // from any of our non-wtxidrelay peers.\n+            RecentRejectsFilter().insert(tx.GetHash().ToUint256());",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "77560a690ce05697400dcbb73bcb4d89724a9e4f",
      "in_reply_to_id": 1722273831,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "agree, though leaving out of this PR to limit its scope. Could add a nonsegwit parent + segwit child test to be added to p2p_orphan_handling.py. Maybe a good first issue.",
      "created_at": "2024-08-21T10:43:35Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724840174",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724840174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3082,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724863898",
      "pull_request_review_id": 2250344089,
      "id": 1724863898,
      "node_id": "PRRC_kwDOABII585mz1Wa",
      "diff_hunk": "@@ -3104,6 +3117,14 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n             // because we should not download or submit this transaction by itself again, but may\n             // submit it as part of a package later.\n             RecentRejectsReconsiderableFilter().insert(ptx->GetWitnessHash().ToUint256());\n+\n+            if (maybe_add_extra_compact_tx) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 72,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "d3fb8ca103b32f6071790bf7a9471fe4f80f5479",
      "in_reply_to_id": 1722277826,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-21T11:04:10Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724863898",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724863898"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3121,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724864056",
      "pull_request_review_id": 2250344089,
      "id": 1724864056,
      "node_id": "PRRC_kwDOABII585mz1Y4",
      "diff_hunk": "@@ -594,8 +604,8 @@ class PeerManagerImpl final : public PeerManager\n      *                                            Set to false if the tx has already been rejected before,\n      *                                            e.g. is an orphan, to avoid adding duplicate entries.\n      * Updates m_txrequest, m_lazy_recent_rejects, m_lazy_recent_rejects_reconsiderable, m_orphanage, and vExtraTxnForCompact. */\n-    void ProcessInvalidTx(NodeId nodeid, const CTransactionRef& tx, const TxValidationState& result,\n-                          bool maybe_add_extra_compact_tx)\n+    std::optional<PackageToValidate> ProcessInvalidTx(NodeId nodeid, const CTransactionRef& tx, const TxValidationState& result,",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 34,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "d3fb8ca103b32f6071790bf7a9471fe4f80f5479",
      "in_reply_to_id": 1722276530,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added",
      "created_at": "2024-08-21T11:04:18Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724864056",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724864056"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 607,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724880934",
      "pull_request_review_id": 2250344089,
      "id": 1724880934,
      "node_id": "PRRC_kwDOABII585mz5gm",
      "diff_hunk": "@@ -3129,17 +3129,7 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     AssertLockHeld(g_msgproc_mutex);\n     AssertLockHeld(m_tx_download_mutex);\n \n-    auto& m_orphanage = m_txdownloadman.GetOrphanageRef();\n-    auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n-\n-    // As this version of the transaction was acceptable, we can forget about any requests for it.\n-    // No-op if the tx is not in txrequest.\n-    m_txrequest.ForgetTxHash(tx->GetHash());\n-    m_txrequest.ForgetTxHash(tx->GetWitnessHash());\n-\n-    m_orphanage.AddChildrenToWorkSet(*tx);\n-    // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n-    m_orphanage.EraseTx(tx->GetWitnessHash());\n+    m_txdownloadman.MempoolAcceptedTx(tx);",
      "path": "src/net_processing.cpp",
      "position": 517,
      "original_position": 15,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "65d773feb7384a6893ee7e6a7b24dfa60f2d8d39",
      "in_reply_to_id": 1723275394,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-08-21T11:19:19Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724880934",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724880934"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2998,
      "original_line": 2998,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724882313",
      "pull_request_review_id": 2250344089,
      "id": 1724882313,
      "node_id": "PRRC_kwDOABII585mz52J",
      "diff_hunk": "@@ -4220,24 +4214,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         LOCK2(cs_main, m_tx_download_mutex);\n \n-        auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n-\n-        m_txrequest.ReceivedResponse(pfrom.GetId(), txid);\n-        if (tx.HasWitness()) m_txrequest.ReceivedResponse(pfrom.GetId(), wtxid);\n-\n-        // We do the AlreadyHaveTx() check using wtxid, rather than txid - in the\n-        // absence of witness malleation, this is strictly better, because the\n-        // recent rejects filter may contain the wtxid but rarely contains\n-        // the txid of a segwit transaction that has been rejected.\n-        // In the presence of witness malleation, it's possible that by only\n-        // doing the check with wtxid, we could overlook a transaction which\n-        // was confirmed with a different witness, or exists in our mempool\n-        // with a different witness, but this has limited downside:\n-        // mempool validation does its own lookup of whether we have the txid\n-        // already; and an adversary can already relay us old transactions\n-        // (older than our recency filter) if trying to DoS us, without any need\n-        // for witness malleation.\n-        if (m_txdownloadman.AlreadyHaveTx(GenTxid::Wtxid(wtxid), /*include_reconsiderable=*/true)) {\n+        const auto& [should_validate, package_to_validate] = m_txdownloadman.ReceivedTx(pfrom.GetId(), ptx);\n+        if (!should_validate) {",
      "path": "src/net_processing.cpp",
      "position": 682,
      "original_position": 36,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "ed96f3ef3dfb42fef4564aa5eedc636c2d6d8845",
      "in_reply_to_id": 1723307535,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added",
      "created_at": "2024-08-21T11:20:34Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724882313",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724882313"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4234,
      "original_line": 4234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724970034",
      "pull_request_review_id": 2250669642,
      "id": 1724970034,
      "node_id": "PRRC_kwDOABII585m0PQy",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 70,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": 1723401360,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-21T12:30:55Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724970034",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724970034"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724970656",
      "pull_request_review_id": 2250669642,
      "id": 1724970656,
      "node_id": "PRRC_kwDOABII585m0Pag",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to\n+    // ensure uniqueness. Here, we want to avoid direct parent/child relationships between transactions.\n+    const auto two_transactions{CreateTransactions(/*num_txns=*/2)};\n+    return two_transactions.back();\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+\n+    TxValidationState state;\n+\n+    for (const auto& [result, expected_behavior] : expected_behaviors) {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+        const auto ptx = GetNewTransaction();",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 101,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": 1723414301,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-21T12:31:22Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724970656",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724970656"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725039042",
      "pull_request_review_id": 2250782824,
      "id": 1725039042,
      "node_id": "PRRC_kwDOABII585m0gHC",
      "diff_hunk": "@@ -4220,24 +4214,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         LOCK2(cs_main, m_tx_download_mutex);\n \n-        auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n-\n-        m_txrequest.ReceivedResponse(pfrom.GetId(), txid);\n-        if (tx.HasWitness()) m_txrequest.ReceivedResponse(pfrom.GetId(), wtxid);\n-\n-        // We do the AlreadyHaveTx() check using wtxid, rather than txid - in the\n-        // absence of witness malleation, this is strictly better, because the\n-        // recent rejects filter may contain the wtxid but rarely contains\n-        // the txid of a segwit transaction that has been rejected.\n-        // In the presence of witness malleation, it's possible that by only\n-        // doing the check with wtxid, we could overlook a transaction which\n-        // was confirmed with a different witness, or exists in our mempool\n-        // with a different witness, but this has limited downside:\n-        // mempool validation does its own lookup of whether we have the txid\n-        // already; and an adversary can already relay us old transactions\n-        // (older than our recency filter) if trying to DoS us, without any need\n-        // for witness malleation.\n-        if (m_txdownloadman.AlreadyHaveTx(GenTxid::Wtxid(wtxid), /*include_reconsiderable=*/true)) {\n+        const auto& [should_validate, package_to_validate] = m_txdownloadman.ReceivedTx(pfrom.GetId(), ptx);\n+        if (!should_validate) {",
      "path": "src/net_processing.cpp",
      "position": 682,
      "original_position": 36,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "ed96f3ef3dfb42fef4564aa5eedc636c2d6d8845",
      "in_reply_to_id": 1723307535,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "think you added the other way, that if `should_validate` is false, it must have a package to validate, which is incorrect(and caught by our 1p1c tests)",
      "created_at": "2024-08-21T13:17:15Z",
      "updated_at": "2024-08-21T13:17:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725039042",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725039042"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4234,
      "original_line": 4234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725185420",
      "pull_request_review_id": 2250669642,
      "id": 1725185420,
      "node_id": "PRRC_kwDOABII585m1D2M",
      "diff_hunk": "@@ -4220,24 +4214,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         LOCK2(cs_main, m_tx_download_mutex);\n \n-        auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n-\n-        m_txrequest.ReceivedResponse(pfrom.GetId(), txid);\n-        if (tx.HasWitness()) m_txrequest.ReceivedResponse(pfrom.GetId(), wtxid);\n-\n-        // We do the AlreadyHaveTx() check using wtxid, rather than txid - in the\n-        // absence of witness malleation, this is strictly better, because the\n-        // recent rejects filter may contain the wtxid but rarely contains\n-        // the txid of a segwit transaction that has been rejected.\n-        // In the presence of witness malleation, it's possible that by only\n-        // doing the check with wtxid, we could overlook a transaction which\n-        // was confirmed with a different witness, or exists in our mempool\n-        // with a different witness, but this has limited downside:\n-        // mempool validation does its own lookup of whether we have the txid\n-        // already; and an adversary can already relay us old transactions\n-        // (older than our recency filter) if trying to DoS us, without any need\n-        // for witness malleation.\n-        if (m_txdownloadman.AlreadyHaveTx(GenTxid::Wtxid(wtxid), /*include_reconsiderable=*/true)) {\n+        const auto& [should_validate, package_to_validate] = m_txdownloadman.ReceivedTx(pfrom.GetId(), ptx);\n+        if (!should_validate) {",
      "path": "src/net_processing.cpp",
      "position": 682,
      "original_position": 36,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "ed96f3ef3dfb42fef4564aa5eedc636c2d6d8845",
      "in_reply_to_id": 1723307535,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "woops, fixed now",
      "created_at": "2024-08-21T14:44:48Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725185420",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725185420"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4234,
      "original_line": 4234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725187075",
      "pull_request_review_id": 2250669642,
      "id": 1725187075,
      "node_id": "PRRC_kwDOABII585m1EQD",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 168,
      "original_position": 154,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723456852,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">  womp womp\r\n\r\nCan you be a bit more specific :joy:",
      "created_at": "2024-08-21T14:45:46Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725187075",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725187075"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 168,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725358054",
      "pull_request_review_id": 2250669642,
      "id": 1725358054,
      "node_id": "PRRC_kwDOABII585m1t_m",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 177,
      "original_position": 163,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723465940,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It makes them potentially larger transactions?",
      "created_at": "2024-08-21T16:06:16Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725358054",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725358054"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 177,
      "original_line": 177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725359052",
      "pull_request_review_id": 2250669642,
      "id": 1725359052,
      "node_id": "PRRC_kwDOABII585m1uPM",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 215,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723471572,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-21T16:07:08Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725359052",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725359052"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725360295",
      "pull_request_review_id": 2250669642,
      "id": 1725360295,
      "node_id": "PRRC_kwDOABII585m1uin",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // If PackageToValidate is returned then should_validate = false.\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(GetPackageHash(package)));\n+                    // Neither is in m_lazy_recent_rejects\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                txdownload_impl.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownload_impl.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownload_impl.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                    Assert(txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(ptx->GetWitnessHash()), /*include_reconsiderable=*/false));\n+                    // Presumably we have validated this tx. Use \"missing inputs\" to keep it in the\n+                    // orphanage longer. Later iterations might call MempoolAcceptedTx or\n+                    // MempoolRejectedTx with a different error.\n+                    TxValidationState state_missing_inputs;\n+                    state_missing_inputs.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                    txdownload_impl.MempoolRejectedTx(ptx, state_missing_inputs, rand_peer, fuzzed_data_provider.ConsumeBool());\n+                }\n+            }\n+        );\n+\n+        // Jump ahead in time",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 433,
      "original_position": 392,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723473284,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I thought they were all positive?",
      "created_at": "2024-08-21T16:08:02Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725360295",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725360295"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 433,
      "original_line": 433,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725361353",
      "pull_request_review_id": 2250669642,
      "id": 1725361353,
      "node_id": "PRRC_kwDOABII585m1uzJ",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 336,
      "original_position": 305,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723482380,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-21T16:08:52Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725361353",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725361353"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 336,
      "original_line": 336,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725361680",
      "pull_request_review_id": 2250669642,
      "id": 1725361680,
      "node_id": "PRRC_kwDOABII585m1u4Q",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 292,
      "original_position": 262,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723492507,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added",
      "created_at": "2024-08-21T16:09:10Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725361680",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725361680"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 292,
      "original_line": 292,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725365000",
      "pull_request_review_id": 2250669642,
      "id": 1725365000,
      "node_id": "PRRC_kwDOABII585m1vsI",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // If PackageToValidate is returned then should_validate = false.\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 399,
      "original_position": 358,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723512996,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think something would be wrong then. It wouldn't be missing inputs if we knew what the fee was.",
      "created_at": "2024-08-21T16:11:44Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725365000",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725365000"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 399,
      "original_line": 399,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725367714",
      "pull_request_review_id": 2250669642,
      "id": 1725367714,
      "node_id": "PRRC_kwDOABII585m1wWi",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // If PackageToValidate is returned then should_validate = false.\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(GetPackageHash(package)));\n+                    // Neither is in m_lazy_recent_rejects\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                txdownload_impl.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownload_impl.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownload_impl.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 415,
      "original_position": 374,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723520777,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1. tx is added to workset\r\n2. tx is removed from orphanage\r\n3. peer workset is nonempty, but its wtxids correspond to stuff that isn't there anymore",
      "created_at": "2024-08-21T16:13:54Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725367714",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725367714"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 415,
      "original_line": 415,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725373422",
      "pull_request_review_id": 2250669642,
      "id": 1725373422,
      "node_id": "PRRC_kwDOABII585m1xvu",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};",
      "path": "src/test/fuzz/tx_download.cpp",
      "position": null,
      "original_position": 114,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "04856ed32c17ce60e9c503d92b21092a0f9ac271",
      "in_reply_to_id": 1723610455,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "changed to come from fuzzer",
      "created_at": "2024-08-21T16:18:32Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725373422",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725373422"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725373542",
      "pull_request_review_id": 2250669642,
      "id": 1725373542,
      "node_id": "PRRC_kwDOABII585m1xxm",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        // \"Good\" peers send the inv at most once, and otherwise will not send an unsolicited message.\n+        if (m_good) {\n+            if (!m_sent_inv && (force_announce || fuzzed_data_provider.ConsumeBool())) {\n+                m_sent_inv = true;\n+                return PossibleMessage::INV_REAL;\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // Non-good peers might send anything!\n+        auto message = fuzzed_data_provider.PickValueInArray(ALL_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    PossibleResponse ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return PossibleResponse::NOTHING;\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(ALL_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return PossibleResponse::NOTHING;\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return response;\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = false;\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();",
      "path": "src/test/fuzz/tx_download.cpp",
      "position": null,
      "original_position": 170,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "04856ed32c17ce60e9c503d92b21092a0f9ac271",
      "in_reply_to_id": 1723534366,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added",
      "created_at": "2024-08-21T16:18:38Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725373542",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725373542"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725374135",
      "pull_request_review_id": 2250669642,
      "id": 1725374135,
      "node_id": "PRRC_kwDOABII585m1x63",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 361,
      "original_position": 328,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723496334,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "should it? seems more complete if it handles all types, and we test them",
      "created_at": "2024-08-21T16:18:59Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725374135",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725374135"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 361,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725375345",
      "pull_request_review_id": 2250669642,
      "id": 1725375345,
      "node_id": "PRRC_kwDOABII585m1yNx",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 86,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": 1723435539,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added tests for orphans with rejected parents",
      "created_at": "2024-08-21T16:19:49Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725375345",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725375345"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725534553",
      "pull_request_review_id": 2251598808,
      "id": 1725534553,
      "node_id": "PRRC_kwDOABII585m2ZFZ",
      "diff_hunk": "@@ -2995,16 +2995,95 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n     AssertLockHeld(g_msgproc_mutex);\n     AssertLockHeld(m_tx_download_mutex);\n \n+    PeerRef peer{GetPeerRef(nodeid)};\n+\n     auto& m_orphanage = m_txdownloadman.GetOrphanageRef();\n     auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n+    const CTransaction& tx{*ptx};\n \n     LogDebug(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n         ptx->GetHash().ToString(),\n         ptx->GetWitnessHash().ToString(),\n         nodeid,\n         state.ToString());\n \n-    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+    // Only process a new orphan if maybe_add_extra_compact_tx, as otherwise it must be either",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 17,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "77560a690ce05697400dcbb73bcb4d89724a9e4f",
      "in_reply_to_id": 1722268907,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "new name is better and makes flow easier to understand,thanks",
      "created_at": "2024-08-21T18:28:08Z",
      "updated_at": "2024-08-21T18:28:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725534553",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725534553"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3010,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725548581",
      "pull_request_review_id": 2251621214,
      "id": 1725548581,
      "node_id": "PRRC_kwDOABII585m2cgl",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to\n+    // ensure uniqueness. Here, we want to avoid direct parent/child relationships between transactions.",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 87,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": 1723403236,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ":facepalm: I was missing the `static` in front of `prevout_hash`. This is making a lot more sense now.",
      "created_at": "2024-08-21T18:41:03Z",
      "updated_at": "2024-08-21T18:41:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725548581",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725548581"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725548968",
      "pull_request_review_id": 2251621868,
      "id": 1725548968,
      "node_id": "PRRC_kwDOABII585m2cmo",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to\n+    // ensure uniqueness. Here, we want to avoid direct parent/child relationships between transactions.",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 87,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": 1723403236,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "might be worth a comment!",
      "created_at": "2024-08-21T18:41:24Z",
      "updated_at": "2024-08-21T18:41:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725548968",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725548968"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725592055",
      "pull_request_review_id": 2251681805,
      "id": 1725592055,
      "node_id": "PRRC_kwDOABII585m2nH3",
      "diff_hunk": "@@ -0,0 +1,248 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+\n+    // A new TxDownloadImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+\n+    for (const auto segwit_parent : {true, false}) {\n+        for (const auto segwit_child : {true, false}) {\n+            const auto ptx_parent = CreateTransactionChain(1, segwit_parent).front();\n+            const auto ptx_child = CreateTransactionChain(1, segwit_child).front();\n+            const auto& parent_txid = ptx_parent->GetHash().ToUint256();\n+            const auto& parent_wtxid = ptx_parent->GetWitnessHash().ToUint256();\n+            const auto& child_txid = ptx_child->GetHash().ToUint256();\n+            const auto& child_wtxid = ptx_child->GetWitnessHash().ToUint256();\n+\n+            for (const auto& [result, expected_behavior] : expected_behaviors) {\n+                node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+                // Parent failure\n+                state.Invalid(result, \"\");\n+                const auto& [keep, unique_txids, package_to_validate] = txdownload_impl.MempoolRejectedTx(ptx_parent, state, nodeid, /*first_time_failure=*/true);\n+\n+                // No distinction between txid and wtxid caching for nonsegwit transactions, so only test these specific\n+                // behaviors for segwit transactions.\n+                Behaviors actual_behavior{\n+                    /*txid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_txid),\n+                    /*wtxid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_wtxid),\n+                    /*txid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_txid),\n+                    /*wtxid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_wtxid),\n+                    /*keep=*/keep,\n+                    /*txid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Txid(parent_txid), now, /*p2p_inv=*/true),\n+                    /*wtxid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Wtxid(parent_wtxid), now, /*p2p_inv=*/true),\n+                };\n+                BOOST_TEST_MESSAGE(\"Testing behavior for \" << result << (segwit_parent ? \" segwit \" : \" nonsegwit\"));\n+                actual_behavior.CheckEqual(expected_behavior, /*segwit=*/segwit_parent);\n+\n+                // Later, a child of this transaction fails for missing inputs\n+                state.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                txdownload_impl.MempoolRejectedTx(ptx_child, state, nodeid, /*first_time_failure=*/true);\n+\n+                // If parent (by txid) was rejected, child is too.\n+                const bool parent_txid_rejected{segwit_parent ? expected_behavior.m_txid_in_rejects : expected_behavior.m_wtxid_in_rejects};\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_txid));\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_wtxid));\n+\n+                // Unless rejected, the child should be in orphanage.\n+                BOOST_CHECK_EQUAL(!parent_txid_rejected, txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+            }\n+        }\n+    }\n+\n+    // More specific examples of orphans with parent(s) that we have seen before.\n+    TxValidationState state_reconsiderable;\n+    state_reconsiderable.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"\");\n+\n+    TxValidationState state_orphan;\n+    state_orphan.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+\n+    const auto ptx_parent_1 = CreateTransactionChain(1, /*segwit=*/false).front();\n+    const auto ptx_parent_2 = CreateTransactionChain(1, /*segwit=*/false).front();\n+    CMutableTransaction mtx_child;\n+    mtx_child.vin.emplace_back(ptx_parent_1->GetHash(), 0);\n+    mtx_child.vin.emplace_back(ptx_parent_2->GetHash(), 0);\n+    mtx_child.vout.emplace_back(CENT, CScript());\n+    auto ptx_child = MakeTransactionRef(mtx_child);\n+    const std::vector<uint256> vec_parent_txids = {ptx_parent_1->GetHash(), ptx_parent_2->GetHash()};\n+\n+    // 1 reconsiderable parent\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Parent reconsiderable failure\n+        const auto& [p1_keep, p1_unique_txids, p1_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_1, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p1_keep);\n+        BOOST_CHECK(p1_unique_txids.empty());\n+        BOOST_CHECK(!p1_package.has_value());\n+\n+        // Child missing inputs, should be added to orphanage.\n+        const auto& [c_keep, c_unique_txids, c_package] = txdownload_impl.MempoolRejectedTx(ptx_child, state_orphan, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(c_keep);\n+        BOOST_CHECK(c_unique_txids == vec_parent_txids);\n+        BOOST_CHECK(!c_package.has_value());\n+        BOOST_CHECK(txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+    }\n+\n+    // 2 reconsiderable parents\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Parent reconsiderable failure\n+        const auto& [p1_keep, p1_unique_txids, p1_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_1, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p1_keep);\n+        BOOST_CHECK(p1_unique_txids.empty());\n+        BOOST_CHECK(!p1_package.has_value());\n+\n+        const auto& [p2_keep, p2_unique_txids, p2_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_2, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p2_keep);\n+        BOOST_CHECK(p2_unique_txids.empty());\n+        BOOST_CHECK(!p2_package.has_value());\n+\n+        // Child missing inputs. Not added to orphanage because only 1 reconsiderable rejected parent is tolerated.\n+        const auto& [c_keep, c_unique_txids, c_package] = txdownload_impl.MempoolRejectedTx(ptx_child, state_orphan, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(c_keep);\n+        BOOST_CHECK(c_unique_txids == vec_parent_txids);\n+        BOOST_CHECK(!c_package.has_value());\n+        BOOST_CHECK(!txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+    }\n+\n+    // 1 reconsiderable parent + 1 non-reconsiderable parent\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Parent reconsiderable failure\n+        const auto& [p1_keep, p1_unique_txids, p1_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_1, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p1_keep);\n+        BOOST_CHECK(p1_unique_txids.empty());\n+        BOOST_CHECK(!p1_package.has_value());\n+\n+        TxValidationState state_not_reconsiderable;\n+        state_not_reconsiderable.Invalid(TxValidationResult::TX_CONSENSUS, \"\");\n+\n+        const auto& [p2_keep, p2_unique_txids, p2_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_2, state_not_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p2_keep);\n+        BOOST_CHECK(p2_unique_txids.empty());\n+        BOOST_CHECK(!p2_package.has_value());\n+\n+        // Child missing inputs. Not added to orphanage because only 1 reconsiderable rejected parent is tolerated.\n+        const auto& [c_keep, c_unique_txids, c_package] = txdownload_impl.MempoolRejectedTx(ptx_child, state_orphan, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(c_keep);\n+        BOOST_CHECK(c_unique_txids == vec_parent_txids);\n+        BOOST_CHECK(!c_package.has_value());\n+        BOOST_CHECK(!txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+\n+    }\n+\n+    // Reconsiderable parent of a tx already in orphanage: the only time PackageToValidate is returned.\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Child missing inputs, should be added to orphanage.",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 232,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "8f5163e8a19e0963679a16c6fe7936af0536db26",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: just assert it's in orphanage instead",
      "created_at": "2024-08-21T19:00:29Z",
      "updated_at": "2024-08-21T19:06:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725592055",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725592055"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 238,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1726878944",
      "pull_request_review_id": 2254257168,
      "id": 1726878944,
      "node_id": "PRRC_kwDOABII585m7hTg",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 361,
      "original_position": 328,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723496334,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The fuzz target is always setting `state.Invalid`, so I don't see where this coverage would come from?",
      "created_at": "2024-08-22T11:29:10Z",
      "updated_at": "2024-08-22T11:29:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1726878944",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1726878944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 361,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1726881353",
      "pull_request_review_id": 2254260615,
      "id": 1726881353,
      "node_id": "PRRC_kwDOABII585m7h5J",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // If PackageToValidate is returned then should_validate = false.\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(GetPackageHash(package)));\n+                    // Neither is in m_lazy_recent_rejects\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                txdownload_impl.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownload_impl.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownload_impl.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                    Assert(txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(ptx->GetWitnessHash()), /*include_reconsiderable=*/false));\n+                    // Presumably we have validated this tx. Use \"missing inputs\" to keep it in the\n+                    // orphanage longer. Later iterations might call MempoolAcceptedTx or\n+                    // MempoolRejectedTx with a different error.\n+                    TxValidationState state_missing_inputs;\n+                    state_missing_inputs.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                    txdownload_impl.MempoolRejectedTx(ptx, state_missing_inputs, rand_peer, fuzzed_data_provider.ConsumeBool());\n+                }\n+            }\n+        );\n+\n+        // Jump ahead in time",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 433,
      "original_position": 392,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723473284,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "hmm, must have been referencing something else, nevermind",
      "created_at": "2024-08-22T11:30:52Z",
      "updated_at": "2024-08-22T11:30:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1726881353",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1726881353"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 433,
      "original_line": 433,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1727240719",
      "pull_request_review_id": 2254798839,
      "id": 1727240719,
      "node_id": "PRRC_kwDOABII585m85oP",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 168,
      "original_position": 154,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723456852,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No. I just had to google this magic number and felt slightly rickrolled ",
      "created_at": "2024-08-22T15:02:04Z",
      "updated_at": "2024-08-22T15:02:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1727240719",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1727240719"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 168,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1727243654",
      "pull_request_review_id": 2254802540,
      "id": 1727243654,
      "node_id": "PRRC_kwDOABII585m86WG",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 212,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "0de01c034e2977516d11f370efa1495d9b9577b0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "this fails if we have a package to validate...",
      "created_at": "2024-08-22T15:02:42Z",
      "updated_at": "2024-08-22T15:02:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1727243654",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1727243654"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1727249636",
      "pull_request_review_id": 2254810948,
      "id": 1727249636,
      "node_id": "PRRC_kwDOABII585m87zk",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 168,
      "original_position": 154,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723456852,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ohhh i get it now. i thought you found a crash and were giving a cryptic description of the input",
      "created_at": "2024-08-22T15:04:27Z",
      "updated_at": "2024-08-22T15:04:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1727249636",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1727249636"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 168,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728679985",
      "pull_request_review_id": 2256803176,
      "id": 1728679985,
      "node_id": "PRRC_kwDOABII585nCZAx",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 212,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "0de01c034e2977516d11f370efa1495d9b9577b0",
      "in_reply_to_id": 1727243654,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I wrote the assertion incorrectly. The only combination that's not ok is both.",
      "created_at": "2024-08-23T09:32:55Z",
      "updated_at": "2024-08-23T09:32:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1728679985",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728679985"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728680149",
      "pull_request_review_id": 2256803329,
      "id": 1728680149,
      "node_id": "PRRC_kwDOABII585nCZDV",
      "diff_hunk": "@@ -0,0 +1,248 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+\n+    // A new TxDownloadImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+\n+    for (const auto segwit_parent : {true, false}) {\n+        for (const auto segwit_child : {true, false}) {\n+            const auto ptx_parent = CreateTransactionChain(1, segwit_parent).front();\n+            const auto ptx_child = CreateTransactionChain(1, segwit_child).front();\n+            const auto& parent_txid = ptx_parent->GetHash().ToUint256();\n+            const auto& parent_wtxid = ptx_parent->GetWitnessHash().ToUint256();\n+            const auto& child_txid = ptx_child->GetHash().ToUint256();\n+            const auto& child_wtxid = ptx_child->GetWitnessHash().ToUint256();\n+\n+            for (const auto& [result, expected_behavior] : expected_behaviors) {\n+                node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+                // Parent failure\n+                state.Invalid(result, \"\");\n+                const auto& [keep, unique_txids, package_to_validate] = txdownload_impl.MempoolRejectedTx(ptx_parent, state, nodeid, /*first_time_failure=*/true);\n+\n+                // No distinction between txid and wtxid caching for nonsegwit transactions, so only test these specific\n+                // behaviors for segwit transactions.\n+                Behaviors actual_behavior{\n+                    /*txid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_txid),\n+                    /*wtxid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_wtxid),\n+                    /*txid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_txid),\n+                    /*wtxid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_wtxid),\n+                    /*keep=*/keep,\n+                    /*txid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Txid(parent_txid), now, /*p2p_inv=*/true),\n+                    /*wtxid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Wtxid(parent_wtxid), now, /*p2p_inv=*/true),\n+                };\n+                BOOST_TEST_MESSAGE(\"Testing behavior for \" << result << (segwit_parent ? \" segwit \" : \" nonsegwit\"));\n+                actual_behavior.CheckEqual(expected_behavior, /*segwit=*/segwit_parent);\n+\n+                // Later, a child of this transaction fails for missing inputs\n+                state.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                txdownload_impl.MempoolRejectedTx(ptx_child, state, nodeid, /*first_time_failure=*/true);\n+\n+                // If parent (by txid) was rejected, child is too.\n+                const bool parent_txid_rejected{segwit_parent ? expected_behavior.m_txid_in_rejects : expected_behavior.m_wtxid_in_rejects};\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_txid));\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_wtxid));\n+\n+                // Unless rejected, the child should be in orphanage.\n+                BOOST_CHECK_EQUAL(!parent_txid_rejected, txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+            }\n+        }\n+    }\n+\n+    // More specific examples of orphans with parent(s) that we have seen before.\n+    TxValidationState state_reconsiderable;\n+    state_reconsiderable.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"\");\n+\n+    TxValidationState state_orphan;\n+    state_orphan.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+\n+    const auto ptx_parent_1 = CreateTransactionChain(1, /*segwit=*/false).front();\n+    const auto ptx_parent_2 = CreateTransactionChain(1, /*segwit=*/false).front();\n+    CMutableTransaction mtx_child;\n+    mtx_child.vin.emplace_back(ptx_parent_1->GetHash(), 0);\n+    mtx_child.vin.emplace_back(ptx_parent_2->GetHash(), 0);\n+    mtx_child.vout.emplace_back(CENT, CScript());\n+    auto ptx_child = MakeTransactionRef(mtx_child);\n+    const std::vector<uint256> vec_parent_txids = {ptx_parent_1->GetHash(), ptx_parent_2->GetHash()};\n+\n+    // 1 reconsiderable parent\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Parent reconsiderable failure\n+        const auto& [p1_keep, p1_unique_txids, p1_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_1, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p1_keep);\n+        BOOST_CHECK(p1_unique_txids.empty());\n+        BOOST_CHECK(!p1_package.has_value());\n+\n+        // Child missing inputs, should be added to orphanage.\n+        const auto& [c_keep, c_unique_txids, c_package] = txdownload_impl.MempoolRejectedTx(ptx_child, state_orphan, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(c_keep);\n+        BOOST_CHECK(c_unique_txids == vec_parent_txids);\n+        BOOST_CHECK(!c_package.has_value());\n+        BOOST_CHECK(txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+    }\n+\n+    // 2 reconsiderable parents\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Parent reconsiderable failure\n+        const auto& [p1_keep, p1_unique_txids, p1_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_1, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p1_keep);\n+        BOOST_CHECK(p1_unique_txids.empty());\n+        BOOST_CHECK(!p1_package.has_value());\n+\n+        const auto& [p2_keep, p2_unique_txids, p2_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_2, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p2_keep);\n+        BOOST_CHECK(p2_unique_txids.empty());\n+        BOOST_CHECK(!p2_package.has_value());\n+\n+        // Child missing inputs. Not added to orphanage because only 1 reconsiderable rejected parent is tolerated.\n+        const auto& [c_keep, c_unique_txids, c_package] = txdownload_impl.MempoolRejectedTx(ptx_child, state_orphan, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(c_keep);\n+        BOOST_CHECK(c_unique_txids == vec_parent_txids);\n+        BOOST_CHECK(!c_package.has_value());\n+        BOOST_CHECK(!txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+    }\n+\n+    // 1 reconsiderable parent + 1 non-reconsiderable parent\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Parent reconsiderable failure\n+        const auto& [p1_keep, p1_unique_txids, p1_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_1, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p1_keep);\n+        BOOST_CHECK(p1_unique_txids.empty());\n+        BOOST_CHECK(!p1_package.has_value());\n+\n+        TxValidationState state_not_reconsiderable;\n+        state_not_reconsiderable.Invalid(TxValidationResult::TX_CONSENSUS, \"\");\n+\n+        const auto& [p2_keep, p2_unique_txids, p2_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_2, state_not_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p2_keep);\n+        BOOST_CHECK(p2_unique_txids.empty());\n+        BOOST_CHECK(!p2_package.has_value());\n+\n+        // Child missing inputs. Not added to orphanage because only 1 reconsiderable rejected parent is tolerated.\n+        const auto& [c_keep, c_unique_txids, c_package] = txdownload_impl.MempoolRejectedTx(ptx_child, state_orphan, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(c_keep);\n+        BOOST_CHECK(c_unique_txids == vec_parent_txids);\n+        BOOST_CHECK(!c_package.has_value());\n+        BOOST_CHECK(!txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+\n+    }\n+\n+    // Reconsiderable parent of a tx already in orphanage: the only time PackageToValidate is returned.\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Child missing inputs, should be added to orphanage.",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 232,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "8f5163e8a19e0963679a16c6fe7936af0536db26",
      "in_reply_to_id": 1725592055,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added",
      "created_at": "2024-08-23T09:33:00Z",
      "updated_at": "2024-08-23T09:33:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1728680149",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728680149"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 238,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728863544",
      "pull_request_review_id": 2257071619,
      "id": 1728863544,
      "node_id": "PRRC_kwDOABII585nDF04",
      "diff_hunk": "@@ -0,0 +1,157 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {\n+    /** Read-only reference to mempool. */\n+    const CTxMemPool& m_mempool;\n+    /** RNG provided by caller. */\n+    FastRandomContext& m_rng;\n+    /** Maximum number of transactions allowed in orphanage. */\n+    const uint32_t m_max_orphan_txs;\n+};\n+struct TxDownloadConnectionInfo {\n+    /** Whether this peer is preferred for transaction download. */\n+    const bool m_preferred;\n+    /** Whether this peer has Relay permissions. */\n+    const bool m_relay_permissions;\n+    /** Whether this peer supports wtxid relay. */\n+    const bool m_wtxid_relay;\n+};\n+struct PackageToValidate {\n+    Package m_txns;\n+    std::vector<NodeId> m_senders;\n+    /** Construct a 1-parent-1-child package. */\n+    explicit PackageToValidate(const CTransactionRef& parent,\n+                               const CTransactionRef& child,\n+                               NodeId parent_sender,\n+                               NodeId child_sender) :\n+        m_txns{parent, child},\n+        m_senders{parent_sender, child_sender}\n+    {}\n+\n+    // Move ctor\n+    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\n+    // Copy ctor\n+    PackageToValidate(const PackageToValidate& other) = default;\n+\n+    // Move assignment\n+    PackageToValidate& operator=(PackageToValidate&& other) {\n+        this->m_txns = std::move(other.m_txns);\n+        this->m_senders = std::move(other.m_senders);\n+        return *this;\n+    }\n+\n+    std::string ToString() const {\n+        Assume(m_txns.size() == 2);\n+        return strprintf(\"parent %s (wtxid=%s, sender=%d) + child %s (wtxid=%s, sender=%d)\",\n+                         m_txns.front()->GetHash().ToString(),\n+                         m_txns.front()->GetWitnessHash().ToString(),\n+                         m_senders.front(),\n+                         m_txns.back()->GetHash().ToString(),\n+                         m_txns.back()->GetWitnessHash().ToString(),\n+                         m_senders.back());\n+    }\n+};\n+struct RejectedTxTodo\n+{\n+    bool m_should_add_extra_compact_tx;\n+    std::vector<uint256> m_unique_parents;\n+    std::optional<PackageToValidate> m_package_to_validate;\n+};\n+\n+\n+class TxDownloadManager {\n+    const std::unique_ptr<TxDownloadImpl> m_impl;",
      "path": "src/node/txdownloadman.h",
      "position": null,
      "original_position": 101,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    const std::unique_ptr<TxDownloadManagerImpl> m_impl;\r\n```\r\n\r\nðŸ‘‰ðŸ‘ˆ",
      "created_at": "2024-08-23T12:05:18Z",
      "updated_at": "2024-08-23T12:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1728863544",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728863544"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728864031",
      "pull_request_review_id": 2257071619,
      "id": 1728864031,
      "node_id": "PRRC_kwDOABII585nDF8f",
      "diff_hunk": "@@ -0,0 +1,436 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        // \"Good\" peers send the inv at most once, and otherwise will not send an unsolicited message.\n+        if (m_good) {\n+            if (!m_sent_inv && (force_announce || fuzzed_data_provider.ConsumeBool())) {\n+                m_sent_inv = true;\n+                return PossibleMessage::INV_REAL;\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // Non-good peers might send anything!\n+        auto message = fuzzed_data_provider.PickValueInArray(ALL_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    PossibleResponse ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return PossibleResponse::NOTHING;\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(ALL_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return PossibleResponse::NOTHING;\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return response;\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{10};\n+COutPoint COINS[NUM_COINS];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(tx_download_one_honest_peer, .init = initialize)",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 226,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nFUZZ_TARGET(txdownloadman_one_honest_peer, .init = initialize)\r\n```\r\n\r\nðŸ‘‰ðŸ‘ˆ",
      "created_at": "2024-08-23T12:05:46Z",
      "updated_at": "2024-08-23T12:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1728864031",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728864031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728864722",
      "pull_request_review_id": 2257071619,
      "id": 1728864722,
      "node_id": "PRRC_kwDOABII585nDGHS",
      "diff_hunk": "@@ -0,0 +1,423 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (maybe_package.has_value()) CheckPackageToValidate(*maybe_package, rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+    txdownload_impl.m_txrequest.SanityCheck();\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 280,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nFUZZ_TARGET(txdownloadman_impl, .init = initialize)\r\n```\r\n\r\n(if you take the other naming suggestion)\r\n\r\nðŸ‘‰ðŸ‘ˆ",
      "created_at": "2024-08-23T12:06:24Z",
      "updated_at": "2024-08-23T12:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1728864722",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728864722"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728880703",
      "pull_request_review_id": 2257097696,
      "id": 1728880703,
      "node_id": "PRRC_kwDOABII585nDKA_",
      "diff_hunk": "@@ -0,0 +1,436 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        // \"Good\" peers send the inv at most once, and otherwise will not send an unsolicited message.\n+        if (m_good) {\n+            if (!m_sent_inv && (force_announce || fuzzed_data_provider.ConsumeBool())) {\n+                m_sent_inv = true;\n+                return PossibleMessage::INV_REAL;\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // Non-good peers might send anything!\n+        auto message = fuzzed_data_provider.PickValueInArray(ALL_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    PossibleResponse ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return PossibleResponse::NOTHING;\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(ALL_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return PossibleResponse::NOTHING;\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return response;\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{10};\n+COutPoint COINS[NUM_COINS];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(tx_download_one_honest_peer, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+\n+    // Make target transaction, malleated, and stripped\n+    auto target_tx{MakeTransactionSpending(\n+        {fuzzed_data_provider.PickValueInArray(COINS)},\n+        /*num_outputs=*/2,\n+        /*add_witness=*/fuzzed_data_provider.ConsumeBool())\n+    };\n+    auto malleated_tx = Malleate(target_tx);\n+    auto stripped_tx = StripWitness(target_tx);\n+    const auto& target_txid = target_tx->GetHash().ToUint256();\n+    const auto& target_wtxid = target_tx->GetWitnessHash().ToUint256();\n+    const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+    std::chrono::microseconds time{244466666};\n+\n+    // Decide what the peers are.\n+    std::vector<TestPeer> all_peers;\n+    // NodeId of the \"designated good peer\"\n+    // Other TestPeers may be \"good\" as well, but not guaranteed.\n+    NodeId honestid = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 7);\n+    // 8 outbound peers. NodeId = o. We indicate outbound using preferred=true\n+    for (unsigned int o = 0; o < 8; ++o) {\n+        bool good = (o == honestid) || fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, o, /*preferred=*/true, /*force_good=*/good));\n+    }\n+    // 0-120 inbound peers. NodeId = i. We indicate inbound using preferred=false\n+    auto num_inbound_peers = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 120);\n+    for (unsigned int i = 8; i < num_inbound_peers + 8; ++i) {\n+        bool good = fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, i, /*preferred=*/false, /*force_good=*/good));\n+    }\n+\n+    // Indexes for random peer iteration\n+    std::vector<size_t> indexes;\n+    indexes.resize(all_peers.size());\n+    std::iota(indexes.begin(), indexes.end(), 0);\n+\n+    // We are trying to ensure that we always download the tx as long as we have 1 good outbound\n+    // peer who is able to send it to us.\n+    bool got_tx{false};\n+\n+    // Keep track of how many iterations the loop has done to make sure the target transaction is\n+    // announced within the first 1000 rounds. Note that the good peer is guaranteed to connect\n+    // within the first round and will never be disconnected.\n+    int counter = 0;\n+\n+    LIMITED_WHILE(!got_tx, 100000)\n+    {\n+        std::shuffle(indexes.begin(), indexes.end(), det_rand);",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 284,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Any reason not to let the fuzzer decide the order?\r\n\r\nIf the order is interesting (i.e. a specific order might trigger a bug) then I think it'd make more sense to let the fuzzer choose the order.",
      "created_at": "2024-08-23T12:20:05Z",
      "updated_at": "2024-08-23T12:20:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1728880703",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728880703"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728887570",
      "pull_request_review_id": 2257108313,
      "id": 1728887570,
      "node_id": "PRRC_kwDOABII585nDLsS",
      "diff_hunk": "@@ -0,0 +1,81 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+\n+namespace node {\n+\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()",
      "path": "src/node/txdownloadman.cpp",
      "position": null,
      "original_position": 15,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "To avoid the circular dependency, you could get rid of this file and move its contents to `txdownloadman_impl.cpp`. ",
      "created_at": "2024-08-23T12:25:54Z",
      "updated_at": "2024-08-23T12:26:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1728887570",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728887570"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729130184",
      "pull_request_review_id": 2257483519,
      "id": 1729130184,
      "node_id": "PRRC_kwDOABII585nEG7I",
      "diff_hunk": "@@ -0,0 +1,436 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        // \"Good\" peers send the inv at most once, and otherwise will not send an unsolicited message.\n+        if (m_good) {\n+            if (!m_sent_inv && (force_announce || fuzzed_data_provider.ConsumeBool())) {\n+                m_sent_inv = true;\n+                return PossibleMessage::INV_REAL;\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // Non-good peers might send anything!\n+        auto message = fuzzed_data_provider.PickValueInArray(ALL_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    PossibleResponse ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return PossibleResponse::NOTHING;\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(ALL_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return PossibleResponse::NOTHING;\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return response;\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{10};\n+COutPoint COINS[NUM_COINS];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(tx_download_one_honest_peer, .init = initialize)",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 226,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": 1728864031,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-23T15:09:57Z",
      "updated_at": "2024-08-23T15:09:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1729130184",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729130184"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729130331",
      "pull_request_review_id": 2257483749,
      "id": 1729130331,
      "node_id": "PRRC_kwDOABII585nEG9b",
      "diff_hunk": "@@ -0,0 +1,423 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (maybe_package.has_value()) CheckPackageToValidate(*maybe_package, rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+    txdownload_impl.m_txrequest.SanityCheck();\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 280,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": 1728864722,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-23T15:10:02Z",
      "updated_at": "2024-08-23T15:10:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1729130331",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729130331"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729130506",
      "pull_request_review_id": 2257484030,
      "id": 1729130506,
      "node_id": "PRRC_kwDOABII585nEHAK",
      "diff_hunk": "@@ -0,0 +1,436 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        // \"Good\" peers send the inv at most once, and otherwise will not send an unsolicited message.\n+        if (m_good) {\n+            if (!m_sent_inv && (force_announce || fuzzed_data_provider.ConsumeBool())) {\n+                m_sent_inv = true;\n+                return PossibleMessage::INV_REAL;\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // Non-good peers might send anything!\n+        auto message = fuzzed_data_provider.PickValueInArray(ALL_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    PossibleResponse ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return PossibleResponse::NOTHING;\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(ALL_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return PossibleResponse::NOTHING;\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return response;\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{10};\n+COutPoint COINS[NUM_COINS];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(tx_download_one_honest_peer, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+\n+    // Make target transaction, malleated, and stripped\n+    auto target_tx{MakeTransactionSpending(\n+        {fuzzed_data_provider.PickValueInArray(COINS)},\n+        /*num_outputs=*/2,\n+        /*add_witness=*/fuzzed_data_provider.ConsumeBool())\n+    };\n+    auto malleated_tx = Malleate(target_tx);\n+    auto stripped_tx = StripWitness(target_tx);\n+    const auto& target_txid = target_tx->GetHash().ToUint256();\n+    const auto& target_wtxid = target_tx->GetWitnessHash().ToUint256();\n+    const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+    std::chrono::microseconds time{244466666};\n+\n+    // Decide what the peers are.\n+    std::vector<TestPeer> all_peers;\n+    // NodeId of the \"designated good peer\"\n+    // Other TestPeers may be \"good\" as well, but not guaranteed.\n+    NodeId honestid = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 7);\n+    // 8 outbound peers. NodeId = o. We indicate outbound using preferred=true\n+    for (unsigned int o = 0; o < 8; ++o) {\n+        bool good = (o == honestid) || fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, o, /*preferred=*/true, /*force_good=*/good));\n+    }\n+    // 0-120 inbound peers. NodeId = i. We indicate inbound using preferred=false\n+    auto num_inbound_peers = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 120);\n+    for (unsigned int i = 8; i < num_inbound_peers + 8; ++i) {\n+        bool good = fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, i, /*preferred=*/false, /*force_good=*/good));\n+    }\n+\n+    // Indexes for random peer iteration\n+    std::vector<size_t> indexes;\n+    indexes.resize(all_peers.size());\n+    std::iota(indexes.begin(), indexes.end(), 0);\n+\n+    // We are trying to ensure that we always download the tx as long as we have 1 good outbound\n+    // peer who is able to send it to us.\n+    bool got_tx{false};\n+\n+    // Keep track of how many iterations the loop has done to make sure the target transaction is\n+    // announced within the first 1000 rounds. Note that the good peer is guaranteed to connect\n+    // within the first round and will never be disconnected.\n+    int counter = 0;\n+\n+    LIMITED_WHILE(!got_tx, 100000)\n+    {\n+        std::shuffle(indexes.begin(), indexes.end(), det_rand);",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 284,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": 1728880703,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-23T15:10:10Z",
      "updated_at": "2024-08-23T15:10:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1729130506",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729130506"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729201357",
      "pull_request_review_id": 2257590987,
      "id": 1729201357,
      "node_id": "PRRC_kwDOABII585nEYTN",
      "diff_hunk": "@@ -3070,17 +3073,14 @@ std::optional<PeerManagerImpl::PackageToValidate> PeerManagerImpl::ProcessInvali\n                 // Eventually we should replace this with an improved\n                 // protocol for getting all unconfirmed parents.\n                 const auto gtxid{GenTxid::Txid(parent_txid)};\n-                if (peer) AddKnownTx(*peer, parent_txid);\n                 // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n                 // previously rejected for being too low feerate. This orphan might CPFP it.\n                 if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n                     m_txdownloadman.AddTxAnnouncement(nodeid, gtxid, current_time, /*p2p_inv=*/false);\n                 }\n             }\n \n-            if (m_orphanage.AddTx(ptx, nodeid)) {\n-                AddToCompactExtraTransactions(ptx);\n-            }\n+            add_extra_compact_tx &= m_orphanage.AddTx(ptx, nodeid);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 43,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "1468112dda32592a9fb5fdf177fc563d8f3e0aa1",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "just to be sure, was it intentional to use the bit-wise AND operator here, rather than the logical one (`&&=`), to avoid potential short-circuiting (see e.g. https://stackoverflow.com/questions/23107162/do-the-and-operators-for-bool-short-circuit)? IIUC, `add_extra_compact_tx` is always true at this point anyway (otherwise the if condition at the very top couldn't be true), so could also just do a regular assignment, I guess. But not sure what's better, one could argue that the current way is more future-proof.",
      "created_at": "2024-08-23T16:04:25Z",
      "updated_at": "2024-08-23T16:24:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1729201357",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729201357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3083,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732688924",
      "pull_request_review_id": 2263061918,
      "id": 1732688924,
      "node_id": "PRRC_kwDOABII585nRrwc",
      "diff_hunk": "@@ -0,0 +1,157 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {\n+    /** Read-only reference to mempool. */\n+    const CTxMemPool& m_mempool;\n+    /** RNG provided by caller. */\n+    FastRandomContext& m_rng;\n+    /** Maximum number of transactions allowed in orphanage. */\n+    const uint32_t m_max_orphan_txs;\n+};\n+struct TxDownloadConnectionInfo {\n+    /** Whether this peer is preferred for transaction download. */\n+    const bool m_preferred;\n+    /** Whether this peer has Relay permissions. */\n+    const bool m_relay_permissions;\n+    /** Whether this peer supports wtxid relay. */\n+    const bool m_wtxid_relay;\n+};\n+struct PackageToValidate {\n+    Package m_txns;\n+    std::vector<NodeId> m_senders;\n+    /** Construct a 1-parent-1-child package. */\n+    explicit PackageToValidate(const CTransactionRef& parent,\n+                               const CTransactionRef& child,\n+                               NodeId parent_sender,\n+                               NodeId child_sender) :\n+        m_txns{parent, child},\n+        m_senders{parent_sender, child_sender}\n+    {}\n+\n+    // Move ctor\n+    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\n+    // Copy ctor\n+    PackageToValidate(const PackageToValidate& other) = default;\n+\n+    // Move assignment\n+    PackageToValidate& operator=(PackageToValidate&& other) {\n+        this->m_txns = std::move(other.m_txns);\n+        this->m_senders = std::move(other.m_senders);\n+        return *this;\n+    }\n+\n+    std::string ToString() const {\n+        Assume(m_txns.size() == 2);\n+        return strprintf(\"parent %s (wtxid=%s, sender=%d) + child %s (wtxid=%s, sender=%d)\",\n+                         m_txns.front()->GetHash().ToString(),\n+                         m_txns.front()->GetWitnessHash().ToString(),\n+                         m_senders.front(),\n+                         m_txns.back()->GetHash().ToString(),\n+                         m_txns.back()->GetWitnessHash().ToString(),\n+                         m_senders.back());\n+    }\n+};\n+struct RejectedTxTodo\n+{\n+    bool m_should_add_extra_compact_tx;\n+    std::vector<uint256> m_unique_parents;\n+    std::optional<PackageToValidate> m_package_to_validate;\n+};\n+\n+\n+class TxDownloadManager {\n+    const std::unique_ptr<TxDownloadImpl> m_impl;",
      "path": "src/node/txdownloadman.h",
      "position": null,
      "original_position": 101,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": 1728863544,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-27T11:45:20Z",
      "updated_at": "2024-08-27T11:45:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1732688924",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732688924"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732689092",
      "pull_request_review_id": 2263062110,
      "id": 1732689092,
      "node_id": "PRRC_kwDOABII585nRrzE",
      "diff_hunk": "@@ -0,0 +1,81 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+\n+namespace node {\n+\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()",
      "path": "src/node/txdownloadman.cpp",
      "position": null,
      "original_position": 15,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": 1728887570,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-27T11:45:25Z",
      "updated_at": "2024-08-27T11:45:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1732689092",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732689092"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732691023",
      "pull_request_review_id": 2263065206,
      "id": 1732691023,
      "node_id": "PRRC_kwDOABII585nRsRP",
      "diff_hunk": "@@ -3070,17 +3073,14 @@ std::optional<PeerManagerImpl::PackageToValidate> PeerManagerImpl::ProcessInvali\n                 // Eventually we should replace this with an improved\n                 // protocol for getting all unconfirmed parents.\n                 const auto gtxid{GenTxid::Txid(parent_txid)};\n-                if (peer) AddKnownTx(*peer, parent_txid);\n                 // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n                 // previously rejected for being too low feerate. This orphan might CPFP it.\n                 if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n                     m_txdownloadman.AddTxAnnouncement(nodeid, gtxid, current_time, /*p2p_inv=*/false);\n                 }\n             }\n \n-            if (m_orphanage.AddTx(ptx, nodeid)) {\n-                AddToCompactExtraTransactions(ptx);\n-            }\n+            add_extra_compact_tx &= m_orphanage.AddTx(ptx, nodeid);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 43,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "1468112dda32592a9fb5fdf177fc563d8f3e0aa1",
      "in_reply_to_id": 1729201357,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, we don't want a short circuit, though in practice `add_extra_compact_tx` should always be true at this point in the code. I've added a comment describing what the expected changes can be.",
      "created_at": "2024-08-27T11:46:43Z",
      "updated_at": "2024-08-27T11:46:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1732691023",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732691023"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3083,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734517492",
      "pull_request_review_id": 2266000970,
      "id": 1734517492,
      "node_id": "PRRC_kwDOABII585nYqL0",
      "diff_hunk": "@@ -0,0 +1,34 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class TxOrphanage;\n+class TxRequestTracker;\n+class CRollingBloomFilter;\n+\n+namespace node {\n+class TxDownloadImpl;",
      "path": "src/node/txdownloadman.h",
      "position": null,
      "original_position": 16,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "58fb38c182906645161af04e84becc824dee2ba5",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "At first I was wondering if their is any benefit of not declaring the implementation class private to `TxDownloadManager` as recommended in https://en.cppreference.com/w/cpp/language/pimpl.\r\n\r\nBut then after the first pass of this PR, I think the reason is to make `TxDownloadManagerImpl` visible to the entire namespace in other to  allow for testing `TxDownloadManagerImpl` specific behaviors in fuzzing.\r\n\r\n",
      "created_at": "2024-08-28T11:36:34Z",
      "updated_at": "2024-08-28T12:57:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734517492",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734517492"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734535670",
      "pull_request_review_id": 2266000970,
      "id": 1734535670,
      "node_id": "PRRC_kwDOABII585nYun2",
      "diff_hunk": "@@ -0,0 +1,34 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 4,
      "original_position": 4,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "58fb38c182906645161af04e84becc824dee2ba5",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In 58fb38c182906645161af04e84becc824dee2ba5 \" [refactor] add TxDownloadManager wrapping TxOrphanage, TxRequestTracker, and bloom filters\"\r\n\r\n\r\nI think the file name should be txdownloadman.cpp ?\r\n`TxDownloadManager` is the public interface.",
      "created_at": "2024-08-28T11:48:46Z",
      "updated_at": "2024-08-28T12:57:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734535670",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734535670"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4,
      "original_line": 4,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734554084",
      "pull_request_review_id": 2266000970,
      "id": 1734554084,
      "node_id": "PRRC_kwDOABII585nYzHk",
      "diff_hunk": "@@ -1672,6 +1582,8 @@ void PeerManagerImpl::AddTxAnnouncement(const CNode& node, const GenTxid& gtxid,\n     AssertLockHeld(::cs_main); // for State\n     AssertLockHeld(m_tx_download_mutex); // For m_txrequest",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 146,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "58fb38c182906645161af04e84becc824dee2ba5",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    AssertLockHeld(m_tx_download_mutex); // For m_txdownloadman\r\n```",
      "created_at": "2024-08-28T12:03:24Z",
      "updated_at": "2024-08-28T12:57:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734554084",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734554084"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1583,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734565020",
      "pull_request_review_id": 2266000970,
      "id": 1734565020,
      "node_id": "PRRC_kwDOABII585nY1yc",
      "diff_hunk": "@@ -0,0 +1,157 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {\n+    /** Read-only reference to mempool. */\n+    const CTxMemPool& m_mempool;\n+    /** RNG provided by caller. */\n+    FastRandomContext& m_rng;\n+    /** Maximum number of transactions allowed in orphanage. */\n+    const uint32_t m_max_orphan_txs;\n+};\n+struct TxDownloadConnectionInfo {\n+    /** Whether this peer is preferred for transaction download. */\n+    const bool m_preferred;\n+    /** Whether this peer has Relay permissions. */\n+    const bool m_relay_permissions;\n+    /** Whether this peer supports wtxid relay. */\n+    const bool m_wtxid_relay;\n+};\n+struct PackageToValidate {\n+    Package m_txns;\n+    std::vector<NodeId> m_senders;\n+    /** Construct a 1-parent-1-child package. */\n+    explicit PackageToValidate(const CTransactionRef& parent,\n+                               const CTransactionRef& child,\n+                               NodeId parent_sender,\n+                               NodeId child_sender) :\n+        m_txns{parent, child},\n+        m_senders{parent_sender, child_sender}\n+    {}\n+\n+    // Move ctor\n+    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\n+    // Copy ctor\n+    PackageToValidate(const PackageToValidate& other) = default;\n+\n+    // Move assignment\n+    PackageToValidate& operator=(PackageToValidate&& other) {\n+        this->m_txns = std::move(other.m_txns);\n+        this->m_senders = std::move(other.m_senders);\n+        return *this;\n+    }\n+\n+    std::string ToString() const {\n+        Assume(m_txns.size() == 2);\n+        return strprintf(\"parent %s (wtxid=%s, sender=%d) + child %s (wtxid=%s, sender=%d)\",\n+                         m_txns.front()->GetHash().ToString(),\n+                         m_txns.front()->GetWitnessHash().ToString(),\n+                         m_senders.front(),\n+                         m_txns.back()->GetHash().ToString(),\n+                         m_txns.back()->GetWitnessHash().ToString(),\n+                         m_senders.back());\n+    }\n+};\n+struct RejectedTxTodo\n+{\n+    bool m_should_add_extra_compact_tx;\n+    std::vector<uint256> m_unique_parents;\n+    std::optional<PackageToValidate> m_package_to_validate;\n+};\n+\n+\n+class TxDownloadManager {\n+    const std::unique_ptr<TxDownloadImpl> m_impl;",
      "path": "src/node/txdownloadman.h",
      "position": null,
      "original_position": 101,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": 1728863544,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The update was effected in the second commit",
      "created_at": "2024-08-28T12:12:09Z",
      "updated_at": "2024-08-28T12:57:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734565020",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734565020"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734663166",
      "pull_request_review_id": 2266240226,
      "id": 1734663166,
      "node_id": "PRRC_kwDOABII585nZNv-",
      "diff_hunk": "@@ -0,0 +1,34 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 4,
      "original_position": 4,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "58fb38c182906645161af04e84becc824dee2ba5",
      "in_reply_to_id": 1734535670,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It contains the implementation for `TxDownloadManagerImpl` as well.",
      "created_at": "2024-08-28T13:18:31Z",
      "updated_at": "2024-08-28T13:18:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734663166",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734663166"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4,
      "original_line": 4,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734686231",
      "pull_request_review_id": 2266280167,
      "id": 1734686231,
      "node_id": "PRRC_kwDOABII585nZTYX",
      "diff_hunk": "@@ -1672,6 +1582,8 @@ void PeerManagerImpl::AddTxAnnouncement(const CNode& node, const GenTxid& gtxid,\n     AssertLockHeld(::cs_main); // for State\n     AssertLockHeld(m_tx_download_mutex); // For m_txrequest",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 146,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "58fb38c182906645161af04e84becc824dee2ba5",
      "in_reply_to_id": 1734554084,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Assuming this is on one of the earlier commits - the whole line is deleted in 0e6e135e303",
      "created_at": "2024-08-28T13:32:17Z",
      "updated_at": "2024-08-28T13:32:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734686231",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734686231"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1583,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734688133",
      "pull_request_review_id": 2266283496,
      "id": 1734688133,
      "node_id": "PRRC_kwDOABII585nZT2F",
      "diff_hunk": "@@ -0,0 +1,157 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {\n+    /** Read-only reference to mempool. */\n+    const CTxMemPool& m_mempool;\n+    /** RNG provided by caller. */\n+    FastRandomContext& m_rng;\n+    /** Maximum number of transactions allowed in orphanage. */\n+    const uint32_t m_max_orphan_txs;\n+};\n+struct TxDownloadConnectionInfo {\n+    /** Whether this peer is preferred for transaction download. */\n+    const bool m_preferred;\n+    /** Whether this peer has Relay permissions. */\n+    const bool m_relay_permissions;\n+    /** Whether this peer supports wtxid relay. */\n+    const bool m_wtxid_relay;\n+};\n+struct PackageToValidate {\n+    Package m_txns;\n+    std::vector<NodeId> m_senders;\n+    /** Construct a 1-parent-1-child package. */\n+    explicit PackageToValidate(const CTransactionRef& parent,\n+                               const CTransactionRef& child,\n+                               NodeId parent_sender,\n+                               NodeId child_sender) :\n+        m_txns{parent, child},\n+        m_senders{parent_sender, child_sender}\n+    {}\n+\n+    // Move ctor\n+    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\n+    // Copy ctor\n+    PackageToValidate(const PackageToValidate& other) = default;\n+\n+    // Move assignment\n+    PackageToValidate& operator=(PackageToValidate&& other) {\n+        this->m_txns = std::move(other.m_txns);\n+        this->m_senders = std::move(other.m_senders);\n+        return *this;\n+    }\n+\n+    std::string ToString() const {\n+        Assume(m_txns.size() == 2);\n+        return strprintf(\"parent %s (wtxid=%s, sender=%d) + child %s (wtxid=%s, sender=%d)\",\n+                         m_txns.front()->GetHash().ToString(),\n+                         m_txns.front()->GetWitnessHash().ToString(),\n+                         m_senders.front(),\n+                         m_txns.back()->GetHash().ToString(),\n+                         m_txns.back()->GetWitnessHash().ToString(),\n+                         m_senders.back());\n+    }\n+};\n+struct RejectedTxTodo\n+{\n+    bool m_should_add_extra_compact_tx;\n+    std::vector<uint256> m_unique_parents;\n+    std::optional<PackageToValidate> m_package_to_validate;\n+};\n+\n+\n+class TxDownloadManager {\n+    const std::unique_ptr<TxDownloadImpl> m_impl;",
      "path": "src/node/txdownloadman.h",
      "position": null,
      "original_position": 101,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": 1728863544,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Woops, ran the script from `HEAD~24` instead of `HEAD~25`. Fixed now.",
      "created_at": "2024-08-28T13:33:25Z",
      "updated_at": "2024-08-28T13:33:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734688133",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734688133"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734804944",
      "pull_request_review_id": 2266475743,
      "id": 1734804944,
      "node_id": "PRRC_kwDOABII585nZwXQ",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+\n+    // A new TxDownloadManagerImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+    node::TxDownloadConnectionInfo connection_info{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};",
      "path": "src/test/txdownload_tests.cpp",
      "position": 124,
      "original_position": 99,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "caedaec23a7ffd08b1cb7f45966857148a25eeec",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "IIUC this would at least give more coverage to `AddTxAnnouncement` getting deeper during new orphan processing",
      "created_at": "2024-08-28T14:33:35Z",
      "updated_at": "2024-08-28T14:34:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734804944",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734804944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 124,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734817526",
      "pull_request_review_id": 2266495841,
      "id": 1734817526,
      "node_id": "PRRC_kwDOABII585nZzb2",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+\n+    // A new TxDownloadManagerImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+    node::TxDownloadConnectionInfo connection_info{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};",
      "path": "src/test/txdownload_tests.cpp",
      "position": 124,
      "original_position": 99,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "caedaec23a7ffd08b1cb7f45966857148a25eeec",
      "in_reply_to_id": 1734804944,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right. I'm also building my orphan resolution branch that effectively skips adding orphans for peers that aren't \"registered\" (we need to know their connection info to decide some params). These tests started failing there, so I had to add `ConnectPeer`. Figured it makes sense to do this now.",
      "created_at": "2024-08-28T14:40:28Z",
      "updated_at": "2024-08-28T14:40:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734817526",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734817526"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 124,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1742665719",
      "pull_request_review_id": 2278214287,
      "id": 1742665719,
      "node_id": "PRRC_kwDOABII585n3vf3",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 44,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "this comment is outdated, as TX_REAL now means really whatever the node getdata'd",
      "created_at": "2024-09-03T20:42:35Z",
      "updated_at": "2024-09-03T20:43:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1742665719",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1742665719"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1742884245",
      "pull_request_review_id": 2278788723,
      "id": 1742884245,
      "node_id": "PRRC_kwDOABII585n4k2V",
      "diff_hunk": "@@ -5135,16 +5135,19 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n     if (msg_type == NetMsgType::NOTFOUND) {\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n+        std::vector<uint256> tx_invs;\n         if (vInv.size() <= node::MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             LOCK(m_tx_download_mutex);\n             for (CInv &inv : vInv) {\n                 if (inv.IsGenTxMsg()) {\n                     // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\n                     // completed in TxRequestTracker.\n-                    m_txdownloadman.GetTxRequestRef().ReceivedResponse(pfrom.GetId(), inv.hash);\n+                    tx_invs.emplace_back(inv.hash);\n                 }\n             }\n         }\n+        LOCK(m_tx_download_mutex);\n+        m_txdownloadman.ReceivedNotFound(pfrom.GetId(), tx_invs);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 17,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "c40cb8565952f62732fa64875c99ef9082b9a6f4",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in commit c40cb8565952f62732fa64875c99ef9082b9a6f4: now that the if-body above only reads and writes from local variables (`vInv` and `tx_invs`), acquiring the `m_tx_download_mutex` lock before the for-loop (line 5140 at this commit) is not needed anymore",
      "created_at": "2024-09-04T01:52:14Z",
      "updated_at": "2024-09-05T10:46:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1742884245",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1742884245"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 5138,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 4883,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1743907527",
      "pull_request_review_id": 2280398534,
      "id": 1743907527,
      "node_id": "PRRC_kwDOABII585n8erH",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 44,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "in_reply_to_id": 1742665719,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, will fix if I retouch",
      "created_at": "2024-09-04T14:25:41Z",
      "updated_at": "2024-09-04T14:25:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1743907527",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1743907527"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1745457490",
      "pull_request_review_id": 2282915874,
      "id": 1745457490,
      "node_id": "PRRC_kwDOABII585oCZFS",
      "diff_hunk": "@@ -5135,16 +5135,19 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n     if (msg_type == NetMsgType::NOTFOUND) {\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n+        std::vector<uint256> tx_invs;\n         if (vInv.size() <= node::MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             LOCK(m_tx_download_mutex);\n             for (CInv &inv : vInv) {\n                 if (inv.IsGenTxMsg()) {\n                     // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\n                     // completed in TxRequestTracker.\n-                    m_txdownloadman.GetTxRequestRef().ReceivedResponse(pfrom.GetId(), inv.hash);\n+                    tx_invs.emplace_back(inv.hash);\n                 }\n             }\n         }\n+        LOCK(m_tx_download_mutex);\n+        m_txdownloadman.ReceivedNotFound(pfrom.GetId(), tx_invs);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 17,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "c40cb8565952f62732fa64875c99ef9082b9a6f4",
      "in_reply_to_id": 1742884245,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "good point :+1:",
      "created_at": "2024-09-05T12:48:02Z",
      "updated_at": "2024-09-05T12:48:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1745457490",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1745457490"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 5138,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 4883,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1761911213",
      "pull_request_review_id": 2307779875,
      "id": 1761911213,
      "node_id": "PRRC_kwDOABII585pBKGt",
      "diff_hunk": "@@ -0,0 +1,127 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_IMPL_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_IMPL_H\n+\n+#include <node/txdownloadman.h>\n+\n+#include <common/bloom.h>\n+#include <net.h>\n+#include <txorphanage.h>\n+#include <txrequest.h>\n+\n+namespace node {\n+class TxDownloadManagerImpl {\n+public:\n+    /** Manages unvalidated tx data (orphan transactions for which we are downloading ancestors). */\n+    TxOrphanage m_orphanage;\n+    /** Tracks candidates for requesting and downloading transaction data. */\n+    TxRequestTracker m_txrequest;\n+\n+    /**\n+     * Filter for transactions that were recently rejected by the mempool.\n+     * These are not rerequested until the chain tip changes, at which point\n+     * the entire filter is reset.\n+     *\n+     * Without this filter we'd be re-requesting txs from each of our peers,\n+     * increasing bandwidth consumption considerably. For instance, with 100\n+     * peers, half of which relay a tx we don't accept, that might be a 50x\n+     * bandwidth increase. A flooding attacker attempting to roll-over the\n+     * filter using minimum-sized, 60byte, transactions might manage to send\n+     * 1000/sec if we have fast peers, so we pick 120,000 to give our peers a\n+     * two minute window to send invs to us.\n+     *\n+     * Decreasing the false positive rate is fairly cheap, so we pick one in a\n+     * million to make it highly unlikely for users to have issues with this\n+     * filter.\n+     *\n+     * We typically only add wtxids to this filter. For non-segwit\n+     * transactions, the txid == wtxid, so this only prevents us from\n+     * re-downloading non-segwit transactions when communicating with\n+     * non-wtxidrelay peers -- which is important for avoiding malleation\n+     * attacks that could otherwise interfere with transaction relay from\n+     * non-wtxidrelay peers. For communicating with wtxidrelay peers, having\n+     * the reject filter store wtxids is exactly what we want to avoid\n+     * redownload of a rejected transaction.\n+     *\n+     * In cases where we can tell that a segwit transaction will fail\n+     * validation no matter the witness, we may add the txid of such\n+     * transaction to the filter as well. This can be helpful when\n+     * communicating with txid-relay peers or if we were to otherwise fetch a\n+     * transaction via txid (eg in our orphan handling).\n+     *\n+     * Memory used: 1.3 MB\n+     */\n+    std::unique_ptr<CRollingBloomFilter> m_lazy_recent_rejects{nullptr};\n+\n+    CRollingBloomFilter& RecentRejectsFilter()\n+    {\n+        if (!m_lazy_recent_rejects) {\n+            m_lazy_recent_rejects = std::make_unique<CRollingBloomFilter>(120'000, 0.000'001);\n+        }\n+\n+        return *m_lazy_recent_rejects;\n+    }\n+\n+    /**\n+     * Filter for:\n+     * (1) wtxids of transactions that were recently rejected by the mempool but are\n+     * eligible for reconsideration if submitted with other transactions.\n+     * (2) packages (see GetPackageHash) we have already rejected before and should not retry.\n+     *\n+     * Similar to m_lazy_recent_rejects, this filter is used to save bandwidth when e.g. all of our peers\n+     * have larger mempools and thus lower minimum feerates than us.\n+     *\n+     * When a transaction's error is TxValidationResult::TX_RECONSIDERABLE (in a package or by\n+     * itself), add its wtxid to this filter. When a package fails for any reason, add the combined\n+     * hash to this filter.\n+     *\n+     * Upon receiving an announcement for a transaction, if it exists in this filter, do not\n+     * download the txdata. When considering packages, if it exists in this filter, drop it.\n+     *\n+     * Reset this filter when the chain tip changes.\n+     *\n+     * Parameters are picked to be the same as m_lazy_recent_rejects, with the same rationale.\n+     */\n+    std::unique_ptr<CRollingBloomFilter> m_lazy_recent_rejects_reconsiderable{nullptr};\n+\n+    CRollingBloomFilter& RecentRejectsReconsiderableFilter()\n+    {\n+        if (!m_lazy_recent_rejects_reconsiderable) {\n+            m_lazy_recent_rejects_reconsiderable = std::make_unique<CRollingBloomFilter>(120'000, 0.000'001);\n+        }\n+\n+        return *m_lazy_recent_rejects_reconsiderable;\n+    }\n+\n+    /*\n+     * Filter for transactions that have been recently confirmed.\n+     * We use this to avoid requesting transactions that have already been\n+     * confirnmed.\n+     *\n+     * Blocks don't typically have more than 4000 transactions, so this should\n+     * be at least six blocks (~1 hr) worth of transactions that we can store,\n+     * inserting both a txid and wtxid for every observed transaction.\n+     * If the number of transactions appearing in a block goes up, or if we are\n+     * seeing getdata requests more than an hour after initial announcement, we\n+     * can increase this number.\n+     * The false positive rate of 1/1M should come out to less than 1\n+     * transaction per day that would be inadvertently ignored (which is the\n+     * same probability that we have in the reject filter).\n+     */\n+    std::unique_ptr<CRollingBloomFilter> m_lazy_recent_confirmed_transactions{nullptr};\n+\n+    CRollingBloomFilter& RecentConfirmedTransactionsFilter()\n+    {\n+        if (!m_lazy_recent_confirmed_transactions) {\n+            m_lazy_recent_confirmed_transactions = std::make_unique<CRollingBloomFilter>(120'000, 0.000'001);",
      "path": "src/node/txdownloadman_impl.h",
      "position": null,
      "original_position": 118,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "ecbbadf0f79bb32730d9e1400d84b84893e35e56",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In ecbbadf0f79bb32730d9e1400d84b84893e35e56 \"[refactor] add TxDownloadManager wrapping TxOrphanage, TxRequestTracker, and bloom filters\"\r\n\r\nWhy have this bloom filter's parameters changed? It was previously `48'000` and `0.000'001`. If this was intentional, it should probably be a separate commit and a rationale provided.",
      "created_at": "2024-09-16T20:32:06Z",
      "updated_at": "2024-09-16T21:27:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1761911213",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1761911213"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1761957878",
      "pull_request_review_id": 2307779875,
      "id": 1761957878,
      "node_id": "PRRC_kwDOABII585pBVf2",
      "diff_hunk": "@@ -203,4 +207,13 @@ std::vector<GenTxid> TxDownloadManagerImpl::GetRequestsToSend(NodeId nodeid, std\n     }\n     return requests;\n }\n+\n+void TxDownloadManagerImpl::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    for (const auto& txhash: txhashes) {",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 18,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "c40cb8565952f62732fa64875c99ef9082b9a6f4",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In c40cb8565952f62732fa64875c99ef9082b9a6f4 \"[refactor] move notfound processing to txdownload\"\r\n\r\nnit:\r\n\r\n```suggestion\r\n    for (const auto& txhash : txhashes) {\r\n```",
      "created_at": "2024-09-16T20:59:20Z",
      "updated_at": "2024-09-16T21:27:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1761957878",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1761957878"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 213,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1761978429",
      "pull_request_review_id": 2307779875,
      "id": 1761978429,
      "node_id": "PRRC_kwDOABII585pBag9",
      "diff_hunk": "@@ -444,4 +444,58 @@ void TxDownloadManagerImpl::MempoolRejectedPackage(const Package& package)\n {\n     RecentRejectsReconsiderableFilter().insert(GetPackageHash(package));\n }\n+\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManagerImpl::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    const uint256& txid = ptx->GetHash();\n+    const uint256& wtxid = ptx->GetWitnessHash();\n+\n+    // Mark that we have received a response\n+    m_txrequest.ReceivedResponse(nodeid, ptx->GetHash());\n+    if (ptx->HasWitness()) m_txrequest.ReceivedResponse(nodeid, ptx->GetWitnessHash());",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 34,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "f3cc6322798ca61a31f90b2ad7a0c32471db0410",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In f3cc6322798ca61a31f90b2ad7a0c32471db0410 \"[refactor] move new tx logic to txdownload\"\r\n\r\nnit:\r\n\r\n```suggestion\r\n    m_txrequest.ReceivedResponse(nodeid, txid);\r\n    if (ptx->HasWitness()) m_txrequest.ReceivedResponse(nodeid, wtxid);\r\n```",
      "created_at": "2024-09-16T21:19:35Z",
      "updated_at": "2024-09-16T21:27:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1761978429",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1761978429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 454,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 455,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1762117682",
      "pull_request_review_id": 2308033371,
      "id": 1762117682,
      "node_id": "PRRC_kwDOABII585pB8gy",
      "diff_hunk": "@@ -0,0 +1,127 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_IMPL_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_IMPL_H\n+\n+#include <node/txdownloadman.h>\n+\n+#include <common/bloom.h>\n+#include <net.h>\n+#include <txorphanage.h>\n+#include <txrequest.h>\n+\n+namespace node {\n+class TxDownloadManagerImpl {\n+public:\n+    /** Manages unvalidated tx data (orphan transactions for which we are downloading ancestors). */\n+    TxOrphanage m_orphanage;\n+    /** Tracks candidates for requesting and downloading transaction data. */\n+    TxRequestTracker m_txrequest;\n+\n+    /**\n+     * Filter for transactions that were recently rejected by the mempool.\n+     * These are not rerequested until the chain tip changes, at which point\n+     * the entire filter is reset.\n+     *\n+     * Without this filter we'd be re-requesting txs from each of our peers,\n+     * increasing bandwidth consumption considerably. For instance, with 100\n+     * peers, half of which relay a tx we don't accept, that might be a 50x\n+     * bandwidth increase. A flooding attacker attempting to roll-over the\n+     * filter using minimum-sized, 60byte, transactions might manage to send\n+     * 1000/sec if we have fast peers, so we pick 120,000 to give our peers a\n+     * two minute window to send invs to us.\n+     *\n+     * Decreasing the false positive rate is fairly cheap, so we pick one in a\n+     * million to make it highly unlikely for users to have issues with this\n+     * filter.\n+     *\n+     * We typically only add wtxids to this filter. For non-segwit\n+     * transactions, the txid == wtxid, so this only prevents us from\n+     * re-downloading non-segwit transactions when communicating with\n+     * non-wtxidrelay peers -- which is important for avoiding malleation\n+     * attacks that could otherwise interfere with transaction relay from\n+     * non-wtxidrelay peers. For communicating with wtxidrelay peers, having\n+     * the reject filter store wtxids is exactly what we want to avoid\n+     * redownload of a rejected transaction.\n+     *\n+     * In cases where we can tell that a segwit transaction will fail\n+     * validation no matter the witness, we may add the txid of such\n+     * transaction to the filter as well. This can be helpful when\n+     * communicating with txid-relay peers or if we were to otherwise fetch a\n+     * transaction via txid (eg in our orphan handling).\n+     *\n+     * Memory used: 1.3 MB\n+     */\n+    std::unique_ptr<CRollingBloomFilter> m_lazy_recent_rejects{nullptr};\n+\n+    CRollingBloomFilter& RecentRejectsFilter()\n+    {\n+        if (!m_lazy_recent_rejects) {\n+            m_lazy_recent_rejects = std::make_unique<CRollingBloomFilter>(120'000, 0.000'001);\n+        }\n+\n+        return *m_lazy_recent_rejects;\n+    }\n+\n+    /**\n+     * Filter for:\n+     * (1) wtxids of transactions that were recently rejected by the mempool but are\n+     * eligible for reconsideration if submitted with other transactions.\n+     * (2) packages (see GetPackageHash) we have already rejected before and should not retry.\n+     *\n+     * Similar to m_lazy_recent_rejects, this filter is used to save bandwidth when e.g. all of our peers\n+     * have larger mempools and thus lower minimum feerates than us.\n+     *\n+     * When a transaction's error is TxValidationResult::TX_RECONSIDERABLE (in a package or by\n+     * itself), add its wtxid to this filter. When a package fails for any reason, add the combined\n+     * hash to this filter.\n+     *\n+     * Upon receiving an announcement for a transaction, if it exists in this filter, do not\n+     * download the txdata. When considering packages, if it exists in this filter, drop it.\n+     *\n+     * Reset this filter when the chain tip changes.\n+     *\n+     * Parameters are picked to be the same as m_lazy_recent_rejects, with the same rationale.\n+     */\n+    std::unique_ptr<CRollingBloomFilter> m_lazy_recent_rejects_reconsiderable{nullptr};\n+\n+    CRollingBloomFilter& RecentRejectsReconsiderableFilter()\n+    {\n+        if (!m_lazy_recent_rejects_reconsiderable) {\n+            m_lazy_recent_rejects_reconsiderable = std::make_unique<CRollingBloomFilter>(120'000, 0.000'001);\n+        }\n+\n+        return *m_lazy_recent_rejects_reconsiderable;\n+    }\n+\n+    /*\n+     * Filter for transactions that have been recently confirmed.\n+     * We use this to avoid requesting transactions that have already been\n+     * confirnmed.\n+     *\n+     * Blocks don't typically have more than 4000 transactions, so this should\n+     * be at least six blocks (~1 hr) worth of transactions that we can store,\n+     * inserting both a txid and wtxid for every observed transaction.\n+     * If the number of transactions appearing in a block goes up, or if we are\n+     * seeing getdata requests more than an hour after initial announcement, we\n+     * can increase this number.\n+     * The false positive rate of 1/1M should come out to less than 1\n+     * transaction per day that would be inadvertently ignored (which is the\n+     * same probability that we have in the reject filter).\n+     */\n+    std::unique_ptr<CRollingBloomFilter> m_lazy_recent_confirmed_transactions{nullptr};\n+\n+    CRollingBloomFilter& RecentConfirmedTransactionsFilter()\n+    {\n+        if (!m_lazy_recent_confirmed_transactions) {\n+            m_lazy_recent_confirmed_transactions = std::make_unique<CRollingBloomFilter>(120'000, 0.000'001);",
      "path": "src/node/txdownloadman_impl.h",
      "position": null,
      "original_position": 118,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "ecbbadf0f79bb32730d9e1400d84b84893e35e56",
      "in_reply_to_id": 1761911213,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "good catch!! that was unintentional, reverted now",
      "created_at": "2024-09-17T00:32:31Z",
      "updated_at": "2024-09-17T00:32:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1762117682",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1762117682"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1762117778",
      "pull_request_review_id": 2308033445,
      "id": 1762117778,
      "node_id": "PRRC_kwDOABII585pB8iS",
      "diff_hunk": "@@ -203,4 +207,13 @@ std::vector<GenTxid> TxDownloadManagerImpl::GetRequestsToSend(NodeId nodeid, std\n     }\n     return requests;\n }\n+\n+void TxDownloadManagerImpl::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    for (const auto& txhash: txhashes) {",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 18,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "c40cb8565952f62732fa64875c99ef9082b9a6f4",
      "in_reply_to_id": 1761957878,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-09-17T00:32:38Z",
      "updated_at": "2024-09-17T00:32:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1762117778",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1762117778"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 213,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1762118393",
      "pull_request_review_id": 2308034101,
      "id": 1762118393,
      "node_id": "PRRC_kwDOABII585pB8r5",
      "diff_hunk": "@@ -444,4 +444,58 @@ void TxDownloadManagerImpl::MempoolRejectedPackage(const Package& package)\n {\n     RecentRejectsReconsiderableFilter().insert(GetPackageHash(package));\n }\n+\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManagerImpl::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    const uint256& txid = ptx->GetHash();\n+    const uint256& wtxid = ptx->GetWitnessHash();\n+\n+    // Mark that we have received a response\n+    m_txrequest.ReceivedResponse(nodeid, ptx->GetHash());\n+    if (ptx->HasWitness()) m_txrequest.ReceivedResponse(nodeid, ptx->GetWitnessHash());",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 34,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "f3cc6322798ca61a31f90b2ad7a0c32471db0410",
      "in_reply_to_id": 1761978429,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-09-17T00:33:40Z",
      "updated_at": "2024-09-17T00:33:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1762118393",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1762118393"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 454,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 455,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1763652769",
      "pull_request_review_id": 2310444165,
      "id": 1763652769,
      "node_id": "PRRC_kwDOABII585pHzSh",
      "diff_hunk": "@@ -0,0 +1,523 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }\n+}\n+\n+bool TxDownloadManagerImpl::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    // If this is an inv received from a peer and we already have it, we can drop it.\n+    // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\n+    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\n+    if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\n+\n+    if (m_peer_info.count(peer) == 0) return false;\n+    const auto& info = m_peer_info.at(peer).m_connection_info;\n+    if (!info.m_relay_permissions && m_txrequest.Count(peer) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements for this peer\n+        return false;\n+    }\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or NetPermissionFlags::NoBan permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for txid announcements while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from peers which have at least\n+    //     MAX_PEER_TX_REQUEST_IN_FLIGHT requests in flight (and don't have NetPermissionFlags::Relay).\n+    auto delay{0us};\n+    if (!info.m_preferred) delay += NONPREF_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && m_num_wtxid_peers > 0) delay += TXID_RELAY_DELAY;\n+    const bool overloaded = !info.m_relay_permissions && m_txrequest.CountInFlight(peer) >= MAX_PEER_TX_REQUEST_IN_FLIGHT;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+\n+    m_txrequest.ReceivedInv(peer, gtxid, info.m_preferred, now + delay);\n+\n+    return false;\n+}\n+\n+std::vector<GenTxid> TxDownloadManagerImpl::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    std::vector<GenTxid> requests;\n+    std::vector<std::pair<NodeId, GenTxid>> expired;\n+    auto requestable = m_txrequest.GetRequestable(nodeid, current_time, &expired);\n+    for (const auto& entry : expired) {\n+        LogDebug(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n+            entry.second.GetHash().ToString(), entry.first);\n+    }\n+    for (const GenTxid& gtxid : requestable) {\n+        if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+            LogDebug(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n+                gtxid.GetHash().ToString(), nodeid);\n+            requests.emplace_back(gtxid);\n+            m_txrequest.RequestedTx(nodeid, gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n+        } else {\n+            // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n+            // this should already be called whenever a transaction becomes AlreadyHaveTx().\n+            m_txrequest.ForgetTxHash(gtxid.GetHash());\n+        }\n+    }\n+    return requests;\n+}\n+\n+void TxDownloadManagerImpl::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    for (const auto& txhash : txhashes) {\n+        // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\n+        // completed in TxRequestTracker.\n+        m_txrequest.ReceivedResponse(nodeid, txhash);\n+    }\n+}\n+\n+std::optional<PackageToValidate> TxDownloadManagerImpl::Find1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    Assume(RecentRejectsReconsiderableFilter().contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child, nodeid, nodeid};\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+    // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+    // create a bias that attackers can use to delay package acceptance.\n+    //\n+    // Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    std::shuffle(tx_indices.begin(), tx_indices.end(), m_opts.m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_lazy_recent_rejects_reconsiderable.\n+        const auto [child_tx, child_sender] = cpfp_candidates_different_peer.at(index);\n+        Package maybe_cpfp_package{ptx, child_tx};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child_tx, nodeid, child_sender};\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+void TxDownloadManagerImpl::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    // As this version of the transaction was acceptable, we can forget about any requests for it.\n+    // No-op if the tx is not in txrequest.\n+    m_txrequest.ForgetTxHash(tx->GetHash());\n+    m_txrequest.ForgetTxHash(tx->GetWitnessHash());\n+\n+    m_orphanage.AddChildrenToWorkSet(*tx);\n+    // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n+    m_orphanage.EraseTx(tx->GetWitnessHash());\n+}\n+\n+node::RejectedTxTodo TxDownloadManagerImpl::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    const CTransaction& tx{*ptx};\n+    // Results returned to caller\n+    // Whether we should call AddToCompactExtraTransactions at the end\n+    bool add_extra_compact_tx{first_time_failure};\n+    // Hashes to pass to AddKnownTx later\n+    std::vector<uint256> unique_parents;\n+    // Populated if failure is reconsiderable and eligible package is found.\n+    std::optional<node::PackageToValidate> package_to_validate;\n+\n+    // Only process a new orphan if this is a first time failure, as otherwise it must be either\n+    // already in orphanage or from 1p1c processing.\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS && first_time_failure &&\n+            !RecentRejectsFilter().contains(ptx->GetWitnessHash().ToUint256())) {\n+        bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+        // Deduplicate parent txids, so that we don't have to loop over\n+        // the same parent txid more than once down below.\n+        unique_parents.reserve(tx.vin.size());\n+        for (const CTxIn& txin : tx.vin) {\n+            // We start with all parents, and then remove duplicates below.\n+            unique_parents.push_back(txin.prevout.hash);\n+        }\n+        std::sort(unique_parents.begin(), unique_parents.end());\n+        unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+        // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.\n+        // We can tolerate having up to 1 parent in m_lazy_recent_rejects_reconsiderable since we\n+        // submit 1p1c packages. However, fail immediately if any are in m_lazy_recent_rejects.\n+        std::optional<uint256> rejected_parent_reconsiderable;\n+        for (const uint256& parent_txid : unique_parents) {\n+            if (RecentRejectsFilter().contains(parent_txid)) {\n+                fRejectedParents = true;\n+                break;\n+            } else if (RecentRejectsReconsiderableFilter().contains(parent_txid) && !m_opts.m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                // More than 1 parent in m_lazy_recent_rejects_reconsiderable: 1p1c will not be\n+                // sufficient to accept this package, so just give up here.\n+                if (rejected_parent_reconsiderable.has_value()) {\n+                    fRejectedParents = true;\n+                    break;\n+                }\n+                rejected_parent_reconsiderable = parent_txid;\n+            }\n+        }\n+        if (!fRejectedParents) {\n+            const auto current_time{GetTime<std::chrono::microseconds>()};\n+\n+            for (const uint256& parent_txid : unique_parents) {\n+                // Here, we only have the txid (and not wtxid) of the\n+                // inputs, so we only request in txid mode, even for\n+                // wtxidrelay peers.\n+                // Eventually we should replace this with an improved\n+                // protocol for getting all unconfirmed parents.\n+                const auto gtxid{GenTxid::Txid(parent_txid)};\n+                // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n+                // previously rejected for being too low feerate. This orphan might CPFP it.\n+                if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+                    AddTxAnnouncement(nodeid, gtxid, current_time, /*p2p_inv=*/false);\n+                }\n+            }\n+\n+            // Potentially flip add_extra_compact_tx to false if AddTx returns false because the tx was already there\n+            add_extra_compact_tx &= m_orphanage.AddTx(ptx, nodeid);\n+\n+            // Once added to the orphan pool, a tx is considered AlreadyHave, and we shouldn't request it anymore.\n+            m_txrequest.ForgetTxHash(tx.GetHash());\n+            m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+\n+            // DoS prevention: do not allow m_orphanage to grow unbounded (see CVE-2012-3789)\n+            m_orphanage.LimitOrphans(m_opts.m_max_orphan_txs, m_opts.m_rng);\n+        } else {\n+            LogDebug(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s (wtxid=%s)\\n\",\n+                     tx.GetHash().ToString(),\n+                     tx.GetWitnessHash().ToString());\n+            // We will continue to reject this tx since it has rejected\n+            // parents so avoid re-requesting it from other peers.\n+            // Here we add both the txid and the wtxid, as we know that\n+            // regardless of what witness is provided, we will not accept\n+            // this, so we don't need to allow for redownload of this txid\n+            // from any of our non-wtxidrelay peers.\n+            RecentRejectsFilter().insert(tx.GetHash().ToUint256());\n+            RecentRejectsFilter().insert(tx.GetWitnessHash().ToUint256());\n+            m_txrequest.ForgetTxHash(tx.GetHash());\n+            m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+        }\n+    } else if (state.GetResult() == TxValidationResult::TX_WITNESS_STRIPPED) {\n+        add_extra_compact_tx = false;\n+    } else {\n+        // We can add the wtxid of this transaction to our reject filter.\n+        // Do not add txids of witness transactions or witness-stripped\n+        // transactions to the filter, as they can have been malleated;\n+        // adding such txids to the reject filter would potentially\n+        // interfere with relay of valid transactions from peers that\n+        // do not support wtxid-based relay. See\n+        // https://github.com/bitcoin/bitcoin/issues/8279 for details.\n+        // We can remove this restriction (and always add wtxids to\n+        // the filter even for witness stripped transactions) once\n+        // wtxid-based relay is broadly deployed.\n+        // See also comments in https://github.com/bitcoin/bitcoin/pull/18044#discussion_r443419034\n+        // for concerns around weakening security of unupgraded nodes\n+        // if we start doing this too early.\n+        if (state.GetResult() == TxValidationResult::TX_RECONSIDERABLE) {\n+            // If the result is TX_RECONSIDERABLE, add it to m_lazy_recent_rejects_reconsiderable\n+            // because we should not download or submit this transaction by itself again, but may\n+            // submit it as part of a package later.\n+            RecentRejectsReconsiderableFilter().insert(ptx->GetWitnessHash().ToUint256());\n+\n+            if (first_time_failure) {\n+                // When a transaction fails for TX_RECONSIDERABLE, look for a matching child in the\n+                // orphanage, as it is possible that they succeed as a package.\n+                LogDebug(BCLog::TXPACKAGES, \"tx %s (wtxid=%s) failed but reconsiderable, looking for child in orphanage\\n\",\n+                         ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString());\n+                package_to_validate = Find1P1CPackage(ptx, nodeid);\n+            }\n+        } else {\n+            RecentRejectsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+        // If the transaction failed for TX_INPUTS_NOT_STANDARD,\n+        // then we know that the witness was irrelevant to the policy\n+        // failure, since this check depends only on the txid\n+        // (the scriptPubKey being spent is covered by the txid).\n+        // Add the txid to the reject filter to prevent repeated\n+        // processing of this transaction in the event that child\n+        // transactions are later received (resulting in\n+        // parent-fetching by txid via the orphan-handling logic).\n+        // We only add the txid if it differs from the wtxid, to avoid wasting entries in the\n+        // rolling bloom filter.\n+        if (state.GetResult() == TxValidationResult::TX_INPUTS_NOT_STANDARD && ptx->HasWitness()) {\n+            RecentRejectsFilter().insert(ptx->GetHash().ToUint256());\n+            m_txrequest.ForgetTxHash(ptx->GetHash());\n+        }\n+    }\n+\n+    // If the tx failed in ProcessOrphanTx, it should be removed from the orphanage unless the\n+    // tx was still missing inputs. If the tx was not in the orphanage, EraseTx does nothing and returns 0.\n+    if (state.GetResult() != TxValidationResult::TX_MISSING_INPUTS && m_orphanage.EraseTx(ptx->GetWitnessHash()) > 0) {\n+        LogDebug(BCLog::TXPACKAGES, \"   removed orphan tx %s (wtxid=%s)\\n\", ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString());\n+    }\n+\n+    return RejectedTxTodo{\n+        .m_should_add_extra_compact_tx = add_extra_compact_tx,\n+        .m_unique_parents = std::move(unique_parents),\n+        .m_package_to_validate = std::move(package_to_validate)\n+    };\n+}\n+\n+void TxDownloadManagerImpl::MempoolRejectedPackage(const Package& package)\n+{\n+    RecentRejectsReconsiderableFilter().insert(GetPackageHash(package));\n+}\n+\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManagerImpl::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    const uint256& txid = ptx->GetHash();\n+    const uint256& wtxid = ptx->GetWitnessHash();",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 467,
      "original_position": 452,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "5724926a9b2c7b7d35fc5176caf3710d8aa2f098",
      "in_reply_to_id": null,
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why is it that we don't initialize these with the`Txid` and `Wtxid` types? Have been thinking about making `RelayTransaction` type safe, so just wondering.",
      "created_at": "2024-09-17T17:52:28Z",
      "updated_at": "2024-09-17T17:52:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1763652769",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1763652769"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 467,
      "original_line": 467,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1764183486",
      "pull_request_review_id": 2311312557,
      "id": 1764183486,
      "node_id": "PRRC_kwDOABII585pJ02-",
      "diff_hunk": "@@ -0,0 +1,523 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }\n+}\n+\n+bool TxDownloadManagerImpl::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    // If this is an inv received from a peer and we already have it, we can drop it.\n+    // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\n+    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\n+    if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\n+\n+    if (m_peer_info.count(peer) == 0) return false;\n+    const auto& info = m_peer_info.at(peer).m_connection_info;\n+    if (!info.m_relay_permissions && m_txrequest.Count(peer) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements for this peer\n+        return false;\n+    }\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or NetPermissionFlags::NoBan permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for txid announcements while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from peers which have at least\n+    //     MAX_PEER_TX_REQUEST_IN_FLIGHT requests in flight (and don't have NetPermissionFlags::Relay).\n+    auto delay{0us};\n+    if (!info.m_preferred) delay += NONPREF_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && m_num_wtxid_peers > 0) delay += TXID_RELAY_DELAY;\n+    const bool overloaded = !info.m_relay_permissions && m_txrequest.CountInFlight(peer) >= MAX_PEER_TX_REQUEST_IN_FLIGHT;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+\n+    m_txrequest.ReceivedInv(peer, gtxid, info.m_preferred, now + delay);\n+\n+    return false;\n+}\n+\n+std::vector<GenTxid> TxDownloadManagerImpl::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    std::vector<GenTxid> requests;\n+    std::vector<std::pair<NodeId, GenTxid>> expired;\n+    auto requestable = m_txrequest.GetRequestable(nodeid, current_time, &expired);\n+    for (const auto& entry : expired) {\n+        LogDebug(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n+            entry.second.GetHash().ToString(), entry.first);\n+    }\n+    for (const GenTxid& gtxid : requestable) {\n+        if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+            LogDebug(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n+                gtxid.GetHash().ToString(), nodeid);\n+            requests.emplace_back(gtxid);\n+            m_txrequest.RequestedTx(nodeid, gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n+        } else {\n+            // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n+            // this should already be called whenever a transaction becomes AlreadyHaveTx().\n+            m_txrequest.ForgetTxHash(gtxid.GetHash());\n+        }\n+    }\n+    return requests;\n+}\n+\n+void TxDownloadManagerImpl::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    for (const auto& txhash : txhashes) {\n+        // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\n+        // completed in TxRequestTracker.\n+        m_txrequest.ReceivedResponse(nodeid, txhash);\n+    }\n+}\n+\n+std::optional<PackageToValidate> TxDownloadManagerImpl::Find1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    Assume(RecentRejectsReconsiderableFilter().contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child, nodeid, nodeid};\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+    // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+    // create a bias that attackers can use to delay package acceptance.\n+    //\n+    // Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    std::shuffle(tx_indices.begin(), tx_indices.end(), m_opts.m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_lazy_recent_rejects_reconsiderable.\n+        const auto [child_tx, child_sender] = cpfp_candidates_different_peer.at(index);\n+        Package maybe_cpfp_package{ptx, child_tx};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child_tx, nodeid, child_sender};\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+void TxDownloadManagerImpl::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    // As this version of the transaction was acceptable, we can forget about any requests for it.\n+    // No-op if the tx is not in txrequest.\n+    m_txrequest.ForgetTxHash(tx->GetHash());\n+    m_txrequest.ForgetTxHash(tx->GetWitnessHash());\n+\n+    m_orphanage.AddChildrenToWorkSet(*tx);\n+    // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n+    m_orphanage.EraseTx(tx->GetWitnessHash());\n+}\n+\n+node::RejectedTxTodo TxDownloadManagerImpl::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    const CTransaction& tx{*ptx};\n+    // Results returned to caller\n+    // Whether we should call AddToCompactExtraTransactions at the end\n+    bool add_extra_compact_tx{first_time_failure};\n+    // Hashes to pass to AddKnownTx later\n+    std::vector<uint256> unique_parents;\n+    // Populated if failure is reconsiderable and eligible package is found.\n+    std::optional<node::PackageToValidate> package_to_validate;\n+\n+    // Only process a new orphan if this is a first time failure, as otherwise it must be either\n+    // already in orphanage or from 1p1c processing.\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS && first_time_failure &&\n+            !RecentRejectsFilter().contains(ptx->GetWitnessHash().ToUint256())) {\n+        bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+        // Deduplicate parent txids, so that we don't have to loop over\n+        // the same parent txid more than once down below.\n+        unique_parents.reserve(tx.vin.size());\n+        for (const CTxIn& txin : tx.vin) {\n+            // We start with all parents, and then remove duplicates below.\n+            unique_parents.push_back(txin.prevout.hash);\n+        }\n+        std::sort(unique_parents.begin(), unique_parents.end());\n+        unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+        // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.\n+        // We can tolerate having up to 1 parent in m_lazy_recent_rejects_reconsiderable since we\n+        // submit 1p1c packages. However, fail immediately if any are in m_lazy_recent_rejects.\n+        std::optional<uint256> rejected_parent_reconsiderable;\n+        for (const uint256& parent_txid : unique_parents) {\n+            if (RecentRejectsFilter().contains(parent_txid)) {\n+                fRejectedParents = true;\n+                break;\n+            } else if (RecentRejectsReconsiderableFilter().contains(parent_txid) && !m_opts.m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                // More than 1 parent in m_lazy_recent_rejects_reconsiderable: 1p1c will not be\n+                // sufficient to accept this package, so just give up here.\n+                if (rejected_parent_reconsiderable.has_value()) {\n+                    fRejectedParents = true;\n+                    break;\n+                }\n+                rejected_parent_reconsiderable = parent_txid;\n+            }\n+        }\n+        if (!fRejectedParents) {\n+            const auto current_time{GetTime<std::chrono::microseconds>()};\n+\n+            for (const uint256& parent_txid : unique_parents) {\n+                // Here, we only have the txid (and not wtxid) of the\n+                // inputs, so we only request in txid mode, even for\n+                // wtxidrelay peers.\n+                // Eventually we should replace this with an improved\n+                // protocol for getting all unconfirmed parents.\n+                const auto gtxid{GenTxid::Txid(parent_txid)};\n+                // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n+                // previously rejected for being too low feerate. This orphan might CPFP it.\n+                if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+                    AddTxAnnouncement(nodeid, gtxid, current_time, /*p2p_inv=*/false);\n+                }\n+            }\n+\n+            // Potentially flip add_extra_compact_tx to false if AddTx returns false because the tx was already there\n+            add_extra_compact_tx &= m_orphanage.AddTx(ptx, nodeid);\n+\n+            // Once added to the orphan pool, a tx is considered AlreadyHave, and we shouldn't request it anymore.\n+            m_txrequest.ForgetTxHash(tx.GetHash());\n+            m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+\n+            // DoS prevention: do not allow m_orphanage to grow unbounded (see CVE-2012-3789)\n+            m_orphanage.LimitOrphans(m_opts.m_max_orphan_txs, m_opts.m_rng);\n+        } else {\n+            LogDebug(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s (wtxid=%s)\\n\",\n+                     tx.GetHash().ToString(),\n+                     tx.GetWitnessHash().ToString());\n+            // We will continue to reject this tx since it has rejected\n+            // parents so avoid re-requesting it from other peers.\n+            // Here we add both the txid and the wtxid, as we know that\n+            // regardless of what witness is provided, we will not accept\n+            // this, so we don't need to allow for redownload of this txid\n+            // from any of our non-wtxidrelay peers.\n+            RecentRejectsFilter().insert(tx.GetHash().ToUint256());\n+            RecentRejectsFilter().insert(tx.GetWitnessHash().ToUint256());\n+            m_txrequest.ForgetTxHash(tx.GetHash());\n+            m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+        }\n+    } else if (state.GetResult() == TxValidationResult::TX_WITNESS_STRIPPED) {\n+        add_extra_compact_tx = false;\n+    } else {\n+        // We can add the wtxid of this transaction to our reject filter.\n+        // Do not add txids of witness transactions or witness-stripped\n+        // transactions to the filter, as they can have been malleated;\n+        // adding such txids to the reject filter would potentially\n+        // interfere with relay of valid transactions from peers that\n+        // do not support wtxid-based relay. See\n+        // https://github.com/bitcoin/bitcoin/issues/8279 for details.\n+        // We can remove this restriction (and always add wtxids to\n+        // the filter even for witness stripped transactions) once\n+        // wtxid-based relay is broadly deployed.\n+        // See also comments in https://github.com/bitcoin/bitcoin/pull/18044#discussion_r443419034\n+        // for concerns around weakening security of unupgraded nodes\n+        // if we start doing this too early.\n+        if (state.GetResult() == TxValidationResult::TX_RECONSIDERABLE) {\n+            // If the result is TX_RECONSIDERABLE, add it to m_lazy_recent_rejects_reconsiderable\n+            // because we should not download or submit this transaction by itself again, but may\n+            // submit it as part of a package later.\n+            RecentRejectsReconsiderableFilter().insert(ptx->GetWitnessHash().ToUint256());\n+\n+            if (first_time_failure) {\n+                // When a transaction fails for TX_RECONSIDERABLE, look for a matching child in the\n+                // orphanage, as it is possible that they succeed as a package.\n+                LogDebug(BCLog::TXPACKAGES, \"tx %s (wtxid=%s) failed but reconsiderable, looking for child in orphanage\\n\",\n+                         ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString());\n+                package_to_validate = Find1P1CPackage(ptx, nodeid);\n+            }\n+        } else {\n+            RecentRejectsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+        // If the transaction failed for TX_INPUTS_NOT_STANDARD,\n+        // then we know that the witness was irrelevant to the policy\n+        // failure, since this check depends only on the txid\n+        // (the scriptPubKey being spent is covered by the txid).\n+        // Add the txid to the reject filter to prevent repeated\n+        // processing of this transaction in the event that child\n+        // transactions are later received (resulting in\n+        // parent-fetching by txid via the orphan-handling logic).\n+        // We only add the txid if it differs from the wtxid, to avoid wasting entries in the\n+        // rolling bloom filter.\n+        if (state.GetResult() == TxValidationResult::TX_INPUTS_NOT_STANDARD && ptx->HasWitness()) {\n+            RecentRejectsFilter().insert(ptx->GetHash().ToUint256());\n+            m_txrequest.ForgetTxHash(ptx->GetHash());\n+        }\n+    }\n+\n+    // If the tx failed in ProcessOrphanTx, it should be removed from the orphanage unless the\n+    // tx was still missing inputs. If the tx was not in the orphanage, EraseTx does nothing and returns 0.\n+    if (state.GetResult() != TxValidationResult::TX_MISSING_INPUTS && m_orphanage.EraseTx(ptx->GetWitnessHash()) > 0) {\n+        LogDebug(BCLog::TXPACKAGES, \"   removed orphan tx %s (wtxid=%s)\\n\", ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString());\n+    }\n+\n+    return RejectedTxTodo{\n+        .m_should_add_extra_compact_tx = add_extra_compact_tx,\n+        .m_unique_parents = std::move(unique_parents),\n+        .m_package_to_validate = std::move(package_to_validate)\n+    };\n+}\n+\n+void TxDownloadManagerImpl::MempoolRejectedPackage(const Package& package)\n+{\n+    RecentRejectsReconsiderableFilter().insert(GetPackageHash(package));\n+}\n+\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManagerImpl::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    const uint256& txid = ptx->GetHash();\n+    const uint256& wtxid = ptx->GetWitnessHash();",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 467,
      "original_position": 452,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "5724926a9b2c7b7d35fc5176caf3710d8aa2f098",
      "in_reply_to_id": 1763652769,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "txrequest and the bloom filters take uint256s, so this seemed easiest. I don't feel strongly. `RelayTransaction` isn't called here...?",
      "created_at": "2024-09-17T23:18:44Z",
      "updated_at": "2024-09-17T23:18:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1764183486",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1764183486"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 467,
      "original_line": 467,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1764693774",
      "pull_request_review_id": 2312103594,
      "id": 1764693774,
      "node_id": "PRRC_kwDOABII585pLxcO",
      "diff_hunk": "@@ -0,0 +1,523 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }\n+}\n+\n+bool TxDownloadManagerImpl::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    // If this is an inv received from a peer and we already have it, we can drop it.\n+    // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\n+    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\n+    if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\n+\n+    if (m_peer_info.count(peer) == 0) return false;\n+    const auto& info = m_peer_info.at(peer).m_connection_info;\n+    if (!info.m_relay_permissions && m_txrequest.Count(peer) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements for this peer\n+        return false;\n+    }\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or NetPermissionFlags::NoBan permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for txid announcements while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from peers which have at least\n+    //     MAX_PEER_TX_REQUEST_IN_FLIGHT requests in flight (and don't have NetPermissionFlags::Relay).\n+    auto delay{0us};\n+    if (!info.m_preferred) delay += NONPREF_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && m_num_wtxid_peers > 0) delay += TXID_RELAY_DELAY;\n+    const bool overloaded = !info.m_relay_permissions && m_txrequest.CountInFlight(peer) >= MAX_PEER_TX_REQUEST_IN_FLIGHT;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+\n+    m_txrequest.ReceivedInv(peer, gtxid, info.m_preferred, now + delay);\n+\n+    return false;\n+}\n+\n+std::vector<GenTxid> TxDownloadManagerImpl::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    std::vector<GenTxid> requests;\n+    std::vector<std::pair<NodeId, GenTxid>> expired;\n+    auto requestable = m_txrequest.GetRequestable(nodeid, current_time, &expired);\n+    for (const auto& entry : expired) {\n+        LogDebug(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n+            entry.second.GetHash().ToString(), entry.first);\n+    }\n+    for (const GenTxid& gtxid : requestable) {\n+        if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+            LogDebug(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n+                gtxid.GetHash().ToString(), nodeid);\n+            requests.emplace_back(gtxid);\n+            m_txrequest.RequestedTx(nodeid, gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n+        } else {\n+            // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n+            // this should already be called whenever a transaction becomes AlreadyHaveTx().\n+            m_txrequest.ForgetTxHash(gtxid.GetHash());\n+        }\n+    }\n+    return requests;\n+}\n+\n+void TxDownloadManagerImpl::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    for (const auto& txhash : txhashes) {\n+        // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\n+        // completed in TxRequestTracker.\n+        m_txrequest.ReceivedResponse(nodeid, txhash);\n+    }\n+}\n+\n+std::optional<PackageToValidate> TxDownloadManagerImpl::Find1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    Assume(RecentRejectsReconsiderableFilter().contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child, nodeid, nodeid};\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+    // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+    // create a bias that attackers can use to delay package acceptance.\n+    //\n+    // Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    std::shuffle(tx_indices.begin(), tx_indices.end(), m_opts.m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_lazy_recent_rejects_reconsiderable.\n+        const auto [child_tx, child_sender] = cpfp_candidates_different_peer.at(index);\n+        Package maybe_cpfp_package{ptx, child_tx};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child_tx, nodeid, child_sender};\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+void TxDownloadManagerImpl::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    // As this version of the transaction was acceptable, we can forget about any requests for it.\n+    // No-op if the tx is not in txrequest.\n+    m_txrequest.ForgetTxHash(tx->GetHash());\n+    m_txrequest.ForgetTxHash(tx->GetWitnessHash());\n+\n+    m_orphanage.AddChildrenToWorkSet(*tx);\n+    // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n+    m_orphanage.EraseTx(tx->GetWitnessHash());\n+}\n+\n+node::RejectedTxTodo TxDownloadManagerImpl::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    const CTransaction& tx{*ptx};\n+    // Results returned to caller\n+    // Whether we should call AddToCompactExtraTransactions at the end\n+    bool add_extra_compact_tx{first_time_failure};\n+    // Hashes to pass to AddKnownTx later\n+    std::vector<uint256> unique_parents;\n+    // Populated if failure is reconsiderable and eligible package is found.\n+    std::optional<node::PackageToValidate> package_to_validate;\n+\n+    // Only process a new orphan if this is a first time failure, as otherwise it must be either\n+    // already in orphanage or from 1p1c processing.\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS && first_time_failure &&\n+            !RecentRejectsFilter().contains(ptx->GetWitnessHash().ToUint256())) {\n+        bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+        // Deduplicate parent txids, so that we don't have to loop over\n+        // the same parent txid more than once down below.\n+        unique_parents.reserve(tx.vin.size());\n+        for (const CTxIn& txin : tx.vin) {\n+            // We start with all parents, and then remove duplicates below.\n+            unique_parents.push_back(txin.prevout.hash);\n+        }\n+        std::sort(unique_parents.begin(), unique_parents.end());\n+        unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+        // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.\n+        // We can tolerate having up to 1 parent in m_lazy_recent_rejects_reconsiderable since we\n+        // submit 1p1c packages. However, fail immediately if any are in m_lazy_recent_rejects.\n+        std::optional<uint256> rejected_parent_reconsiderable;\n+        for (const uint256& parent_txid : unique_parents) {\n+            if (RecentRejectsFilter().contains(parent_txid)) {\n+                fRejectedParents = true;\n+                break;\n+            } else if (RecentRejectsReconsiderableFilter().contains(parent_txid) && !m_opts.m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                // More than 1 parent in m_lazy_recent_rejects_reconsiderable: 1p1c will not be\n+                // sufficient to accept this package, so just give up here.\n+                if (rejected_parent_reconsiderable.has_value()) {\n+                    fRejectedParents = true;\n+                    break;\n+                }\n+                rejected_parent_reconsiderable = parent_txid;\n+            }\n+        }\n+        if (!fRejectedParents) {\n+            const auto current_time{GetTime<std::chrono::microseconds>()};\n+\n+            for (const uint256& parent_txid : unique_parents) {\n+                // Here, we only have the txid (and not wtxid) of the\n+                // inputs, so we only request in txid mode, even for\n+                // wtxidrelay peers.\n+                // Eventually we should replace this with an improved\n+                // protocol for getting all unconfirmed parents.\n+                const auto gtxid{GenTxid::Txid(parent_txid)};\n+                // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n+                // previously rejected for being too low feerate. This orphan might CPFP it.\n+                if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+                    AddTxAnnouncement(nodeid, gtxid, current_time, /*p2p_inv=*/false);\n+                }\n+            }\n+\n+            // Potentially flip add_extra_compact_tx to false if AddTx returns false because the tx was already there\n+            add_extra_compact_tx &= m_orphanage.AddTx(ptx, nodeid);\n+\n+            // Once added to the orphan pool, a tx is considered AlreadyHave, and we shouldn't request it anymore.\n+            m_txrequest.ForgetTxHash(tx.GetHash());\n+            m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+\n+            // DoS prevention: do not allow m_orphanage to grow unbounded (see CVE-2012-3789)\n+            m_orphanage.LimitOrphans(m_opts.m_max_orphan_txs, m_opts.m_rng);\n+        } else {\n+            LogDebug(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s (wtxid=%s)\\n\",\n+                     tx.GetHash().ToString(),\n+                     tx.GetWitnessHash().ToString());\n+            // We will continue to reject this tx since it has rejected\n+            // parents so avoid re-requesting it from other peers.\n+            // Here we add both the txid and the wtxid, as we know that\n+            // regardless of what witness is provided, we will not accept\n+            // this, so we don't need to allow for redownload of this txid\n+            // from any of our non-wtxidrelay peers.\n+            RecentRejectsFilter().insert(tx.GetHash().ToUint256());\n+            RecentRejectsFilter().insert(tx.GetWitnessHash().ToUint256());\n+            m_txrequest.ForgetTxHash(tx.GetHash());\n+            m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+        }\n+    } else if (state.GetResult() == TxValidationResult::TX_WITNESS_STRIPPED) {\n+        add_extra_compact_tx = false;\n+    } else {\n+        // We can add the wtxid of this transaction to our reject filter.\n+        // Do not add txids of witness transactions or witness-stripped\n+        // transactions to the filter, as they can have been malleated;\n+        // adding such txids to the reject filter would potentially\n+        // interfere with relay of valid transactions from peers that\n+        // do not support wtxid-based relay. See\n+        // https://github.com/bitcoin/bitcoin/issues/8279 for details.\n+        // We can remove this restriction (and always add wtxids to\n+        // the filter even for witness stripped transactions) once\n+        // wtxid-based relay is broadly deployed.\n+        // See also comments in https://github.com/bitcoin/bitcoin/pull/18044#discussion_r443419034\n+        // for concerns around weakening security of unupgraded nodes\n+        // if we start doing this too early.\n+        if (state.GetResult() == TxValidationResult::TX_RECONSIDERABLE) {\n+            // If the result is TX_RECONSIDERABLE, add it to m_lazy_recent_rejects_reconsiderable\n+            // because we should not download or submit this transaction by itself again, but may\n+            // submit it as part of a package later.\n+            RecentRejectsReconsiderableFilter().insert(ptx->GetWitnessHash().ToUint256());\n+\n+            if (first_time_failure) {\n+                // When a transaction fails for TX_RECONSIDERABLE, look for a matching child in the\n+                // orphanage, as it is possible that they succeed as a package.\n+                LogDebug(BCLog::TXPACKAGES, \"tx %s (wtxid=%s) failed but reconsiderable, looking for child in orphanage\\n\",\n+                         ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString());\n+                package_to_validate = Find1P1CPackage(ptx, nodeid);\n+            }\n+        } else {\n+            RecentRejectsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+        // If the transaction failed for TX_INPUTS_NOT_STANDARD,\n+        // then we know that the witness was irrelevant to the policy\n+        // failure, since this check depends only on the txid\n+        // (the scriptPubKey being spent is covered by the txid).\n+        // Add the txid to the reject filter to prevent repeated\n+        // processing of this transaction in the event that child\n+        // transactions are later received (resulting in\n+        // parent-fetching by txid via the orphan-handling logic).\n+        // We only add the txid if it differs from the wtxid, to avoid wasting entries in the\n+        // rolling bloom filter.\n+        if (state.GetResult() == TxValidationResult::TX_INPUTS_NOT_STANDARD && ptx->HasWitness()) {\n+            RecentRejectsFilter().insert(ptx->GetHash().ToUint256());\n+            m_txrequest.ForgetTxHash(ptx->GetHash());\n+        }\n+    }\n+\n+    // If the tx failed in ProcessOrphanTx, it should be removed from the orphanage unless the\n+    // tx was still missing inputs. If the tx was not in the orphanage, EraseTx does nothing and returns 0.\n+    if (state.GetResult() != TxValidationResult::TX_MISSING_INPUTS && m_orphanage.EraseTx(ptx->GetWitnessHash()) > 0) {\n+        LogDebug(BCLog::TXPACKAGES, \"   removed orphan tx %s (wtxid=%s)\\n\", ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString());\n+    }\n+\n+    return RejectedTxTodo{\n+        .m_should_add_extra_compact_tx = add_extra_compact_tx,\n+        .m_unique_parents = std::move(unique_parents),\n+        .m_package_to_validate = std::move(package_to_validate)\n+    };\n+}\n+\n+void TxDownloadManagerImpl::MempoolRejectedPackage(const Package& package)\n+{\n+    RecentRejectsReconsiderableFilter().insert(GetPackageHash(package));\n+}\n+\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManagerImpl::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    const uint256& txid = ptx->GetHash();\n+    const uint256& wtxid = ptx->GetWitnessHash();",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 467,
      "original_position": 452,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "5724926a9b2c7b7d35fc5176caf3710d8aa2f098",
      "in_reply_to_id": 1763652769,
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Makes sense. Don't feel strongly either, was asking for my own understanding. I meant the `RelayTransaction` comment as a separate topic/PR, referring to transaction types (uint256 vs Txid/Wxid) in general, not specific to this line. I guess, overall, trying to gauge how strongly we're trying to adhere to the newer types.",
      "created_at": "2024-09-18T09:16:23Z",
      "updated_at": "2024-09-18T09:26:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1764693774",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1764693774"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 467,
      "original_line": 467,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1765046861",
      "pull_request_review_id": 2312673209,
      "id": 1765046861,
      "node_id": "PRRC_kwDOABII585pNHpN",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (maybe_package.has_value()) CheckPackageToValidate(*maybe_package, rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        // Jump forwards or backwards\n+        auto time_skip = fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+        if (fuzzed_data_provider.ConsumeBool()) time_skip *= -1;\n+        time += time_skip;\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadManagerImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+    txdownload_impl.m_txrequest.SanityCheck();\n+}\n+\n+FUZZ_TARGET(txdownloadman_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadManagerImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManagerImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                for (const auto& tx : TRANSACTIONS) {\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(tx->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(tx->GetHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(tx->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(tx->GetHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    CheckPackageToValidate(*maybe_package, rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 402,
      "original_position": 383,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "df0b8a055cfc5afc9d919fac7594aa3011ceff93",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think these checks on down can be pulled into `CheckPackageToValidate`?",
      "created_at": "2024-09-18T13:20:43Z",
      "updated_at": "2024-09-18T13:30:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1765046861",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1765046861"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 402,
      "original_line": 402,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1768765758",
      "pull_request_review_id": 2318522392,
      "id": 1768765758,
      "node_id": "PRRC_kwDOABII585pbTk-",
      "diff_hunk": "@@ -286,4 +288,160 @@ void TxDownloadManagerImpl::MempoolAcceptedTx(const CTransactionRef& tx)\n     // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n     m_orphanage.EraseTx(tx->GetWitnessHash());\n }\n+\n+node::RejectedTxTodo TxDownloadManagerImpl::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    const CTransaction& tx{*ptx};\n+    // Results returned to caller\n+    // Whether we should call AddToCompactExtraTransactions at the end\n+    bool add_extra_compact_tx{first_time_failure};\n+    // Hashes to pass to AddKnownTx later\n+    std::vector<uint256> unique_parents;\n+    // Populated if failure is reconsiderable and eligible package is found.\n+    std::optional<node::PackageToValidate> package_to_validate;\n+\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+        // Only process a new orphan if this is a first time failure, as otherwise it must be either\n+        // already in orphanage or from 1p1c processing.\n+        if (first_time_failure) {\n+            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+            // Deduplicate parent txids, so that we don't have to loop over\n+            // the same parent txid more than once down below.\n+            unique_parents.reserve(tx.vin.size());\n+            for (const CTxIn& txin : tx.vin) {\n+                // We start with all parents, and then remove duplicates below.\n+                unique_parents.push_back(txin.prevout.hash);\n+            }\n+            std::sort(unique_parents.begin(), unique_parents.end());\n+            unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+            // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.\n+            // We can tolerate having up to 1 parent in m_lazy_recent_rejects_reconsiderable since we\n+            // submit 1p1c packages. However, fail immediately if any are in m_lazy_recent_rejects.\n+            std::optional<uint256> rejected_parent_reconsiderable;\n+            for (const uint256& parent_txid : unique_parents) {\n+                if (RecentRejectsFilter().contains(parent_txid)) {\n+                    fRejectedParents = true;\n+                    break;\n+                } else if (RecentRejectsReconsiderableFilter().contains(parent_txid) &&\n+                           !m_opts.m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                    // More than 1 parent in m_lazy_recent_rejects_reconsiderable: 1p1c will not be\n+                    // sufficient to accept this package, so just give up here.\n+                    if (rejected_parent_reconsiderable.has_value()) {\n+                        fRejectedParents = true;\n+                        break;\n+                    }\n+                }\n+                rejected_parent_reconsiderable = parent_txid;",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "287510e9ea9e45881499bffcc1b5fa5bc803db8a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this line got pulled out of the `else if` conditional. Won't this set the value for all unique parents and reject any transaction with two unique prevout hashes from the orphanage?",
      "created_at": "2024-09-20T14:52:20Z",
      "updated_at": "2024-09-20T15:15:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1768765758",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1768765758"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 336,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1769185572",
      "pull_request_review_id": 2319225808,
      "id": 1769185572,
      "node_id": "PRRC_kwDOABII585pc6Ek",
      "diff_hunk": "@@ -286,4 +288,160 @@ void TxDownloadManagerImpl::MempoolAcceptedTx(const CTransactionRef& tx)\n     // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n     m_orphanage.EraseTx(tx->GetWitnessHash());\n }\n+\n+node::RejectedTxTodo TxDownloadManagerImpl::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    const CTransaction& tx{*ptx};\n+    // Results returned to caller\n+    // Whether we should call AddToCompactExtraTransactions at the end\n+    bool add_extra_compact_tx{first_time_failure};\n+    // Hashes to pass to AddKnownTx later\n+    std::vector<uint256> unique_parents;\n+    // Populated if failure is reconsiderable and eligible package is found.\n+    std::optional<node::PackageToValidate> package_to_validate;\n+\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+        // Only process a new orphan if this is a first time failure, as otherwise it must be either\n+        // already in orphanage or from 1p1c processing.\n+        if (first_time_failure) {\n+            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+            // Deduplicate parent txids, so that we don't have to loop over\n+            // the same parent txid more than once down below.\n+            unique_parents.reserve(tx.vin.size());\n+            for (const CTxIn& txin : tx.vin) {\n+                // We start with all parents, and then remove duplicates below.\n+                unique_parents.push_back(txin.prevout.hash);\n+            }\n+            std::sort(unique_parents.begin(), unique_parents.end());\n+            unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+            // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.\n+            // We can tolerate having up to 1 parent in m_lazy_recent_rejects_reconsiderable since we\n+            // submit 1p1c packages. However, fail immediately if any are in m_lazy_recent_rejects.\n+            std::optional<uint256> rejected_parent_reconsiderable;\n+            for (const uint256& parent_txid : unique_parents) {\n+                if (RecentRejectsFilter().contains(parent_txid)) {\n+                    fRejectedParents = true;\n+                    break;\n+                } else if (RecentRejectsReconsiderableFilter().contains(parent_txid) &&\n+                           !m_opts.m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                    // More than 1 parent in m_lazy_recent_rejects_reconsiderable: 1p1c will not be\n+                    // sufficient to accept this package, so just give up here.\n+                    if (rejected_parent_reconsiderable.has_value()) {\n+                        fRejectedParents = true;\n+                        break;\n+                    }\n+                }\n+                rejected_parent_reconsiderable = parent_txid;",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "287510e9ea9e45881499bffcc1b5fa5bc803db8a",
      "in_reply_to_id": 1768765758,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ugh yes, a bad rebase sorry. I've been using a new setup and haven't perfected my diff-viewing yet.\r\n\r\nI don't understand how 0 tests failed, though ðŸ˜¬ gotta look into that",
      "created_at": "2024-09-20T19:54:33Z",
      "updated_at": "2024-09-20T19:54:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1769185572",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1769185572"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 336,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770543742",
      "pull_request_review_id": 2320844778,
      "id": 1770543742,
      "node_id": "PRRC_kwDOABII585piFp-",
      "diff_hunk": "",
      "path": "src/net_processing.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "original_commit_id": "f0b2b37dbbbb0ffe877e45b921ae7ae06f6facf0",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Commit messages:\r\n\r\n> add TxDownloadOptions bool to make deterministic TxRequestTracker\r\n\r\nnit: may be clearer as `add TxDownloadOptions bool to make TxRequestTracker deterministic`\r\n\r\n> [refactor] ProcessInvalidTx logic to put peerman tasks at the end\r\n\r\nnit2:  `[refactor] put peerman tasks in ProcessInvalidTx logic at the end`",
      "created_at": "2024-09-22T12:28:57Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770543742",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770543742"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770544781",
      "pull_request_review_id": 2320844778,
      "id": 1770544781,
      "node_id": "PRRC_kwDOABII585piF6N",
      "diff_hunk": "@@ -583,53 +568,29 @@ class PeerManagerImpl final : public PeerManager\n     bool MaybeDiscourageAndDisconnect(CNode& pnode, Peer& peer);\n \n     /** Handle a transaction whose result was not MempoolAcceptResult::ResultType::VALID.\n-     * @param[in]   maybe_add_extra_compact_tx    Whether this tx should be added to vExtraTxnForCompact.\n+     * @param[in]   first_time_failure            Whether we should consider inserting into vExtraTxnForCompact, adding",
      "path": "src/net_processing.cpp",
      "position": 45,
      "original_position": 45,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "* how come we're only documenting the `first_time_failure` parameter?\r\n* is there any particular reason for this weird formatting?",
      "created_at": "2024-09-22T12:34:23Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770544781",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770544781"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 571,
      "original_line": 571,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770545259",
      "pull_request_review_id": 2320844778,
      "id": 1770545259,
      "node_id": "PRRC_kwDOABII585piGBr",
      "diff_hunk": "@@ -4597,128 +4246,27 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 }\n             }\n \n-            if (RecentRejectsReconsiderableFilter().contains(wtxid)) {\n-                // When a transaction is already in m_lazy_recent_rejects_reconsiderable, we shouldn't submit\n-                // it by itself again. However, look for a matching child in the orphanage, as it is\n-                // possible that they succeed as a package.\n-                LogDebug(BCLog::TXPACKAGES, \"found tx %s (wtxid=%s) in reconsiderable rejects, looking for child in orphanage\\n\",\n-                         txid.ToString(), wtxid.ToString());\n-                if (auto package_to_validate{Find1P1CPackage(ptx, pfrom.GetId())}) {\n-                    const auto package_result{ProcessNewPackage(m_chainman.ActiveChainstate(), m_mempool, package_to_validate->m_txns, /*test_accept=*/false, /*client_maxfeerate=*/std::nullopt)};\n-                    LogDebug(BCLog::TXPACKAGES, \"package evaluation for %s: %s\\n\", package_to_validate->ToString(),\n-                             package_result.m_state.IsValid() ? \"package accepted\" : \"package rejected\");\n-                    ProcessPackageResult(package_to_validate.value(), package_result);\n-                }\n+            if (package_to_validate) {\n+                const auto package_result{ProcessNewPackage(m_chainman.ActiveChainstate(), m_mempool, package_to_validate->m_txns, /*test_accept=*/false, /*client_maxfeerate=*/std::nullopt)};\n+                LogDebug(BCLog::TXPACKAGES, \"package evaluation for %s: %s\\n\", package_to_validate->ToString(),\n+                         package_result.m_state.IsValid() ? \"package accepted\" : \"package rejected\");\n+                ProcessPackageResult(package_to_validate.value(), package_result);\n             }\n-            // If a tx is detected by m_lazy_recent_rejects it is ignored. Because we haven't\n-            // submitted the tx to our mempool, we won't have computed a DoS\n-            // score for it or determined exactly why we consider it invalid.\n-            //\n-            // This means we won't penalize any peer subsequently relaying a DoSy\n-            // tx (even if we penalized the first peer who gave it to us) because\n-            // we have to account for m_lazy_recent_rejects showing false positives. In\n-            // other words, we shouldn't penalize a peer if we aren't *sure* they\n-            // submitted a DoSy tx.\n-            //\n-            // Note that m_lazy_recent_rejects doesn't just record DoSy or invalid\n-            // transactions, but any tx not accepted by the mempool, which may be\n-            // due to node policy (vs. consensus). So we can't blanket penalize a\n-            // peer simply for relaying a tx that our m_lazy_recent_rejects has caught,\n-            // regardless of false positives.\n             return;\n         }\n \n+        // ReceivedTx should not be telling us to validate the tx and a package.\n+        Assume(!package_to_validate.has_value());",
      "path": "src/net_processing.cpp",
      "position": 727,
      "original_position": 727,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        Assume(!package_to_validate);\r\n```",
      "created_at": "2024-09-22T12:37:40Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770545259",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770545259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4259,
      "original_line": 4259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770546568",
      "pull_request_review_id": 2320844778,
      "id": 1770546568,
      "node_id": "PRRC_kwDOABII585piGWI",
      "diff_hunk": "@@ -5321,16 +4869,18 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n     if (msg_type == NetMsgType::NOTFOUND) {\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n-        if (vInv.size() <= MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-            LOCK(m_tx_download_mutex);\n+        std::vector<uint256> tx_invs;\n+        if (vInv.size() <= node::MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             for (CInv &inv : vInv) {",
      "path": "src/net_processing.cpp",
      "position": 832,
      "original_position": 832,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We could reserve the vector to the expected size to avoid resizing:\r\n```C++\r\ntx_invs.reserve(std::ranges::count_if(vInv, &CInv::IsGenTxMsg));\r\nfor (CInv &inv : vInv) {\r\n```",
      "created_at": "2024-09-22T12:45:24Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770546568",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770546568"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4874,
      "original_line": 4874,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770548378",
      "pull_request_review_id": 2320844778,
      "id": 1770548378,
      "node_id": "PRRC_kwDOABII585piGya",
      "diff_hunk": "@@ -6345,31 +5895,14 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         //\n         {\n             LOCK(m_tx_download_mutex);\n-            std::vector<std::pair<NodeId, GenTxid>> expired;\n-            auto requestable = m_txrequest.GetRequestable(pto->GetId(), current_time, &expired);\n-            for (const auto& entry : expired) {\n-                LogDebug(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n-                    entry.second.GetHash().ToString(), entry.first);\n-            }\n-            for (const GenTxid& gtxid : requestable) {\n-                // Exclude m_lazy_recent_rejects_reconsiderable: we may be requesting a missing parent\n-                // that was previously rejected for being too low feerate.\n-                if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n-                    LogDebug(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n-                        gtxid.GetHash().ToString(), pto->GetId());\n-                    vGetData.emplace_back(gtxid.IsWtxid() ? MSG_WTX : (MSG_TX | GetFetchFlags(*peer)), gtxid.GetHash());\n-                    if (vGetData.size() >= MAX_GETDATA_SZ) {\n-                        MakeAndPushMessage(*pto, NetMsgType::GETDATA, vGetData);\n-                        vGetData.clear();\n-                    }\n-                    m_txrequest.RequestedTx(pto->GetId(), gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n-                } else {\n-                    // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n-                    // this should already be called whenever a transaction becomes AlreadyHaveTx().\n-                    m_txrequest.ForgetTxHash(gtxid.GetHash());\n+            for (const GenTxid& gtxid : m_txdownloadman.GetRequestsToSend(pto->GetId(), current_time)) {",
      "path": "src/net_processing.cpp",
      "position": 881,
      "original_position": 881,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "same, I think we can preallocate these as well:\r\n```C++\r\nvGetData.reserve(vToDownload.size());\r\nfor (const CBlockIndex *pindex : vToDownload) {\r\n```\r\nfollowed by\r\n```C++\r\nconst auto& tx_requests = m_txdownloadman.GetRequestsToSend(pto->GetId(), current_time);\r\nvGetData.reserve(vGetData.size() + tx_requests.size());\r\nfor (const GenTxid& gtxid : tx_requests) {\r\n```",
      "created_at": "2024-09-22T12:53:29Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770548378",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770548378"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 5898,
      "original_line": 5898,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770549633",
      "pull_request_review_id": 2320844778,
      "id": 1770549633,
      "node_id": "PRRC_kwDOABII585piHGB",
      "diff_hunk": "@@ -0,0 +1,159 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadManagerImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {\n+    /** Read-only reference to mempool. */\n+    const CTxMemPool& m_mempool;\n+    /** RNG provided by caller. */\n+    FastRandomContext& m_rng;\n+    /** Maximum number of transactions allowed in orphanage. */\n+    const uint32_t m_max_orphan_txs;\n+    /** Instantiate TxRequestTracker as deterministic (used for tests). */\n+    bool m_deterministic_txrequest{false};\n+};\n+struct TxDownloadConnectionInfo {\n+    /** Whether this peer is preferred for transaction download. */\n+    const bool m_preferred;\n+    /** Whether this peer has Relay permissions. */\n+    const bool m_relay_permissions;\n+    /** Whether this peer supports wtxid relay. */\n+    const bool m_wtxid_relay;\n+};\n+struct PackageToValidate {\n+    Package m_txns;\n+    std::vector<NodeId> m_senders;\n+    /** Construct a 1-parent-1-child package. */\n+    explicit PackageToValidate(const CTransactionRef& parent,\n+                               const CTransactionRef& child,\n+                               NodeId parent_sender,\n+                               NodeId child_sender) :\n+        m_txns{parent, child},\n+        m_senders{parent_sender, child_sender}\n+    {}\n+\n+    // Move ctor\n+    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\n+    // Copy ctor\n+    PackageToValidate(const PackageToValidate& other) = default;\n+\n+    // Move assignment\n+    PackageToValidate& operator=(PackageToValidate&& other) {\n+        this->m_txns = std::move(other.m_txns);\n+        this->m_senders = std::move(other.m_senders);\n+        return *this;\n+    }",
      "path": "src/node/txdownloadman.h",
      "position": 81,
      "original_position": 81,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We might as well simplify these:\r\n```C++\r\n    PackageToValidate(PackageToValidate&&) = default;\r\n    PackageToValidate(const PackageToValidate&) = default;\r\n    PackageToValidate& operator=(PackageToValidate&&) = default;\r\n```",
      "created_at": "2024-09-22T13:00:27Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770549633",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770549633"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 72,
      "original_start_line": 72,
      "start_side": "RIGHT",
      "line": 81,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770549777",
      "pull_request_review_id": 2320844778,
      "id": 1770549777,
      "node_id": "PRRC_kwDOABII585piHIR",
      "diff_hunk": "@@ -0,0 +1,159 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadManagerImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {\n+    /** Read-only reference to mempool. */\n+    const CTxMemPool& m_mempool;\n+    /** RNG provided by caller. */\n+    FastRandomContext& m_rng;\n+    /** Maximum number of transactions allowed in orphanage. */\n+    const uint32_t m_max_orphan_txs;\n+    /** Instantiate TxRequestTracker as deterministic (used for tests). */\n+    bool m_deterministic_txrequest{false};\n+};\n+struct TxDownloadConnectionInfo {\n+    /** Whether this peer is preferred for transaction download. */\n+    const bool m_preferred;\n+    /** Whether this peer has Relay permissions. */\n+    const bool m_relay_permissions;\n+    /** Whether this peer supports wtxid relay. */\n+    const bool m_wtxid_relay;\n+};\n+struct PackageToValidate {\n+    Package m_txns;\n+    std::vector<NodeId> m_senders;\n+    /** Construct a 1-parent-1-child package. */\n+    explicit PackageToValidate(const CTransactionRef& parent,\n+                               const CTransactionRef& child,\n+                               NodeId parent_sender,\n+                               NodeId child_sender) :\n+        m_txns{parent, child},\n+        m_senders{parent_sender, child_sender}\n+    {}\n+\n+    // Move ctor\n+    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\n+    // Copy ctor\n+    PackageToValidate(const PackageToValidate& other) = default;\n+\n+    // Move assignment\n+    PackageToValidate& operator=(PackageToValidate&& other) {\n+        this->m_txns = std::move(other.m_txns);\n+        this->m_senders = std::move(other.m_senders);\n+        return *this;\n+    }\n+\n+    std::string ToString() const {\n+        Assume(m_txns.size() == 2);\n+        return strprintf(\"parent %s (wtxid=%s, sender=%d) + child %s (wtxid=%s, sender=%d)\",\n+                         m_txns.front()->GetHash().ToString(),\n+                         m_txns.front()->GetWitnessHash().ToString(),\n+                         m_senders.front(),\n+                         m_txns.back()->GetHash().ToString(),\n+                         m_txns.back()->GetWitnessHash().ToString(),\n+                         m_senders.back());\n+    }\n+};\n+struct RejectedTxTodo\n+{\n+    bool m_should_add_extra_compact_tx;\n+    std::vector<uint256> m_unique_parents;\n+    std::optional<PackageToValidate> m_package_to_validate;\n+};\n+\n+\n+class TxDownloadManager {\n+    const std::unique_ptr<TxDownloadManagerImpl> m_impl;\n+\n+public:\n+    explicit TxDownloadManager(const TxDownloadOptions& options);\n+    ~TxDownloadManager();\n+\n+    // Responses to chain events. TxDownloadManager is not an actual client of ValidationInterface, these are called through PeerManager.\n+    void ActiveTipChange();\n+    void BlockConnected(const std::shared_ptr<const CBlock>& pblock);\n+    void BlockDisconnected();\n+\n+    /** Creates a new PeerInfo. Saves the connection info to calculate tx announcement delays later. */\n+    void ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info);\n+\n+    /** Deletes all txrequest announcements and orphans for a given peer. */\n+    void DisconnectedPeer(NodeId nodeid);\n+\n+    /** New inv has been received. May be added as a candidate to txrequest.\n+     * @param[in] p2p_inv     When true, only add this announcement if we don't already have the tx.",
      "path": "src/node/txdownloadman.h",
      "position": 121,
      "original_position": 121,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: formatting seems off",
      "created_at": "2024-09-22T13:01:13Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770549777",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770549777"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 121,
      "original_line": 121,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770550296",
      "pull_request_review_id": 2320844778,
      "id": 1770550296,
      "node_id": "PRRC_kwDOABII585piHQY",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 153,
      "original_position": 153,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "can we log warn/error if it does?\r\nOr even better, I assume this is because of testing, can we rather move the check to the tests and assert here instead?",
      "created_at": "2024-09-22T13:03:52Z",
      "updated_at": "2024-09-23T10:56:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770550296",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770550296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 153,
      "original_line": 153,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770552145",
      "pull_request_review_id": 2320844778,
      "id": 1770552145,
      "node_id": "PRRC_kwDOABII585piHtR",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 167,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We seem to have 3 nodeid loopups here: `contains(nodeid)`, `at(nodeid)`, `erase(nodeid)`.\r\nI think we can reduce it to a single iterator lookup:\r\n```suggestion\r\n    if (auto it = m_peer_info.find(nodeid); it != m_peer_info.end()) {\r\n        if (it->second.m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\r\n        m_peer_info.erase(it);\r\n    }\r\n````",
      "created_at": "2024-09-22T13:13:59Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770552145",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770552145"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770553366",
      "pull_request_review_id": 2320844778,
      "id": 1770553366,
      "node_id": "PRRC_kwDOABII585piIAW",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }\n+}\n+\n+bool TxDownloadManagerImpl::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    // If this is an inv received from a peer and we already have it, we can drop it.\n+    // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\n+    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\n+    if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\n+\n+    if (m_peer_info.count(peer) == 0) return false;\n+    const auto& info = m_peer_info.at(peer).m_connection_info;",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 178,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Similarly we can avoid two lookups here:\r\n```suggestion\r\n    auto it = m_peer_info.find(peer);\r\n    if (it == m_peer_info.end()) return false;\r\n    const auto& info = it->second.m_connection_info;\r\n```",
      "created_at": "2024-09-22T13:19:48Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770553366",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770553366"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 177,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 178,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770558551",
      "pull_request_review_id": 2320844778,
      "id": 1770558551,
      "node_id": "PRRC_kwDOABII585piJRX",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }\n+}\n+\n+bool TxDownloadManagerImpl::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    // If this is an inv received from a peer and we already have it, we can drop it.\n+    // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\n+    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\n+    if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\n+\n+    if (m_peer_info.count(peer) == 0) return false;\n+    const auto& info = m_peer_info.at(peer).m_connection_info;\n+    if (!info.m_relay_permissions && m_txrequest.Count(peer) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements for this peer\n+        return false;\n+    }\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or NetPermissionFlags::NoBan permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for txid announcements while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from peers which have at least\n+    //     MAX_PEER_TX_REQUEST_IN_FLIGHT requests in flight (and don't have NetPermissionFlags::Relay).\n+    auto delay{0us};\n+    if (!info.m_preferred) delay += NONPREF_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && m_num_wtxid_peers > 0) delay += TXID_RELAY_DELAY;\n+    const bool overloaded = !info.m_relay_permissions && m_txrequest.CountInFlight(peer) >= MAX_PEER_TX_REQUEST_IN_FLIGHT;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+\n+    m_txrequest.ReceivedInv(peer, gtxid, info.m_preferred, now + delay);\n+\n+    return false;\n+}\n+\n+std::vector<GenTxid> TxDownloadManagerImpl::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    std::vector<GenTxid> requests;\n+    std::vector<std::pair<NodeId, GenTxid>> expired;\n+    auto requestable = m_txrequest.GetRequestable(nodeid, current_time, &expired);\n+    for (const auto& entry : expired) {\n+        LogDebug(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n+            entry.second.GetHash().ToString(), entry.first);\n+    }\n+    for (const GenTxid& gtxid : requestable) {\n+        if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+            LogDebug(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n+                gtxid.GetHash().ToString(), nodeid);\n+            requests.emplace_back(gtxid);\n+            m_txrequest.RequestedTx(nodeid, gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n+        } else {\n+            // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n+            // this should already be called whenever a transaction becomes AlreadyHaveTx().\n+            m_txrequest.ForgetTxHash(gtxid.GetHash());\n+        }\n+    }\n+    return requests;\n+}\n+\n+void TxDownloadManagerImpl::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    for (const auto& txhash : txhashes) {\n+        // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\n+        // completed in TxRequestTracker.\n+        m_txrequest.ReceivedResponse(nodeid, txhash);\n+    }\n+}\n+\n+std::optional<PackageToValidate> TxDownloadManagerImpl::Find1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    Assume(RecentRejectsReconsiderableFilter().contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child, nodeid, nodeid};\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+    // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+    // create a bias that attackers can use to delay package acceptance.\n+    //\n+    // Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    std::shuffle(tx_indices.begin(), tx_indices.end(), m_opts.m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_lazy_recent_rejects_reconsiderable.\n+        const auto [child_tx, child_sender] = cpfp_candidates_different_peer.at(index);",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 277,
      "original_position": 275,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What's the rationale behind shuffling the indices instead of the values? That requires an `O(n)` copy, and the elements are accessed randomly, which could impact locality.\r\nUnless I'm missing something (likely at this stage, that's why I'm asking), wouldn't shuffling the values directly achieve the same outcome while avoiding the copy and potentially improving cache locality during iteration?\r\n```suggestion\r\n    auto cpfp_candidates_different_peer = m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid);\r\n    // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\r\n    // create a bias that attackers can use to delay package acceptance.\r\n    //\r\n    std::shuffle(cpfp_candidates_different_peer.begin(), cpfp_candidates_different_peer.end(), m_opts.m_rng);\r\n    for (const auto& [child_tx, child_sender] : cpfp_candidates_different_peer) {\r\n        // If we already tried a package and failed for any reason, the combined hash was\r\n        // cached in m_lazy_recent_rejects_reconsiderable.\r\n        Package maybe_cpfp_package{ptx, child_tx};\r\n        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\r\n            return PackageToValidate{ptx, child_tx, nodeid, child_sender};\r\n        }\r\n    }\r\n    return std::nullopt;\r\n```",
      "created_at": "2024-09-22T13:43:47Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770558551",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770558551"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 264,
      "original_start_line": 262,
      "start_side": "RIGHT",
      "line": 277,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770561104",
      "pull_request_review_id": 2320844778,
      "id": 1770561104,
      "node_id": "PRRC_kwDOABII585piJ5Q",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }\n+}\n+\n+bool TxDownloadManagerImpl::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    // If this is an inv received from a peer and we already have it, we can drop it.\n+    // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\n+    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\n+    if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\n+\n+    if (m_peer_info.count(peer) == 0) return false;\n+    const auto& info = m_peer_info.at(peer).m_connection_info;\n+    if (!info.m_relay_permissions && m_txrequest.Count(peer) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements for this peer\n+        return false;\n+    }\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or NetPermissionFlags::NoBan permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for txid announcements while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from peers which have at least\n+    //     MAX_PEER_TX_REQUEST_IN_FLIGHT requests in flight (and don't have NetPermissionFlags::Relay).\n+    auto delay{0us};\n+    if (!info.m_preferred) delay += NONPREF_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && m_num_wtxid_peers > 0) delay += TXID_RELAY_DELAY;\n+    const bool overloaded = !info.m_relay_permissions && m_txrequest.CountInFlight(peer) >= MAX_PEER_TX_REQUEST_IN_FLIGHT;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+\n+    m_txrequest.ReceivedInv(peer, gtxid, info.m_preferred, now + delay);\n+\n+    return false;\n+}\n+\n+std::vector<GenTxid> TxDownloadManagerImpl::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    std::vector<GenTxid> requests;\n+    std::vector<std::pair<NodeId, GenTxid>> expired;\n+    auto requestable = m_txrequest.GetRequestable(nodeid, current_time, &expired);\n+    for (const auto& entry : expired) {\n+        LogDebug(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n+            entry.second.GetHash().ToString(), entry.first);\n+    }\n+    for (const GenTxid& gtxid : requestable) {\n+        if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+            LogDebug(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n+                gtxid.GetHash().ToString(), nodeid);\n+            requests.emplace_back(gtxid);\n+            m_txrequest.RequestedTx(nodeid, gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n+        } else {\n+            // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n+            // this should already be called whenever a transaction becomes AlreadyHaveTx().\n+            m_txrequest.ForgetTxHash(gtxid.GetHash());\n+        }\n+    }\n+    return requests;\n+}\n+\n+void TxDownloadManagerImpl::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    for (const auto& txhash : txhashes) {\n+        // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\n+        // completed in TxRequestTracker.\n+        m_txrequest.ReceivedResponse(nodeid, txhash);\n+    }\n+}\n+\n+std::optional<PackageToValidate> TxDownloadManagerImpl::Find1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    Assume(RecentRejectsReconsiderableFilter().contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child, nodeid, nodeid};\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+    // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+    // create a bias that attackers can use to delay package acceptance.\n+    //\n+    // Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    std::shuffle(tx_indices.begin(), tx_indices.end(), m_opts.m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_lazy_recent_rejects_reconsiderable.\n+        const auto [child_tx, child_sender] = cpfp_candidates_different_peer.at(index);\n+        Package maybe_cpfp_package{ptx, child_tx};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child_tx, nodeid, child_sender};\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+void TxDownloadManagerImpl::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    // As this version of the transaction was acceptable, we can forget about any requests for it.\n+    // No-op if the tx is not in txrequest.\n+    m_txrequest.ForgetTxHash(tx->GetHash());\n+    m_txrequest.ForgetTxHash(tx->GetWitnessHash());\n+\n+    m_orphanage.AddChildrenToWorkSet(*tx);\n+    // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n+    m_orphanage.EraseTx(tx->GetWitnessHash());\n+}\n+\n+node::RejectedTxTodo TxDownloadManagerImpl::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    const CTransaction& tx{*ptx};\n+    // Results returned to caller\n+    // Whether we should call AddToCompactExtraTransactions at the end\n+    bool add_extra_compact_tx{first_time_failure};\n+    // Hashes to pass to AddKnownTx later\n+    std::vector<uint256> unique_parents;\n+    // Populated if failure is reconsiderable and eligible package is found.\n+    std::optional<node::PackageToValidate> package_to_validate;\n+\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+        // Only process a new orphan if this is a first time failure, as otherwise it must be either\n+        // already in orphanage or from 1p1c processing.\n+        if (first_time_failure && !RecentRejectsFilter().contains(ptx->GetWitnessHash().ToUint256())) {\n+            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+            // Deduplicate parent txids, so that we don't have to loop over\n+            // the same parent txid more than once down below.\n+            unique_parents.reserve(tx.vin.size());\n+            for (const CTxIn& txin : tx.vin) {\n+                // We start with all parents, and then remove duplicates below.\n+                unique_parents.push_back(txin.prevout.hash);\n+            }\n+            std::sort(unique_parents.begin(), unique_parents.end());\n+            unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 327,
      "original_position": 321,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "sorting + erasing duplicates indicates to me that we may be using the wrong datastructure:\r\n```C++\r\n    std::set<uint256> unique_parents;\r\n...\r\n    // Deduplicate parent txids, so that we don't have to loop over\r\n    // the same parent txid more than once down below.\r\n    for (const CTxIn& txin : tx.vin) {\r\n        // We start with all parents, and then remove duplicates below.\r\n        unique_parents.insert(txin.prevout.hash);\r\n    }\r\n```\r\n\r\n(std::vector seems to have `O(n) inserts + O(nlogn) sort + O(n) deduplication`, std::set has simply `O(nlogn)` sorted inserts)",
      "created_at": "2024-09-22T13:56:20Z",
      "updated_at": "2024-09-24T11:54:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770561104",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770561104"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 326,
      "original_start_line": 320,
      "start_side": "RIGHT",
      "line": 327,
      "original_line": 327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770562266",
      "pull_request_review_id": 2320844778,
      "id": 1770562266,
      "node_id": "PRRC_kwDOABII585piKLa",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+\n+    // A new TxDownloadManagerImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+    node::TxDownloadConnectionInfo connection_info{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};\n+\n+    for (const auto segwit_parent : {true, false}) {\n+        for (const auto segwit_child : {true, false}) {\n+            const auto ptx_parent = CreateTransactionChain(1, segwit_parent).front();\n+            const auto ptx_child = CreateTransactionChain(1, segwit_child).front();\n+            const auto& parent_txid = ptx_parent->GetHash().ToUint256();\n+            const auto& parent_wtxid = ptx_parent->GetWitnessHash().ToUint256();\n+            const auto& child_txid = ptx_child->GetHash().ToUint256();\n+            const auto& child_wtxid = ptx_child->GetWitnessHash().ToUint256();\n+\n+            for (const auto& [result, expected_behavior] : expected_behaviors) {\n+                node::TxDownloadManagerImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true}};\n+                txdownload_impl.ConnectedPeer(nodeid, connection_info);\n+                // Parent failure\n+                state.Invalid(result, \"\");\n+                const auto& [keep, unique_txids, package_to_validate] = txdownload_impl.MempoolRejectedTx(ptx_parent, state, nodeid, /*first_time_failure=*/true);\n+\n+                // No distinction between txid and wtxid caching for nonsegwit transactions, so only test these specific\n+                // behaviors for segwit transactions.\n+                Behaviors actual_behavior{\n+                    /*txid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_txid),\n+                    /*wtxid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_wtxid),\n+                    /*txid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_txid),\n+                    /*wtxid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_wtxid),\n+                    /*keep=*/keep,\n+                    /*txid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Txid(parent_txid), now, /*p2p_inv=*/true),\n+                    /*wtxid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Wtxid(parent_wtxid), now, /*p2p_inv=*/true),\n+                };\n+                BOOST_TEST_MESSAGE(\"Testing behavior for \" << result << (segwit_parent ? \" segwit \" : \" nonsegwit\"));\n+                actual_behavior.CheckEqual(expected_behavior, /*segwit=*/segwit_parent);\n+\n+                // Later, a child of this transaction fails for missing inputs\n+                state.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                txdownload_impl.MempoolRejectedTx(ptx_child, state, nodeid, /*first_time_failure=*/true);\n+\n+                // If parent (by txid) was rejected, child is too.\n+                const bool parent_txid_rejected{segwit_parent ? expected_behavior.m_txid_in_rejects : expected_behavior.m_wtxid_in_rejects};\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_txid));\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_wtxid));\n+\n+                // Unless rejected, the child should be in orphanage.\n+                BOOST_CHECK_EQUAL(!parent_txid_rejected, txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+            }\n+        }\n+    }\n+\n+    // More specific examples of orphans with parent(s) that we have seen before.\n+    TxValidationState state_reconsiderable;\n+    state_reconsiderable.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"\");\n+\n+    TxValidationState state_orphan;\n+    state_orphan.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+\n+    const auto ptx_parent_1 = CreateTransactionChain(1, /*segwit=*/false).front();\n+    const auto ptx_parent_2 = CreateTransactionChain(1, /*segwit=*/false).front();\n+    CMutableTransaction mtx_child;\n+    mtx_child.vin.emplace_back(ptx_parent_1->GetHash(), 0);\n+    mtx_child.vin.emplace_back(ptx_parent_2->GetHash(), 0);\n+    mtx_child.vout.emplace_back(CENT, CScript());\n+    auto ptx_child = MakeTransactionRef(mtx_child);\n+    const std::vector<uint256> vec_parent_txids = {ptx_parent_1->GetHash(), ptx_parent_2->GetHash()};\n+\n+    // 1 reconsiderable parent\n+    {\n+        node::TxDownloadManagerImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true}};\n+        txdownload_impl.ConnectedPeer(nodeid, connection_info);\n+\n+        // Parent reconsiderable failure\n+        const auto& [p1_keep, p1_unique_txids, p1_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_1, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p1_keep);\n+        BOOST_CHECK(p1_unique_txids.empty());\n+        BOOST_CHECK(!p1_package.has_value());\n+\n+        // Child missing inputs, should be added to orphanage.\n+        const auto& [c_keep, c_unique_txids, c_package] = txdownload_impl.MempoolRejectedTx(ptx_child, state_orphan, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(c_keep);\n+        BOOST_CHECK(c_unique_txids == vec_parent_txids);",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 176,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "While `BOOST_CHECK_EQUAL_COLLECTIONS` is more verbose, it produces better failure messages:\r\n```suggestion\r\n        BOOST_CHECK_EQUAL_COLLECTIONS(c_unique_txids.begin(), c_unique_txids.end(), vec_parent_txids.begin(), vec_parent_txids.end());\r\n```",
      "created_at": "2024-09-22T14:03:37Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770562266",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770562266"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770562355",
      "pull_request_review_id": 2320844778,
      "id": 1770562355,
      "node_id": "PRRC_kwDOABII585piKMz",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+\n+    // A new TxDownloadManagerImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+    node::TxDownloadConnectionInfo connection_info{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};\n+\n+    for (const auto segwit_parent : {true, false}) {\n+        for (const auto segwit_child : {true, false}) {\n+            const auto ptx_parent = CreateTransactionChain(1, segwit_parent).front();\n+            const auto ptx_child = CreateTransactionChain(1, segwit_child).front();\n+            const auto& parent_txid = ptx_parent->GetHash().ToUint256();\n+            const auto& parent_wtxid = ptx_parent->GetWitnessHash().ToUint256();\n+            const auto& child_txid = ptx_child->GetHash().ToUint256();\n+            const auto& child_wtxid = ptx_child->GetWitnessHash().ToUint256();\n+\n+            for (const auto& [result, expected_behavior] : expected_behaviors) {\n+                node::TxDownloadManagerImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true}};\n+                txdownload_impl.ConnectedPeer(nodeid, connection_info);\n+                // Parent failure\n+                state.Invalid(result, \"\");\n+                const auto& [keep, unique_txids, package_to_validate] = txdownload_impl.MempoolRejectedTx(ptx_parent, state, nodeid, /*first_time_failure=*/true);\n+\n+                // No distinction between txid and wtxid caching for nonsegwit transactions, so only test these specific\n+                // behaviors for segwit transactions.\n+                Behaviors actual_behavior{\n+                    /*txid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_txid),\n+                    /*wtxid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_wtxid),\n+                    /*txid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_txid),\n+                    /*wtxid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_wtxid),\n+                    /*keep=*/keep,\n+                    /*txid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Txid(parent_txid), now, /*p2p_inv=*/true),\n+                    /*wtxid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Wtxid(parent_wtxid), now, /*p2p_inv=*/true),\n+                };\n+                BOOST_TEST_MESSAGE(\"Testing behavior for \" << result << (segwit_parent ? \" segwit \" : \" nonsegwit\"));\n+                actual_behavior.CheckEqual(expected_behavior, /*segwit=*/segwit_parent);\n+\n+                // Later, a child of this transaction fails for missing inputs\n+                state.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                txdownload_impl.MempoolRejectedTx(ptx_child, state, nodeid, /*first_time_failure=*/true);\n+\n+                // If parent (by txid) was rejected, child is too.\n+                const bool parent_txid_rejected{segwit_parent ? expected_behavior.m_txid_in_rejects : expected_behavior.m_wtxid_in_rejects};\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_txid));\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_wtxid));\n+\n+                // Unless rejected, the child should be in orphanage.\n+                BOOST_CHECK_EQUAL(!parent_txid_rejected, txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+            }\n+        }\n+    }\n+\n+    // More specific examples of orphans with parent(s) that we have seen before.\n+    TxValidationState state_reconsiderable;\n+    state_reconsiderable.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"\");\n+\n+    TxValidationState state_orphan;\n+    state_orphan.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+\n+    const auto ptx_parent_1 = CreateTransactionChain(1, /*segwit=*/false).front();\n+    const auto ptx_parent_2 = CreateTransactionChain(1, /*segwit=*/false).front();\n+    CMutableTransaction mtx_child;\n+    mtx_child.vin.emplace_back(ptx_parent_1->GetHash(), 0);\n+    mtx_child.vin.emplace_back(ptx_parent_2->GetHash(), 0);\n+    mtx_child.vout.emplace_back(CENT, CScript());\n+    auto ptx_child = MakeTransactionRef(mtx_child);\n+    const std::vector<uint256> vec_parent_txids = {ptx_parent_1->GetHash(), ptx_parent_2->GetHash()};\n+\n+    // 1 reconsiderable parent\n+    {\n+        node::TxDownloadManagerImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true}};\n+        txdownload_impl.ConnectedPeer(nodeid, connection_info);\n+\n+        // Parent reconsiderable failure\n+        const auto& [p1_keep, p1_unique_txids, p1_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_1, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p1_keep);\n+        BOOST_CHECK(p1_unique_txids.empty());\n+        BOOST_CHECK(!p1_package.has_value());",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 171,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        BOOST_CHECK(!p1_package);\r\n```",
      "created_at": "2024-09-22T14:04:01Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770562355",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770562355"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 171,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770562862",
      "pull_request_review_id": 2320844778,
      "id": 1770562862,
      "node_id": "PRRC_kwDOABII585piKUu",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 70,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: we seem to be always calling this with `num_txns == 1`",
      "created_at": "2024-09-22T14:06:56Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770562862",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770562862"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770563421",
      "pull_request_review_id": 2320844778,
      "id": 1770563421,
      "node_id": "PRRC_kwDOABII585piKdd",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 67,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Alternatively, to avoid repetition and noise (labels AND data) we could group it slightly differently:\r\n```C++\r\n    //                                                txid_rejects, wtxid_rejects, txid_recon, wtxid_recon, keep, txid_inv, wtxid_inv\r\n    {TxValidationResult::TX_CONSENSUS,               {0,            1,             0,          0,           1,    0,        1}},\r\n    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {0,            1,             0,          0,           1,    0,        1}},\r\n    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {1,            1,             0,          0,           1,    1,        1}},\r\n    {TxValidationResult::TX_NOT_STANDARD,            {0,            1,             0,          0,           1,    0,        1}},\r\n    {TxValidationResult::TX_MISSING_INPUTS,          {0,            0,             0,          0,           1,    0,        1}},\r\n    {TxValidationResult::TX_PREMATURE_SPEND,         {0,            1,             0,          0,           1,    0,        1}},\r\n    {TxValidationResult::TX_WITNESS_MUTATED,         {0,            1,             0,          0,           1,    0,        1}},\r\n    {TxValidationResult::TX_WITNESS_STRIPPED,        {0,            0,             0,          0,           0,    0,        0}},\r\n    {TxValidationResult::TX_CONFLICT,                {0,            1,             0,          0,           1,    0,        1}},\r\n    {TxValidationResult::TX_MEMPOOL_POLICY,          {0,            1,             0,          0,           1,    0,        1}},\r\n    {TxValidationResult::TX_NO_MEMPOOL,              {0,            1,             0,          0,           1,    0,        1}},\r\n    {TxValidationResult::TX_RECONSIDERABLE,          {0,            0,             0,          1,           1,    0,        1}},\r\n    {TxValidationResult::TX_UNKNOWN,                 {0,            1,             0,          0,           1,    0,        1}},\r\n```",
      "created_at": "2024-09-22T14:09:34Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770563421",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770563421"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 55,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770564258",
      "pull_request_review_id": 2320844778,
      "id": 1770564258,
      "node_id": "PRRC_kwDOABII585piKqi",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\n+    }\n+}\n+\n+static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.first;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetStrippedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return StripWitness(tx_it->second.first);\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetMalleatedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.second;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetRandomTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, FuzzedDataProvider& fuzzed_data_provider, bool correct_only = false)\n+{\n+    auto it = txmap.begin();\n+    // Jump forward a random number of times.\n+    for (size_t i = 0; i <= fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1); ++i) it++;\n+    if (it == txmap.end()) return nullptr;\n+    return correct_only || fuzzed_data_provider.ConsumeBool() ? it->second.first : it->second.second;\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(txdownloadman_one_honest_peer, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+    std::chrono::microseconds time{244466666};\n+\n+    // Decide the target transaction. Disallow selecting a witness-stripped or non-segwit\n+    // transaction because it can lead to false negatives. This test may mark a same-txid\n+    // transaction as invalid, and we don't want that to cause rejection of the target tx.\n+    const auto& target_tx = GetRandomTx(TRANSACTIONS, fuzzed_data_provider, /*correct_only=*/true);\n+    Assert(target_tx != nullptr);\n+    Assert(target_tx->HasWitness());\n+\n+    const auto& target_txid = target_tx->GetHash();\n+    const auto& target_wtxid = target_tx->GetWitnessHash();\n+\n+    // Decide what the peers are.\n+    std::vector<TestPeer> all_peers;\n+    // NodeId of the \"designated good peer\"\n+    // Other TestPeers may be \"good\" as well, but not guaranteed.\n+    NodeId honestid = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 7);\n+    // 8 outbound peers. NodeId = o. We indicate outbound using preferred=true\n+    for (unsigned int o = 0; o < 8; ++o) {\n+        bool good = (o == honestid) || fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, o, /*preferred=*/true, /*force_good=*/good));\n+    }\n+    // 0-120 inbound peers. NodeId = i. We indicate inbound using preferred=false\n+    auto num_inbound_peers = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 120);\n+    for (unsigned int i = 8; i < num_inbound_peers + 8; ++i) {\n+        bool good = fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, i, /*preferred=*/false, /*force_good=*/good));\n+    }\n+\n+    // Indexes for random peer iteration\n+    std::vector<size_t> indexes;\n+    indexes.resize(all_peers.size());\n+    std::iota(indexes.begin(), indexes.end(), 0);\n+\n+    // We are trying to ensure that we always download the tx as long as we have 1 good outbound\n+    // peer who is able to send it to us.\n+    bool got_tx{false};\n+\n+    // Keep track of how many iterations the loop has done to make sure the target transaction is\n+    // announced within the first 1000 rounds. Note that the good peer is guaranteed to connect\n+    // within the first round and will never be disconnected.\n+    int counter = 0;\n+\n+    LIMITED_WHILE(!got_tx, 100000)\n+    {\n+        FastRandomContext rng{ConsumeUInt256(fuzzed_data_provider)};\n+        std::shuffle(indexes.begin(), indexes.end(), rng);\n+        // For each peer in random order, mock a ProcessMessages + SendMessages\n+        for (const auto index : indexes) {\n+            auto& peer = all_peers.at(index);\n+            NodeId nodeid = peer.m_nodeid;\n+\n+            // Maybe connect the peer if we haven't already. Always connect if it's the good peer.\n+            if (nodeid == honestid ||\n+                (peer.m_connection_state == ConnectionState::NEVER_CONNECTED && fuzzed_data_provider.ConsumeBool())) {\n+                node::TxDownloadConnectionInfo info{peer.m_connection_preferred, peer.m_relay_permissions, peer.m_wtxid_relay};\n+                txdownloadman.ConnectedPeer(nodeid, info);\n+                peer.m_connection_state = ConnectionState::CONNECTED;\n+            }\n+\n+            if (peer.m_connection_state == ConnectionState::CONNECTED) {\n+                // Peer will do its own ProcessMessages, i.e. respond to the next item in its message queue\n+                // If the message queue is empty or it decides to send nothing, maybe_gtxid is\n+                // std::nullopt. Otherwise, maybe_gtxid must contain the gtxid we are responding to.\n+                const auto& [peer_response, maybe_gtxid] = peer.ProcessOneMessage(fuzzed_data_provider);\n+\n+                // Simulate a ProcessMessage.\n+                switch (peer_response) {\n+                    case PossibleResponse::TX_REAL:\n+                    {\n+                        // If the transaction exists, use ReceivedTx. Otherwise, maybe send notfound.\n+                        if (auto ptx{GetCorrectTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, ptx);\n+                            if (should_validate || package_to_validate.has_value()) {\n+                                if (ptx->GetWitnessHash() == target_wtxid) {\n+                                    // We received the target tx and decided to validate it! Win!\n+                                    got_tx = true;\n+                                } else {\n+                                    // If not the target tx, pick some failure reason.\n+                                    TxValidationState state;\n+                                    state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                                    txdownloadman.MempoolRejectedTx(ptx, state, nodeid, true);\n+                                }\n+                            } else {\n+                            }\n+                        } else {\n+                            Assert(!peer.m_good);\n+                            if (fuzzed_data_provider.ConsumeBool()) {\n+                                txdownloadman.ReceivedNotFound(nodeid, {maybe_gtxid.value().GetHash()});\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::TX_WITNESS_STRIPPED:\n+                    {\n+                        // Call ReceivedTx. If txdownloadman instructs us to validate the\n+                        // transaction, say the result was TX_WITNESS_STRIPPED.\n+                        if (auto stripped_tx{GetStrippedTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+                            const auto& [should_validate, package] = txdownloadman.ReceivedTx(nodeid, stripped_tx);\n+                            if (should_validate) {\n+                                TxValidationState state;\n+                                state.Invalid(TxValidationResult::TX_WITNESS_STRIPPED, \"\");\n+                                txdownloadman.MempoolRejectedTx(stripped_tx, state, nodeid, true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::TX_WITNESS_MALLEATED:\n+                    {\n+                        // Call ReceivedTx. If txdownloadman instructs us to validate the\n+                        // transaction, return some error.\n+                        if (auto malleated_tx{GetMalleatedTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+\n+                            // Prevent accidental lose conditions.\n+                            if (malleated_tx == target_tx) break;\n+\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, malleated_tx);\n+                            if (should_validate) {\n+                                TxValidationState state;\n+                                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                                txdownloadman.MempoolRejectedTx(malleated_tx, state, nodeid, true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::NOTFOUND:\n+                    {\n+                        txdownloadman.ReceivedNotFound(nodeid, {maybe_gtxid.value().GetHash()});\n+                        break;\n+                    }\n+                    case PossibleResponse::NOTHING:\n+                    {\n+                        break;\n+                    }\n+                    case PossibleResponse::DEFER:\n+                    {\n+                        // bug\n+                        Assert(false);\n+                        break;\n+                    }\n+                }\n+\n+                // The peer may also send some unsolicited message. Simulate a ProcessMessage.\n+                // Ensure the good peer sends the inv within the first 1000 rounds.\n+                auto peer_unsolicited_message = peer.SendOneMessage(fuzzed_data_provider, /*force_announce=*/counter > 1000);\n+\n+                switch (peer_unsolicited_message) {\n+                    case PossibleMessage::NOTHING:\n+                    {\n+                        break;\n+                    }\n+                    case PossibleMessage::INV_REAL:\n+                    {\n+                        if (peer.m_wtxid_relay) {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Wtxid(target_wtxid), time, /*p2p_inv=*/true);\n+                        } else {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Txid(target_txid), time, /*p2p_inv=*/true);\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::INV_DIFFERENT:\n+                    {\n+                        // This may or may not be target_tx\n+                        if (auto random_tx{GetRandomTx(TRANSACTIONS, fuzzed_data_provider)}) {\n+                            if (peer.m_wtxid_relay) {\n+                                txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Txid(random_tx->GetHash()), time, /*p2p_inv=*/true);\n+                            } else {\n+                                txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Wtxid(random_tx->GetWitnessHash()), time, /*p2p_inv=*/true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::INV_RANDOM:\n+                    {\n+                        auto random_txhash = ConsumeUInt256(fuzzed_data_provider);\n+                        if (peer.m_wtxid_relay) {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Wtxid(random_txhash), time, /*p2p_inv=*/true);\n+                        } else {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Txid(random_txhash), time, /*p2p_inv=*/true);\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::TX_RANDOM:\n+                    {\n+                        if (auto random_tx{GetRandomTx(TRANSACTIONS, fuzzed_data_provider)}) {\n+                            // Disallow winning this way.\n+                            if (random_tx == target_tx) break;\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, random_tx);\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::NOTFOUND:\n+                    {\n+                        if (auto random_tx{GetRandomTx(TRANSACTIONS, fuzzed_data_provider)}) {\n+                            const auto txhash{fuzzed_data_provider.ConsumeBool() ? random_tx->GetHash().ToUint256() : random_tx->GetWitnessHash().ToUint256()};\n+                            txdownloadman.ReceivedNotFound(nodeid, {txhash});\n+                        }\n+                        break;\n+                    }\n+                }\n+\n+                // Simulate a SendMessages, which includes sending getdata to request transactions.\n+                for (const auto& gtxid : txdownloadman.GetRequestsToSend(nodeid, time)) {\n+                    peer.m_getdata_queue.push_back(gtxid);\n+                }\n+\n+                // Maybe disconnect the peer if we haven't already. Never disconnect the good peer.\n+                if (peer.m_connection_state == ConnectionState::CONNECTED && nodeid != honestid && fuzzed_data_provider.ConsumeBool()) {\n+                    peer.m_connection_state = ConnectionState::DISCONNECTED;\n+                    txdownloadman.DisconnectedPeer(nodeid);\n+                    txdownloadman.CheckIsEmpty(nodeid);\n+                }\n+                ++counter;\n+            }\n+        }\n+\n+        // Skip time by 100-300ms",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 512,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`ms` or `Î¼s`?",
      "created_at": "2024-09-22T14:13:50Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770564258",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770564258"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 512,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770564734",
      "pull_request_review_id": 2320844778,
      "id": 1770564734,
      "node_id": "PRRC_kwDOABII585piKx-",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\n+    }\n+}\n+\n+static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.first;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetStrippedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return StripWitness(tx_it->second.first);\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetMalleatedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.second;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetRandomTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, FuzzedDataProvider& fuzzed_data_provider, bool correct_only = false)\n+{\n+    auto it = txmap.begin();\n+    // Jump forward a random number of times.\n+    for (size_t i = 0; i <= fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1); ++i) it++;\n+    if (it == txmap.end()) return nullptr;\n+    return correct_only || fuzzed_data_provider.ConsumeBool() ? it->second.first : it->second.second;\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(txdownloadman_one_honest_peer, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+    std::chrono::microseconds time{244466666};\n+\n+    // Decide the target transaction. Disallow selecting a witness-stripped or non-segwit\n+    // transaction because it can lead to false negatives. This test may mark a same-txid\n+    // transaction as invalid, and we don't want that to cause rejection of the target tx.\n+    const auto& target_tx = GetRandomTx(TRANSACTIONS, fuzzed_data_provider, /*correct_only=*/true);\n+    Assert(target_tx != nullptr);\n+    Assert(target_tx->HasWitness());\n+\n+    const auto& target_txid = target_tx->GetHash();\n+    const auto& target_wtxid = target_tx->GetWitnessHash();\n+\n+    // Decide what the peers are.\n+    std::vector<TestPeer> all_peers;\n+    // NodeId of the \"designated good peer\"\n+    // Other TestPeers may be \"good\" as well, but not guaranteed.\n+    NodeId honestid = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 7);\n+    // 8 outbound peers. NodeId = o. We indicate outbound using preferred=true\n+    for (unsigned int o = 0; o < 8; ++o) {\n+        bool good = (o == honestid) || fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, o, /*preferred=*/true, /*force_good=*/good));\n+    }\n+    // 0-120 inbound peers. NodeId = i. We indicate inbound using preferred=false\n+    auto num_inbound_peers = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 120);\n+    for (unsigned int i = 8; i < num_inbound_peers + 8; ++i) {\n+        bool good = fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, i, /*preferred=*/false, /*force_good=*/good));\n+    }\n+\n+    // Indexes for random peer iteration\n+    std::vector<size_t> indexes;\n+    indexes.resize(all_peers.size());\n+    std::iota(indexes.begin(), indexes.end(), 0);\n+\n+    // We are trying to ensure that we always download the tx as long as we have 1 good outbound\n+    // peer who is able to send it to us.\n+    bool got_tx{false};\n+\n+    // Keep track of how many iterations the loop has done to make sure the target transaction is\n+    // announced within the first 1000 rounds. Note that the good peer is guaranteed to connect\n+    // within the first round and will never be disconnected.\n+    int counter = 0;\n+\n+    LIMITED_WHILE(!got_tx, 100000)\n+    {\n+        FastRandomContext rng{ConsumeUInt256(fuzzed_data_provider)};\n+        std::shuffle(indexes.begin(), indexes.end(), rng);\n+        // For each peer in random order, mock a ProcessMessages + SendMessages\n+        for (const auto index : indexes) {\n+            auto& peer = all_peers.at(index);\n+            NodeId nodeid = peer.m_nodeid;\n+\n+            // Maybe connect the peer if we haven't already. Always connect if it's the good peer.\n+            if (nodeid == honestid ||\n+                (peer.m_connection_state == ConnectionState::NEVER_CONNECTED && fuzzed_data_provider.ConsumeBool())) {\n+                node::TxDownloadConnectionInfo info{peer.m_connection_preferred, peer.m_relay_permissions, peer.m_wtxid_relay};\n+                txdownloadman.ConnectedPeer(nodeid, info);\n+                peer.m_connection_state = ConnectionState::CONNECTED;\n+            }\n+\n+            if (peer.m_connection_state == ConnectionState::CONNECTED) {\n+                // Peer will do its own ProcessMessages, i.e. respond to the next item in its message queue\n+                // If the message queue is empty or it decides to send nothing, maybe_gtxid is\n+                // std::nullopt. Otherwise, maybe_gtxid must contain the gtxid we are responding to.\n+                const auto& [peer_response, maybe_gtxid] = peer.ProcessOneMessage(fuzzed_data_provider);\n+\n+                // Simulate a ProcessMessage.\n+                switch (peer_response) {\n+                    case PossibleResponse::TX_REAL:\n+                    {\n+                        // If the transaction exists, use ReceivedTx. Otherwise, maybe send notfound.\n+                        if (auto ptx{GetCorrectTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, ptx);\n+                            if (should_validate || package_to_validate.has_value()) {\n+                                if (ptx->GetWitnessHash() == target_wtxid) {\n+                                    // We received the target tx and decided to validate it! Win!\n+                                    got_tx = true;\n+                                } else {\n+                                    // If not the target tx, pick some failure reason.\n+                                    TxValidationState state;\n+                                    state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                                    txdownloadman.MempoolRejectedTx(ptx, state, nodeid, true);\n+                                }\n+                            } else {\n+                            }\n+                        } else {\n+                            Assert(!peer.m_good);\n+                            if (fuzzed_data_provider.ConsumeBool()) {\n+                                txdownloadman.ReceivedNotFound(nodeid, {maybe_gtxid.value().GetHash()});\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::TX_WITNESS_STRIPPED:\n+                    {\n+                        // Call ReceivedTx. If txdownloadman instructs us to validate the\n+                        // transaction, say the result was TX_WITNESS_STRIPPED.\n+                        if (auto stripped_tx{GetStrippedTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+                            const auto& [should_validate, package] = txdownloadman.ReceivedTx(nodeid, stripped_tx);\n+                            if (should_validate) {\n+                                TxValidationState state;\n+                                state.Invalid(TxValidationResult::TX_WITNESS_STRIPPED, \"\");\n+                                txdownloadman.MempoolRejectedTx(stripped_tx, state, nodeid, true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::TX_WITNESS_MALLEATED:\n+                    {\n+                        // Call ReceivedTx. If txdownloadman instructs us to validate the\n+                        // transaction, return some error.\n+                        if (auto malleated_tx{GetMalleatedTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+\n+                            // Prevent accidental lose conditions.\n+                            if (malleated_tx == target_tx) break;\n+\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, malleated_tx);\n+                            if (should_validate) {\n+                                TxValidationState state;\n+                                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                                txdownloadman.MempoolRejectedTx(malleated_tx, state, nodeid, true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::NOTFOUND:\n+                    {\n+                        txdownloadman.ReceivedNotFound(nodeid, {maybe_gtxid.value().GetHash()});\n+                        break;\n+                    }\n+                    case PossibleResponse::NOTHING:\n+                    {\n+                        break;\n+                    }\n+                    case PossibleResponse::DEFER:\n+                    {\n+                        // bug\n+                        Assert(false);\n+                        break;\n+                    }\n+                }\n+\n+                // The peer may also send some unsolicited message. Simulate a ProcessMessage.\n+                // Ensure the good peer sends the inv within the first 1000 rounds.",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": 437,
      "original_position": 439,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "since counter starts from 0, aren't we sending within the first `1001 rounds`?",
      "created_at": "2024-09-22T14:16:51Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770564734",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770564734"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 437,
      "original_line": 437,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770565713",
      "pull_request_review_id": 2320844778,
      "id": 1770565713,
      "node_id": "PRRC_kwDOABII585piLBR",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\n+    }\n+}\n+\n+static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.first;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetStrippedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return StripWitness(tx_it->second.first);\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetMalleatedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.second;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetRandomTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, FuzzedDataProvider& fuzzed_data_provider, bool correct_only = false)\n+{\n+    auto it = txmap.begin();\n+    // Jump forward a random number of times.\n+    for (size_t i = 0; i <= fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1); ++i) it++;\n+    if (it == txmap.end()) return nullptr;\n+    return correct_only || fuzzed_data_provider.ConsumeBool() ? it->second.first : it->second.second;\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(txdownloadman_one_honest_peer, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+    std::chrono::microseconds time{244466666};\n+\n+    // Decide the target transaction. Disallow selecting a witness-stripped or non-segwit\n+    // transaction because it can lead to false negatives. This test may mark a same-txid\n+    // transaction as invalid, and we don't want that to cause rejection of the target tx.\n+    const auto& target_tx = GetRandomTx(TRANSACTIONS, fuzzed_data_provider, /*correct_only=*/true);\n+    Assert(target_tx != nullptr);\n+    Assert(target_tx->HasWitness());\n+\n+    const auto& target_txid = target_tx->GetHash();\n+    const auto& target_wtxid = target_tx->GetWitnessHash();\n+\n+    // Decide what the peers are.\n+    std::vector<TestPeer> all_peers;\n+    // NodeId of the \"designated good peer\"\n+    // Other TestPeers may be \"good\" as well, but not guaranteed.\n+    NodeId honestid = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 7);\n+    // 8 outbound peers. NodeId = o. We indicate outbound using preferred=true\n+    for (unsigned int o = 0; o < 8; ++o) {\n+        bool good = (o == honestid) || fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, o, /*preferred=*/true, /*force_good=*/good));\n+    }\n+    // 0-120 inbound peers. NodeId = i. We indicate inbound using preferred=false\n+    auto num_inbound_peers = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 120);\n+    for (unsigned int i = 8; i < num_inbound_peers + 8; ++i) {\n+        bool good = fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, i, /*preferred=*/false, /*force_good=*/good));\n+    }\n+\n+    // Indexes for random peer iteration\n+    std::vector<size_t> indexes;\n+    indexes.resize(all_peers.size());",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 327,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "we can simplify this to either:\r\n```suggestion\r\nstd::vector<size_t> indexes(all_peers.size());\r\n```\r\n\r\nor shuffle `all_peers` directly (unless I'm missing something, as mentioned in a previous comment)",
      "created_at": "2024-09-22T14:21:28Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770565713",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770565713"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 326,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770565944",
      "pull_request_review_id": 2320844778,
      "id": 1770565944,
      "node_id": "PRRC_kwDOABII585piLE4",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\n+    }\n+}\n+\n+static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": 248,
      "original_position": 249,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: we can narrow the scope of the iterator:\r\n```suggestion\r\n    if (auto tx_it = txmap.find(gtxid.GetHash()); tx_it != txmap.end()) {\r\n```",
      "created_at": "2024-09-22T14:22:45Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770565944",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770565944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 247,
      "original_start_line": 248,
      "start_side": "RIGHT",
      "line": 248,
      "original_line": 248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770567453",
      "pull_request_review_id": 2320844778,
      "id": 1770567453,
      "node_id": "PRRC_kwDOABII585piLcd",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 242,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "we can modernize these slightly:\r\n```suggestion\r\n        TRANSACTIONS.try_emplace(target_wtxid, correct_tx, malleated_tx);\r\n        TRANSACTIONS.try_emplace(target_txid, correct_tx, correct_tx);\r\n\r\n        TRANSACTIONS.try_emplace(malleated_wtxid, malleated_tx, stripped_tx);\r\n```",
      "created_at": "2024-09-22T14:29:07Z",
      "updated_at": "2024-09-23T10:57:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770567453",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770567453"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 239,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770567839",
      "pull_request_review_id": 2320844778,
      "id": 1770567839,
      "node_id": "PRRC_kwDOABII585piLif",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\n+    }\n+}\n+\n+static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.first;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetStrippedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return StripWitness(tx_it->second.first);\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetMalleatedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.second;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetRandomTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, FuzzedDataProvider& fuzzed_data_provider, bool correct_only = false)\n+{\n+    auto it = txmap.begin();\n+    // Jump forward a random number of times.\n+    for (size_t i = 0; i <= fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1); ++i) it++;\n+    if (it == txmap.end()) return nullptr;\n+    return correct_only || fuzzed_data_provider.ConsumeBool() ? it->second.first : it->second.second;\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(txdownloadman_one_honest_peer, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+    std::chrono::microseconds time{244466666};\n+\n+    // Decide the target transaction. Disallow selecting a witness-stripped or non-segwit\n+    // transaction because it can lead to false negatives. This test may mark a same-txid\n+    // transaction as invalid, and we don't want that to cause rejection of the target tx.\n+    const auto& target_tx = GetRandomTx(TRANSACTIONS, fuzzed_data_provider, /*correct_only=*/true);\n+    Assert(target_tx != nullptr);\n+    Assert(target_tx->HasWitness());",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": 302,
      "original_position": 303,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "what's the reason for `Assert` in tests instead of `assert` (as both are used here)?",
      "created_at": "2024-09-22T14:30:50Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770567839",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770567839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 301,
      "original_start_line": 302,
      "start_side": "RIGHT",
      "line": 302,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770568085",
      "pull_request_review_id": 2320844778,
      "id": 1770568085,
      "node_id": "PRRC_kwDOABII585piLmV",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\n+    }\n+}\n+\n+static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.first;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetStrippedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return StripWitness(tx_it->second.first);\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetMalleatedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.second;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetRandomTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, FuzzedDataProvider& fuzzed_data_provider, bool correct_only = false)\n+{\n+    auto it = txmap.begin();\n+    // Jump forward a random number of times.\n+    for (size_t i = 0; i <= fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1); ++i) it++;",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 274,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "* aren't we jumping one more time than needed (`<=`)? This way we can't select the first value, right?\r\n* isn't `fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1` reevaluated on every iteration? What's the advantage of that over generating the limit a single time, e.g.:\r\n```C++\r\n    if (txmap.empty()) return nullptr;\r\n    size_t rand_index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1);\r\n    auto it = std::next(txmap.begin(), rand_index);\r\n    return correct_only || fuzzed_data_provider.ConsumeBool() ? it->second.first : it->second.second;\r\n```",
      "created_at": "2024-09-22T14:31:47Z",
      "updated_at": "2024-09-23T10:55:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770568085",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770568085"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770570141",
      "pull_request_review_id": 2320844778,
      "id": 1770570141,
      "node_id": "PRRC_kwDOABII585piMGd",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 75,
      "original_position": 75,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could we init it as `constexpr uint32_t NUM_COINS{50};` instead?",
      "created_at": "2024-09-22T14:42:44Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770570141",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770570141"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 75,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770582090",
      "pull_request_review_id": 2320844778,
      "id": 1770582090,
      "node_id": "PRRC_kwDOABII585piPBK",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": 157,
      "original_position": 157,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "seems we're always popping, and the queue is never empty, might as well pop once after we're getting the front value (and before we're potentially pushing):\r\n```C++\r\n// Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\r\n// not change, as DEFER may just push it to the back again.\r\nstd::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider)\r\n{\r\n    // Nothing to do if no messages to process\r\n    if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\r\n\r\n    auto request{m_getdata_queue.front()};\r\n    m_getdata_queue.pop_front();\r\n\r\n    auto response{m_good ? PossibleResponse::TX_REAL : fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES)};\r\n    if (response == PossibleResponse::DEFER) {\r\n        // Move the request from the front to the back of the queue and return nothing.\r\n        // This simulates responding out of order and/or stalling.\r\n        m_getdata_queue.emplace_back(std::move(request));\r\n        return {PossibleResponse::NOTHING, std::nullopt};\r\n    } else {\r\n        return {response, request};\r\n    }\r\n}\r\n```\r\n\r\nnote: changed to `emplace_back` and used `std::move` to avoid copies and merged `response` inits.\r\nAlso note that deleting before pushing is a tiny bit better memory-wise (but I doubt it matters here)",
      "created_at": "2024-09-22T15:45:13Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770582090",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770582090"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 157,
      "original_line": 157,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770586217",
      "pull_request_review_id": 2320844778,
      "id": 1770586217,
      "node_id": "PRRC_kwDOABII585piQBp",
      "diff_hunk": "@@ -0,0 +1,190 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_IMPL_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_IMPL_H\n+\n+#include <node/txdownloadman.h>\n+\n+#include <common/bloom.h>\n+#include <consensus/validation.h>\n+#include <kernel/chain.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <policy/packages.h>\n+#include <txorphanage.h>\n+#include <txrequest.h>\n+\n+class CTxMemPool;\n+namespace node {\n+class TxDownloadManagerImpl {\n+public:\n+    TxDownloadOptions m_opts;\n+\n+    /** Manages unvalidated tx data (orphan transactions for which we are downloading ancestors). */\n+    TxOrphanage m_orphanage;\n+    /** Tracks candidates for requesting and downloading transaction data. */\n+    TxRequestTracker m_txrequest;\n+\n+    /**\n+     * Filter for transactions that were recently rejected by the mempool.\n+     * These are not rerequested until the chain tip changes, at which point\n+     * the entire filter is reset.\n+     *\n+     * Without this filter we'd be re-requesting txs from each of our peers,\n+     * increasing bandwidth consumption considerably. For instance, with 100\n+     * peers, half of which relay a tx we don't accept, that might be a 50x\n+     * bandwidth increase. A flooding attacker attempting to roll-over the\n+     * filter using minimum-sized, 60byte, transactions might manage to send\n+     * 1000/sec if we have fast peers, so we pick 120,000 to give our peers a\n+     * two minute window to send invs to us.\n+     *\n+     * Decreasing the false positive rate is fairly cheap, so we pick one in a\n+     * million to make it highly unlikely for users to have issues with this\n+     * filter.\n+     *\n+     * We typically only add wtxids to this filter. For non-segwit\n+     * transactions, the txid == wtxid, so this only prevents us from\n+     * re-downloading non-segwit transactions when communicating with\n+     * non-wtxidrelay peers -- which is important for avoiding malleation\n+     * attacks that could otherwise interfere with transaction relay from\n+     * non-wtxidrelay peers. For communicating with wtxidrelay peers, having\n+     * the reject filter store wtxids is exactly what we want to avoid\n+     * redownload of a rejected transaction.\n+     *\n+     * In cases where we can tell that a segwit transaction will fail\n+     * validation no matter the witness, we may add the txid of such\n+     * transaction to the filter as well. This can be helpful when\n+     * communicating with txid-relay peers or if we were to otherwise fetch a\n+     * transaction via txid (eg in our orphan handling).\n+     *\n+     * Memory used: 1.3 MB\n+     */\n+    std::unique_ptr<CRollingBloomFilter> m_lazy_recent_rejects{nullptr};\n+\n+    CRollingBloomFilter& RecentRejectsFilter()\n+    {\n+        if (!m_lazy_recent_rejects) {\n+            m_lazy_recent_rejects = std::make_unique<CRollingBloomFilter>(120'000, 0.000'001);\n+        }\n+\n+        return *m_lazy_recent_rejects;\n+    }\n+\n+    /**\n+     * Filter for:\n+     * (1) wtxids of transactions that were recently rejected by the mempool but are\n+     * eligible for reconsideration if submitted with other transactions.\n+     * (2) packages (see GetPackageHash) we have already rejected before and should not retry.\n+     *\n+     * Similar to m_lazy_recent_rejects, this filter is used to save bandwidth when e.g. all of our peers\n+     * have larger mempools and thus lower minimum feerates than us.\n+     *\n+     * When a transaction's error is TxValidationResult::TX_RECONSIDERABLE (in a package or by\n+     * itself), add its wtxid to this filter. When a package fails for any reason, add the combined\n+     * hash to this filter.\n+     *\n+     * Upon receiving an announcement for a transaction, if it exists in this filter, do not\n+     * download the txdata. When considering packages, if it exists in this filter, drop it.\n+     *\n+     * Reset this filter when the chain tip changes.\n+     *\n+     * Parameters are picked to be the same as m_lazy_recent_rejects, with the same rationale.\n+     */\n+    std::unique_ptr<CRollingBloomFilter> m_lazy_recent_rejects_reconsiderable{nullptr};\n+\n+    CRollingBloomFilter& RecentRejectsReconsiderableFilter()\n+    {\n+        if (!m_lazy_recent_rejects_reconsiderable) {\n+            m_lazy_recent_rejects_reconsiderable = std::make_unique<CRollingBloomFilter>(120'000, 0.000'001);\n+        }\n+\n+        return *m_lazy_recent_rejects_reconsiderable;\n+    }\n+\n+    /*\n+     * Filter for transactions that have been recently confirmed.\n+     * We use this to avoid requesting transactions that have already been\n+     * confirnmed.",
      "path": "src/node/txdownloadman_impl.h",
      "position": null,
      "original_position": 108,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n     * confirmed.\r\n```",
      "created_at": "2024-09-22T16:09:33Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770586217",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770586217"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 108,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770587752",
      "pull_request_review_id": 2320844778,
      "id": 1770587752,
      "node_id": "PRRC_kwDOABII585piQZo",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }\n+}\n+\n+bool TxDownloadManagerImpl::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    // If this is an inv received from a peer and we already have it, we can drop it.\n+    // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\n+    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\n+    if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\n+\n+    if (m_peer_info.count(peer) == 0) return false;\n+    const auto& info = m_peer_info.at(peer).m_connection_info;\n+    if (!info.m_relay_permissions && m_txrequest.Count(peer) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements for this peer\n+        return false;\n+    }\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or NetPermissionFlags::NoBan permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for txid announcements while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from peers which have at least\n+    //     MAX_PEER_TX_REQUEST_IN_FLIGHT requests in flight (and don't have NetPermissionFlags::Relay).\n+    auto delay{0us};\n+    if (!info.m_preferred) delay += NONPREF_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && m_num_wtxid_peers > 0) delay += TXID_RELAY_DELAY;\n+    const bool overloaded = !info.m_relay_permissions && m_txrequest.CountInFlight(peer) >= MAX_PEER_TX_REQUEST_IN_FLIGHT;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+\n+    m_txrequest.ReceivedInv(peer, gtxid, info.m_preferred, now + delay);\n+\n+    return false;\n+}\n+\n+std::vector<GenTxid> TxDownloadManagerImpl::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    std::vector<GenTxid> requests;\n+    std::vector<std::pair<NodeId, GenTxid>> expired;\n+    auto requestable = m_txrequest.GetRequestable(nodeid, current_time, &expired);\n+    for (const auto& entry : expired) {\n+        LogDebug(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n+            entry.second.GetHash().ToString(), entry.first);\n+    }\n+    for (const GenTxid& gtxid : requestable) {\n+        if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+            LogDebug(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n+                gtxid.GetHash().ToString(), nodeid);\n+            requests.emplace_back(gtxid);\n+            m_txrequest.RequestedTx(nodeid, gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n+        } else {\n+            // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n+            // this should already be called whenever a transaction becomes AlreadyHaveTx().\n+            m_txrequest.ForgetTxHash(gtxid.GetHash());\n+        }\n+    }\n+    return requests;\n+}\n+\n+void TxDownloadManagerImpl::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    for (const auto& txhash : txhashes) {\n+        // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\n+        // completed in TxRequestTracker.\n+        m_txrequest.ReceivedResponse(nodeid, txhash);\n+    }\n+}\n+\n+std::optional<PackageToValidate> TxDownloadManagerImpl::Find1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    Assume(RecentRejectsReconsiderableFilter().contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child, nodeid, nodeid};\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+    // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+    // create a bias that attackers can use to delay package acceptance.\n+    //\n+    // Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    std::shuffle(tx_indices.begin(), tx_indices.end(), m_opts.m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_lazy_recent_rejects_reconsiderable.\n+        const auto [child_tx, child_sender] = cpfp_candidates_different_peer.at(index);\n+        Package maybe_cpfp_package{ptx, child_tx};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child_tx, nodeid, child_sender};\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+void TxDownloadManagerImpl::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    // As this version of the transaction was acceptable, we can forget about any requests for it.\n+    // No-op if the tx is not in txrequest.\n+    m_txrequest.ForgetTxHash(tx->GetHash());\n+    m_txrequest.ForgetTxHash(tx->GetWitnessHash());\n+\n+    m_orphanage.AddChildrenToWorkSet(*tx);\n+    // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n+    m_orphanage.EraseTx(tx->GetWitnessHash());\n+}\n+\n+node::RejectedTxTodo TxDownloadManagerImpl::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    const CTransaction& tx{*ptx};\n+    // Results returned to caller\n+    // Whether we should call AddToCompactExtraTransactions at the end\n+    bool add_extra_compact_tx{first_time_failure};\n+    // Hashes to pass to AddKnownTx later\n+    std::vector<uint256> unique_parents;\n+    // Populated if failure is reconsiderable and eligible package is found.\n+    std::optional<node::PackageToValidate> package_to_validate;\n+\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+        // Only process a new orphan if this is a first time failure, as otherwise it must be either\n+        // already in orphanage or from 1p1c processing.\n+        if (first_time_failure && !RecentRejectsFilter().contains(ptx->GetWitnessHash().ToUint256())) {\n+            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+            // Deduplicate parent txids, so that we don't have to loop over\n+            // the same parent txid more than once down below.\n+            unique_parents.reserve(tx.vin.size());\n+            for (const CTxIn& txin : tx.vin) {\n+                // We start with all parents, and then remove duplicates below.\n+                unique_parents.push_back(txin.prevout.hash);\n+            }\n+            std::sort(unique_parents.begin(), unique_parents.end());\n+            unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+            // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 329,
      "original_position": 323,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`m_lazy_recent_rejects_reconsiderable` is usually accessed through `RecentRejectsReconsiderableFilter`, might make sense to update the comments",
      "created_at": "2024-09-22T16:19:08Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770587752",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770587752"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 329,
      "original_line": 329,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770590245",
      "pull_request_review_id": 2320844778,
      "id": 1770590245,
      "node_id": "PRRC_kwDOABII585piRAl",
      "diff_hunk": "@@ -865,112 +867,23 @@ class PeerManagerImpl final : public PeerManager\n     bool AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n         EXCLUSIVE_LOCKS_REQUIRED(m_tx_download_mutex);\n \n-    /**\n-     * Filter for transactions that were recently rejected by the mempool.\n-     * These are not rerequested until the chain tip changes, at which point\n-     * the entire filter is reset.\n-     *\n-     * Without this filter we'd be re-requesting txs from each of our peers,\n-     * increasing bandwidth consumption considerably. For instance, with 100\n-     * peers, half of which relay a tx we don't accept, that might be a 50x\n-     * bandwidth increase. A flooding attacker attempting to roll-over the\n-     * filter using minimum-sized, 60byte, transactions might manage to send\n-     * 1000/sec if we have fast peers, so we pick 120,000 to give our peers a\n-     * two minute window to send invs to us.\n-     *\n-     * Decreasing the false positive rate is fairly cheap, so we pick one in a\n-     * million to make it highly unlikely for users to have issues with this\n-     * filter.\n-     *\n-     * We typically only add wtxids to this filter. For non-segwit\n-     * transactions, the txid == wtxid, so this only prevents us from\n-     * re-downloading non-segwit transactions when communicating with\n-     * non-wtxidrelay peers -- which is important for avoiding malleation\n-     * attacks that could otherwise interfere with transaction relay from\n-     * non-wtxidrelay peers. For communicating with wtxidrelay peers, having\n-     * the reject filter store wtxids is exactly what we want to avoid\n-     * redownload of a rejected transaction.\n-     *\n-     * In cases where we can tell that a segwit transaction will fail\n-     * validation no matter the witness, we may add the txid of such\n-     * transaction to the filter as well. This can be helpful when\n-     * communicating with txid-relay peers or if we were to otherwise fetch a\n-     * transaction via txid (eg in our orphan handling).\n-     *\n-     * Memory used: 1.3 MB\n-     */\n-    std::unique_ptr<CRollingBloomFilter> m_lazy_recent_rejects GUARDED_BY(m_tx_download_mutex){nullptr};\n \n     CRollingBloomFilter& RecentRejectsFilter() EXCLUSIVE_LOCKS_REQUIRED(m_tx_download_mutex)\n     {\n         AssertLockHeld(m_tx_download_mutex);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 60,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "85edaf2556c9ce531573dc3dee8fff2f7b4d9abf",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "how come we're removing all locks here?",
      "created_at": "2024-09-22T16:33:16Z",
      "updated_at": "2024-09-24T11:50:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770590245",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770590245"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 873,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770593262",
      "pull_request_review_id": 2320844778,
      "id": 1770593262,
      "node_id": "PRRC_kwDOABII585piRvu",
      "diff_hunk": "@@ -1685,6 +1595,8 @@ void PeerManagerImpl::AddTxAnnouncement(const CNode& node, const GenTxid& gtxid,\n     AssertLockHeld(::cs_main); // for State\n     AssertLockHeld(m_tx_download_mutex); // For m_txrequest\n     NodeId nodeid = node.GetId();\n+\n+    auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n     if (!node.HasPermission(NetPermissionFlags::Relay) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 150,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "85edaf2556c9ce531573dc3dee8fff2f7b4d9abf",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "what's the reason for changing `m_txrequest.Count(nodeid)` to `m_txdownloadman.GetTxRequestRef().Count` in the init but not here (85edaf2556c9ce531573dc3dee8fff2f7b4d9abf)",
      "created_at": "2024-09-22T16:50:46Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770593262",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770593262"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1600,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770637906",
      "pull_request_review_id": 2320924468,
      "id": 1770637906,
      "node_id": "PRRC_kwDOABII585picpS",
      "diff_hunk": "@@ -286,4 +288,160 @@ void TxDownloadManagerImpl::MempoolAcceptedTx(const CTransactionRef& tx)\n     // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n     m_orphanage.EraseTx(tx->GetWitnessHash());\n }\n+\n+node::RejectedTxTodo TxDownloadManagerImpl::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    const CTransaction& tx{*ptx};\n+    // Results returned to caller\n+    // Whether we should call AddToCompactExtraTransactions at the end\n+    bool add_extra_compact_tx{first_time_failure};\n+    // Hashes to pass to AddKnownTx later\n+    std::vector<uint256> unique_parents;\n+    // Populated if failure is reconsiderable and eligible package is found.\n+    std::optional<node::PackageToValidate> package_to_validate;\n+\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+        // Only process a new orphan if this is a first time failure, as otherwise it must be either\n+        // already in orphanage or from 1p1c processing.\n+        if (first_time_failure) {\n+            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+            // Deduplicate parent txids, so that we don't have to loop over\n+            // the same parent txid more than once down below.\n+            unique_parents.reserve(tx.vin.size());\n+            for (const CTxIn& txin : tx.vin) {\n+                // We start with all parents, and then remove duplicates below.\n+                unique_parents.push_back(txin.prevout.hash);\n+            }\n+            std::sort(unique_parents.begin(), unique_parents.end());\n+            unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+            // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.\n+            // We can tolerate having up to 1 parent in m_lazy_recent_rejects_reconsiderable since we\n+            // submit 1p1c packages. However, fail immediately if any are in m_lazy_recent_rejects.\n+            std::optional<uint256> rejected_parent_reconsiderable;\n+            for (const uint256& parent_txid : unique_parents) {\n+                if (RecentRejectsFilter().contains(parent_txid)) {\n+                    fRejectedParents = true;\n+                    break;\n+                } else if (RecentRejectsReconsiderableFilter().contains(parent_txid) &&\n+                           !m_opts.m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                    // More than 1 parent in m_lazy_recent_rejects_reconsiderable: 1p1c will not be\n+                    // sufficient to accept this package, so just give up here.\n+                    if (rejected_parent_reconsiderable.has_value()) {\n+                        fRejectedParents = true;\n+                        break;\n+                    }\n+                }\n+                rejected_parent_reconsiderable = parent_txid;",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "287510e9ea9e45881499bffcc1b5fa5bc803db8a",
      "in_reply_to_id": 1768765758,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> I don't understand how 0 tests failed, though ðŸ˜¬ gotta look into that\r\n\r\nyeah was a bit worrying to me too... glad we can add unit tests in this PR!",
      "created_at": "2024-09-22T21:21:23Z",
      "updated_at": "2024-09-22T21:21:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1770637906",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1770637906"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 336,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771038519",
      "pull_request_review_id": 2320844778,
      "id": 1771038519,
      "node_id": "PRRC_kwDOABII585pj-c3",
      "diff_hunk": "@@ -0,0 +1,159 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadManagerImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {\n+    /** Read-only reference to mempool. */\n+    const CTxMemPool& m_mempool;\n+    /** RNG provided by caller. */\n+    FastRandomContext& m_rng;\n+    /** Maximum number of transactions allowed in orphanage. */\n+    const uint32_t m_max_orphan_txs;\n+    /** Instantiate TxRequestTracker as deterministic (used for tests). */\n+    bool m_deterministic_txrequest{false};\n+};\n+struct TxDownloadConnectionInfo {\n+    /** Whether this peer is preferred for transaction download. */\n+    const bool m_preferred;\n+    /** Whether this peer has Relay permissions. */\n+    const bool m_relay_permissions;\n+    /** Whether this peer supports wtxid relay. */\n+    const bool m_wtxid_relay;\n+};\n+struct PackageToValidate {\n+    Package m_txns;\n+    std::vector<NodeId> m_senders;\n+    /** Construct a 1-parent-1-child package. */\n+    explicit PackageToValidate(const CTransactionRef& parent,\n+                               const CTransactionRef& child,\n+                               NodeId parent_sender,\n+                               NodeId child_sender) :\n+        m_txns{parent, child},\n+        m_senders{parent_sender, child_sender}\n+    {}\n+\n+    // Move ctor\n+    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\n+    // Copy ctor\n+    PackageToValidate(const PackageToValidate& other) = default;\n+\n+    // Move assignment\n+    PackageToValidate& operator=(PackageToValidate&& other) {\n+        this->m_txns = std::move(other.m_txns);\n+        this->m_senders = std::move(other.m_senders);\n+        return *this;\n+    }\n+\n+    std::string ToString() const {\n+        Assume(m_txns.size() == 2);\n+        return strprintf(\"parent %s (wtxid=%s, sender=%d) + child %s (wtxid=%s, sender=%d)\",\n+                         m_txns.front()->GetHash().ToString(),\n+                         m_txns.front()->GetWitnessHash().ToString(),\n+                         m_senders.front(),\n+                         m_txns.back()->GetHash().ToString(),\n+                         m_txns.back()->GetWitnessHash().ToString(),\n+                         m_senders.back());",
      "path": "src/node/txdownloadman.h",
      "position": 91,
      "original_position": 91,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: we could avoid the repetition via a lambda:\r\n```suggestion\r\n        auto format_tx{[&](const CTransactionRef& tx, NodeId sender) {\r\n            return strprintf(\"%s (wtxid=%s, sender=%d)\", tx->GetHash().ToString(), tx->GetWitnessHash().ToString(), sender);\r\n        }};\r\n        return strprintf(\"parent %s + child %s\", format_tx(m_txns.front(), m_senders.front()), format_tx(m_txns.back(), m_senders.back()));\r\n```",
      "created_at": "2024-09-23T09:18:54Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1771038519",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771038519"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 85,
      "original_start_line": 85,
      "start_side": "RIGHT",
      "line": 91,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771043258",
      "pull_request_review_id": 2320844778,
      "id": 1771043258,
      "node_id": "PRRC_kwDOABII585pj_m6",
      "diff_hunk": "@@ -0,0 +1,530 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 155,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can be modernized to:\r\n```suggestion\r\n    m_peer_info.try_emplace(nodeid, info);\r\n```",
      "created_at": "2024-09-23T09:22:33Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1771043258",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771043258"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771051808",
      "pull_request_review_id": 2320844778,
      "id": 1771051808,
      "node_id": "PRRC_kwDOABII585pkBsg",
      "diff_hunk": "@@ -4270,12 +3934,11 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     return;\n                 }\n                 const GenTxid gtxid = ToGenTxid(inv);\n-                const bool fAlreadyHave = AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true);\n-                LogDebug(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n-\n                 AddKnownTx(*peer, inv.hash);\n-                if (!fAlreadyHave && !m_chainman.IsInitialBlockDownload()) {\n-                    AddTxAnnouncement(pfrom, gtxid, current_time);\n+\n+                if (!m_chainman.IsInitialBlockDownload()) {\n+                    const bool fAlreadyHave{m_txdownloadman.AddTxAnnouncement(pfrom.GetId(), gtxid, current_time, /*p2p_inv=*/true)};\n+                    LogDebug(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());",
      "path": "src/net_processing.cpp",
      "position": 657,
      "original_position": 657,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "super-nit:\r\n```suggestion\r\n                    LogDebug(BCLog::NET, \"got inv: %s %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\r\n```",
      "created_at": "2024-09-23T09:27:46Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1771051808",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771051808"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3941,
      "original_line": 3941,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771062663",
      "pull_request_review_id": 2320844778,
      "id": 1771062663,
      "node_id": "PRRC_kwDOABII585pkEWH",
      "diff_hunk": "@@ -5449,7 +4999,7 @@ bool PeerManagerImpl::ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt\n         //  the extra work may not be noticed, possibly resulting in an\n         //  unnecessary 100ms delay)\n         LOCK(m_tx_download_mutex);\n-        if (m_orphanage.HaveTxToReconsider(peer->m_id)) fMoreWork = true;\n+        if (m_txdownloadman.HaveMoreWork(peer->m_id)) fMoreWork = true;",
      "path": "src/net_processing.cpp",
      "position": 851,
      "original_position": 851,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "do we need to call the `const` `HaveMoreWork` when `fMoreWork` was already `true`? If not, we may even avoid the the lock:\r\n```suggestion\r\n        if (!fMoreWork) {\r\n            LOCK(m_tx_download_mutex);\r\n            fMoreWork = m_txdownloadman.HaveMoreWork(peer->m_id);\r\n        }\r\n```",
      "created_at": "2024-09-23T09:34:14Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1771062663",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771062663"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 5001,
      "original_start_line": 5001,
      "start_side": "RIGHT",
      "line": 5002,
      "original_line": 5002,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771078008",
      "pull_request_review_id": 2320844778,
      "id": 1771078008,
      "node_id": "PRRC_kwDOABII585pkIF4",
      "diff_hunk": "@@ -0,0 +1,530 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "is it deliberate to return in a void method here?",
      "created_at": "2024-09-23T09:42:14Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1771078008",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771078008"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771081901",
      "pull_request_review_id": 2320844778,
      "id": 1771081901,
      "node_id": "PRRC_kwDOABII585pkJCt",
      "diff_hunk": "@@ -0,0 +1,530 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 147,
      "original_position": 147,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Seems to me we could simplify to a single return:\r\n```suggestion\r\n    return (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) \r\n           || RecentConfirmedTransactionsFilter().contains(hash) \r\n           || RecentRejectsFilter().contains(hash) \r\n           || m_opts.m_mempool.exists(gtxid);\r\n```",
      "created_at": "2024-09-23T09:45:22Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1771081901",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771081901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 143,
      "original_start_line": 143,
      "start_side": "RIGHT",
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771087858",
      "pull_request_review_id": 2320844778,
      "id": 1771087858,
      "node_id": "PRRC_kwDOABII585pkKfy",
      "diff_hunk": "@@ -0,0 +1,530 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }\n+}\n+\n+bool TxDownloadManagerImpl::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    // If this is an inv received from a peer and we already have it, we can drop it.\n+    // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\n+    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\n+    if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\n+\n+    if (m_peer_info.count(peer) == 0) return false;\n+    const auto& info = m_peer_info.at(peer).m_connection_info;\n+    if (!info.m_relay_permissions && m_txrequest.Count(peer) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements for this peer\n+        return false;\n+    }\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or NetPermissionFlags::NoBan permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for txid announcements while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from peers which have at least\n+    //     MAX_PEER_TX_REQUEST_IN_FLIGHT requests in flight (and don't have NetPermissionFlags::Relay).\n+    auto delay{0us};\n+    if (!info.m_preferred) delay += NONPREF_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && m_num_wtxid_peers > 0) delay += TXID_RELAY_DELAY;\n+    const bool overloaded = !info.m_relay_permissions && m_txrequest.CountInFlight(peer) >= MAX_PEER_TX_REQUEST_IN_FLIGHT;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+\n+    m_txrequest.ReceivedInv(peer, gtxid, info.m_preferred, now + delay);\n+\n+    return false;\n+}\n+\n+std::vector<GenTxid> TxDownloadManagerImpl::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    std::vector<GenTxid> requests;\n+    std::vector<std::pair<NodeId, GenTxid>> expired;\n+    auto requestable = m_txrequest.GetRequestable(nodeid, current_time, &expired);\n+    for (const auto& entry : expired) {\n+        LogDebug(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n+            entry.second.GetHash().ToString(), entry.first);\n+    }\n+    for (const GenTxid& gtxid : requestable) {\n+        if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+            LogDebug(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n+                gtxid.GetHash().ToString(), nodeid);\n+            requests.emplace_back(gtxid);\n+            m_txrequest.RequestedTx(nodeid, gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n+        } else {\n+            // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n+            // this should already be called whenever a transaction becomes AlreadyHaveTx().\n+            m_txrequest.ForgetTxHash(gtxid.GetHash());\n+        }\n+    }\n+    return requests;\n+}\n+\n+void TxDownloadManagerImpl::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    for (const auto& txhash : txhashes) {\n+        // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\n+        // completed in TxRequestTracker.\n+        m_txrequest.ReceivedResponse(nodeid, txhash);\n+    }\n+}\n+\n+std::optional<PackageToValidate> TxDownloadManagerImpl::Find1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    Assume(RecentRejectsReconsiderableFilter().contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child, nodeid, nodeid};\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+    // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+    // create a bias that attackers can use to delay package acceptance.\n+    //\n+    // Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    std::shuffle(tx_indices.begin(), tx_indices.end(), m_opts.m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_lazy_recent_rejects_reconsiderable.\n+        const auto [child_tx, child_sender] = cpfp_candidates_different_peer.at(index);\n+        Package maybe_cpfp_package{ptx, child_tx};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child_tx, nodeid, child_sender};\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+void TxDownloadManagerImpl::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    // As this version of the transaction was acceptable, we can forget about any requests for it.\n+    // No-op if the tx is not in txrequest.\n+    m_txrequest.ForgetTxHash(tx->GetHash());\n+    m_txrequest.ForgetTxHash(tx->GetWitnessHash());\n+\n+    m_orphanage.AddChildrenToWorkSet(*tx);\n+    // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n+    m_orphanage.EraseTx(tx->GetWitnessHash());\n+}\n+\n+node::RejectedTxTodo TxDownloadManagerImpl::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    const CTransaction& tx{*ptx};\n+    // Results returned to caller\n+    // Whether we should call AddToCompactExtraTransactions at the end\n+    bool add_extra_compact_tx{first_time_failure};\n+    // Hashes to pass to AddKnownTx later\n+    std::vector<uint256> unique_parents;\n+    // Populated if failure is reconsiderable and eligible package is found.\n+    std::optional<node::PackageToValidate> package_to_validate;\n+\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+        // Only process a new orphan if this is a first time failure, as otherwise it must be either\n+        // already in orphanage or from 1p1c processing.\n+        if (first_time_failure && !RecentRejectsFilter().contains(ptx->GetWitnessHash().ToUint256())) {\n+            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+            // Deduplicate parent txids, so that we don't have to loop over\n+            // the same parent txid more than once down below.\n+            unique_parents.reserve(tx.vin.size());\n+            for (const CTxIn& txin : tx.vin) {\n+                // We start with all parents, and then remove duplicates below.\n+                unique_parents.push_back(txin.prevout.hash);\n+            }\n+            std::sort(unique_parents.begin(), unique_parents.end());\n+            unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+            // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.\n+            // We can tolerate having up to 1 parent in m_lazy_recent_rejects_reconsiderable since we\n+            // submit 1p1c packages. However, fail immediately if any are in m_lazy_recent_rejects.\n+            std::optional<uint256> rejected_parent_reconsiderable;\n+            for (const uint256& parent_txid : unique_parents) {\n+                if (RecentRejectsFilter().contains(parent_txid)) {\n+                    fRejectedParents = true;\n+                    break;\n+                } else if (RecentRejectsReconsiderableFilter().contains(parent_txid) &&\n+                           !m_opts.m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                    // More than 1 parent in m_lazy_recent_rejects_reconsiderable: 1p1c will not be\n+                    // sufficient to accept this package, so just give up here.\n+                    if (rejected_parent_reconsiderable.has_value()) {\n+                        fRejectedParents = true;\n+                        break;\n+                    }\n+                    rejected_parent_reconsiderable = parent_txid;\n+                }\n+            }\n+            if (!fRejectedParents) {\n+                const auto current_time{GetTime<std::chrono::microseconds>()};\n+\n+                for (const uint256& parent_txid : unique_parents) {\n+                    // Here, we only have the txid (and not wtxid) of the\n+                    // inputs, so we only request in txid mode, even for\n+                    // wtxidrelay peers.\n+                    // Eventually we should replace this with an improved\n+                    // protocol for getting all unconfirmed parents.\n+                    const auto gtxid{GenTxid::Txid(parent_txid)};\n+                    // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n+                    // previously rejected for being too low feerate. This orphan might CPFP it.\n+                    if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+                        AddTxAnnouncement(nodeid, gtxid, current_time, /*p2p_inv=*/false);\n+                    }\n+                }\n+\n+                // Potentially flip add_extra_compact_tx to false if AddTx returns false because the tx was already there\n+                add_extra_compact_tx &= m_orphanage.AddTx(ptx, nodeid);\n+\n+                // Once added to the orphan pool, a tx is considered AlreadyHave, and we shouldn't request it anymore.\n+                m_txrequest.ForgetTxHash(tx.GetHash());\n+                m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+\n+                // DoS prevention: do not allow m_orphanage to grow unbounded (see CVE-2012-3789)\n+                m_orphanage.LimitOrphans(m_opts.m_max_orphan_txs, m_opts.m_rng);\n+            } else {\n+                unique_parents.clear();\n+                LogDebug(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s (wtxid=%s)\\n\",\n+                         tx.GetHash().ToString(),\n+                         tx.GetWitnessHash().ToString());\n+                // We will continue to reject this tx since it has rejected\n+                // parents so avoid re-requesting it from other peers.\n+                // Here we add both the txid and the wtxid, as we know that\n+                // regardless of what witness is provided, we will not accept\n+                // this, so we don't need to allow for redownload of this txid\n+                // from any of our non-wtxidrelay peers.\n+                RecentRejectsFilter().insert(tx.GetHash().ToUint256());\n+                RecentRejectsFilter().insert(tx.GetWitnessHash().ToUint256());\n+                m_txrequest.ForgetTxHash(tx.GetHash());\n+                m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+            }\n+        }\n+        // Whether or not we added an orphan, quit here.\n+        return RejectedTxTodo{\n+            .m_should_add_extra_compact_tx = add_extra_compact_tx,\n+            .m_unique_parents = std::move(unique_parents),\n+            .m_package_to_validate = std::nullopt\n+        };\n+    } else if (state.GetResult() == TxValidationResult::TX_WITNESS_STRIPPED) {\n+        add_extra_compact_tx = false;\n+    } else {\n+        // We can add the wtxid of this transaction to our reject filter.\n+        // Do not add txids of witness transactions or witness-stripped\n+        // transactions to the filter, as they can have been malleated;\n+        // adding such txids to the reject filter would potentially\n+        // interfere with relay of valid transactions from peers that\n+        // do not support wtxid-based relay. See\n+        // https://github.com/bitcoin/bitcoin/issues/8279 for details.\n+        // We can remove this restriction (and always add wtxids to\n+        // the filter even for witness stripped transactions) once\n+        // wtxid-based relay is broadly deployed.\n+        // See also comments in https://github.com/bitcoin/bitcoin/pull/18044#discussion_r443419034\n+        // for concerns around weakening security of unupgraded nodes\n+        // if we start doing this too early.\n+        if (state.GetResult() == TxValidationResult::TX_RECONSIDERABLE) {\n+            // If the result is TX_RECONSIDERABLE, add it to m_lazy_recent_rejects_reconsiderable\n+            // because we should not download or submit this transaction by itself again, but may\n+            // submit it as part of a package later.\n+            RecentRejectsReconsiderableFilter().insert(ptx->GetWitnessHash().ToUint256());\n+\n+            if (first_time_failure) {\n+                // When a transaction fails for TX_RECONSIDERABLE, look for a matching child in the\n+                // orphanage, as it is possible that they succeed as a package.\n+                LogDebug(BCLog::TXPACKAGES, \"tx %s (wtxid=%s) failed but reconsiderable, looking for child in orphanage\\n\",\n+                         ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString());\n+                package_to_validate = Find1P1CPackage(ptx, nodeid);\n+            }\n+        } else {\n+            RecentRejectsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+        // If the transaction failed for TX_INPUTS_NOT_STANDARD,\n+        // then we know that the witness was irrelevant to the policy\n+        // failure, since this check depends only on the txid\n+        // (the scriptPubKey being spent is covered by the txid).\n+        // Add the txid to the reject filter to prevent repeated\n+        // processing of this transaction in the event that child\n+        // transactions are later received (resulting in\n+        // parent-fetching by txid via the orphan-handling logic).\n+        // We only add the txid if it differs from the wtxid, to avoid wasting entries in the\n+        // rolling bloom filter.\n+        if (state.GetResult() == TxValidationResult::TX_INPUTS_NOT_STANDARD && ptx->HasWitness()) {\n+            RecentRejectsFilter().insert(ptx->GetHash().ToUint256());\n+            m_txrequest.ForgetTxHash(ptx->GetHash());\n+        }\n+    }\n+\n+    // If the tx failed in ProcessOrphanTx, it should be removed from the orphanage unless the\n+    // tx was still missing inputs. If the tx was not in the orphanage, EraseTx does nothing and returns 0.\n+    if (state.GetResult() != TxValidationResult::TX_MISSING_INPUTS && m_orphanage.EraseTx(ptx->GetWitnessHash()) > 0) {\n+        LogDebug(BCLog::TXPACKAGES, \"   removed orphan tx %s (wtxid=%s)\\n\", ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString());\n+    }\n+\n+    return RejectedTxTodo{\n+        .m_should_add_extra_compact_tx = add_extra_compact_tx,\n+        .m_unique_parents = std::move(unique_parents),\n+        .m_package_to_validate = std::move(package_to_validate)\n+    };\n+}\n+\n+void TxDownloadManagerImpl::MempoolRejectedPackage(const Package& package)\n+{\n+    RecentRejectsReconsiderableFilter().insert(GetPackageHash(package));\n+}\n+\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManagerImpl::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    const uint256& txid = ptx->GetHash();\n+    const uint256& wtxid = ptx->GetWitnessHash();\n+\n+    // Mark that we have received a response\n+    m_txrequest.ReceivedResponse(nodeid, txid);\n+    if (ptx->HasWitness()) m_txrequest.ReceivedResponse(nodeid, wtxid);\n+\n+    // First check if we should drop this tx.\n+    // We do the AlreadyHaveTx() check using wtxid, rather than txid - in the\n+    // absence of witness malleation, this is strictly better, because the\n+    // recent rejects filter may contain the wtxid but rarely contains\n+    // the txid of a segwit transaction that has been rejected.\n+    // In the presence of witness malleation, it's possible that by only\n+    // doing the check with wtxid, we could overlook a transaction which\n+    // was confirmed with a different witness, or exists in our mempool\n+    // with a different witness, but this has limited downside:\n+    // mempool validation does its own lookup of whether we have the txid\n+    // already; and an adversary can already relay us old transactions\n+    // (older than our recency filter) if trying to DoS us, without any need\n+    // for witness malleation.\n+    if (AlreadyHaveTx(GenTxid::Wtxid(wtxid), /*include_reconsiderable=*/false)) {\n+        // If a tx is detected by m_lazy_recent_rejects it is ignored. Because we haven't\n+        // submitted the tx to our mempool, we won't have computed a DoS\n+        // score for it or determined exactly why we consider it invalid.\n+        //\n+        // This means we won't penalize any peer subsequently relaying a DoSy\n+        // tx (even if we penalized the first peer who gave it to us) because\n+        // we have to account for m_lazy_recent_rejects showing false positives. In\n+        // other words, we shouldn't penalize a peer if we aren't *sure* they\n+        // submitted a DoSy tx.\n+        //\n+        // Note that m_lazy_recent_rejects doesn't just record DoSy or invalid\n+        // transactions, but any tx not accepted by the mempool, which may be\n+        // due to node policy (vs. consensus). So we can't blanket penalize a\n+        // peer simply for relaying a tx that our m_lazy_recent_rejects has caught,\n+        // regardless of false positives.\n+        return std::make_pair(false, std::nullopt);\n+    } else if (RecentRejectsReconsiderableFilter().contains(wtxid)) {\n+        // When a transaction is already in m_lazy_recent_rejects_reconsiderable, we shouldn't submit\n+        // it by itself again. However, look for a matching child in the orphanage, as it is\n+        // possible that they succeed as a package.\n+        LogDebug(BCLog::TXPACKAGES, \"found tx %s (wtxid=%s) in reconsiderable rejects, looking for child in orphanage\\n\",\n+                 txid.ToString(), wtxid.ToString());\n+        return std::make_pair(false, Find1P1CPackage(ptx, nodeid));\n+    }\n+\n+\n+    return std::make_pair(true, std::nullopt);",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 507,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "we should be able to modernize these:\r\n```suggestion\r\n        return {false, Find1P1CPackage(ptx, nodeid)};\r\n    }\r\n\r\n\r\n    return {true, std::nullopt};\r\n```",
      "created_at": "2024-09-23T09:49:38Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1771087858",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771087858"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 503,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 507,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771088927",
      "pull_request_review_id": 2320844778,
      "id": 1771088927,
      "node_id": "PRRC_kwDOABII585pkKwf",
      "diff_hunk": "@@ -0,0 +1,190 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_IMPL_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_IMPL_H\n+\n+#include <node/txdownloadman.h>\n+\n+#include <common/bloom.h>\n+#include <consensus/validation.h>\n+#include <kernel/chain.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <policy/packages.h>\n+#include <txorphanage.h>\n+#include <txrequest.h>\n+\n+class CTxMemPool;\n+namespace node {\n+class TxDownloadManagerImpl {\n+public:\n+    TxDownloadOptions m_opts;\n+\n+    /** Manages unvalidated tx data (orphan transactions for which we are downloading ancestors). */\n+    TxOrphanage m_orphanage;\n+    /** Tracks candidates for requesting and downloading transaction data. */\n+    TxRequestTracker m_txrequest;\n+\n+    /**\n+     * Filter for transactions that were recently rejected by the mempool.\n+     * These are not rerequested until the chain tip changes, at which point\n+     * the entire filter is reset.\n+     *\n+     * Without this filter we'd be re-requesting txs from each of our peers,\n+     * increasing bandwidth consumption considerably. For instance, with 100\n+     * peers, half of which relay a tx we don't accept, that might be a 50x\n+     * bandwidth increase. A flooding attacker attempting to roll-over the\n+     * filter using minimum-sized, 60byte, transactions might manage to send\n+     * 1000/sec if we have fast peers, so we pick 120,000 to give our peers a\n+     * two minute window to send invs to us.\n+     *\n+     * Decreasing the false positive rate is fairly cheap, so we pick one in a\n+     * million to make it highly unlikely for users to have issues with this\n+     * filter.\n+     *\n+     * We typically only add wtxids to this filter. For non-segwit\n+     * transactions, the txid == wtxid, so this only prevents us from\n+     * re-downloading non-segwit transactions when communicating with\n+     * non-wtxidrelay peers -- which is important for avoiding malleation\n+     * attacks that could otherwise interfere with transaction relay from\n+     * non-wtxidrelay peers. For communicating with wtxidrelay peers, having\n+     * the reject filter store wtxids is exactly what we want to avoid\n+     * redownload of a rejected transaction.\n+     *\n+     * In cases where we can tell that a segwit transaction will fail\n+     * validation no matter the witness, we may add the txid of such\n+     * transaction to the filter as well. This can be helpful when\n+     * communicating with txid-relay peers or if we were to otherwise fetch a\n+     * transaction via txid (eg in our orphan handling).\n+     *\n+     * Memory used: 1.3 MB",
      "path": "src/node/txdownloadman_impl.h",
      "position": 61,
      "original_position": 61,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "do we know if this is still the case?",
      "created_at": "2024-09-23T09:50:27Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1771088927",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771088927"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 61,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771093497",
      "pull_request_review_id": 2320844778,
      "id": 1771093497,
      "node_id": "PRRC_kwDOABII585pkL35",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (maybe_package.has_value()) CheckPackageToValidate(*maybe_package, rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        // Jump forwards or backwards\n+        auto time_skip = fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+        if (fuzzed_data_provider.ConsumeBool()) time_skip *= -1;\n+        time += time_skip;\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadManagerImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+    txdownload_impl.m_txrequest.SanityCheck();\n+}\n+\n+FUZZ_TARGET(txdownloadman_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadManagerImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManagerImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                for (const auto& tx : TRANSACTIONS) {\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(tx->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(tx->GetHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(tx->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(tx->GetHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    CheckPackageToValidate(*maybe_package, rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(GetPackageHash(package)));\n+                    // Neither is in m_lazy_recent_rejects\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                txdownload_impl.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownload_impl.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownload_impl.GetTxToReconsider(rand_peer);",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 395,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: previous line used brace initialization, this one uses assignment",
      "created_at": "2024-09-23T09:53:41Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1771093497",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771093497"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 395,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771098235",
      "pull_request_review_id": 2320844778,
      "id": 1771098235,
      "node_id": "PRRC_kwDOABII585pkNB7",
      "diff_hunk": "@@ -0,0 +1,339 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <addresstype.h>\n+#include <consensus/validation.h>\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <primitives/transaction.h>\n+#include <script/script.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static bool CheckOrphanBehavior(node::TxDownloadManagerImpl& txdownload_impl, const CTransactionRef& tx, const node::RejectedTxTodo& ret, std::string& err_msg,\n+                                bool expect_orphan, bool expect_keep, unsigned int expected_parents)\n+{\n+    // Missing inputs can never result in a PackageToValidate.\n+    if (ret.m_package_to_validate.has_value()) {\n+        err_msg = strprintf(\"returned a PackageToValidate on missing inputs\");\n+        return false;",
      "path": "src/test/txdownload_tests.cpp",
      "position": 81,
      "original_position": 81,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "so we're setting an input param and returning whether we've modified it, right?\r\nCould we modernize it to return an `std::optional` instead?",
      "created_at": "2024-09-23T09:56:39Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1771098235",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771098235"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 80,
      "original_start_line": 80,
      "start_side": "RIGHT",
      "line": 81,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771111489",
      "pull_request_review_id": 2320844778,
      "id": 1771111489,
      "node_id": "PRRC_kwDOABII585pkQRB",
      "diff_hunk": "@@ -0,0 +1,159 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadManagerImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;",
      "path": "src/node/txdownloadman.h",
      "position": 27,
      "original_position": 27,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: brace inits vs assignments",
      "created_at": "2024-09-23T10:06:26Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1771111489",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771111489"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 27,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771117667",
      "pull_request_review_id": 2320844778,
      "id": 1771117667,
      "node_id": "PRRC_kwDOABII585pkRxj",
      "diff_hunk": "@@ -0,0 +1,530 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 87,
      "original_position": 87,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "what's the role of this comment, is it just a delimiter?",
      "created_at": "2024-09-23T10:11:14Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1771117667",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771117667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 87,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771123840",
      "pull_request_review_id": 2320844778,
      "id": 1771123840,
      "node_id": "PRRC_kwDOABII585pkTSA",
      "diff_hunk": "@@ -0,0 +1,530 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 141,
      "original_position": 141,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't understand the purpose of this, basically if orphanage has the hash transaction, we're returning true, regardless of whether IsWtxid or not.\r\n```suggestion\r\n    if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\r\n```",
      "created_at": "2024-09-23T10:16:06Z",
      "updated_at": "2024-09-23T10:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1771123840",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771123840"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 125,
      "original_start_line": 125,
      "start_side": "RIGHT",
      "line": 141,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771221285",
      "pull_request_review_id": 2321889186,
      "id": 1771221285,
      "node_id": "PRRC_kwDOABII585pkrEl",
      "diff_hunk": "@@ -286,4 +288,160 @@ void TxDownloadManagerImpl::MempoolAcceptedTx(const CTransactionRef& tx)\n     // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n     m_orphanage.EraseTx(tx->GetWitnessHash());\n }\n+\n+node::RejectedTxTodo TxDownloadManagerImpl::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    const CTransaction& tx{*ptx};\n+    // Results returned to caller\n+    // Whether we should call AddToCompactExtraTransactions at the end\n+    bool add_extra_compact_tx{first_time_failure};\n+    // Hashes to pass to AddKnownTx later\n+    std::vector<uint256> unique_parents;\n+    // Populated if failure is reconsiderable and eligible package is found.\n+    std::optional<node::PackageToValidate> package_to_validate;\n+\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+        // Only process a new orphan if this is a first time failure, as otherwise it must be either\n+        // already in orphanage or from 1p1c processing.\n+        if (first_time_failure) {\n+            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+            // Deduplicate parent txids, so that we don't have to loop over\n+            // the same parent txid more than once down below.\n+            unique_parents.reserve(tx.vin.size());\n+            for (const CTxIn& txin : tx.vin) {\n+                // We start with all parents, and then remove duplicates below.\n+                unique_parents.push_back(txin.prevout.hash);\n+            }\n+            std::sort(unique_parents.begin(), unique_parents.end());\n+            unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+            // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.\n+            // We can tolerate having up to 1 parent in m_lazy_recent_rejects_reconsiderable since we\n+            // submit 1p1c packages. However, fail immediately if any are in m_lazy_recent_rejects.\n+            std::optional<uint256> rejected_parent_reconsiderable;\n+            for (const uint256& parent_txid : unique_parents) {\n+                if (RecentRejectsFilter().contains(parent_txid)) {\n+                    fRejectedParents = true;\n+                    break;\n+                } else if (RecentRejectsReconsiderableFilter().contains(parent_txid) &&\n+                           !m_opts.m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                    // More than 1 parent in m_lazy_recent_rejects_reconsiderable: 1p1c will not be\n+                    // sufficient to accept this package, so just give up here.\n+                    if (rejected_parent_reconsiderable.has_value()) {\n+                        fRejectedParents = true;\n+                        break;\n+                    }\n+                }\n+                rejected_parent_reconsiderable = parent_txid;",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "287510e9ea9e45881499bffcc1b5fa5bc803db8a",
      "in_reply_to_id": 1768765758,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added some unit tests yesterday btw, should definitely catch this in I think 2 cases.",
      "created_at": "2024-09-23T11:18:42Z",
      "updated_at": "2024-09-23T11:18:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1771221285",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1771221285"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 336,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772385648",
      "pull_request_review_id": 2323753194,
      "id": 1772385648,
      "node_id": "PRRC_kwDOABII585ppHVw",
      "diff_hunk": "@@ -583,53 +568,29 @@ class PeerManagerImpl final : public PeerManager\n     bool MaybeDiscourageAndDisconnect(CNode& pnode, Peer& peer);\n \n     /** Handle a transaction whose result was not MempoolAcceptResult::ResultType::VALID.\n-     * @param[in]   maybe_add_extra_compact_tx    Whether this tx should be added to vExtraTxnForCompact.\n+     * @param[in]   first_time_failure            Whether we should consider inserting into vExtraTxnForCompact, adding",
      "path": "src/net_processing.cpp",
      "position": 45,
      "original_position": 45,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770544781,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "- Are the other parameters not self-explanatory?\r\n- What do you mean by weird?",
      "created_at": "2024-09-24T00:41:22Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1772385648",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772385648"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 571,
      "original_line": 571,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772386007",
      "pull_request_review_id": 2323753194,
      "id": 1772386007,
      "node_id": "PRRC_kwDOABII585ppHbX",
      "diff_hunk": "@@ -4270,12 +3934,11 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     return;\n                 }\n                 const GenTxid gtxid = ToGenTxid(inv);\n-                const bool fAlreadyHave = AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true);\n-                LogDebug(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n-\n                 AddKnownTx(*peer, inv.hash);\n-                if (!fAlreadyHave && !m_chainman.IsInitialBlockDownload()) {\n-                    AddTxAnnouncement(pfrom, gtxid, current_time);\n+\n+                if (!m_chainman.IsInitialBlockDownload()) {\n+                    const bool fAlreadyHave{m_txdownloadman.AddTxAnnouncement(pfrom.GetId(), gtxid, current_time, /*p2p_inv=*/true)};\n+                    LogDebug(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());",
      "path": "src/net_processing.cpp",
      "position": 657,
      "original_position": 657,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": 1771051808,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The string isn't changed in this PR, marking as resolved. Can be done in a followup.",
      "created_at": "2024-09-24T00:42:01Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1772386007",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772386007"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3941,
      "original_line": 3941,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772395176",
      "pull_request_review_id": 2323753194,
      "id": 1772395176,
      "node_id": "PRRC_kwDOABII585ppJqo",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }\n+}\n+\n+bool TxDownloadManagerImpl::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    // If this is an inv received from a peer and we already have it, we can drop it.\n+    // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\n+    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\n+    if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\n+\n+    if (m_peer_info.count(peer) == 0) return false;\n+    const auto& info = m_peer_info.at(peer).m_connection_info;\n+    if (!info.m_relay_permissions && m_txrequest.Count(peer) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements for this peer\n+        return false;\n+    }\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or NetPermissionFlags::NoBan permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for txid announcements while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from peers which have at least\n+    //     MAX_PEER_TX_REQUEST_IN_FLIGHT requests in flight (and don't have NetPermissionFlags::Relay).\n+    auto delay{0us};\n+    if (!info.m_preferred) delay += NONPREF_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && m_num_wtxid_peers > 0) delay += TXID_RELAY_DELAY;\n+    const bool overloaded = !info.m_relay_permissions && m_txrequest.CountInFlight(peer) >= MAX_PEER_TX_REQUEST_IN_FLIGHT;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+\n+    m_txrequest.ReceivedInv(peer, gtxid, info.m_preferred, now + delay);\n+\n+    return false;\n+}\n+\n+std::vector<GenTxid> TxDownloadManagerImpl::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    std::vector<GenTxid> requests;\n+    std::vector<std::pair<NodeId, GenTxid>> expired;\n+    auto requestable = m_txrequest.GetRequestable(nodeid, current_time, &expired);\n+    for (const auto& entry : expired) {\n+        LogDebug(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n+            entry.second.GetHash().ToString(), entry.first);\n+    }\n+    for (const GenTxid& gtxid : requestable) {\n+        if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+            LogDebug(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n+                gtxid.GetHash().ToString(), nodeid);\n+            requests.emplace_back(gtxid);\n+            m_txrequest.RequestedTx(nodeid, gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n+        } else {\n+            // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n+            // this should already be called whenever a transaction becomes AlreadyHaveTx().\n+            m_txrequest.ForgetTxHash(gtxid.GetHash());\n+        }\n+    }\n+    return requests;\n+}\n+\n+void TxDownloadManagerImpl::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    for (const auto& txhash : txhashes) {\n+        // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\n+        // completed in TxRequestTracker.\n+        m_txrequest.ReceivedResponse(nodeid, txhash);\n+    }\n+}\n+\n+std::optional<PackageToValidate> TxDownloadManagerImpl::Find1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    Assume(RecentRejectsReconsiderableFilter().contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child, nodeid, nodeid};\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+    // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+    // create a bias that attackers can use to delay package acceptance.\n+    //\n+    // Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    std::shuffle(tx_indices.begin(), tx_indices.end(), m_opts.m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_lazy_recent_rejects_reconsiderable.\n+        const auto [child_tx, child_sender] = cpfp_candidates_different_peer.at(index);",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 277,
      "original_position": 275,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770558551,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Considering this out of scope as it is being moved, not introduced.\r\n\r\nAlso, this is intended for deletion in #28031.",
      "created_at": "2024-09-24T00:57:45Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1772395176",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772395176"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 264,
      "original_start_line": 262,
      "start_side": "RIGHT",
      "line": 277,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772396013",
      "pull_request_review_id": 2323753194,
      "id": 1772396013,
      "node_id": "PRRC_kwDOABII585ppJ3t",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }\n+}\n+\n+bool TxDownloadManagerImpl::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    // If this is an inv received from a peer and we already have it, we can drop it.\n+    // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\n+    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\n+    if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\n+\n+    if (m_peer_info.count(peer) == 0) return false;\n+    const auto& info = m_peer_info.at(peer).m_connection_info;\n+    if (!info.m_relay_permissions && m_txrequest.Count(peer) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements for this peer\n+        return false;\n+    }\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or NetPermissionFlags::NoBan permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for txid announcements while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from peers which have at least\n+    //     MAX_PEER_TX_REQUEST_IN_FLIGHT requests in flight (and don't have NetPermissionFlags::Relay).\n+    auto delay{0us};\n+    if (!info.m_preferred) delay += NONPREF_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && m_num_wtxid_peers > 0) delay += TXID_RELAY_DELAY;\n+    const bool overloaded = !info.m_relay_permissions && m_txrequest.CountInFlight(peer) >= MAX_PEER_TX_REQUEST_IN_FLIGHT;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+\n+    m_txrequest.ReceivedInv(peer, gtxid, info.m_preferred, now + delay);\n+\n+    return false;\n+}\n+\n+std::vector<GenTxid> TxDownloadManagerImpl::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    std::vector<GenTxid> requests;\n+    std::vector<std::pair<NodeId, GenTxid>> expired;\n+    auto requestable = m_txrequest.GetRequestable(nodeid, current_time, &expired);\n+    for (const auto& entry : expired) {\n+        LogDebug(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n+            entry.second.GetHash().ToString(), entry.first);\n+    }\n+    for (const GenTxid& gtxid : requestable) {\n+        if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+            LogDebug(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n+                gtxid.GetHash().ToString(), nodeid);\n+            requests.emplace_back(gtxid);\n+            m_txrequest.RequestedTx(nodeid, gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n+        } else {\n+            // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n+            // this should already be called whenever a transaction becomes AlreadyHaveTx().\n+            m_txrequest.ForgetTxHash(gtxid.GetHash());\n+        }\n+    }\n+    return requests;\n+}\n+\n+void TxDownloadManagerImpl::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    for (const auto& txhash : txhashes) {\n+        // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\n+        // completed in TxRequestTracker.\n+        m_txrequest.ReceivedResponse(nodeid, txhash);\n+    }\n+}\n+\n+std::optional<PackageToValidate> TxDownloadManagerImpl::Find1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    Assume(RecentRejectsReconsiderableFilter().contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child, nodeid, nodeid};\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+    // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+    // create a bias that attackers can use to delay package acceptance.\n+    //\n+    // Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    std::shuffle(tx_indices.begin(), tx_indices.end(), m_opts.m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_lazy_recent_rejects_reconsiderable.\n+        const auto [child_tx, child_sender] = cpfp_candidates_different_peer.at(index);\n+        Package maybe_cpfp_package{ptx, child_tx};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child_tx, nodeid, child_sender};\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+void TxDownloadManagerImpl::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    // As this version of the transaction was acceptable, we can forget about any requests for it.\n+    // No-op if the tx is not in txrequest.\n+    m_txrequest.ForgetTxHash(tx->GetHash());\n+    m_txrequest.ForgetTxHash(tx->GetWitnessHash());\n+\n+    m_orphanage.AddChildrenToWorkSet(*tx);\n+    // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n+    m_orphanage.EraseTx(tx->GetWitnessHash());\n+}\n+\n+node::RejectedTxTodo TxDownloadManagerImpl::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    const CTransaction& tx{*ptx};\n+    // Results returned to caller\n+    // Whether we should call AddToCompactExtraTransactions at the end\n+    bool add_extra_compact_tx{first_time_failure};\n+    // Hashes to pass to AddKnownTx later\n+    std::vector<uint256> unique_parents;\n+    // Populated if failure is reconsiderable and eligible package is found.\n+    std::optional<node::PackageToValidate> package_to_validate;\n+\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+        // Only process a new orphan if this is a first time failure, as otherwise it must be either\n+        // already in orphanage or from 1p1c processing.\n+        if (first_time_failure && !RecentRejectsFilter().contains(ptx->GetWitnessHash().ToUint256())) {\n+            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+            // Deduplicate parent txids, so that we don't have to loop over\n+            // the same parent txid more than once down below.\n+            unique_parents.reserve(tx.vin.size());\n+            for (const CTxIn& txin : tx.vin) {\n+                // We start with all parents, and then remove duplicates below.\n+                unique_parents.push_back(txin.prevout.hash);\n+            }\n+            std::sort(unique_parents.begin(), unique_parents.end());\n+            unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 327,
      "original_position": 321,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770561104,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Considering this out of scope as it is being moved, not introduced.",
      "created_at": "2024-09-24T00:57:57Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1772396013",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772396013"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 326,
      "original_start_line": 320,
      "start_side": "RIGHT",
      "line": 327,
      "original_line": 327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772396205",
      "pull_request_review_id": 2323753194,
      "id": 1772396205,
      "node_id": "PRRC_kwDOABII585ppJ6t",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }\n+}\n+\n+bool TxDownloadManagerImpl::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    // If this is an inv received from a peer and we already have it, we can drop it.\n+    // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\n+    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\n+    if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\n+\n+    if (m_peer_info.count(peer) == 0) return false;\n+    const auto& info = m_peer_info.at(peer).m_connection_info;\n+    if (!info.m_relay_permissions && m_txrequest.Count(peer) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements for this peer\n+        return false;\n+    }\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or NetPermissionFlags::NoBan permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for txid announcements while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from peers which have at least\n+    //     MAX_PEER_TX_REQUEST_IN_FLIGHT requests in flight (and don't have NetPermissionFlags::Relay).\n+    auto delay{0us};\n+    if (!info.m_preferred) delay += NONPREF_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && m_num_wtxid_peers > 0) delay += TXID_RELAY_DELAY;\n+    const bool overloaded = !info.m_relay_permissions && m_txrequest.CountInFlight(peer) >= MAX_PEER_TX_REQUEST_IN_FLIGHT;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+\n+    m_txrequest.ReceivedInv(peer, gtxid, info.m_preferred, now + delay);\n+\n+    return false;\n+}\n+\n+std::vector<GenTxid> TxDownloadManagerImpl::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    std::vector<GenTxid> requests;\n+    std::vector<std::pair<NodeId, GenTxid>> expired;\n+    auto requestable = m_txrequest.GetRequestable(nodeid, current_time, &expired);\n+    for (const auto& entry : expired) {\n+        LogDebug(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n+            entry.second.GetHash().ToString(), entry.first);\n+    }\n+    for (const GenTxid& gtxid : requestable) {\n+        if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+            LogDebug(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n+                gtxid.GetHash().ToString(), nodeid);\n+            requests.emplace_back(gtxid);\n+            m_txrequest.RequestedTx(nodeid, gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n+        } else {\n+            // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n+            // this should already be called whenever a transaction becomes AlreadyHaveTx().\n+            m_txrequest.ForgetTxHash(gtxid.GetHash());\n+        }\n+    }\n+    return requests;\n+}\n+\n+void TxDownloadManagerImpl::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    for (const auto& txhash : txhashes) {\n+        // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\n+        // completed in TxRequestTracker.\n+        m_txrequest.ReceivedResponse(nodeid, txhash);\n+    }\n+}\n+\n+std::optional<PackageToValidate> TxDownloadManagerImpl::Find1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    Assume(RecentRejectsReconsiderableFilter().contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child, nodeid, nodeid};\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+    // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+    // create a bias that attackers can use to delay package acceptance.\n+    //\n+    // Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    std::shuffle(tx_indices.begin(), tx_indices.end(), m_opts.m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_lazy_recent_rejects_reconsiderable.\n+        const auto [child_tx, child_sender] = cpfp_candidates_different_peer.at(index);\n+        Package maybe_cpfp_package{ptx, child_tx};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child_tx, nodeid, child_sender};\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+void TxDownloadManagerImpl::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    // As this version of the transaction was acceptable, we can forget about any requests for it.\n+    // No-op if the tx is not in txrequest.\n+    m_txrequest.ForgetTxHash(tx->GetHash());\n+    m_txrequest.ForgetTxHash(tx->GetWitnessHash());\n+\n+    m_orphanage.AddChildrenToWorkSet(*tx);\n+    // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n+    m_orphanage.EraseTx(tx->GetWitnessHash());\n+}\n+\n+node::RejectedTxTodo TxDownloadManagerImpl::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    const CTransaction& tx{*ptx};\n+    // Results returned to caller\n+    // Whether we should call AddToCompactExtraTransactions at the end\n+    bool add_extra_compact_tx{first_time_failure};\n+    // Hashes to pass to AddKnownTx later\n+    std::vector<uint256> unique_parents;\n+    // Populated if failure is reconsiderable and eligible package is found.\n+    std::optional<node::PackageToValidate> package_to_validate;\n+\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+        // Only process a new orphan if this is a first time failure, as otherwise it must be either\n+        // already in orphanage or from 1p1c processing.\n+        if (first_time_failure && !RecentRejectsFilter().contains(ptx->GetWitnessHash().ToUint256())) {\n+            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+            // Deduplicate parent txids, so that we don't have to loop over\n+            // the same parent txid more than once down below.\n+            unique_parents.reserve(tx.vin.size());\n+            for (const CTxIn& txin : tx.vin) {\n+                // We start with all parents, and then remove duplicates below.\n+                unique_parents.push_back(txin.prevout.hash);\n+            }\n+            std::sort(unique_parents.begin(), unique_parents.end());\n+            unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+            // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 329,
      "original_position": 323,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770587752,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Considering this out of scope as it is being moved, not introduced.",
      "created_at": "2024-09-24T00:58:02Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1772396205",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772396205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 329,
      "original_line": 329,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772396732",
      "pull_request_review_id": 2323753194,
      "id": 1772396732,
      "node_id": "PRRC_kwDOABII585ppKC8",
      "diff_hunk": "@@ -0,0 +1,159 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadManagerImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {\n+    /** Read-only reference to mempool. */\n+    const CTxMemPool& m_mempool;\n+    /** RNG provided by caller. */\n+    FastRandomContext& m_rng;\n+    /** Maximum number of transactions allowed in orphanage. */\n+    const uint32_t m_max_orphan_txs;\n+    /** Instantiate TxRequestTracker as deterministic (used for tests). */\n+    bool m_deterministic_txrequest{false};\n+};\n+struct TxDownloadConnectionInfo {\n+    /** Whether this peer is preferred for transaction download. */\n+    const bool m_preferred;\n+    /** Whether this peer has Relay permissions. */\n+    const bool m_relay_permissions;\n+    /** Whether this peer supports wtxid relay. */\n+    const bool m_wtxid_relay;\n+};\n+struct PackageToValidate {\n+    Package m_txns;\n+    std::vector<NodeId> m_senders;\n+    /** Construct a 1-parent-1-child package. */\n+    explicit PackageToValidate(const CTransactionRef& parent,\n+                               const CTransactionRef& child,\n+                               NodeId parent_sender,\n+                               NodeId child_sender) :\n+        m_txns{parent, child},\n+        m_senders{parent_sender, child_sender}\n+    {}\n+\n+    // Move ctor\n+    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\n+    // Copy ctor\n+    PackageToValidate(const PackageToValidate& other) = default;\n+\n+    // Move assignment\n+    PackageToValidate& operator=(PackageToValidate&& other) {\n+        this->m_txns = std::move(other.m_txns);\n+        this->m_senders = std::move(other.m_senders);\n+        return *this;\n+    }\n+\n+    std::string ToString() const {\n+        Assume(m_txns.size() == 2);\n+        return strprintf(\"parent %s (wtxid=%s, sender=%d) + child %s (wtxid=%s, sender=%d)\",\n+                         m_txns.front()->GetHash().ToString(),\n+                         m_txns.front()->GetWitnessHash().ToString(),\n+                         m_senders.front(),\n+                         m_txns.back()->GetHash().ToString(),\n+                         m_txns.back()->GetWitnessHash().ToString(),\n+                         m_senders.back());",
      "path": "src/node/txdownloadman.h",
      "position": 91,
      "original_position": 91,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": 1771038519,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Considering this out of scope as it is being moved, not introduced.",
      "created_at": "2024-09-24T00:58:33Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1772396732",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772396732"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 85,
      "original_start_line": 85,
      "start_side": "RIGHT",
      "line": 91,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772396787",
      "pull_request_review_id": 2323753194,
      "id": 1772396787,
      "node_id": "PRRC_kwDOABII585ppKDz",
      "diff_hunk": "@@ -0,0 +1,159 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadManagerImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {\n+    /** Read-only reference to mempool. */\n+    const CTxMemPool& m_mempool;\n+    /** RNG provided by caller. */\n+    FastRandomContext& m_rng;\n+    /** Maximum number of transactions allowed in orphanage. */\n+    const uint32_t m_max_orphan_txs;\n+    /** Instantiate TxRequestTracker as deterministic (used for tests). */\n+    bool m_deterministic_txrequest{false};\n+};\n+struct TxDownloadConnectionInfo {\n+    /** Whether this peer is preferred for transaction download. */\n+    const bool m_preferred;\n+    /** Whether this peer has Relay permissions. */\n+    const bool m_relay_permissions;\n+    /** Whether this peer supports wtxid relay. */\n+    const bool m_wtxid_relay;\n+};\n+struct PackageToValidate {\n+    Package m_txns;\n+    std::vector<NodeId> m_senders;\n+    /** Construct a 1-parent-1-child package. */\n+    explicit PackageToValidate(const CTransactionRef& parent,\n+                               const CTransactionRef& child,\n+                               NodeId parent_sender,\n+                               NodeId child_sender) :\n+        m_txns{parent, child},\n+        m_senders{parent_sender, child_sender}\n+    {}\n+\n+    // Move ctor\n+    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\n+    // Copy ctor\n+    PackageToValidate(const PackageToValidate& other) = default;\n+\n+    // Move assignment\n+    PackageToValidate& operator=(PackageToValidate&& other) {\n+        this->m_txns = std::move(other.m_txns);\n+        this->m_senders = std::move(other.m_senders);\n+        return *this;\n+    }",
      "path": "src/node/txdownloadman.h",
      "position": 81,
      "original_position": 81,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770549633,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Considering this out of scope as it is being moved, not introduced.",
      "created_at": "2024-09-24T00:58:39Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1772396787",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772396787"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 72,
      "original_start_line": 72,
      "start_side": "RIGHT",
      "line": 81,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772396829",
      "pull_request_review_id": 2323753194,
      "id": 1772396829,
      "node_id": "PRRC_kwDOABII585ppKEd",
      "diff_hunk": "@@ -0,0 +1,159 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadManagerImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;",
      "path": "src/node/txdownloadman.h",
      "position": 27,
      "original_position": 27,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": 1771111489,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Considering this out of scope as it is being moved, not introduced.",
      "created_at": "2024-09-24T00:58:44Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1772396829",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772396829"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 27,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772397934",
      "pull_request_review_id": 2323753194,
      "id": 1772397934,
      "node_id": "PRRC_kwDOABII585ppKVu",
      "diff_hunk": "@@ -0,0 +1,530 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 141,
      "original_position": 141,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": 1771123840,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Considering this out of scope as it is being moved, not introduced.",
      "created_at": "2024-09-24T01:00:36Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1772397934",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772397934"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 125,
      "original_start_line": 125,
      "start_side": "RIGHT",
      "line": 141,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772398029",
      "pull_request_review_id": 2323753194,
      "id": 1772398029,
      "node_id": "PRRC_kwDOABII585ppKXN",
      "diff_hunk": "@@ -0,0 +1,530 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 147,
      "original_position": 147,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": 1771081901,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Considering this out of scope as it is being moved, not introduced.",
      "created_at": "2024-09-24T01:00:48Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1772398029",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772398029"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 143,
      "original_start_line": 143,
      "start_side": "RIGHT",
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772399108",
      "pull_request_review_id": 2323753194,
      "id": 1772399108,
      "node_id": "PRRC_kwDOABII585ppKoE",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 153,
      "original_position": 153,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770550296,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I prefer not to assert. My philosophy is that the interface should be simple/robust, i.e. not have a ton of assumptions that would cause the class to fall over if broken. And yes, it means we can easily fuzz that this is the case.",
      "created_at": "2024-09-24T01:02:55Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1772399108",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772399108"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 153,
      "original_line": 153,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772401383",
      "pull_request_review_id": 2323753194,
      "id": 1772401383,
      "node_id": "PRRC_kwDOABII585ppLLn",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\n+    }\n+}\n+\n+static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.first;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetStrippedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return StripWitness(tx_it->second.first);\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetMalleatedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.second;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetRandomTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, FuzzedDataProvider& fuzzed_data_provider, bool correct_only = false)\n+{\n+    auto it = txmap.begin();\n+    // Jump forward a random number of times.\n+    for (size_t i = 0; i <= fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1); ++i) it++;\n+    if (it == txmap.end()) return nullptr;\n+    return correct_only || fuzzed_data_provider.ConsumeBool() ? it->second.first : it->second.second;\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(txdownloadman_one_honest_peer, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+    std::chrono::microseconds time{244466666};\n+\n+    // Decide the target transaction. Disallow selecting a witness-stripped or non-segwit\n+    // transaction because it can lead to false negatives. This test may mark a same-txid\n+    // transaction as invalid, and we don't want that to cause rejection of the target tx.\n+    const auto& target_tx = GetRandomTx(TRANSACTIONS, fuzzed_data_provider, /*correct_only=*/true);\n+    Assert(target_tx != nullptr);\n+    Assert(target_tx->HasWitness());\n+\n+    const auto& target_txid = target_tx->GetHash();\n+    const auto& target_wtxid = target_tx->GetWitnessHash();\n+\n+    // Decide what the peers are.\n+    std::vector<TestPeer> all_peers;\n+    // NodeId of the \"designated good peer\"\n+    // Other TestPeers may be \"good\" as well, but not guaranteed.\n+    NodeId honestid = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 7);\n+    // 8 outbound peers. NodeId = o. We indicate outbound using preferred=true\n+    for (unsigned int o = 0; o < 8; ++o) {\n+        bool good = (o == honestid) || fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, o, /*preferred=*/true, /*force_good=*/good));\n+    }\n+    // 0-120 inbound peers. NodeId = i. We indicate inbound using preferred=false\n+    auto num_inbound_peers = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 120);\n+    for (unsigned int i = 8; i < num_inbound_peers + 8; ++i) {\n+        bool good = fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, i, /*preferred=*/false, /*force_good=*/good));\n+    }\n+\n+    // Indexes for random peer iteration\n+    std::vector<size_t> indexes;\n+    indexes.resize(all_peers.size());\n+    std::iota(indexes.begin(), indexes.end(), 0);\n+\n+    // We are trying to ensure that we always download the tx as long as we have 1 good outbound\n+    // peer who is able to send it to us.\n+    bool got_tx{false};\n+\n+    // Keep track of how many iterations the loop has done to make sure the target transaction is\n+    // announced within the first 1000 rounds. Note that the good peer is guaranteed to connect\n+    // within the first round and will never be disconnected.\n+    int counter = 0;\n+\n+    LIMITED_WHILE(!got_tx, 100000)\n+    {\n+        FastRandomContext rng{ConsumeUInt256(fuzzed_data_provider)};\n+        std::shuffle(indexes.begin(), indexes.end(), rng);\n+        // For each peer in random order, mock a ProcessMessages + SendMessages\n+        for (const auto index : indexes) {\n+            auto& peer = all_peers.at(index);\n+            NodeId nodeid = peer.m_nodeid;\n+\n+            // Maybe connect the peer if we haven't already. Always connect if it's the good peer.\n+            if (nodeid == honestid ||\n+                (peer.m_connection_state == ConnectionState::NEVER_CONNECTED && fuzzed_data_provider.ConsumeBool())) {\n+                node::TxDownloadConnectionInfo info{peer.m_connection_preferred, peer.m_relay_permissions, peer.m_wtxid_relay};\n+                txdownloadman.ConnectedPeer(nodeid, info);\n+                peer.m_connection_state = ConnectionState::CONNECTED;\n+            }\n+\n+            if (peer.m_connection_state == ConnectionState::CONNECTED) {\n+                // Peer will do its own ProcessMessages, i.e. respond to the next item in its message queue\n+                // If the message queue is empty or it decides to send nothing, maybe_gtxid is\n+                // std::nullopt. Otherwise, maybe_gtxid must contain the gtxid we are responding to.\n+                const auto& [peer_response, maybe_gtxid] = peer.ProcessOneMessage(fuzzed_data_provider);\n+\n+                // Simulate a ProcessMessage.\n+                switch (peer_response) {\n+                    case PossibleResponse::TX_REAL:\n+                    {\n+                        // If the transaction exists, use ReceivedTx. Otherwise, maybe send notfound.\n+                        if (auto ptx{GetCorrectTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, ptx);\n+                            if (should_validate || package_to_validate.has_value()) {\n+                                if (ptx->GetWitnessHash() == target_wtxid) {\n+                                    // We received the target tx and decided to validate it! Win!\n+                                    got_tx = true;\n+                                } else {\n+                                    // If not the target tx, pick some failure reason.\n+                                    TxValidationState state;\n+                                    state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                                    txdownloadman.MempoolRejectedTx(ptx, state, nodeid, true);\n+                                }\n+                            } else {\n+                            }\n+                        } else {\n+                            Assert(!peer.m_good);\n+                            if (fuzzed_data_provider.ConsumeBool()) {\n+                                txdownloadman.ReceivedNotFound(nodeid, {maybe_gtxid.value().GetHash()});\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::TX_WITNESS_STRIPPED:\n+                    {\n+                        // Call ReceivedTx. If txdownloadman instructs us to validate the\n+                        // transaction, say the result was TX_WITNESS_STRIPPED.\n+                        if (auto stripped_tx{GetStrippedTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+                            const auto& [should_validate, package] = txdownloadman.ReceivedTx(nodeid, stripped_tx);\n+                            if (should_validate) {\n+                                TxValidationState state;\n+                                state.Invalid(TxValidationResult::TX_WITNESS_STRIPPED, \"\");\n+                                txdownloadman.MempoolRejectedTx(stripped_tx, state, nodeid, true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::TX_WITNESS_MALLEATED:\n+                    {\n+                        // Call ReceivedTx. If txdownloadman instructs us to validate the\n+                        // transaction, return some error.\n+                        if (auto malleated_tx{GetMalleatedTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+\n+                            // Prevent accidental lose conditions.\n+                            if (malleated_tx == target_tx) break;\n+\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, malleated_tx);\n+                            if (should_validate) {\n+                                TxValidationState state;\n+                                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                                txdownloadman.MempoolRejectedTx(malleated_tx, state, nodeid, true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::NOTFOUND:\n+                    {\n+                        txdownloadman.ReceivedNotFound(nodeid, {maybe_gtxid.value().GetHash()});\n+                        break;\n+                    }\n+                    case PossibleResponse::NOTHING:\n+                    {\n+                        break;\n+                    }\n+                    case PossibleResponse::DEFER:\n+                    {\n+                        // bug\n+                        Assert(false);\n+                        break;\n+                    }\n+                }\n+\n+                // The peer may also send some unsolicited message. Simulate a ProcessMessage.\n+                // Ensure the good peer sends the inv within the first 1000 rounds.\n+                auto peer_unsolicited_message = peer.SendOneMessage(fuzzed_data_provider, /*force_announce=*/counter > 1000);\n+\n+                switch (peer_unsolicited_message) {\n+                    case PossibleMessage::NOTHING:\n+                    {\n+                        break;\n+                    }\n+                    case PossibleMessage::INV_REAL:\n+                    {\n+                        if (peer.m_wtxid_relay) {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Wtxid(target_wtxid), time, /*p2p_inv=*/true);\n+                        } else {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Txid(target_txid), time, /*p2p_inv=*/true);\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::INV_DIFFERENT:\n+                    {\n+                        // This may or may not be target_tx\n+                        if (auto random_tx{GetRandomTx(TRANSACTIONS, fuzzed_data_provider)}) {\n+                            if (peer.m_wtxid_relay) {\n+                                txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Txid(random_tx->GetHash()), time, /*p2p_inv=*/true);\n+                            } else {\n+                                txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Wtxid(random_tx->GetWitnessHash()), time, /*p2p_inv=*/true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::INV_RANDOM:\n+                    {\n+                        auto random_txhash = ConsumeUInt256(fuzzed_data_provider);\n+                        if (peer.m_wtxid_relay) {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Wtxid(random_txhash), time, /*p2p_inv=*/true);\n+                        } else {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Txid(random_txhash), time, /*p2p_inv=*/true);\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::TX_RANDOM:\n+                    {\n+                        if (auto random_tx{GetRandomTx(TRANSACTIONS, fuzzed_data_provider)}) {\n+                            // Disallow winning this way.\n+                            if (random_tx == target_tx) break;\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, random_tx);\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::NOTFOUND:\n+                    {\n+                        if (auto random_tx{GetRandomTx(TRANSACTIONS, fuzzed_data_provider)}) {\n+                            const auto txhash{fuzzed_data_provider.ConsumeBool() ? random_tx->GetHash().ToUint256() : random_tx->GetWitnessHash().ToUint256()};\n+                            txdownloadman.ReceivedNotFound(nodeid, {txhash});\n+                        }\n+                        break;\n+                    }\n+                }\n+\n+                // Simulate a SendMessages, which includes sending getdata to request transactions.\n+                for (const auto& gtxid : txdownloadman.GetRequestsToSend(nodeid, time)) {\n+                    peer.m_getdata_queue.push_back(gtxid);\n+                }\n+\n+                // Maybe disconnect the peer if we haven't already. Never disconnect the good peer.\n+                if (peer.m_connection_state == ConnectionState::CONNECTED && nodeid != honestid && fuzzed_data_provider.ConsumeBool()) {\n+                    peer.m_connection_state = ConnectionState::DISCONNECTED;\n+                    txdownloadman.DisconnectedPeer(nodeid);\n+                    txdownloadman.CheckIsEmpty(nodeid);\n+                }\n+                ++counter;\n+            }\n+        }\n+\n+        // Skip time by 100-300ms",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 512,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770564258,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ms",
      "created_at": "2024-09-24T01:06:55Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1772401383",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772401383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 512,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780058381",
      "pull_request_review_id": 2323753194,
      "id": 1780058381,
      "node_id": "PRRC_kwDOABII585qGYkN",
      "diff_hunk": "",
      "path": "src/net_processing.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "original_commit_id": "f0b2b37dbbbb0ffe877e45b921ae7ae06f6facf0",
      "in_reply_to_id": 1770543742,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-09-29T14:27:38Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780058381",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780058381"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780058788",
      "pull_request_review_id": 2323753194,
      "id": 1780058788,
      "node_id": "PRRC_kwDOABII585qGYqk",
      "diff_hunk": "@@ -5321,16 +4869,18 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n     if (msg_type == NetMsgType::NOTFOUND) {\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n-        if (vInv.size() <= MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-            LOCK(m_tx_download_mutex);\n+        std::vector<uint256> tx_invs;\n+        if (vInv.size() <= node::MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             for (CInv &inv : vInv) {",
      "path": "src/net_processing.cpp",
      "position": 832,
      "original_position": 832,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770546568,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We don't know the number of transaction invs ahead of time, so this could reserve a bunch of extra space that is never used. Unsure the best way to handle this - if it's transactions, the size should generally only be a handful anyway.",
      "created_at": "2024-09-29T14:30:08Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780058788",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780058788"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4874,
      "original_line": 4874,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780059287",
      "pull_request_review_id": 2323753194,
      "id": 1780059287,
      "node_id": "PRRC_kwDOABII585qGYyX",
      "diff_hunk": "@@ -0,0 +1,159 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadManagerImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {\n+    /** Read-only reference to mempool. */\n+    const CTxMemPool& m_mempool;\n+    /** RNG provided by caller. */\n+    FastRandomContext& m_rng;\n+    /** Maximum number of transactions allowed in orphanage. */\n+    const uint32_t m_max_orphan_txs;\n+    /** Instantiate TxRequestTracker as deterministic (used for tests). */\n+    bool m_deterministic_txrequest{false};\n+};\n+struct TxDownloadConnectionInfo {\n+    /** Whether this peer is preferred for transaction download. */\n+    const bool m_preferred;\n+    /** Whether this peer has Relay permissions. */\n+    const bool m_relay_permissions;\n+    /** Whether this peer supports wtxid relay. */\n+    const bool m_wtxid_relay;\n+};\n+struct PackageToValidate {\n+    Package m_txns;\n+    std::vector<NodeId> m_senders;\n+    /** Construct a 1-parent-1-child package. */\n+    explicit PackageToValidate(const CTransactionRef& parent,\n+                               const CTransactionRef& child,\n+                               NodeId parent_sender,\n+                               NodeId child_sender) :\n+        m_txns{parent, child},\n+        m_senders{parent_sender, child_sender}\n+    {}\n+\n+    // Move ctor\n+    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\n+    // Copy ctor\n+    PackageToValidate(const PackageToValidate& other) = default;\n+\n+    // Move assignment\n+    PackageToValidate& operator=(PackageToValidate&& other) {\n+        this->m_txns = std::move(other.m_txns);\n+        this->m_senders = std::move(other.m_senders);\n+        return *this;\n+    }\n+\n+    std::string ToString() const {\n+        Assume(m_txns.size() == 2);\n+        return strprintf(\"parent %s (wtxid=%s, sender=%d) + child %s (wtxid=%s, sender=%d)\",\n+                         m_txns.front()->GetHash().ToString(),\n+                         m_txns.front()->GetWitnessHash().ToString(),\n+                         m_senders.front(),\n+                         m_txns.back()->GetHash().ToString(),\n+                         m_txns.back()->GetWitnessHash().ToString(),\n+                         m_senders.back());\n+    }\n+};\n+struct RejectedTxTodo\n+{\n+    bool m_should_add_extra_compact_tx;\n+    std::vector<uint256> m_unique_parents;\n+    std::optional<PackageToValidate> m_package_to_validate;\n+};\n+\n+\n+class TxDownloadManager {\n+    const std::unique_ptr<TxDownloadManagerImpl> m_impl;\n+\n+public:\n+    explicit TxDownloadManager(const TxDownloadOptions& options);\n+    ~TxDownloadManager();\n+\n+    // Responses to chain events. TxDownloadManager is not an actual client of ValidationInterface, these are called through PeerManager.\n+    void ActiveTipChange();\n+    void BlockConnected(const std::shared_ptr<const CBlock>& pblock);\n+    void BlockDisconnected();\n+\n+    /** Creates a new PeerInfo. Saves the connection info to calculate tx announcement delays later. */\n+    void ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info);\n+\n+    /** Deletes all txrequest announcements and orphans for a given peer. */\n+    void DisconnectedPeer(NodeId nodeid);\n+\n+    /** New inv has been received. May be added as a candidate to txrequest.\n+     * @param[in] p2p_inv     When true, only add this announcement if we don't already have the tx.",
      "path": "src/node/txdownloadman.h",
      "position": 121,
      "original_position": 121,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770549777,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think you're referring to the extra space? That's done to leave room for other params to be added in the future, it's more readable.",
      "created_at": "2024-09-29T14:32:21Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780059287",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780059287"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 121,
      "original_line": 121,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780059441",
      "pull_request_review_id": 2323753194,
      "id": 1780059441,
      "node_id": "PRRC_kwDOABII585qGY0x",
      "diff_hunk": "@@ -0,0 +1,530 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": 1771078008,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nope - fixed, thanks",
      "created_at": "2024-09-29T14:33:13Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780059441",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780059441"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780059493",
      "pull_request_review_id": 2323753194,
      "id": 1780059493,
      "node_id": "PRRC_kwDOABII585qGY1l",
      "diff_hunk": "@@ -0,0 +1,530 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 87,
      "original_position": 87,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": 1771117667,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes",
      "created_at": "2024-09-29T14:33:30Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780059493",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780059493"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 87,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780059621",
      "pull_request_review_id": 2323753194,
      "id": 1780059621,
      "node_id": "PRRC_kwDOABII585qGY3l",
      "diff_hunk": "@@ -0,0 +1,530 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 141,
      "original_position": 141,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": 1771123840,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You may find #30000 discussion interesting",
      "created_at": "2024-09-29T14:34:03Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780059621",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780059621"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 125,
      "original_start_line": 125,
      "start_side": "RIGHT",
      "line": 141,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780060159",
      "pull_request_review_id": 2323753194,
      "id": 1780060159,
      "node_id": "PRRC_kwDOABII585qGY__",
      "diff_hunk": "@@ -0,0 +1,530 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 155,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": 1771043258,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sure, done",
      "created_at": "2024-09-29T14:36:40Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780060159",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780060159"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780060465",
      "pull_request_review_id": 2323753194,
      "id": 1780060465,
      "node_id": "PRRC_kwDOABII585qGZEx",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 167,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770552145,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agree, changed",
      "created_at": "2024-09-29T14:38:29Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780060465",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780060465"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780061010",
      "pull_request_review_id": 2323753194,
      "id": 1780061010,
      "node_id": "PRRC_kwDOABII585qGZNS",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }\n+}\n+\n+bool TxDownloadManagerImpl::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    // If this is an inv received from a peer and we already have it, we can drop it.\n+    // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\n+    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\n+    if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\n+\n+    if (m_peer_info.count(peer) == 0) return false;\n+    const auto& info = m_peer_info.at(peer).m_connection_info;",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 178,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770553366,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-09-29T14:40:43Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780061010",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780061010"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 177,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 178,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780061508",
      "pull_request_review_id": 2323753194,
      "id": 1780061508,
      "node_id": "PRRC_kwDOABII585qGZVE",
      "diff_hunk": "@@ -0,0 +1,190 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_IMPL_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_IMPL_H\n+\n+#include <node/txdownloadman.h>\n+\n+#include <common/bloom.h>\n+#include <consensus/validation.h>\n+#include <kernel/chain.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <policy/packages.h>\n+#include <txorphanage.h>\n+#include <txrequest.h>\n+\n+class CTxMemPool;\n+namespace node {\n+class TxDownloadManagerImpl {\n+public:\n+    TxDownloadOptions m_opts;\n+\n+    /** Manages unvalidated tx data (orphan transactions for which we are downloading ancestors). */\n+    TxOrphanage m_orphanage;\n+    /** Tracks candidates for requesting and downloading transaction data. */\n+    TxRequestTracker m_txrequest;\n+\n+    /**\n+     * Filter for transactions that were recently rejected by the mempool.\n+     * These are not rerequested until the chain tip changes, at which point\n+     * the entire filter is reset.\n+     *\n+     * Without this filter we'd be re-requesting txs from each of our peers,\n+     * increasing bandwidth consumption considerably. For instance, with 100\n+     * peers, half of which relay a tx we don't accept, that might be a 50x\n+     * bandwidth increase. A flooding attacker attempting to roll-over the\n+     * filter using minimum-sized, 60byte, transactions might manage to send\n+     * 1000/sec if we have fast peers, so we pick 120,000 to give our peers a\n+     * two minute window to send invs to us.\n+     *\n+     * Decreasing the false positive rate is fairly cheap, so we pick one in a\n+     * million to make it highly unlikely for users to have issues with this\n+     * filter.\n+     *\n+     * We typically only add wtxids to this filter. For non-segwit\n+     * transactions, the txid == wtxid, so this only prevents us from\n+     * re-downloading non-segwit transactions when communicating with\n+     * non-wtxidrelay peers -- which is important for avoiding malleation\n+     * attacks that could otherwise interfere with transaction relay from\n+     * non-wtxidrelay peers. For communicating with wtxidrelay peers, having\n+     * the reject filter store wtxids is exactly what we want to avoid\n+     * redownload of a rejected transaction.\n+     *\n+     * In cases where we can tell that a segwit transaction will fail\n+     * validation no matter the witness, we may add the txid of such\n+     * transaction to the filter as well. This can be helpful when\n+     * communicating with txid-relay peers or if we were to otherwise fetch a\n+     * transaction via txid (eg in our orphan handling).\n+     *\n+     * Memory used: 1.3 MB",
      "path": "src/node/txdownloadman_impl.h",
      "position": 61,
      "original_position": 61,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": 1771088927,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good question. See the comment on src/common/bloom.h for the usage formula, AFAIK it has not changed.",
      "created_at": "2024-09-29T14:43:12Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780061508",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780061508"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 61,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780061911",
      "pull_request_review_id": 2323753194,
      "id": 1780061911,
      "node_id": "PRRC_kwDOABII585qGZbX",
      "diff_hunk": "@@ -0,0 +1,530 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }\n+}\n+\n+bool TxDownloadManagerImpl::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    // If this is an inv received from a peer and we already have it, we can drop it.\n+    // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\n+    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\n+    if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\n+\n+    if (m_peer_info.count(peer) == 0) return false;\n+    const auto& info = m_peer_info.at(peer).m_connection_info;\n+    if (!info.m_relay_permissions && m_txrequest.Count(peer) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements for this peer\n+        return false;\n+    }\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or NetPermissionFlags::NoBan permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for txid announcements while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from peers which have at least\n+    //     MAX_PEER_TX_REQUEST_IN_FLIGHT requests in flight (and don't have NetPermissionFlags::Relay).\n+    auto delay{0us};\n+    if (!info.m_preferred) delay += NONPREF_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && m_num_wtxid_peers > 0) delay += TXID_RELAY_DELAY;\n+    const bool overloaded = !info.m_relay_permissions && m_txrequest.CountInFlight(peer) >= MAX_PEER_TX_REQUEST_IN_FLIGHT;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+\n+    m_txrequest.ReceivedInv(peer, gtxid, info.m_preferred, now + delay);\n+\n+    return false;\n+}\n+\n+std::vector<GenTxid> TxDownloadManagerImpl::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    std::vector<GenTxid> requests;\n+    std::vector<std::pair<NodeId, GenTxid>> expired;\n+    auto requestable = m_txrequest.GetRequestable(nodeid, current_time, &expired);\n+    for (const auto& entry : expired) {\n+        LogDebug(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n+            entry.second.GetHash().ToString(), entry.first);\n+    }\n+    for (const GenTxid& gtxid : requestable) {\n+        if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+            LogDebug(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n+                gtxid.GetHash().ToString(), nodeid);\n+            requests.emplace_back(gtxid);\n+            m_txrequest.RequestedTx(nodeid, gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n+        } else {\n+            // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n+            // this should already be called whenever a transaction becomes AlreadyHaveTx().\n+            m_txrequest.ForgetTxHash(gtxid.GetHash());\n+        }\n+    }\n+    return requests;\n+}\n+\n+void TxDownloadManagerImpl::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    for (const auto& txhash : txhashes) {\n+        // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\n+        // completed in TxRequestTracker.\n+        m_txrequest.ReceivedResponse(nodeid, txhash);\n+    }\n+}\n+\n+std::optional<PackageToValidate> TxDownloadManagerImpl::Find1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    Assume(RecentRejectsReconsiderableFilter().contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child, nodeid, nodeid};\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+    // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+    // create a bias that attackers can use to delay package acceptance.\n+    //\n+    // Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    std::shuffle(tx_indices.begin(), tx_indices.end(), m_opts.m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_lazy_recent_rejects_reconsiderable.\n+        const auto [child_tx, child_sender] = cpfp_candidates_different_peer.at(index);\n+        Package maybe_cpfp_package{ptx, child_tx};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child_tx, nodeid, child_sender};\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+void TxDownloadManagerImpl::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    // As this version of the transaction was acceptable, we can forget about any requests for it.\n+    // No-op if the tx is not in txrequest.\n+    m_txrequest.ForgetTxHash(tx->GetHash());\n+    m_txrequest.ForgetTxHash(tx->GetWitnessHash());\n+\n+    m_orphanage.AddChildrenToWorkSet(*tx);\n+    // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n+    m_orphanage.EraseTx(tx->GetWitnessHash());\n+}\n+\n+node::RejectedTxTodo TxDownloadManagerImpl::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    const CTransaction& tx{*ptx};\n+    // Results returned to caller\n+    // Whether we should call AddToCompactExtraTransactions at the end\n+    bool add_extra_compact_tx{first_time_failure};\n+    // Hashes to pass to AddKnownTx later\n+    std::vector<uint256> unique_parents;\n+    // Populated if failure is reconsiderable and eligible package is found.\n+    std::optional<node::PackageToValidate> package_to_validate;\n+\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+        // Only process a new orphan if this is a first time failure, as otherwise it must be either\n+        // already in orphanage or from 1p1c processing.\n+        if (first_time_failure && !RecentRejectsFilter().contains(ptx->GetWitnessHash().ToUint256())) {\n+            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+            // Deduplicate parent txids, so that we don't have to loop over\n+            // the same parent txid more than once down below.\n+            unique_parents.reserve(tx.vin.size());\n+            for (const CTxIn& txin : tx.vin) {\n+                // We start with all parents, and then remove duplicates below.\n+                unique_parents.push_back(txin.prevout.hash);\n+            }\n+            std::sort(unique_parents.begin(), unique_parents.end());\n+            unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+            // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.\n+            // We can tolerate having up to 1 parent in m_lazy_recent_rejects_reconsiderable since we\n+            // submit 1p1c packages. However, fail immediately if any are in m_lazy_recent_rejects.\n+            std::optional<uint256> rejected_parent_reconsiderable;\n+            for (const uint256& parent_txid : unique_parents) {\n+                if (RecentRejectsFilter().contains(parent_txid)) {\n+                    fRejectedParents = true;\n+                    break;\n+                } else if (RecentRejectsReconsiderableFilter().contains(parent_txid) &&\n+                           !m_opts.m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                    // More than 1 parent in m_lazy_recent_rejects_reconsiderable: 1p1c will not be\n+                    // sufficient to accept this package, so just give up here.\n+                    if (rejected_parent_reconsiderable.has_value()) {\n+                        fRejectedParents = true;\n+                        break;\n+                    }\n+                    rejected_parent_reconsiderable = parent_txid;\n+                }\n+            }\n+            if (!fRejectedParents) {\n+                const auto current_time{GetTime<std::chrono::microseconds>()};\n+\n+                for (const uint256& parent_txid : unique_parents) {\n+                    // Here, we only have the txid (and not wtxid) of the\n+                    // inputs, so we only request in txid mode, even for\n+                    // wtxidrelay peers.\n+                    // Eventually we should replace this with an improved\n+                    // protocol for getting all unconfirmed parents.\n+                    const auto gtxid{GenTxid::Txid(parent_txid)};\n+                    // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n+                    // previously rejected for being too low feerate. This orphan might CPFP it.\n+                    if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+                        AddTxAnnouncement(nodeid, gtxid, current_time, /*p2p_inv=*/false);\n+                    }\n+                }\n+\n+                // Potentially flip add_extra_compact_tx to false if AddTx returns false because the tx was already there\n+                add_extra_compact_tx &= m_orphanage.AddTx(ptx, nodeid);\n+\n+                // Once added to the orphan pool, a tx is considered AlreadyHave, and we shouldn't request it anymore.\n+                m_txrequest.ForgetTxHash(tx.GetHash());\n+                m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+\n+                // DoS prevention: do not allow m_orphanage to grow unbounded (see CVE-2012-3789)\n+                m_orphanage.LimitOrphans(m_opts.m_max_orphan_txs, m_opts.m_rng);\n+            } else {\n+                unique_parents.clear();\n+                LogDebug(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s (wtxid=%s)\\n\",\n+                         tx.GetHash().ToString(),\n+                         tx.GetWitnessHash().ToString());\n+                // We will continue to reject this tx since it has rejected\n+                // parents so avoid re-requesting it from other peers.\n+                // Here we add both the txid and the wtxid, as we know that\n+                // regardless of what witness is provided, we will not accept\n+                // this, so we don't need to allow for redownload of this txid\n+                // from any of our non-wtxidrelay peers.\n+                RecentRejectsFilter().insert(tx.GetHash().ToUint256());\n+                RecentRejectsFilter().insert(tx.GetWitnessHash().ToUint256());\n+                m_txrequest.ForgetTxHash(tx.GetHash());\n+                m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+            }\n+        }\n+        // Whether or not we added an orphan, quit here.\n+        return RejectedTxTodo{\n+            .m_should_add_extra_compact_tx = add_extra_compact_tx,\n+            .m_unique_parents = std::move(unique_parents),\n+            .m_package_to_validate = std::nullopt\n+        };\n+    } else if (state.GetResult() == TxValidationResult::TX_WITNESS_STRIPPED) {\n+        add_extra_compact_tx = false;\n+    } else {\n+        // We can add the wtxid of this transaction to our reject filter.\n+        // Do not add txids of witness transactions or witness-stripped\n+        // transactions to the filter, as they can have been malleated;\n+        // adding such txids to the reject filter would potentially\n+        // interfere with relay of valid transactions from peers that\n+        // do not support wtxid-based relay. See\n+        // https://github.com/bitcoin/bitcoin/issues/8279 for details.\n+        // We can remove this restriction (and always add wtxids to\n+        // the filter even for witness stripped transactions) once\n+        // wtxid-based relay is broadly deployed.\n+        // See also comments in https://github.com/bitcoin/bitcoin/pull/18044#discussion_r443419034\n+        // for concerns around weakening security of unupgraded nodes\n+        // if we start doing this too early.\n+        if (state.GetResult() == TxValidationResult::TX_RECONSIDERABLE) {\n+            // If the result is TX_RECONSIDERABLE, add it to m_lazy_recent_rejects_reconsiderable\n+            // because we should not download or submit this transaction by itself again, but may\n+            // submit it as part of a package later.\n+            RecentRejectsReconsiderableFilter().insert(ptx->GetWitnessHash().ToUint256());\n+\n+            if (first_time_failure) {\n+                // When a transaction fails for TX_RECONSIDERABLE, look for a matching child in the\n+                // orphanage, as it is possible that they succeed as a package.\n+                LogDebug(BCLog::TXPACKAGES, \"tx %s (wtxid=%s) failed but reconsiderable, looking for child in orphanage\\n\",\n+                         ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString());\n+                package_to_validate = Find1P1CPackage(ptx, nodeid);\n+            }\n+        } else {\n+            RecentRejectsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+        // If the transaction failed for TX_INPUTS_NOT_STANDARD,\n+        // then we know that the witness was irrelevant to the policy\n+        // failure, since this check depends only on the txid\n+        // (the scriptPubKey being spent is covered by the txid).\n+        // Add the txid to the reject filter to prevent repeated\n+        // processing of this transaction in the event that child\n+        // transactions are later received (resulting in\n+        // parent-fetching by txid via the orphan-handling logic).\n+        // We only add the txid if it differs from the wtxid, to avoid wasting entries in the\n+        // rolling bloom filter.\n+        if (state.GetResult() == TxValidationResult::TX_INPUTS_NOT_STANDARD && ptx->HasWitness()) {\n+            RecentRejectsFilter().insert(ptx->GetHash().ToUint256());\n+            m_txrequest.ForgetTxHash(ptx->GetHash());\n+        }\n+    }\n+\n+    // If the tx failed in ProcessOrphanTx, it should be removed from the orphanage unless the\n+    // tx was still missing inputs. If the tx was not in the orphanage, EraseTx does nothing and returns 0.\n+    if (state.GetResult() != TxValidationResult::TX_MISSING_INPUTS && m_orphanage.EraseTx(ptx->GetWitnessHash()) > 0) {\n+        LogDebug(BCLog::TXPACKAGES, \"   removed orphan tx %s (wtxid=%s)\\n\", ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString());\n+    }\n+\n+    return RejectedTxTodo{\n+        .m_should_add_extra_compact_tx = add_extra_compact_tx,\n+        .m_unique_parents = std::move(unique_parents),\n+        .m_package_to_validate = std::move(package_to_validate)\n+    };\n+}\n+\n+void TxDownloadManagerImpl::MempoolRejectedPackage(const Package& package)\n+{\n+    RecentRejectsReconsiderableFilter().insert(GetPackageHash(package));\n+}\n+\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManagerImpl::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    const uint256& txid = ptx->GetHash();\n+    const uint256& wtxid = ptx->GetWitnessHash();\n+\n+    // Mark that we have received a response\n+    m_txrequest.ReceivedResponse(nodeid, txid);\n+    if (ptx->HasWitness()) m_txrequest.ReceivedResponse(nodeid, wtxid);\n+\n+    // First check if we should drop this tx.\n+    // We do the AlreadyHaveTx() check using wtxid, rather than txid - in the\n+    // absence of witness malleation, this is strictly better, because the\n+    // recent rejects filter may contain the wtxid but rarely contains\n+    // the txid of a segwit transaction that has been rejected.\n+    // In the presence of witness malleation, it's possible that by only\n+    // doing the check with wtxid, we could overlook a transaction which\n+    // was confirmed with a different witness, or exists in our mempool\n+    // with a different witness, but this has limited downside:\n+    // mempool validation does its own lookup of whether we have the txid\n+    // already; and an adversary can already relay us old transactions\n+    // (older than our recency filter) if trying to DoS us, without any need\n+    // for witness malleation.\n+    if (AlreadyHaveTx(GenTxid::Wtxid(wtxid), /*include_reconsiderable=*/false)) {\n+        // If a tx is detected by m_lazy_recent_rejects it is ignored. Because we haven't\n+        // submitted the tx to our mempool, we won't have computed a DoS\n+        // score for it or determined exactly why we consider it invalid.\n+        //\n+        // This means we won't penalize any peer subsequently relaying a DoSy\n+        // tx (even if we penalized the first peer who gave it to us) because\n+        // we have to account for m_lazy_recent_rejects showing false positives. In\n+        // other words, we shouldn't penalize a peer if we aren't *sure* they\n+        // submitted a DoSy tx.\n+        //\n+        // Note that m_lazy_recent_rejects doesn't just record DoSy or invalid\n+        // transactions, but any tx not accepted by the mempool, which may be\n+        // due to node policy (vs. consensus). So we can't blanket penalize a\n+        // peer simply for relaying a tx that our m_lazy_recent_rejects has caught,\n+        // regardless of false positives.\n+        return std::make_pair(false, std::nullopt);\n+    } else if (RecentRejectsReconsiderableFilter().contains(wtxid)) {\n+        // When a transaction is already in m_lazy_recent_rejects_reconsiderable, we shouldn't submit\n+        // it by itself again. However, look for a matching child in the orphanage, as it is\n+        // possible that they succeed as a package.\n+        LogDebug(BCLog::TXPACKAGES, \"found tx %s (wtxid=%s) in reconsiderable rejects, looking for child in orphanage\\n\",\n+                 txid.ToString(), wtxid.ToString());\n+        return std::make_pair(false, Find1P1CPackage(ptx, nodeid));\n+    }\n+\n+\n+    return std::make_pair(true, std::nullopt);",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": null,
      "original_position": 507,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": 1771087858,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-09-29T14:45:27Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780061911",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780061911"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 503,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 507,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780062651",
      "pull_request_review_id": 2323753194,
      "id": 1780062651,
      "node_id": "PRRC_kwDOABII585qGZm7",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 75,
      "original_position": 75,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770570141,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "see L29, that's already done?",
      "created_at": "2024-09-29T14:48:33Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780062651",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780062651"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 75,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780063182",
      "pull_request_review_id": 2323753194,
      "id": 1780063182,
      "node_id": "PRRC_kwDOABII585qGZvO",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (maybe_package.has_value()) CheckPackageToValidate(*maybe_package, rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        // Jump forwards or backwards\n+        auto time_skip = fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+        if (fuzzed_data_provider.ConsumeBool()) time_skip *= -1;\n+        time += time_skip;\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadManagerImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+    txdownload_impl.m_txrequest.SanityCheck();\n+}\n+\n+FUZZ_TARGET(txdownloadman_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadManagerImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManagerImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                for (const auto& tx : TRANSACTIONS) {\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(tx->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(tx->GetHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(tx->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(tx->GetHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    CheckPackageToValidate(*maybe_package, rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 402,
      "original_position": 383,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "df0b8a055cfc5afc9d919fac7594aa3011ceff93",
      "in_reply_to_id": 1765046861,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "(Was my first instinct too). That requires we pass `txdownload_impl` to the function, and the fuzz target above doesn't have access to that.",
      "created_at": "2024-09-29T14:51:00Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780063182",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780063182"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 402,
      "original_line": 402,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780063282",
      "pull_request_review_id": 2323753194,
      "id": 1780063282,
      "node_id": "PRRC_kwDOABII585qGZwy",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (maybe_package.has_value()) CheckPackageToValidate(*maybe_package, rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        // Jump forwards or backwards\n+        auto time_skip = fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+        if (fuzzed_data_provider.ConsumeBool()) time_skip *= -1;\n+        time += time_skip;\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadManagerImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+    txdownload_impl.m_txrequest.SanityCheck();\n+}\n+\n+FUZZ_TARGET(txdownloadman_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadManagerImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManagerImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                for (const auto& tx : TRANSACTIONS) {\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(tx->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(tx->GetHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(tx->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(tx->GetHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    CheckPackageToValidate(*maybe_package, rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(GetPackageHash(package)));\n+                    // Neither is in m_lazy_recent_rejects\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                txdownload_impl.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownload_impl.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownload_impl.GetTxToReconsider(rand_peer);",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 395,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": 1771093497,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "changed",
      "created_at": "2024-09-29T14:51:39Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780063282",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780063282"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 395,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780064782",
      "pull_request_review_id": 2323753194,
      "id": 1780064782,
      "node_id": "PRRC_kwDOABII585qGaIO",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\n+    }\n+}\n+\n+static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.first;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetStrippedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return StripWitness(tx_it->second.first);\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetMalleatedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.second;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetRandomTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, FuzzedDataProvider& fuzzed_data_provider, bool correct_only = false)\n+{\n+    auto it = txmap.begin();\n+    // Jump forward a random number of times.\n+    for (size_t i = 0; i <= fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1); ++i) it++;\n+    if (it == txmap.end()) return nullptr;\n+    return correct_only || fuzzed_data_provider.ConsumeBool() ? it->second.first : it->second.second;\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(txdownloadman_one_honest_peer, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+    std::chrono::microseconds time{244466666};\n+\n+    // Decide the target transaction. Disallow selecting a witness-stripped or non-segwit\n+    // transaction because it can lead to false negatives. This test may mark a same-txid\n+    // transaction as invalid, and we don't want that to cause rejection of the target tx.\n+    const auto& target_tx = GetRandomTx(TRANSACTIONS, fuzzed_data_provider, /*correct_only=*/true);\n+    Assert(target_tx != nullptr);\n+    Assert(target_tx->HasWitness());\n+\n+    const auto& target_txid = target_tx->GetHash();\n+    const auto& target_wtxid = target_tx->GetWitnessHash();\n+\n+    // Decide what the peers are.\n+    std::vector<TestPeer> all_peers;\n+    // NodeId of the \"designated good peer\"\n+    // Other TestPeers may be \"good\" as well, but not guaranteed.\n+    NodeId honestid = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 7);\n+    // 8 outbound peers. NodeId = o. We indicate outbound using preferred=true\n+    for (unsigned int o = 0; o < 8; ++o) {\n+        bool good = (o == honestid) || fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, o, /*preferred=*/true, /*force_good=*/good));\n+    }\n+    // 0-120 inbound peers. NodeId = i. We indicate inbound using preferred=false\n+    auto num_inbound_peers = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 120);\n+    for (unsigned int i = 8; i < num_inbound_peers + 8; ++i) {\n+        bool good = fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, i, /*preferred=*/false, /*force_good=*/good));\n+    }\n+\n+    // Indexes for random peer iteration\n+    std::vector<size_t> indexes;\n+    indexes.resize(all_peers.size());\n+    std::iota(indexes.begin(), indexes.end(), 0);\n+\n+    // We are trying to ensure that we always download the tx as long as we have 1 good outbound\n+    // peer who is able to send it to us.\n+    bool got_tx{false};\n+\n+    // Keep track of how many iterations the loop has done to make sure the target transaction is\n+    // announced within the first 1000 rounds. Note that the good peer is guaranteed to connect\n+    // within the first round and will never be disconnected.\n+    int counter = 0;\n+\n+    LIMITED_WHILE(!got_tx, 100000)\n+    {\n+        FastRandomContext rng{ConsumeUInt256(fuzzed_data_provider)};\n+        std::shuffle(indexes.begin(), indexes.end(), rng);\n+        // For each peer in random order, mock a ProcessMessages + SendMessages\n+        for (const auto index : indexes) {\n+            auto& peer = all_peers.at(index);\n+            NodeId nodeid = peer.m_nodeid;\n+\n+            // Maybe connect the peer if we haven't already. Always connect if it's the good peer.\n+            if (nodeid == honestid ||\n+                (peer.m_connection_state == ConnectionState::NEVER_CONNECTED && fuzzed_data_provider.ConsumeBool())) {\n+                node::TxDownloadConnectionInfo info{peer.m_connection_preferred, peer.m_relay_permissions, peer.m_wtxid_relay};\n+                txdownloadman.ConnectedPeer(nodeid, info);\n+                peer.m_connection_state = ConnectionState::CONNECTED;\n+            }\n+\n+            if (peer.m_connection_state == ConnectionState::CONNECTED) {\n+                // Peer will do its own ProcessMessages, i.e. respond to the next item in its message queue\n+                // If the message queue is empty or it decides to send nothing, maybe_gtxid is\n+                // std::nullopt. Otherwise, maybe_gtxid must contain the gtxid we are responding to.\n+                const auto& [peer_response, maybe_gtxid] = peer.ProcessOneMessage(fuzzed_data_provider);\n+\n+                // Simulate a ProcessMessage.\n+                switch (peer_response) {\n+                    case PossibleResponse::TX_REAL:\n+                    {\n+                        // If the transaction exists, use ReceivedTx. Otherwise, maybe send notfound.\n+                        if (auto ptx{GetCorrectTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, ptx);\n+                            if (should_validate || package_to_validate.has_value()) {\n+                                if (ptx->GetWitnessHash() == target_wtxid) {\n+                                    // We received the target tx and decided to validate it! Win!\n+                                    got_tx = true;\n+                                } else {\n+                                    // If not the target tx, pick some failure reason.\n+                                    TxValidationState state;\n+                                    state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                                    txdownloadman.MempoolRejectedTx(ptx, state, nodeid, true);\n+                                }\n+                            } else {\n+                            }\n+                        } else {\n+                            Assert(!peer.m_good);\n+                            if (fuzzed_data_provider.ConsumeBool()) {\n+                                txdownloadman.ReceivedNotFound(nodeid, {maybe_gtxid.value().GetHash()});\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::TX_WITNESS_STRIPPED:\n+                    {\n+                        // Call ReceivedTx. If txdownloadman instructs us to validate the\n+                        // transaction, say the result was TX_WITNESS_STRIPPED.\n+                        if (auto stripped_tx{GetStrippedTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+                            const auto& [should_validate, package] = txdownloadman.ReceivedTx(nodeid, stripped_tx);\n+                            if (should_validate) {\n+                                TxValidationState state;\n+                                state.Invalid(TxValidationResult::TX_WITNESS_STRIPPED, \"\");\n+                                txdownloadman.MempoolRejectedTx(stripped_tx, state, nodeid, true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::TX_WITNESS_MALLEATED:\n+                    {\n+                        // Call ReceivedTx. If txdownloadman instructs us to validate the\n+                        // transaction, return some error.\n+                        if (auto malleated_tx{GetMalleatedTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+\n+                            // Prevent accidental lose conditions.\n+                            if (malleated_tx == target_tx) break;\n+\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, malleated_tx);\n+                            if (should_validate) {\n+                                TxValidationState state;\n+                                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                                txdownloadman.MempoolRejectedTx(malleated_tx, state, nodeid, true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::NOTFOUND:\n+                    {\n+                        txdownloadman.ReceivedNotFound(nodeid, {maybe_gtxid.value().GetHash()});\n+                        break;\n+                    }\n+                    case PossibleResponse::NOTHING:\n+                    {\n+                        break;\n+                    }\n+                    case PossibleResponse::DEFER:\n+                    {\n+                        // bug\n+                        Assert(false);\n+                        break;\n+                    }\n+                }\n+\n+                // The peer may also send some unsolicited message. Simulate a ProcessMessage.\n+                // Ensure the good peer sends the inv within the first 1000 rounds.",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": 437,
      "original_position": 439,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770564734,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right, changed",
      "created_at": "2024-09-29T14:58:45Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780064782",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780064782"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 437,
      "original_line": 437,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780064811",
      "pull_request_review_id": 2323753194,
      "id": 1780064811,
      "node_id": "PRRC_kwDOABII585qGaIr",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\n+    }\n+}\n+\n+static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.first;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetStrippedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return StripWitness(tx_it->second.first);\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetMalleatedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.second;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetRandomTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, FuzzedDataProvider& fuzzed_data_provider, bool correct_only = false)\n+{\n+    auto it = txmap.begin();\n+    // Jump forward a random number of times.\n+    for (size_t i = 0; i <= fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1); ++i) it++;",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 274,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770568085,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Changed to something like this",
      "created_at": "2024-09-29T14:58:57Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780064811",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780064811"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780065017",
      "pull_request_review_id": 2323753194,
      "id": 1780065017,
      "node_id": "PRRC_kwDOABII585qGaL5",
      "diff_hunk": "@@ -0,0 +1,339 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <addresstype.h>\n+#include <consensus/validation.h>\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <primitives/transaction.h>\n+#include <script/script.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static bool CheckOrphanBehavior(node::TxDownloadManagerImpl& txdownload_impl, const CTransactionRef& tx, const node::RejectedTxTodo& ret, std::string& err_msg,\n+                                bool expect_orphan, bool expect_keep, unsigned int expected_parents)\n+{\n+    // Missing inputs can never result in a PackageToValidate.\n+    if (ret.m_package_to_validate.has_value()) {\n+        err_msg = strprintf(\"returned a PackageToValidate on missing inputs\");\n+        return false;",
      "path": "src/test/txdownload_tests.cpp",
      "position": 81,
      "original_position": 81,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": 1771098235,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah this is so we can have `BOOST_CHECK_MESSAGE` easily check and print the error. IIRC I had trouble getting the `std::optional` way to work.",
      "created_at": "2024-09-29T15:00:04Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780065017",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780065017"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 80,
      "original_start_line": 80,
      "start_side": "RIGHT",
      "line": 81,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780065200",
      "pull_request_review_id": 2323753194,
      "id": 1780065200,
      "node_id": "PRRC_kwDOABII585qGaOw",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\n+    }\n+}\n+\n+static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": 248,
      "original_position": 249,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770565944,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Scope seems to be about the same? There isn't anything happening after this section.",
      "created_at": "2024-09-29T15:01:04Z",
      "updated_at": "2024-09-29T15:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780065200",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780065200"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 247,
      "original_start_line": 248,
      "start_side": "RIGHT",
      "line": 248,
      "original_line": 248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780081814",
      "pull_request_review_id": 2335890660,
      "id": 1780081814,
      "node_id": "PRRC_kwDOABII585qGeSW",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\n+    }\n+}\n+\n+static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.first;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetStrippedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return StripWitness(tx_it->second.first);\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetMalleatedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.second;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetRandomTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, FuzzedDataProvider& fuzzed_data_provider, bool correct_only = false)\n+{\n+    auto it = txmap.begin();\n+    // Jump forward a random number of times.\n+    for (size_t i = 0; i <= fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1); ++i) it++;\n+    if (it == txmap.end()) return nullptr;\n+    return correct_only || fuzzed_data_provider.ConsumeBool() ? it->second.first : it->second.second;\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(txdownloadman_one_honest_peer, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+    std::chrono::microseconds time{244466666};\n+\n+    // Decide the target transaction. Disallow selecting a witness-stripped or non-segwit\n+    // transaction because it can lead to false negatives. This test may mark a same-txid\n+    // transaction as invalid, and we don't want that to cause rejection of the target tx.\n+    const auto& target_tx = GetRandomTx(TRANSACTIONS, fuzzed_data_provider, /*correct_only=*/true);\n+    Assert(target_tx != nullptr);\n+    Assert(target_tx->HasWitness());\n+\n+    const auto& target_txid = target_tx->GetHash();\n+    const auto& target_wtxid = target_tx->GetWitnessHash();\n+\n+    // Decide what the peers are.\n+    std::vector<TestPeer> all_peers;\n+    // NodeId of the \"designated good peer\"\n+    // Other TestPeers may be \"good\" as well, but not guaranteed.\n+    NodeId honestid = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 7);\n+    // 8 outbound peers. NodeId = o. We indicate outbound using preferred=true\n+    for (unsigned int o = 0; o < 8; ++o) {\n+        bool good = (o == honestid) || fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, o, /*preferred=*/true, /*force_good=*/good));\n+    }\n+    // 0-120 inbound peers. NodeId = i. We indicate inbound using preferred=false\n+    auto num_inbound_peers = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 120);\n+    for (unsigned int i = 8; i < num_inbound_peers + 8; ++i) {\n+        bool good = fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, i, /*preferred=*/false, /*force_good=*/good));\n+    }\n+\n+    // Indexes for random peer iteration\n+    std::vector<size_t> indexes;\n+    indexes.resize(all_peers.size());\n+    std::iota(indexes.begin(), indexes.end(), 0);\n+\n+    // We are trying to ensure that we always download the tx as long as we have 1 good outbound\n+    // peer who is able to send it to us.\n+    bool got_tx{false};\n+\n+    // Keep track of how many iterations the loop has done to make sure the target transaction is\n+    // announced within the first 1000 rounds. Note that the good peer is guaranteed to connect\n+    // within the first round and will never be disconnected.\n+    int counter = 0;\n+\n+    LIMITED_WHILE(!got_tx, 100000)\n+    {\n+        FastRandomContext rng{ConsumeUInt256(fuzzed_data_provider)};\n+        std::shuffle(indexes.begin(), indexes.end(), rng);\n+        // For each peer in random order, mock a ProcessMessages + SendMessages\n+        for (const auto index : indexes) {\n+            auto& peer = all_peers.at(index);\n+            NodeId nodeid = peer.m_nodeid;\n+\n+            // Maybe connect the peer if we haven't already. Always connect if it's the good peer.\n+            if (nodeid == honestid ||\n+                (peer.m_connection_state == ConnectionState::NEVER_CONNECTED && fuzzed_data_provider.ConsumeBool())) {\n+                node::TxDownloadConnectionInfo info{peer.m_connection_preferred, peer.m_relay_permissions, peer.m_wtxid_relay};\n+                txdownloadman.ConnectedPeer(nodeid, info);\n+                peer.m_connection_state = ConnectionState::CONNECTED;\n+            }\n+\n+            if (peer.m_connection_state == ConnectionState::CONNECTED) {\n+                // Peer will do its own ProcessMessages, i.e. respond to the next item in its message queue\n+                // If the message queue is empty or it decides to send nothing, maybe_gtxid is\n+                // std::nullopt. Otherwise, maybe_gtxid must contain the gtxid we are responding to.\n+                const auto& [peer_response, maybe_gtxid] = peer.ProcessOneMessage(fuzzed_data_provider);\n+\n+                // Simulate a ProcessMessage.\n+                switch (peer_response) {\n+                    case PossibleResponse::TX_REAL:\n+                    {\n+                        // If the transaction exists, use ReceivedTx. Otherwise, maybe send notfound.\n+                        if (auto ptx{GetCorrectTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, ptx);\n+                            if (should_validate || package_to_validate.has_value()) {\n+                                if (ptx->GetWitnessHash() == target_wtxid) {\n+                                    // We received the target tx and decided to validate it! Win!\n+                                    got_tx = true;\n+                                } else {\n+                                    // If not the target tx, pick some failure reason.\n+                                    TxValidationState state;\n+                                    state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                                    txdownloadman.MempoolRejectedTx(ptx, state, nodeid, true);\n+                                }\n+                            } else {\n+                            }\n+                        } else {\n+                            Assert(!peer.m_good);\n+                            if (fuzzed_data_provider.ConsumeBool()) {\n+                                txdownloadman.ReceivedNotFound(nodeid, {maybe_gtxid.value().GetHash()});\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::TX_WITNESS_STRIPPED:\n+                    {\n+                        // Call ReceivedTx. If txdownloadman instructs us to validate the\n+                        // transaction, say the result was TX_WITNESS_STRIPPED.\n+                        if (auto stripped_tx{GetStrippedTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+                            const auto& [should_validate, package] = txdownloadman.ReceivedTx(nodeid, stripped_tx);\n+                            if (should_validate) {\n+                                TxValidationState state;\n+                                state.Invalid(TxValidationResult::TX_WITNESS_STRIPPED, \"\");\n+                                txdownloadman.MempoolRejectedTx(stripped_tx, state, nodeid, true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::TX_WITNESS_MALLEATED:\n+                    {\n+                        // Call ReceivedTx. If txdownloadman instructs us to validate the\n+                        // transaction, return some error.\n+                        if (auto malleated_tx{GetMalleatedTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+\n+                            // Prevent accidental lose conditions.\n+                            if (malleated_tx == target_tx) break;\n+\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, malleated_tx);\n+                            if (should_validate) {\n+                                TxValidationState state;\n+                                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                                txdownloadman.MempoolRejectedTx(malleated_tx, state, nodeid, true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::NOTFOUND:\n+                    {\n+                        txdownloadman.ReceivedNotFound(nodeid, {maybe_gtxid.value().GetHash()});\n+                        break;\n+                    }\n+                    case PossibleResponse::NOTHING:\n+                    {\n+                        break;\n+                    }\n+                    case PossibleResponse::DEFER:\n+                    {\n+                        // bug\n+                        Assert(false);\n+                        break;\n+                    }\n+                }\n+\n+                // The peer may also send some unsolicited message. Simulate a ProcessMessage.\n+                // Ensure the good peer sends the inv within the first 1000 rounds.\n+                auto peer_unsolicited_message = peer.SendOneMessage(fuzzed_data_provider, /*force_announce=*/counter > 1000);\n+\n+                switch (peer_unsolicited_message) {\n+                    case PossibleMessage::NOTHING:\n+                    {\n+                        break;\n+                    }\n+                    case PossibleMessage::INV_REAL:\n+                    {\n+                        if (peer.m_wtxid_relay) {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Wtxid(target_wtxid), time, /*p2p_inv=*/true);\n+                        } else {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Txid(target_txid), time, /*p2p_inv=*/true);\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::INV_DIFFERENT:\n+                    {\n+                        // This may or may not be target_tx\n+                        if (auto random_tx{GetRandomTx(TRANSACTIONS, fuzzed_data_provider)}) {\n+                            if (peer.m_wtxid_relay) {\n+                                txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Txid(random_tx->GetHash()), time, /*p2p_inv=*/true);\n+                            } else {\n+                                txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Wtxid(random_tx->GetWitnessHash()), time, /*p2p_inv=*/true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::INV_RANDOM:\n+                    {\n+                        auto random_txhash = ConsumeUInt256(fuzzed_data_provider);\n+                        if (peer.m_wtxid_relay) {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Wtxid(random_txhash), time, /*p2p_inv=*/true);\n+                        } else {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Txid(random_txhash), time, /*p2p_inv=*/true);\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::TX_RANDOM:\n+                    {\n+                        if (auto random_tx{GetRandomTx(TRANSACTIONS, fuzzed_data_provider)}) {\n+                            // Disallow winning this way.\n+                            if (random_tx == target_tx) break;\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, random_tx);\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::NOTFOUND:\n+                    {\n+                        if (auto random_tx{GetRandomTx(TRANSACTIONS, fuzzed_data_provider)}) {\n+                            const auto txhash{fuzzed_data_provider.ConsumeBool() ? random_tx->GetHash().ToUint256() : random_tx->GetWitnessHash().ToUint256()};\n+                            txdownloadman.ReceivedNotFound(nodeid, {txhash});\n+                        }\n+                        break;\n+                    }\n+                }\n+\n+                // Simulate a SendMessages, which includes sending getdata to request transactions.\n+                for (const auto& gtxid : txdownloadman.GetRequestsToSend(nodeid, time)) {\n+                    peer.m_getdata_queue.push_back(gtxid);\n+                }\n+\n+                // Maybe disconnect the peer if we haven't already. Never disconnect the good peer.\n+                if (peer.m_connection_state == ConnectionState::CONNECTED && nodeid != honestid && fuzzed_data_provider.ConsumeBool()) {\n+                    peer.m_connection_state = ConnectionState::DISCONNECTED;\n+                    txdownloadman.DisconnectedPeer(nodeid);\n+                    txdownloadman.CheckIsEmpty(nodeid);\n+                }\n+                ++counter;\n+            }\n+        }\n+\n+        // Skip time by 100-300ms",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 512,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770564258,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In that case please consider using `std::chrono::milliseconds` instead of multiplying micros by 1000 - making the comment redundant.",
      "created_at": "2024-09-29T16:28:45Z",
      "updated_at": "2024-09-29T16:56:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780081814",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780081814"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 512,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780081933",
      "pull_request_review_id": 2335890660,
      "id": 1780081933,
      "node_id": "PRRC_kwDOABII585qGeUN",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\n+    }\n+}\n+\n+static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": 248,
      "original_position": 249,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770565944,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Exactly, that's what we'd be signalling by reducing the scope",
      "created_at": "2024-09-29T16:29:39Z",
      "updated_at": "2024-09-29T16:29:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780081933",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780081933"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 247,
      "original_start_line": 248,
      "start_side": "RIGHT",
      "line": 248,
      "original_line": 248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780082276",
      "pull_request_review_id": 2335891096,
      "id": 1780082276,
      "node_id": "PRRC_kwDOABII585qGeZk",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }\n+}\n+\n+bool TxDownloadManagerImpl::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    // If this is an inv received from a peer and we already have it, we can drop it.\n+    // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\n+    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\n+    if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\n+\n+    if (m_peer_info.count(peer) == 0) return false;\n+    const auto& info = m_peer_info.at(peer).m_connection_info;\n+    if (!info.m_relay_permissions && m_txrequest.Count(peer) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements for this peer\n+        return false;\n+    }\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or NetPermissionFlags::NoBan permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for txid announcements while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from peers which have at least\n+    //     MAX_PEER_TX_REQUEST_IN_FLIGHT requests in flight (and don't have NetPermissionFlags::Relay).\n+    auto delay{0us};\n+    if (!info.m_preferred) delay += NONPREF_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && m_num_wtxid_peers > 0) delay += TXID_RELAY_DELAY;\n+    const bool overloaded = !info.m_relay_permissions && m_txrequest.CountInFlight(peer) >= MAX_PEER_TX_REQUEST_IN_FLIGHT;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+\n+    m_txrequest.ReceivedInv(peer, gtxid, info.m_preferred, now + delay);\n+\n+    return false;\n+}\n+\n+std::vector<GenTxid> TxDownloadManagerImpl::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    std::vector<GenTxid> requests;\n+    std::vector<std::pair<NodeId, GenTxid>> expired;\n+    auto requestable = m_txrequest.GetRequestable(nodeid, current_time, &expired);\n+    for (const auto& entry : expired) {\n+        LogDebug(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n+            entry.second.GetHash().ToString(), entry.first);\n+    }\n+    for (const GenTxid& gtxid : requestable) {\n+        if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+            LogDebug(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n+                gtxid.GetHash().ToString(), nodeid);\n+            requests.emplace_back(gtxid);\n+            m_txrequest.RequestedTx(nodeid, gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n+        } else {\n+            // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n+            // this should already be called whenever a transaction becomes AlreadyHaveTx().\n+            m_txrequest.ForgetTxHash(gtxid.GetHash());\n+        }\n+    }\n+    return requests;\n+}\n+\n+void TxDownloadManagerImpl::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    for (const auto& txhash : txhashes) {\n+        // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\n+        // completed in TxRequestTracker.\n+        m_txrequest.ReceivedResponse(nodeid, txhash);\n+    }\n+}\n+\n+std::optional<PackageToValidate> TxDownloadManagerImpl::Find1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    Assume(RecentRejectsReconsiderableFilter().contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child, nodeid, nodeid};\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+    // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+    // create a bias that attackers can use to delay package acceptance.\n+    //\n+    // Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    std::shuffle(tx_indices.begin(), tx_indices.end(), m_opts.m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_lazy_recent_rejects_reconsiderable.\n+        const auto [child_tx, child_sender] = cpfp_candidates_different_peer.at(index);\n+        Package maybe_cpfp_package{ptx, child_tx};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child_tx, nodeid, child_sender};\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+void TxDownloadManagerImpl::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    // As this version of the transaction was acceptable, we can forget about any requests for it.\n+    // No-op if the tx is not in txrequest.\n+    m_txrequest.ForgetTxHash(tx->GetHash());\n+    m_txrequest.ForgetTxHash(tx->GetWitnessHash());\n+\n+    m_orphanage.AddChildrenToWorkSet(*tx);\n+    // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n+    m_orphanage.EraseTx(tx->GetWitnessHash());\n+}\n+\n+node::RejectedTxTodo TxDownloadManagerImpl::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    const CTransaction& tx{*ptx};\n+    // Results returned to caller\n+    // Whether we should call AddToCompactExtraTransactions at the end\n+    bool add_extra_compact_tx{first_time_failure};\n+    // Hashes to pass to AddKnownTx later\n+    std::vector<uint256> unique_parents;\n+    // Populated if failure is reconsiderable and eligible package is found.\n+    std::optional<node::PackageToValidate> package_to_validate;\n+\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+        // Only process a new orphan if this is a first time failure, as otherwise it must be either\n+        // already in orphanage or from 1p1c processing.\n+        if (first_time_failure && !RecentRejectsFilter().contains(ptx->GetWitnessHash().ToUint256())) {\n+            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+            // Deduplicate parent txids, so that we don't have to loop over\n+            // the same parent txid more than once down below.\n+            unique_parents.reserve(tx.vin.size());\n+            for (const CTxIn& txin : tx.vin) {\n+                // We start with all parents, and then remove duplicates below.\n+                unique_parents.push_back(txin.prevout.hash);\n+            }\n+            std::sort(unique_parents.begin(), unique_parents.end());\n+            unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+            // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 329,
      "original_position": 323,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770587752,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There are many such cases, are none of them related to this change?",
      "created_at": "2024-09-29T16:31:23Z",
      "updated_at": "2024-09-29T16:31:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780082276",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780082276"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 329,
      "original_line": 329,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780082684",
      "pull_request_review_id": 2335891493,
      "id": 1780082684,
      "node_id": "PRRC_kwDOABII585qGef8",
      "diff_hunk": "@@ -0,0 +1,339 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <addresstype.h>\n+#include <consensus/validation.h>\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <primitives/transaction.h>\n+#include <script/script.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static bool CheckOrphanBehavior(node::TxDownloadManagerImpl& txdownload_impl, const CTransactionRef& tx, const node::RejectedTxTodo& ret, std::string& err_msg,\n+                                bool expect_orphan, bool expect_keep, unsigned int expected_parents)\n+{\n+    // Missing inputs can never result in a PackageToValidate.\n+    if (ret.m_package_to_validate.has_value()) {\n+        err_msg = strprintf(\"returned a PackageToValidate on missing inputs\");\n+        return false;",
      "path": "src/test/txdownload_tests.cpp",
      "position": 81,
      "original_position": 81,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "b543dc083ddbf43bb172b60ddb90609a600c86b5",
      "in_reply_to_id": 1771098235,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, it was messy before, but now that https://github.com/bitcoin/bitcoin/pull/30618/files#diff-d4a2fb26adedc27f16bd3778424fa94c473342a695b228220a1810119028be5bR257-R261 is merged, it might be simpler",
      "created_at": "2024-09-29T16:33:40Z",
      "updated_at": "2024-09-29T16:33:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780082684",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780082684"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 80,
      "original_start_line": 80,
      "start_side": "RIGHT",
      "line": 81,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780083894",
      "pull_request_review_id": 2335892594,
      "id": 1780083894,
      "node_id": "PRRC_kwDOABII585qGey2",
      "diff_hunk": "@@ -0,0 +1,159 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadManagerImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {\n+    /** Read-only reference to mempool. */\n+    const CTxMemPool& m_mempool;\n+    /** RNG provided by caller. */\n+    FastRandomContext& m_rng;\n+    /** Maximum number of transactions allowed in orphanage. */\n+    const uint32_t m_max_orphan_txs;\n+    /** Instantiate TxRequestTracker as deterministic (used for tests). */\n+    bool m_deterministic_txrequest{false};\n+};\n+struct TxDownloadConnectionInfo {\n+    /** Whether this peer is preferred for transaction download. */\n+    const bool m_preferred;\n+    /** Whether this peer has Relay permissions. */\n+    const bool m_relay_permissions;\n+    /** Whether this peer supports wtxid relay. */\n+    const bool m_wtxid_relay;\n+};\n+struct PackageToValidate {\n+    Package m_txns;\n+    std::vector<NodeId> m_senders;\n+    /** Construct a 1-parent-1-child package. */\n+    explicit PackageToValidate(const CTransactionRef& parent,\n+                               const CTransactionRef& child,\n+                               NodeId parent_sender,\n+                               NodeId child_sender) :\n+        m_txns{parent, child},\n+        m_senders{parent_sender, child_sender}\n+    {}\n+\n+    // Move ctor\n+    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\n+    // Copy ctor\n+    PackageToValidate(const PackageToValidate& other) = default;\n+\n+    // Move assignment\n+    PackageToValidate& operator=(PackageToValidate&& other) {\n+        this->m_txns = std::move(other.m_txns);\n+        this->m_senders = std::move(other.m_senders);\n+        return *this;\n+    }",
      "path": "src/node/txdownloadman.h",
      "position": 81,
      "original_position": 81,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770549633,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "So when would this be in scope?",
      "created_at": "2024-09-29T16:39:43Z",
      "updated_at": "2024-09-29T16:39:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780083894",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780083894"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 72,
      "original_start_line": 72,
      "start_side": "RIGHT",
      "line": 81,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780084321",
      "pull_request_review_id": 2335892884,
      "id": 1780084321,
      "node_id": "PRRC_kwDOABII585qGe5h",
      "diff_hunk": "@@ -5321,16 +4869,18 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n     if (msg_type == NetMsgType::NOTFOUND) {\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n-        if (vInv.size() <= MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-            LOCK(m_tx_download_mutex);\n+        std::vector<uint256> tx_invs;\n+        if (vInv.size() <= node::MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             for (CInv &inv : vInv) {",
      "path": "src/net_processing.cpp",
      "position": 832,
      "original_position": 832,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770546568,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Isn't that what we'd be calculating via `std::ranges::count_if(vInv, &CInv::IsGenTxMsg)`?",
      "created_at": "2024-09-29T16:41:07Z",
      "updated_at": "2024-09-29T16:51:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780084321",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780084321"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4874,
      "original_line": 4874,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780087050",
      "pull_request_review_id": 2335895153,
      "id": 1780087050,
      "node_id": "PRRC_kwDOABII585qGfkK",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 75,
      "original_position": 75,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770570141,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I was referring to getting rid of the cast, but not important, please resolve these.",
      "created_at": "2024-09-29T16:55:14Z",
      "updated_at": "2024-09-29T16:55:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1780087050",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1780087050"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 75,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781283774",
      "pull_request_review_id": 2337805760,
      "id": 1781283774,
      "node_id": "PRRC_kwDOABII585qLDu-",
      "diff_hunk": "@@ -0,0 +1,339 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <addresstype.h>\n+#include <consensus/validation.h>\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <primitives/transaction.h>\n+#include <script/script.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static bool CheckOrphanBehavior(node::TxDownloadManagerImpl& txdownload_impl, const CTransactionRef& tx, const node::RejectedTxTodo& ret, std::string& err_msg,\n+                                bool expect_orphan, bool expect_keep, unsigned int expected_parents)\n+{\n+    // Missing inputs can never result in a PackageToValidate.\n+    if (ret.m_package_to_validate.has_value()) {\n+        err_msg = strprintf(\"returned a PackageToValidate on missing inputs\");\n+        return false;\n+    }\n+\n+    if (expect_orphan != txdownload_impl.m_orphanage.HaveTx(tx->GetWitnessHash())) {\n+        err_msg = strprintf(\"unexpectedly %s tx in orpanage\", expect_orphan ? \"did not find\" : \"found\");\n+        return false;\n+    }\n+    if (expect_keep != ret.m_should_add_extra_compact_tx) {\n+        err_msg = strprintf(\"unexpectedly returned %s add to vExtraTxnForCompact\", expect_keep ? \"should not\" : \"should\");\n+        return false;\n+    }\n+    if (expected_parents != ret.m_unique_parents.size()) {\n+        err_msg = strprintf(\"expected %u unique_parents, got %u\", expected_parents, ret.m_unique_parents.size());\n+        return false;\n+    }\n+    return true;\n+}\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadOptions DEFAULT_OPTS{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true};\n+\n+    // A new TxDownloadManagerImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+    node::TxDownloadConnectionInfo connection_info{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};\n+\n+    for (const auto segwit_parent : {true, false}) {\n+        for (const auto segwit_child : {true, false}) {\n+            const auto ptx_parent = CreateTransactionChain(1, segwit_parent).front();\n+            const auto ptx_child = CreateTransactionChain(1, segwit_child).front();\n+            const auto& parent_txid = ptx_parent->GetHash().ToUint256();\n+            const auto& parent_wtxid = ptx_parent->GetWitnessHash().ToUint256();\n+            const auto& child_txid = ptx_child->GetHash().ToUint256();\n+            const auto& child_wtxid = ptx_child->GetWitnessHash().ToUint256();\n+\n+            for (const auto& [result, expected_behavior] : expected_behaviors) {\n+                node::TxDownloadManagerImpl txdownload_impl{DEFAULT_OPTS};\n+                txdownload_impl.ConnectedPeer(nodeid, connection_info);\n+                // Parent failure\n+                state.Invalid(result, \"\");\n+                const auto& [keep, unique_txids, package_to_validate] = txdownload_impl.MempoolRejectedTx(ptx_parent, state, nodeid, /*first_time_failure=*/true);\n+\n+                // No distinction between txid and wtxid caching for nonsegwit transactions, so only test these specific\n+                // behaviors for segwit transactions.\n+                Behaviors actual_behavior{\n+                    /*txid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_txid),\n+                    /*wtxid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_wtxid),\n+                    /*txid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_txid),\n+                    /*wtxid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_wtxid),\n+                    /*keep=*/keep,\n+                    /*txid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Txid(parent_txid), now, /*p2p_inv=*/true),\n+                    /*wtxid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Wtxid(parent_wtxid), now, /*p2p_inv=*/true),\n+                };\n+                BOOST_TEST_MESSAGE(\"Testing behavior for \" << result << (segwit_parent ? \" segwit \" : \" nonsegwit\"));\n+                actual_behavior.CheckEqual(expected_behavior, /*segwit=*/segwit_parent);\n+\n+                // Later, a child of this transaction fails for missing inputs\n+                state.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                txdownload_impl.MempoolRejectedTx(ptx_child, state, nodeid, /*first_time_failure=*/true);\n+\n+                // If parent (by txid) was rejected, child is too.\n+                const bool parent_txid_rejected{segwit_parent ? expected_behavior.m_txid_in_rejects : expected_behavior.m_wtxid_in_rejects};\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_txid));\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_wtxid));\n+\n+                // Unless rejected, the child should be in orphanage.\n+                BOOST_CHECK_EQUAL(!parent_txid_rejected, txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(handle_missing_inputs, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadOptions DEFAULT_OPTS{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true};\n+    NodeId nodeid{1};\n+    node::TxDownloadConnectionInfo DEFAULT_CONN{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};\n+\n+    // We need mature coinbases\n+    mineBlocks(20);\n+\n+    // Transactions with missing inputs are treated differently depending on how much we know about\n+    // their parents.\n+    CKey wallet_key = GenerateRandomKey();\n+    CScript destination = GetScriptForDestination(PKHash(wallet_key.GetPubKey()));\n+    // Amount for spending coinbase in a 1-in-1-out tx, at depth n, each time deducting 1000 from the amount as fees.\n+    CAmount amount_depth_1{50 * COIN - 1000};\n+    CAmount amount_depth_2{amount_depth_1 - 1000};\n+    // Amount for spending coinbase in a 1-in-2-out tx, deducting 1000 in fees\n+    CAmount amount_split_half{25 * COIN - 500};\n+    int test_chain_height{100};\n+\n+    TxValidationState state_orphan;\n+    state_orphan.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+\n+    // Transactions are not all submitted to mempool. Conserve the number of m_coinbase_txns we\n+    // consume, and only increment this index number when we would conflict with an existing\n+    // mempool transaction.\n+    size_t coinbase_idx{0};\n+\n+    for (int decisions = 0; decisions < (1 << 4); ++decisions) {\n+        auto mtx_single_parent = CreateValidMempoolTransaction(m_coinbase_txns[coinbase_idx], /*input_vout=*/0, test_chain_height, coinbaseKey, destination, amount_depth_1, /*submit=*/false);\n+        auto single_parent = MakeTransactionRef(mtx_single_parent);\n+\n+        auto mtx_orphan = CreateValidMempoolTransaction(single_parent, /*input_vout=*/0, test_chain_height, wallet_key, destination, amount_depth_2, /*submit=*/false);\n+        auto orphan = MakeTransactionRef(mtx_orphan);\n+\n+        node::TxDownloadManagerImpl txdownload_impl{DEFAULT_OPTS};\n+        txdownload_impl.ConnectedPeer(nodeid, DEFAULT_CONN);\n+\n+        // Each bit of decisions tells us whether the parent is in a particular cache.\n+        // It is definitely possible for a transaction to be in multiple caches. For example, it\n+        // may have both a low feerate and found to violate some mempool policy when validated\n+        // in a 1p1c.\n+        const bool parent_recent_rej(decisions & 1);\n+        const bool parent_recent_rej_recon((decisions >> 1) & 1);\n+        const bool parent_recent_conf((decisions >> 2) & 1);\n+        const bool parent_in_mempool((decisions >> 3) & 1);\n+\n+        if (parent_recent_rej) txdownload_impl.RecentRejectsFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_recent_rej_recon) txdownload_impl.RecentRejectsReconsiderableFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_recent_conf) txdownload_impl.RecentConfirmedTransactionsFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_in_mempool) {\n+            const auto mempool_result = WITH_LOCK(::cs_main, return m_node.chainman->ProcessTransaction(single_parent));\n+            BOOST_CHECK(mempool_result.m_result_type == MempoolAcceptResult::ResultType::VALID);\n+            coinbase_idx += 1;",
      "path": "src/test/txdownload_tests.cpp",
      "position": 227,
      "original_position": 232,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "9d6c88fa11daaa4de9381192fdc70f6a1652e178",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could assert that new idx doesn't overflow the `m_coinbase_txns` vector size",
      "created_at": "2024-09-30T14:46:43Z",
      "updated_at": "2024-09-30T15:18:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1781283774",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781283774"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 227,
      "original_line": 227,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781291525",
      "pull_request_review_id": 2337805760,
      "id": 1781291525,
      "node_id": "PRRC_kwDOABII585qLFoF",
      "diff_hunk": "@@ -0,0 +1,339 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <addresstype.h>\n+#include <consensus/validation.h>\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <primitives/transaction.h>\n+#include <script/script.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static bool CheckOrphanBehavior(node::TxDownloadManagerImpl& txdownload_impl, const CTransactionRef& tx, const node::RejectedTxTodo& ret, std::string& err_msg,\n+                                bool expect_orphan, bool expect_keep, unsigned int expected_parents)\n+{\n+    // Missing inputs can never result in a PackageToValidate.\n+    if (ret.m_package_to_validate.has_value()) {\n+        err_msg = strprintf(\"returned a PackageToValidate on missing inputs\");\n+        return false;\n+    }\n+\n+    if (expect_orphan != txdownload_impl.m_orphanage.HaveTx(tx->GetWitnessHash())) {\n+        err_msg = strprintf(\"unexpectedly %s tx in orpanage\", expect_orphan ? \"did not find\" : \"found\");\n+        return false;\n+    }\n+    if (expect_keep != ret.m_should_add_extra_compact_tx) {\n+        err_msg = strprintf(\"unexpectedly returned %s add to vExtraTxnForCompact\", expect_keep ? \"should not\" : \"should\");\n+        return false;\n+    }\n+    if (expected_parents != ret.m_unique_parents.size()) {\n+        err_msg = strprintf(\"expected %u unique_parents, got %u\", expected_parents, ret.m_unique_parents.size());\n+        return false;\n+    }\n+    return true;\n+}\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadOptions DEFAULT_OPTS{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true};\n+\n+    // A new TxDownloadManagerImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+    node::TxDownloadConnectionInfo connection_info{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};\n+\n+    for (const auto segwit_parent : {true, false}) {\n+        for (const auto segwit_child : {true, false}) {\n+            const auto ptx_parent = CreateTransactionChain(1, segwit_parent).front();\n+            const auto ptx_child = CreateTransactionChain(1, segwit_child).front();\n+            const auto& parent_txid = ptx_parent->GetHash().ToUint256();\n+            const auto& parent_wtxid = ptx_parent->GetWitnessHash().ToUint256();\n+            const auto& child_txid = ptx_child->GetHash().ToUint256();\n+            const auto& child_wtxid = ptx_child->GetWitnessHash().ToUint256();\n+\n+            for (const auto& [result, expected_behavior] : expected_behaviors) {\n+                node::TxDownloadManagerImpl txdownload_impl{DEFAULT_OPTS};\n+                txdownload_impl.ConnectedPeer(nodeid, connection_info);\n+                // Parent failure\n+                state.Invalid(result, \"\");\n+                const auto& [keep, unique_txids, package_to_validate] = txdownload_impl.MempoolRejectedTx(ptx_parent, state, nodeid, /*first_time_failure=*/true);\n+\n+                // No distinction between txid and wtxid caching for nonsegwit transactions, so only test these specific\n+                // behaviors for segwit transactions.\n+                Behaviors actual_behavior{\n+                    /*txid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_txid),\n+                    /*wtxid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_wtxid),\n+                    /*txid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_txid),\n+                    /*wtxid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_wtxid),\n+                    /*keep=*/keep,\n+                    /*txid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Txid(parent_txid), now, /*p2p_inv=*/true),\n+                    /*wtxid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Wtxid(parent_wtxid), now, /*p2p_inv=*/true),\n+                };\n+                BOOST_TEST_MESSAGE(\"Testing behavior for \" << result << (segwit_parent ? \" segwit \" : \" nonsegwit\"));\n+                actual_behavior.CheckEqual(expected_behavior, /*segwit=*/segwit_parent);\n+\n+                // Later, a child of this transaction fails for missing inputs\n+                state.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                txdownload_impl.MempoolRejectedTx(ptx_child, state, nodeid, /*first_time_failure=*/true);\n+\n+                // If parent (by txid) was rejected, child is too.\n+                const bool parent_txid_rejected{segwit_parent ? expected_behavior.m_txid_in_rejects : expected_behavior.m_wtxid_in_rejects};\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_txid));\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_wtxid));\n+\n+                // Unless rejected, the child should be in orphanage.\n+                BOOST_CHECK_EQUAL(!parent_txid_rejected, txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(handle_missing_inputs, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadOptions DEFAULT_OPTS{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true};\n+    NodeId nodeid{1};\n+    node::TxDownloadConnectionInfo DEFAULT_CONN{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};\n+\n+    // We need mature coinbases\n+    mineBlocks(20);\n+\n+    // Transactions with missing inputs are treated differently depending on how much we know about\n+    // their parents.\n+    CKey wallet_key = GenerateRandomKey();\n+    CScript destination = GetScriptForDestination(PKHash(wallet_key.GetPubKey()));\n+    // Amount for spending coinbase in a 1-in-1-out tx, at depth n, each time deducting 1000 from the amount as fees.\n+    CAmount amount_depth_1{50 * COIN - 1000};\n+    CAmount amount_depth_2{amount_depth_1 - 1000};\n+    // Amount for spending coinbase in a 1-in-2-out tx, deducting 1000 in fees\n+    CAmount amount_split_half{25 * COIN - 500};\n+    int test_chain_height{100};\n+\n+    TxValidationState state_orphan;\n+    state_orphan.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+\n+    // Transactions are not all submitted to mempool. Conserve the number of m_coinbase_txns we\n+    // consume, and only increment this index number when we would conflict with an existing\n+    // mempool transaction.\n+    size_t coinbase_idx{0};\n+\n+    for (int decisions = 0; decisions < (1 << 4); ++decisions) {\n+        auto mtx_single_parent = CreateValidMempoolTransaction(m_coinbase_txns[coinbase_idx], /*input_vout=*/0, test_chain_height, coinbaseKey, destination, amount_depth_1, /*submit=*/false);\n+        auto single_parent = MakeTransactionRef(mtx_single_parent);\n+\n+        auto mtx_orphan = CreateValidMempoolTransaction(single_parent, /*input_vout=*/0, test_chain_height, wallet_key, destination, amount_depth_2, /*submit=*/false);\n+        auto orphan = MakeTransactionRef(mtx_orphan);\n+\n+        node::TxDownloadManagerImpl txdownload_impl{DEFAULT_OPTS};\n+        txdownload_impl.ConnectedPeer(nodeid, DEFAULT_CONN);\n+\n+        // Each bit of decisions tells us whether the parent is in a particular cache.\n+        // It is definitely possible for a transaction to be in multiple caches. For example, it\n+        // may have both a low feerate and found to violate some mempool policy when validated\n+        // in a 1p1c.\n+        const bool parent_recent_rej(decisions & 1);\n+        const bool parent_recent_rej_recon((decisions >> 1) & 1);\n+        const bool parent_recent_conf((decisions >> 2) & 1);\n+        const bool parent_in_mempool((decisions >> 3) & 1);\n+\n+        if (parent_recent_rej) txdownload_impl.RecentRejectsFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_recent_rej_recon) txdownload_impl.RecentRejectsReconsiderableFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_recent_conf) txdownload_impl.RecentConfirmedTransactionsFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_in_mempool) {\n+            const auto mempool_result = WITH_LOCK(::cs_main, return m_node.chainman->ProcessTransaction(single_parent));\n+            BOOST_CHECK(mempool_result.m_result_type == MempoolAcceptResult::ResultType::VALID);\n+            coinbase_idx += 1;\n+        }\n+\n+        // Whether or not the transaction is added as an orphan depends solely on whether or not\n+        // it's in RecentRejectsFilter. Specifically, the parent is allowed to be in\n+        // RecentRejectsReconsiderableFilter, but it cannot be in both rejection filters.",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 237,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "9d6c88fa11daaa4de9381192fdc70f6a1652e178",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do you mean it cannot be in both, and result in a stored orphan?",
      "created_at": "2024-09-30T14:51:02Z",
      "updated_at": "2024-09-30T15:18:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1781291525",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781291525"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 237,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781293825",
      "pull_request_review_id": 2337805760,
      "id": 1781293825,
      "node_id": "PRRC_kwDOABII585qLGMB",
      "diff_hunk": "@@ -0,0 +1,339 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <addresstype.h>\n+#include <consensus/validation.h>\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <primitives/transaction.h>\n+#include <script/script.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static bool CheckOrphanBehavior(node::TxDownloadManagerImpl& txdownload_impl, const CTransactionRef& tx, const node::RejectedTxTodo& ret, std::string& err_msg,\n+                                bool expect_orphan, bool expect_keep, unsigned int expected_parents)\n+{\n+    // Missing inputs can never result in a PackageToValidate.\n+    if (ret.m_package_to_validate.has_value()) {\n+        err_msg = strprintf(\"returned a PackageToValidate on missing inputs\");\n+        return false;\n+    }\n+\n+    if (expect_orphan != txdownload_impl.m_orphanage.HaveTx(tx->GetWitnessHash())) {\n+        err_msg = strprintf(\"unexpectedly %s tx in orpanage\", expect_orphan ? \"did not find\" : \"found\");\n+        return false;\n+    }\n+    if (expect_keep != ret.m_should_add_extra_compact_tx) {\n+        err_msg = strprintf(\"unexpectedly returned %s add to vExtraTxnForCompact\", expect_keep ? \"should not\" : \"should\");\n+        return false;\n+    }\n+    if (expected_parents != ret.m_unique_parents.size()) {\n+        err_msg = strprintf(\"expected %u unique_parents, got %u\", expected_parents, ret.m_unique_parents.size());\n+        return false;\n+    }\n+    return true;\n+}\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadOptions DEFAULT_OPTS{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true};\n+\n+    // A new TxDownloadManagerImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+    node::TxDownloadConnectionInfo connection_info{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};\n+\n+    for (const auto segwit_parent : {true, false}) {\n+        for (const auto segwit_child : {true, false}) {\n+            const auto ptx_parent = CreateTransactionChain(1, segwit_parent).front();\n+            const auto ptx_child = CreateTransactionChain(1, segwit_child).front();\n+            const auto& parent_txid = ptx_parent->GetHash().ToUint256();\n+            const auto& parent_wtxid = ptx_parent->GetWitnessHash().ToUint256();\n+            const auto& child_txid = ptx_child->GetHash().ToUint256();\n+            const auto& child_wtxid = ptx_child->GetWitnessHash().ToUint256();\n+\n+            for (const auto& [result, expected_behavior] : expected_behaviors) {\n+                node::TxDownloadManagerImpl txdownload_impl{DEFAULT_OPTS};\n+                txdownload_impl.ConnectedPeer(nodeid, connection_info);\n+                // Parent failure\n+                state.Invalid(result, \"\");\n+                const auto& [keep, unique_txids, package_to_validate] = txdownload_impl.MempoolRejectedTx(ptx_parent, state, nodeid, /*first_time_failure=*/true);\n+\n+                // No distinction between txid and wtxid caching for nonsegwit transactions, so only test these specific\n+                // behaviors for segwit transactions.\n+                Behaviors actual_behavior{\n+                    /*txid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_txid),\n+                    /*wtxid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_wtxid),\n+                    /*txid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_txid),\n+                    /*wtxid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_wtxid),\n+                    /*keep=*/keep,\n+                    /*txid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Txid(parent_txid), now, /*p2p_inv=*/true),\n+                    /*wtxid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Wtxid(parent_wtxid), now, /*p2p_inv=*/true),\n+                };\n+                BOOST_TEST_MESSAGE(\"Testing behavior for \" << result << (segwit_parent ? \" segwit \" : \" nonsegwit\"));\n+                actual_behavior.CheckEqual(expected_behavior, /*segwit=*/segwit_parent);\n+\n+                // Later, a child of this transaction fails for missing inputs\n+                state.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                txdownload_impl.MempoolRejectedTx(ptx_child, state, nodeid, /*first_time_failure=*/true);\n+\n+                // If parent (by txid) was rejected, child is too.\n+                const bool parent_txid_rejected{segwit_parent ? expected_behavior.m_txid_in_rejects : expected_behavior.m_wtxid_in_rejects};\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_txid));\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_wtxid));\n+\n+                // Unless rejected, the child should be in orphanage.\n+                BOOST_CHECK_EQUAL(!parent_txid_rejected, txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(handle_missing_inputs, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadOptions DEFAULT_OPTS{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true};\n+    NodeId nodeid{1};\n+    node::TxDownloadConnectionInfo DEFAULT_CONN{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};\n+\n+    // We need mature coinbases\n+    mineBlocks(20);\n+\n+    // Transactions with missing inputs are treated differently depending on how much we know about\n+    // their parents.\n+    CKey wallet_key = GenerateRandomKey();\n+    CScript destination = GetScriptForDestination(PKHash(wallet_key.GetPubKey()));\n+    // Amount for spending coinbase in a 1-in-1-out tx, at depth n, each time deducting 1000 from the amount as fees.\n+    CAmount amount_depth_1{50 * COIN - 1000};\n+    CAmount amount_depth_2{amount_depth_1 - 1000};\n+    // Amount for spending coinbase in a 1-in-2-out tx, deducting 1000 in fees\n+    CAmount amount_split_half{25 * COIN - 500};\n+    int test_chain_height{100};\n+\n+    TxValidationState state_orphan;\n+    state_orphan.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+\n+    // Transactions are not all submitted to mempool. Conserve the number of m_coinbase_txns we\n+    // consume, and only increment this index number when we would conflict with an existing\n+    // mempool transaction.\n+    size_t coinbase_idx{0};\n+\n+    for (int decisions = 0; decisions < (1 << 4); ++decisions) {\n+        auto mtx_single_parent = CreateValidMempoolTransaction(m_coinbase_txns[coinbase_idx], /*input_vout=*/0, test_chain_height, coinbaseKey, destination, amount_depth_1, /*submit=*/false);\n+        auto single_parent = MakeTransactionRef(mtx_single_parent);\n+\n+        auto mtx_orphan = CreateValidMempoolTransaction(single_parent, /*input_vout=*/0, test_chain_height, wallet_key, destination, amount_depth_2, /*submit=*/false);\n+        auto orphan = MakeTransactionRef(mtx_orphan);\n+\n+        node::TxDownloadManagerImpl txdownload_impl{DEFAULT_OPTS};\n+        txdownload_impl.ConnectedPeer(nodeid, DEFAULT_CONN);\n+\n+        // Each bit of decisions tells us whether the parent is in a particular cache.\n+        // It is definitely possible for a transaction to be in multiple caches. For example, it\n+        // may have both a low feerate and found to violate some mempool policy when validated\n+        // in a 1p1c.\n+        const bool parent_recent_rej(decisions & 1);\n+        const bool parent_recent_rej_recon((decisions >> 1) & 1);\n+        const bool parent_recent_conf((decisions >> 2) & 1);\n+        const bool parent_in_mempool((decisions >> 3) & 1);\n+\n+        if (parent_recent_rej) txdownload_impl.RecentRejectsFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_recent_rej_recon) txdownload_impl.RecentRejectsReconsiderableFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_recent_conf) txdownload_impl.RecentConfirmedTransactionsFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_in_mempool) {\n+            const auto mempool_result = WITH_LOCK(::cs_main, return m_node.chainman->ProcessTransaction(single_parent));\n+            BOOST_CHECK(mempool_result.m_result_type == MempoolAcceptResult::ResultType::VALID);\n+            coinbase_idx += 1;\n+        }\n+\n+        // Whether or not the transaction is added as an orphan depends solely on whether or not\n+        // it's in RecentRejectsFilter. Specifically, the parent is allowed to be in\n+        // RecentRejectsReconsiderableFilter, but it cannot be in both rejection filters.\n+        const bool expect_keep_orphan = !parent_recent_rej;\n+        const auto ret_1p1c = txdownload_impl.MempoolRejectedTx(orphan, state_orphan, nodeid, /*first_time_failure=*/true);\n+        std::string err_msg;\n+        const bool ok = CheckOrphanBehavior(txdownload_impl, orphan, ret_1p1c, err_msg,\n+                                            /*expect_orphan=*/expect_keep_orphan, /*expect_keep=*/true, /*expected_parents=*/expect_keep_orphan ? 1 : 0);\n+        BOOST_CHECK_MESSAGE(ok, err_msg);\n+    }\n+\n+    // Orphan with multiple parents\n+    {\n+        std::vector<CTransactionRef> parents;\n+        std::vector<COutPoint> outpoints;\n+        int32_t num_parents{24};\n+        for (int32_t i = 0; i < num_parents; ++i) {\n+            auto mtx_parent = CreateValidMempoolTransaction(m_coinbase_txns[coinbase_idx++], /*input_vout=*/0, test_chain_height,\n+                                                            coinbaseKey, destination, amount_depth_1 + i, /*submit=*/false);\n+            auto ptx_parent = MakeTransactionRef(mtx_parent);\n+            parents.emplace_back(ptx_parent);\n+            outpoints.emplace_back(ptx_parent->GetHash(), 0);\n+        }\n+\n+        // Send all coins to 1 address.",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 259,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "9d6c88fa11daaa4de9381192fdc70f6a1652e178",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n        // Send all coins to 1 output.\r\n```",
      "created_at": "2024-09-30T14:52:33Z",
      "updated_at": "2024-09-30T15:18:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1781293825",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781293825"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781349142",
      "pull_request_review_id": 2337916584,
      "id": 1781349142,
      "node_id": "PRRC_kwDOABII585qLTsW",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 194,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "ce205abe10ebccfdbea60adf4c568a8ba61390c3",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If no outpoints are given, it's no inputs at all? I think every call is using non-empty vectors, and if so should be asserted.",
      "created_at": "2024-09-30T15:29:21Z",
      "updated_at": "2024-09-30T16:00:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1781349142",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781349142"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781367693",
      "pull_request_review_id": 2337916584,
      "id": 1781367693,
      "node_id": "PRRC_kwDOABII585qLYON",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (maybe_package.has_value()) CheckPackageToValidate(*maybe_package, rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        // Jump forwards or backwards\n+        auto time_skip = fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+        if (fuzzed_data_provider.ConsumeBool()) time_skip *= -1;\n+        time += time_skip;\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadManagerImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+    txdownload_impl.m_txrequest.SanityCheck();\n+}\n+\n+FUZZ_TARGET(txdownloadman_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadManagerImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManagerImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 302,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3c1c9e766ad4fc6defdc9b4814c1e184f6603003",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ideally this would select N inputs rather than a static one, otherwise this target really only covers multi-input case with the `// 2 parents 1 child` case, and doesn't even cover duplicate prevout hashes.",
      "created_at": "2024-09-30T15:42:03Z",
      "updated_at": "2024-09-30T16:00:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1781367693",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781367693"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781392510",
      "pull_request_review_id": 2337916584,
      "id": 1781392510,
      "node_id": "PRRC_kwDOABII585qLeR-",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 212,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3c1c9e766ad4fc6defdc9b4814c1e184f6603003",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A few more assertions here and other spot for MempoolRejectedTx?\r\n```\r\n                bool first_time_failure{fuzzed_data_provider.ConsumeBool()};\r\n                bool reject_contains_wtxid{txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256())};\r\n                node::RejectedTxTodo todo = txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, first_time_failure);\r\n                Assert(first_time_failure || !todo.m_should_add_extra_compact_tx);\r\n                if (!reject_contains_wtxid) Assert(todo.m_unique_parents.size() <= rand_tx->vin.size());\r\n```",
      "created_at": "2024-09-30T15:58:49Z",
      "updated_at": "2024-09-30T16:00:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1781392510",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781392510"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781734202",
      "pull_request_review_id": 2338563165,
      "id": 1781734202,
      "node_id": "PRRC_kwDOABII585qMxs6",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 58,
      "original_position": 58,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3c1c9e766ad4fc6defdc9b4814c1e184f6603003",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in commit 3c1c9e766ad4fc6defdc9b4814c1e184f6603003: the `num_outputs` parameter is currently unused, so all txs created with this helper only have one output",
      "created_at": "2024-09-30T21:05:59Z",
      "updated_at": "2024-09-30T21:46:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1781734202",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781734202"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 58,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781744846",
      "pull_request_review_id": 2338563165,
      "id": 1781744846,
      "node_id": "PRRC_kwDOABII585qM0TO",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 172,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3c1c9e766ad4fc6defdc9b4814c1e184f6603003",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "was this meant to be\r\n```suggestion\r\n        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS - 1);\r\n```\r\ninstead, considering that the specified range end is inclusive? the peer loops and asserts have also currently different conditions (`< NUM_PEERS` in `CheckInvariants` vs. `<= NUM_PEERS` in the disconnect loops), so at least one of those needs to be adapted.",
      "created_at": "2024-09-30T21:18:27Z",
      "updated_at": "2024-09-30T21:46:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1781744846",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1781744846"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783207317",
      "pull_request_review_id": 2340935700,
      "id": 1783207317,
      "node_id": "PRRC_kwDOABII585qSZWV",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (maybe_package.has_value()) CheckPackageToValidate(*maybe_package, rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        // Jump forwards or backwards\n+        auto time_skip = fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+        if (fuzzed_data_provider.ConsumeBool()) time_skip *= -1;\n+        time += time_skip;\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadManagerImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+    txdownload_impl.m_txrequest.SanityCheck();\n+}\n+\n+FUZZ_TARGET(txdownloadman_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadManagerImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManagerImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                for (const auto& tx : TRANSACTIONS) {\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(tx->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(tx->GetHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(tx->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(tx->GetHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    CheckPackageToValidate(*maybe_package, rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(GetPackageHash(package)));\n+                    // Neither is in m_lazy_recent_rejects\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256()));",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 406,
      "original_position": 387,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3c1c9e766ad4fc6defdc9b4814c1e184f6603003",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "considering that (rolling) bloom filters always have a certain false-positive rate, I'm wondering if these assertions could unintentionally fail on long fuzzing runs where the filters aren't reset for many iterations? (didn't look at any concrete math yet tho, maybe the set of of possible packages we create/pick from the generated data is so small that the likelihood of this happening is negligible, and everything is fine)",
      "created_at": "2024-10-01T17:01:52Z",
      "updated_at": "2024-10-01T17:02:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783207317",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783207317"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 403,
      "original_start_line": 384,
      "start_side": "RIGHT",
      "line": 406,
      "original_line": 406,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783268585",
      "pull_request_review_id": 2341033710,
      "id": 1783268585,
      "node_id": "PRRC_kwDOABII585qSoTp",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (maybe_package.has_value()) CheckPackageToValidate(*maybe_package, rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        // Jump forwards or backwards\n+        auto time_skip = fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+        if (fuzzed_data_provider.ConsumeBool()) time_skip *= -1;\n+        time += time_skip;\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadManagerImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+    txdownload_impl.m_txrequest.SanityCheck();\n+}\n+\n+FUZZ_TARGET(txdownloadman_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadManagerImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManagerImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                for (const auto& tx : TRANSACTIONS) {\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(tx->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(tx->GetHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(tx->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(tx->GetHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    CheckPackageToValidate(*maybe_package, rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(GetPackageHash(package)));\n+                    // Neither is in m_lazy_recent_rejects\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256()));",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 406,
      "original_position": 387,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3c1c9e766ad4fc6defdc9b4814c1e184f6603003",
      "in_reply_to_id": 1783207317,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I believe it's very rare based on our filter parameters. Each generation has 60k entries expected, and according to my debug-fu has 20 hash functions, and 21,56,646 filter bits. Since the harness does up to 10k iterations(let's assume each iteration makes a unique tx), that is 10k transactions, this leads to:\r\n\r\n```\r\nP_fp = (1 - e^-(20*10000/2156646))^20\r\n        ~= 8.8183022e-22\r\n```\r\n\r\nThis assumes independence of probabilities of each bit being set. Once we get up to 60k iterations, assuming they are all added to the filter, then FP rate will hit ~1/1M. If we set total iterations to 1.5k, then we drop below cryptographic safety margins of 2^-128.",
      "created_at": "2024-10-01T17:55:54Z",
      "updated_at": "2024-10-01T17:55:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783268585",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783268585"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 403,
      "original_start_line": 384,
      "start_side": "RIGHT",
      "line": 406,
      "original_line": 406,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783569179",
      "pull_request_review_id": 2341519109,
      "id": 1783569179,
      "node_id": "PRRC_kwDOABII585qTxsb",
      "diff_hunk": "@@ -0,0 +1,339 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <addresstype.h>\n+#include <consensus/validation.h>\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <primitives/transaction.h>\n+#include <script/script.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static bool CheckOrphanBehavior(node::TxDownloadManagerImpl& txdownload_impl, const CTransactionRef& tx, const node::RejectedTxTodo& ret, std::string& err_msg,\n+                                bool expect_orphan, bool expect_keep, unsigned int expected_parents)\n+{\n+    // Missing inputs can never result in a PackageToValidate.\n+    if (ret.m_package_to_validate.has_value()) {\n+        err_msg = strprintf(\"returned a PackageToValidate on missing inputs\");\n+        return false;\n+    }\n+\n+    if (expect_orphan != txdownload_impl.m_orphanage.HaveTx(tx->GetWitnessHash())) {\n+        err_msg = strprintf(\"unexpectedly %s tx in orpanage\", expect_orphan ? \"did not find\" : \"found\");\n+        return false;\n+    }\n+    if (expect_keep != ret.m_should_add_extra_compact_tx) {\n+        err_msg = strprintf(\"unexpectedly returned %s add to vExtraTxnForCompact\", expect_keep ? \"should not\" : \"should\");\n+        return false;\n+    }\n+    if (expected_parents != ret.m_unique_parents.size()) {\n+        err_msg = strprintf(\"expected %u unique_parents, got %u\", expected_parents, ret.m_unique_parents.size());\n+        return false;\n+    }\n+    return true;\n+}\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadOptions DEFAULT_OPTS{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true};\n+\n+    // A new TxDownloadManagerImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+    node::TxDownloadConnectionInfo connection_info{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};\n+\n+    for (const auto segwit_parent : {true, false}) {\n+        for (const auto segwit_child : {true, false}) {\n+            const auto ptx_parent = CreateTransactionChain(1, segwit_parent).front();\n+            const auto ptx_child = CreateTransactionChain(1, segwit_child).front();\n+            const auto& parent_txid = ptx_parent->GetHash().ToUint256();\n+            const auto& parent_wtxid = ptx_parent->GetWitnessHash().ToUint256();\n+            const auto& child_txid = ptx_child->GetHash().ToUint256();\n+            const auto& child_wtxid = ptx_child->GetWitnessHash().ToUint256();\n+\n+            for (const auto& [result, expected_behavior] : expected_behaviors) {\n+                node::TxDownloadManagerImpl txdownload_impl{DEFAULT_OPTS};\n+                txdownload_impl.ConnectedPeer(nodeid, connection_info);\n+                // Parent failure\n+                state.Invalid(result, \"\");\n+                const auto& [keep, unique_txids, package_to_validate] = txdownload_impl.MempoolRejectedTx(ptx_parent, state, nodeid, /*first_time_failure=*/true);\n+\n+                // No distinction between txid and wtxid caching for nonsegwit transactions, so only test these specific\n+                // behaviors for segwit transactions.\n+                Behaviors actual_behavior{\n+                    /*txid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_txid),\n+                    /*wtxid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_wtxid),\n+                    /*txid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_txid),\n+                    /*wtxid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_wtxid),\n+                    /*keep=*/keep,\n+                    /*txid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Txid(parent_txid), now, /*p2p_inv=*/true),\n+                    /*wtxid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Wtxid(parent_wtxid), now, /*p2p_inv=*/true),\n+                };\n+                BOOST_TEST_MESSAGE(\"Testing behavior for \" << result << (segwit_parent ? \" segwit \" : \" nonsegwit\"));\n+                actual_behavior.CheckEqual(expected_behavior, /*segwit=*/segwit_parent);\n+\n+                // Later, a child of this transaction fails for missing inputs\n+                state.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                txdownload_impl.MempoolRejectedTx(ptx_child, state, nodeid, /*first_time_failure=*/true);\n+\n+                // If parent (by txid) was rejected, child is too.\n+                const bool parent_txid_rejected{segwit_parent ? expected_behavior.m_txid_in_rejects : expected_behavior.m_wtxid_in_rejects};\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_txid));\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_wtxid));\n+\n+                // Unless rejected, the child should be in orphanage.\n+                BOOST_CHECK_EQUAL(!parent_txid_rejected, txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(handle_missing_inputs, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadOptions DEFAULT_OPTS{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true};\n+    NodeId nodeid{1};\n+    node::TxDownloadConnectionInfo DEFAULT_CONN{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};\n+\n+    // We need mature coinbases\n+    mineBlocks(20);\n+\n+    // Transactions with missing inputs are treated differently depending on how much we know about\n+    // their parents.\n+    CKey wallet_key = GenerateRandomKey();\n+    CScript destination = GetScriptForDestination(PKHash(wallet_key.GetPubKey()));\n+    // Amount for spending coinbase in a 1-in-1-out tx, at depth n, each time deducting 1000 from the amount as fees.\n+    CAmount amount_depth_1{50 * COIN - 1000};\n+    CAmount amount_depth_2{amount_depth_1 - 1000};\n+    // Amount for spending coinbase in a 1-in-2-out tx, deducting 1000 in fees\n+    CAmount amount_split_half{25 * COIN - 500};\n+    int test_chain_height{100};\n+\n+    TxValidationState state_orphan;\n+    state_orphan.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+\n+    // Transactions are not all submitted to mempool. Conserve the number of m_coinbase_txns we\n+    // consume, and only increment this index number when we would conflict with an existing\n+    // mempool transaction.\n+    size_t coinbase_idx{0};\n+\n+    for (int decisions = 0; decisions < (1 << 4); ++decisions) {\n+        auto mtx_single_parent = CreateValidMempoolTransaction(m_coinbase_txns[coinbase_idx], /*input_vout=*/0, test_chain_height, coinbaseKey, destination, amount_depth_1, /*submit=*/false);\n+        auto single_parent = MakeTransactionRef(mtx_single_parent);\n+\n+        auto mtx_orphan = CreateValidMempoolTransaction(single_parent, /*input_vout=*/0, test_chain_height, wallet_key, destination, amount_depth_2, /*submit=*/false);\n+        auto orphan = MakeTransactionRef(mtx_orphan);\n+\n+        node::TxDownloadManagerImpl txdownload_impl{DEFAULT_OPTS};\n+        txdownload_impl.ConnectedPeer(nodeid, DEFAULT_CONN);\n+\n+        // Each bit of decisions tells us whether the parent is in a particular cache.\n+        // It is definitely possible for a transaction to be in multiple caches. For example, it\n+        // may have both a low feerate and found to violate some mempool policy when validated\n+        // in a 1p1c.\n+        const bool parent_recent_rej(decisions & 1);\n+        const bool parent_recent_rej_recon((decisions >> 1) & 1);\n+        const bool parent_recent_conf((decisions >> 2) & 1);\n+        const bool parent_in_mempool((decisions >> 3) & 1);\n+\n+        if (parent_recent_rej) txdownload_impl.RecentRejectsFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_recent_rej_recon) txdownload_impl.RecentRejectsReconsiderableFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_recent_conf) txdownload_impl.RecentConfirmedTransactionsFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_in_mempool) {\n+            const auto mempool_result = WITH_LOCK(::cs_main, return m_node.chainman->ProcessTransaction(single_parent));\n+            BOOST_CHECK(mempool_result.m_result_type == MempoolAcceptResult::ResultType::VALID);\n+            coinbase_idx += 1;",
      "path": "src/test/txdownload_tests.cpp",
      "position": 227,
      "original_position": 232,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "9d6c88fa11daaa4de9381192fdc70f6a1652e178",
      "in_reply_to_id": 1781283774,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added",
      "created_at": "2024-10-01T21:49:58Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783569179",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783569179"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 227,
      "original_line": 227,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783569356",
      "pull_request_review_id": 2341519109,
      "id": 1783569356,
      "node_id": "PRRC_kwDOABII585qTxvM",
      "diff_hunk": "@@ -0,0 +1,339 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <addresstype.h>\n+#include <consensus/validation.h>\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <primitives/transaction.h>\n+#include <script/script.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static bool CheckOrphanBehavior(node::TxDownloadManagerImpl& txdownload_impl, const CTransactionRef& tx, const node::RejectedTxTodo& ret, std::string& err_msg,\n+                                bool expect_orphan, bool expect_keep, unsigned int expected_parents)\n+{\n+    // Missing inputs can never result in a PackageToValidate.\n+    if (ret.m_package_to_validate.has_value()) {\n+        err_msg = strprintf(\"returned a PackageToValidate on missing inputs\");\n+        return false;\n+    }\n+\n+    if (expect_orphan != txdownload_impl.m_orphanage.HaveTx(tx->GetWitnessHash())) {\n+        err_msg = strprintf(\"unexpectedly %s tx in orpanage\", expect_orphan ? \"did not find\" : \"found\");\n+        return false;\n+    }\n+    if (expect_keep != ret.m_should_add_extra_compact_tx) {\n+        err_msg = strprintf(\"unexpectedly returned %s add to vExtraTxnForCompact\", expect_keep ? \"should not\" : \"should\");\n+        return false;\n+    }\n+    if (expected_parents != ret.m_unique_parents.size()) {\n+        err_msg = strprintf(\"expected %u unique_parents, got %u\", expected_parents, ret.m_unique_parents.size());\n+        return false;\n+    }\n+    return true;\n+}\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadOptions DEFAULT_OPTS{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true};\n+\n+    // A new TxDownloadManagerImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+    node::TxDownloadConnectionInfo connection_info{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};\n+\n+    for (const auto segwit_parent : {true, false}) {\n+        for (const auto segwit_child : {true, false}) {\n+            const auto ptx_parent = CreateTransactionChain(1, segwit_parent).front();\n+            const auto ptx_child = CreateTransactionChain(1, segwit_child).front();\n+            const auto& parent_txid = ptx_parent->GetHash().ToUint256();\n+            const auto& parent_wtxid = ptx_parent->GetWitnessHash().ToUint256();\n+            const auto& child_txid = ptx_child->GetHash().ToUint256();\n+            const auto& child_wtxid = ptx_child->GetWitnessHash().ToUint256();\n+\n+            for (const auto& [result, expected_behavior] : expected_behaviors) {\n+                node::TxDownloadManagerImpl txdownload_impl{DEFAULT_OPTS};\n+                txdownload_impl.ConnectedPeer(nodeid, connection_info);\n+                // Parent failure\n+                state.Invalid(result, \"\");\n+                const auto& [keep, unique_txids, package_to_validate] = txdownload_impl.MempoolRejectedTx(ptx_parent, state, nodeid, /*first_time_failure=*/true);\n+\n+                // No distinction between txid and wtxid caching for nonsegwit transactions, so only test these specific\n+                // behaviors for segwit transactions.\n+                Behaviors actual_behavior{\n+                    /*txid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_txid),\n+                    /*wtxid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_wtxid),\n+                    /*txid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_txid),\n+                    /*wtxid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_wtxid),\n+                    /*keep=*/keep,\n+                    /*txid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Txid(parent_txid), now, /*p2p_inv=*/true),\n+                    /*wtxid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Wtxid(parent_wtxid), now, /*p2p_inv=*/true),\n+                };\n+                BOOST_TEST_MESSAGE(\"Testing behavior for \" << result << (segwit_parent ? \" segwit \" : \" nonsegwit\"));\n+                actual_behavior.CheckEqual(expected_behavior, /*segwit=*/segwit_parent);\n+\n+                // Later, a child of this transaction fails for missing inputs\n+                state.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                txdownload_impl.MempoolRejectedTx(ptx_child, state, nodeid, /*first_time_failure=*/true);\n+\n+                // If parent (by txid) was rejected, child is too.\n+                const bool parent_txid_rejected{segwit_parent ? expected_behavior.m_txid_in_rejects : expected_behavior.m_wtxid_in_rejects};\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_txid));\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_wtxid));\n+\n+                // Unless rejected, the child should be in orphanage.\n+                BOOST_CHECK_EQUAL(!parent_txid_rejected, txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(handle_missing_inputs, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadOptions DEFAULT_OPTS{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true};\n+    NodeId nodeid{1};\n+    node::TxDownloadConnectionInfo DEFAULT_CONN{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};\n+\n+    // We need mature coinbases\n+    mineBlocks(20);\n+\n+    // Transactions with missing inputs are treated differently depending on how much we know about\n+    // their parents.\n+    CKey wallet_key = GenerateRandomKey();\n+    CScript destination = GetScriptForDestination(PKHash(wallet_key.GetPubKey()));\n+    // Amount for spending coinbase in a 1-in-1-out tx, at depth n, each time deducting 1000 from the amount as fees.\n+    CAmount amount_depth_1{50 * COIN - 1000};\n+    CAmount amount_depth_2{amount_depth_1 - 1000};\n+    // Amount for spending coinbase in a 1-in-2-out tx, deducting 1000 in fees\n+    CAmount amount_split_half{25 * COIN - 500};\n+    int test_chain_height{100};\n+\n+    TxValidationState state_orphan;\n+    state_orphan.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+\n+    // Transactions are not all submitted to mempool. Conserve the number of m_coinbase_txns we\n+    // consume, and only increment this index number when we would conflict with an existing\n+    // mempool transaction.\n+    size_t coinbase_idx{0};\n+\n+    for (int decisions = 0; decisions < (1 << 4); ++decisions) {\n+        auto mtx_single_parent = CreateValidMempoolTransaction(m_coinbase_txns[coinbase_idx], /*input_vout=*/0, test_chain_height, coinbaseKey, destination, amount_depth_1, /*submit=*/false);\n+        auto single_parent = MakeTransactionRef(mtx_single_parent);\n+\n+        auto mtx_orphan = CreateValidMempoolTransaction(single_parent, /*input_vout=*/0, test_chain_height, wallet_key, destination, amount_depth_2, /*submit=*/false);\n+        auto orphan = MakeTransactionRef(mtx_orphan);\n+\n+        node::TxDownloadManagerImpl txdownload_impl{DEFAULT_OPTS};\n+        txdownload_impl.ConnectedPeer(nodeid, DEFAULT_CONN);\n+\n+        // Each bit of decisions tells us whether the parent is in a particular cache.\n+        // It is definitely possible for a transaction to be in multiple caches. For example, it\n+        // may have both a low feerate and found to violate some mempool policy when validated\n+        // in a 1p1c.\n+        const bool parent_recent_rej(decisions & 1);\n+        const bool parent_recent_rej_recon((decisions >> 1) & 1);\n+        const bool parent_recent_conf((decisions >> 2) & 1);\n+        const bool parent_in_mempool((decisions >> 3) & 1);\n+\n+        if (parent_recent_rej) txdownload_impl.RecentRejectsFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_recent_rej_recon) txdownload_impl.RecentRejectsReconsiderableFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_recent_conf) txdownload_impl.RecentConfirmedTransactionsFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_in_mempool) {\n+            const auto mempool_result = WITH_LOCK(::cs_main, return m_node.chainman->ProcessTransaction(single_parent));\n+            BOOST_CHECK(mempool_result.m_result_type == MempoolAcceptResult::ResultType::VALID);\n+            coinbase_idx += 1;\n+        }\n+\n+        // Whether or not the transaction is added as an orphan depends solely on whether or not\n+        // it's in RecentRejectsFilter. Specifically, the parent is allowed to be in\n+        // RecentRejectsReconsiderableFilter, but it cannot be in both rejection filters.",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 237,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "9d6c88fa11daaa4de9381192fdc70f6a1652e178",
      "in_reply_to_id": 1781291525,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "changed to \"cannot be inRecentRejectsFilter\"",
      "created_at": "2024-10-01T21:50:15Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783569356",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783569356"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 237,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783569487",
      "pull_request_review_id": 2341519109,
      "id": 1783569487,
      "node_id": "PRRC_kwDOABII585qTxxP",
      "diff_hunk": "@@ -0,0 +1,339 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <addresstype.h>\n+#include <consensus/validation.h>\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <primitives/transaction.h>\n+#include <script/script.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static bool CheckOrphanBehavior(node::TxDownloadManagerImpl& txdownload_impl, const CTransactionRef& tx, const node::RejectedTxTodo& ret, std::string& err_msg,\n+                                bool expect_orphan, bool expect_keep, unsigned int expected_parents)\n+{\n+    // Missing inputs can never result in a PackageToValidate.\n+    if (ret.m_package_to_validate.has_value()) {\n+        err_msg = strprintf(\"returned a PackageToValidate on missing inputs\");\n+        return false;\n+    }\n+\n+    if (expect_orphan != txdownload_impl.m_orphanage.HaveTx(tx->GetWitnessHash())) {\n+        err_msg = strprintf(\"unexpectedly %s tx in orpanage\", expect_orphan ? \"did not find\" : \"found\");\n+        return false;\n+    }\n+    if (expect_keep != ret.m_should_add_extra_compact_tx) {\n+        err_msg = strprintf(\"unexpectedly returned %s add to vExtraTxnForCompact\", expect_keep ? \"should not\" : \"should\");\n+        return false;\n+    }\n+    if (expected_parents != ret.m_unique_parents.size()) {\n+        err_msg = strprintf(\"expected %u unique_parents, got %u\", expected_parents, ret.m_unique_parents.size());\n+        return false;\n+    }\n+    return true;\n+}\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadOptions DEFAULT_OPTS{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true};\n+\n+    // A new TxDownloadManagerImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+    node::TxDownloadConnectionInfo connection_info{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};\n+\n+    for (const auto segwit_parent : {true, false}) {\n+        for (const auto segwit_child : {true, false}) {\n+            const auto ptx_parent = CreateTransactionChain(1, segwit_parent).front();\n+            const auto ptx_child = CreateTransactionChain(1, segwit_child).front();\n+            const auto& parent_txid = ptx_parent->GetHash().ToUint256();\n+            const auto& parent_wtxid = ptx_parent->GetWitnessHash().ToUint256();\n+            const auto& child_txid = ptx_child->GetHash().ToUint256();\n+            const auto& child_wtxid = ptx_child->GetWitnessHash().ToUint256();\n+\n+            for (const auto& [result, expected_behavior] : expected_behaviors) {\n+                node::TxDownloadManagerImpl txdownload_impl{DEFAULT_OPTS};\n+                txdownload_impl.ConnectedPeer(nodeid, connection_info);\n+                // Parent failure\n+                state.Invalid(result, \"\");\n+                const auto& [keep, unique_txids, package_to_validate] = txdownload_impl.MempoolRejectedTx(ptx_parent, state, nodeid, /*first_time_failure=*/true);\n+\n+                // No distinction between txid and wtxid caching for nonsegwit transactions, so only test these specific\n+                // behaviors for segwit transactions.\n+                Behaviors actual_behavior{\n+                    /*txid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_txid),\n+                    /*wtxid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_wtxid),\n+                    /*txid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_txid),\n+                    /*wtxid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_wtxid),\n+                    /*keep=*/keep,\n+                    /*txid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Txid(parent_txid), now, /*p2p_inv=*/true),\n+                    /*wtxid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Wtxid(parent_wtxid), now, /*p2p_inv=*/true),\n+                };\n+                BOOST_TEST_MESSAGE(\"Testing behavior for \" << result << (segwit_parent ? \" segwit \" : \" nonsegwit\"));\n+                actual_behavior.CheckEqual(expected_behavior, /*segwit=*/segwit_parent);\n+\n+                // Later, a child of this transaction fails for missing inputs\n+                state.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                txdownload_impl.MempoolRejectedTx(ptx_child, state, nodeid, /*first_time_failure=*/true);\n+\n+                // If parent (by txid) was rejected, child is too.\n+                const bool parent_txid_rejected{segwit_parent ? expected_behavior.m_txid_in_rejects : expected_behavior.m_wtxid_in_rejects};\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_txid));\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_wtxid));\n+\n+                // Unless rejected, the child should be in orphanage.\n+                BOOST_CHECK_EQUAL(!parent_txid_rejected, txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(handle_missing_inputs, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadOptions DEFAULT_OPTS{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS, true};\n+    NodeId nodeid{1};\n+    node::TxDownloadConnectionInfo DEFAULT_CONN{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};\n+\n+    // We need mature coinbases\n+    mineBlocks(20);\n+\n+    // Transactions with missing inputs are treated differently depending on how much we know about\n+    // their parents.\n+    CKey wallet_key = GenerateRandomKey();\n+    CScript destination = GetScriptForDestination(PKHash(wallet_key.GetPubKey()));\n+    // Amount for spending coinbase in a 1-in-1-out tx, at depth n, each time deducting 1000 from the amount as fees.\n+    CAmount amount_depth_1{50 * COIN - 1000};\n+    CAmount amount_depth_2{amount_depth_1 - 1000};\n+    // Amount for spending coinbase in a 1-in-2-out tx, deducting 1000 in fees\n+    CAmount amount_split_half{25 * COIN - 500};\n+    int test_chain_height{100};\n+\n+    TxValidationState state_orphan;\n+    state_orphan.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+\n+    // Transactions are not all submitted to mempool. Conserve the number of m_coinbase_txns we\n+    // consume, and only increment this index number when we would conflict with an existing\n+    // mempool transaction.\n+    size_t coinbase_idx{0};\n+\n+    for (int decisions = 0; decisions < (1 << 4); ++decisions) {\n+        auto mtx_single_parent = CreateValidMempoolTransaction(m_coinbase_txns[coinbase_idx], /*input_vout=*/0, test_chain_height, coinbaseKey, destination, amount_depth_1, /*submit=*/false);\n+        auto single_parent = MakeTransactionRef(mtx_single_parent);\n+\n+        auto mtx_orphan = CreateValidMempoolTransaction(single_parent, /*input_vout=*/0, test_chain_height, wallet_key, destination, amount_depth_2, /*submit=*/false);\n+        auto orphan = MakeTransactionRef(mtx_orphan);\n+\n+        node::TxDownloadManagerImpl txdownload_impl{DEFAULT_OPTS};\n+        txdownload_impl.ConnectedPeer(nodeid, DEFAULT_CONN);\n+\n+        // Each bit of decisions tells us whether the parent is in a particular cache.\n+        // It is definitely possible for a transaction to be in multiple caches. For example, it\n+        // may have both a low feerate and found to violate some mempool policy when validated\n+        // in a 1p1c.\n+        const bool parent_recent_rej(decisions & 1);\n+        const bool parent_recent_rej_recon((decisions >> 1) & 1);\n+        const bool parent_recent_conf((decisions >> 2) & 1);\n+        const bool parent_in_mempool((decisions >> 3) & 1);\n+\n+        if (parent_recent_rej) txdownload_impl.RecentRejectsFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_recent_rej_recon) txdownload_impl.RecentRejectsReconsiderableFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_recent_conf) txdownload_impl.RecentConfirmedTransactionsFilter().insert(single_parent->GetHash().ToUint256());\n+        if (parent_in_mempool) {\n+            const auto mempool_result = WITH_LOCK(::cs_main, return m_node.chainman->ProcessTransaction(single_parent));\n+            BOOST_CHECK(mempool_result.m_result_type == MempoolAcceptResult::ResultType::VALID);\n+            coinbase_idx += 1;\n+        }\n+\n+        // Whether or not the transaction is added as an orphan depends solely on whether or not\n+        // it's in RecentRejectsFilter. Specifically, the parent is allowed to be in\n+        // RecentRejectsReconsiderableFilter, but it cannot be in both rejection filters.\n+        const bool expect_keep_orphan = !parent_recent_rej;\n+        const auto ret_1p1c = txdownload_impl.MempoolRejectedTx(orphan, state_orphan, nodeid, /*first_time_failure=*/true);\n+        std::string err_msg;\n+        const bool ok = CheckOrphanBehavior(txdownload_impl, orphan, ret_1p1c, err_msg,\n+                                            /*expect_orphan=*/expect_keep_orphan, /*expect_keep=*/true, /*expected_parents=*/expect_keep_orphan ? 1 : 0);\n+        BOOST_CHECK_MESSAGE(ok, err_msg);\n+    }\n+\n+    // Orphan with multiple parents\n+    {\n+        std::vector<CTransactionRef> parents;\n+        std::vector<COutPoint> outpoints;\n+        int32_t num_parents{24};\n+        for (int32_t i = 0; i < num_parents; ++i) {\n+            auto mtx_parent = CreateValidMempoolTransaction(m_coinbase_txns[coinbase_idx++], /*input_vout=*/0, test_chain_height,\n+                                                            coinbaseKey, destination, amount_depth_1 + i, /*submit=*/false);\n+            auto ptx_parent = MakeTransactionRef(mtx_parent);\n+            parents.emplace_back(ptx_parent);\n+            outpoints.emplace_back(ptx_parent->GetHash(), 0);\n+        }\n+\n+        // Send all coins to 1 address.",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 259,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "9d6c88fa11daaa4de9381192fdc70f6a1652e178",
      "in_reply_to_id": 1781293825,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-10-01T21:50:26Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783569487",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783569487"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783572311",
      "pull_request_review_id": 2341519109,
      "id": 1783572311,
      "node_id": "PRRC_kwDOABII585qTydX",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 70,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770562862,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "edited to no longer be for a chain",
      "created_at": "2024-10-01T21:54:08Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783572311",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783572311"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783578259",
      "pull_request_review_id": 2341519109,
      "id": 1783578259,
      "node_id": "PRRC_kwDOABII585qTz6T",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 67,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770563421,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "edited somewhat. I like the annotations there but only did first row.",
      "created_at": "2024-10-01T22:02:24Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783578259",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783578259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 55,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783581984",
      "pull_request_review_id": 2341519109,
      "id": 1783581984,
      "node_id": "PRRC_kwDOABII585qT00g",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 58,
      "original_position": 58,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3c1c9e766ad4fc6defdc9b4814c1e184f6603003",
      "in_reply_to_id": 1781734202,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "woops! changed",
      "created_at": "2024-10-01T22:08:04Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783581984",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783581984"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 58,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783583715",
      "pull_request_review_id": 2341519109,
      "id": 1783583715,
      "node_id": "PRRC_kwDOABII585qT1Pj",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 172,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3c1c9e766ad4fc6defdc9b4814c1e184f6603003",
      "in_reply_to_id": 1781744846,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "you're right, taken",
      "created_at": "2024-10-01T22:10:33Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783583715",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783583715"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783595218",
      "pull_request_review_id": 2341519109,
      "id": 1783595218,
      "node_id": "PRRC_kwDOABII585qT4DS",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 212,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3c1c9e766ad4fc6defdc9b4814c1e184f6603003",
      "in_reply_to_id": 1781392510,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added. Note we can't see the filter from txdownloadman.",
      "created_at": "2024-10-01T22:14:07Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783595218",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783595218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783598897",
      "pull_request_review_id": 2341519109,
      "id": 1783598897,
      "node_id": "PRRC_kwDOABII585qT48x",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (maybe_package.has_value()) CheckPackageToValidate(*maybe_package, rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        // Jump forwards or backwards\n+        auto time_skip = fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+        if (fuzzed_data_provider.ConsumeBool()) time_skip *= -1;\n+        time += time_skip;\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadManagerImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+    txdownload_impl.m_txrequest.SanityCheck();\n+}\n+\n+FUZZ_TARGET(txdownloadman_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadManagerImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManagerImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 302,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3c1c9e766ad4fc6defdc9b4814c1e184f6603003",
      "in_reply_to_id": 1781367693,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good point. Added a `PickCoins` to select more.",
      "created_at": "2024-10-01T22:17:57Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783598897",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783598897"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783599080",
      "pull_request_review_id": 2341519109,
      "id": 1783599080,
      "node_id": "PRRC_kwDOABII585qT4_o",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 361,
      "original_position": 328,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723496334,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added the `Assume`. I agree it makes more sense.",
      "created_at": "2024-10-01T22:18:15Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783599080",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783599080"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 361,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783599995",
      "pull_request_review_id": 2341519109,
      "id": 1783599995,
      "node_id": "PRRC_kwDOABII585qT5N7",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (maybe_package.has_value()) CheckPackageToValidate(*maybe_package, rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        // Jump forwards or backwards\n+        auto time_skip = fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+        if (fuzzed_data_provider.ConsumeBool()) time_skip *= -1;\n+        time += time_skip;\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadManagerImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+    txdownload_impl.m_txrequest.SanityCheck();\n+}\n+\n+FUZZ_TARGET(txdownloadman_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadManagerImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManagerImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                for (const auto& tx : TRANSACTIONS) {\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(tx->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(tx->GetHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(tx->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(tx->GetHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    CheckPackageToValidate(*maybe_package, rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(GetPackageHash(package)));\n+                    // Neither is in m_lazy_recent_rejects\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256()));",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 406,
      "original_position": 387,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "3c1c9e766ad4fc6defdc9b4814c1e184f6603003",
      "in_reply_to_id": 1783207317,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I hadn't really considered this, thanks @theStack and @instagibbs. It does seem safe to assume we won't have anything roll out within our (limited) fuzz iterations.",
      "created_at": "2024-10-01T22:19:42Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783599995",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783599995"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 403,
      "original_start_line": 384,
      "start_side": "RIGHT",
      "line": 406,
      "original_line": 406,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783601708",
      "pull_request_review_id": 2341519109,
      "id": 1783601708,
      "node_id": "PRRC_kwDOABII585qT5os",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 194,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "ce205abe10ebccfdbea60adf4c568a8ba61390c3",
      "in_reply_to_id": 1781349142,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A very incorrect comment! Deleted it now.",
      "created_at": "2024-10-01T22:22:36Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783601708",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783601708"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783602138",
      "pull_request_review_id": 2341519109,
      "id": 1783602138,
      "node_id": "PRRC_kwDOABII585qT5va",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 242,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770567453,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, done",
      "created_at": "2024-10-01T22:23:24Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783602138",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783602138"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 239,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783602611",
      "pull_request_review_id": 2341519109,
      "id": 1783602611,
      "node_id": "PRRC_kwDOABII585qT52z",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\n+    }\n+}\n+\n+static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.first;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetStrippedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return StripWitness(tx_it->second.first);\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetMalleatedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.second;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetRandomTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, FuzzedDataProvider& fuzzed_data_provider, bool correct_only = false)\n+{\n+    auto it = txmap.begin();\n+    // Jump forward a random number of times.\n+    for (size_t i = 0; i <= fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1); ++i) it++;\n+    if (it == txmap.end()) return nullptr;\n+    return correct_only || fuzzed_data_provider.ConsumeBool() ? it->second.first : it->second.second;\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(txdownloadman_one_honest_peer, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+    std::chrono::microseconds time{244466666};\n+\n+    // Decide the target transaction. Disallow selecting a witness-stripped or non-segwit\n+    // transaction because it can lead to false negatives. This test may mark a same-txid\n+    // transaction as invalid, and we don't want that to cause rejection of the target tx.\n+    const auto& target_tx = GetRandomTx(TRANSACTIONS, fuzzed_data_provider, /*correct_only=*/true);\n+    Assert(target_tx != nullptr);\n+    Assert(target_tx->HasWitness());",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": 302,
      "original_position": 303,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770567839,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Unsure, it's just a habit I guess.",
      "created_at": "2024-10-01T22:24:02Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783602611",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783602611"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": 301,
      "original_start_line": 302,
      "start_side": "RIGHT",
      "line": 302,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783604279",
      "pull_request_review_id": 2341519109,
      "id": 1783604279,
      "node_id": "PRRC_kwDOABII585qT6Q3",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\n+    }\n+}\n+\n+static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.first;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetStrippedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return StripWitness(tx_it->second.first);\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetMalleatedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.second;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetRandomTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, FuzzedDataProvider& fuzzed_data_provider, bool correct_only = false)\n+{\n+    auto it = txmap.begin();\n+    // Jump forward a random number of times.\n+    for (size_t i = 0; i <= fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1); ++i) it++;\n+    if (it == txmap.end()) return nullptr;\n+    return correct_only || fuzzed_data_provider.ConsumeBool() ? it->second.first : it->second.second;\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(txdownloadman_one_honest_peer, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+    std::chrono::microseconds time{244466666};\n+\n+    // Decide the target transaction. Disallow selecting a witness-stripped or non-segwit\n+    // transaction because it can lead to false negatives. This test may mark a same-txid\n+    // transaction as invalid, and we don't want that to cause rejection of the target tx.\n+    const auto& target_tx = GetRandomTx(TRANSACTIONS, fuzzed_data_provider, /*correct_only=*/true);\n+    Assert(target_tx != nullptr);\n+    Assert(target_tx->HasWitness());\n+\n+    const auto& target_txid = target_tx->GetHash();\n+    const auto& target_wtxid = target_tx->GetWitnessHash();\n+\n+    // Decide what the peers are.\n+    std::vector<TestPeer> all_peers;\n+    // NodeId of the \"designated good peer\"\n+    // Other TestPeers may be \"good\" as well, but not guaranteed.\n+    NodeId honestid = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 7);\n+    // 8 outbound peers. NodeId = o. We indicate outbound using preferred=true\n+    for (unsigned int o = 0; o < 8; ++o) {\n+        bool good = (o == honestid) || fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, o, /*preferred=*/true, /*force_good=*/good));\n+    }\n+    // 0-120 inbound peers. NodeId = i. We indicate inbound using preferred=false\n+    auto num_inbound_peers = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 120);\n+    for (unsigned int i = 8; i < num_inbound_peers + 8; ++i) {\n+        bool good = fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, i, /*preferred=*/false, /*force_good=*/good));\n+    }\n+\n+    // Indexes for random peer iteration\n+    std::vector<size_t> indexes;\n+    indexes.resize(all_peers.size());",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 327,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770565713,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "More efficient to shuffle ints than objects. I've changed to use the ctor with the size.",
      "created_at": "2024-10-01T22:25:45Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783604279",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783604279"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 326,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783604666",
      "pull_request_review_id": 2341519109,
      "id": 1783604666,
      "node_id": "PRRC_kwDOABII585qT6W6",
      "diff_hunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce another transaction */\n+    INV_DIFFERENT,\n+    /** Announce a random transaction. */\n+    INV_RANDOM,\n+    /** Send random transaction, perhaps unsolicited */\n+    TX_RANDOM,\n+    /** Send a notfound for a random hash*/\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the transaction requested */\n+    TX_REAL,\n+    /** Send a transaction whose txid matches the requested hash, with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction whose txid matches the requested hash, with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar to becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+// Possible unsolicited messages from a non-good peer.\n+static PossibleMessage NON_GOOD_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_DIFFERENT,\n+    PossibleMessage::INV_RANDOM,\n+    PossibleMessage::TX_RANDOM,\n+    PossibleMessage::NOTFOUND,\n+};\n+// Possible responses from a non-good peer.\n+static PossibleResponse NON_GOOD_RESPONSES[] = {\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdatas to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        if (m_good) {\n+            // \"Good\" peers only send 1 unsolicited message: announcement of the tx.\n+            if (!m_sent_inv) {\n+                if (force_announce || fuzzed_data_provider.ConsumeBool()) {\n+                    m_sent_inv = true;\n+                    return PossibleMessage::INV_REAL;\n+                }\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // No restrictions for non-good peers.\n+        auto message = fuzzed_data_provider.PickValueInArray(NON_GOOD_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    std::pair<PossibleResponse, std::optional<GenTxid>> ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return {PossibleResponse::NOTHING, std::nullopt};\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(NON_GOOD_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return {PossibleResponse::NOTHING, std::nullopt};\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return {response, request};\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // This can lead to orphan resolution\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    // Reconsiderable failures - can lead to package validation.\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    // Represents all non-reconsiderable failures - it's not necessary to distinguish between policy\n+    // and consensus here.\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+};\n+\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{100};\n+// map from uint256 (can be txid or wtxid) to 2 transactions of the same txid.\n+// If the key is a wtxid, the first tx in the pair has that wtxid, and the second doesn't.\n+std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> TRANSACTIONS;\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COutPoint outpoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+\n+        auto correct_tx = MakeTransactionSpending({outpoint}, /*num_outputs=*/2, /*add_witness=*/true);\n+        auto malleated_tx = Malleate(correct_tx);\n+        auto stripped_tx = StripWitness(correct_tx);\n+\n+        const auto& target_txid = correct_tx->GetHash().ToUint256();\n+        const auto& target_wtxid = correct_tx->GetWitnessHash().ToUint256();\n+        const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+        // The first tx in the pair needs to match by wtxid.\n+        TRANSACTIONS.emplace(target_wtxid, std::make_pair(correct_tx, malleated_tx));\n+        TRANSACTIONS.emplace(target_txid, std::make_pair(correct_tx, correct_tx));\n+\n+        TRANSACTIONS.emplace(malleated_wtxid, std::make_pair(malleated_tx, stripped_tx));\n+    }\n+}\n+\n+static CTransactionRef GetCorrectTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.first;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetStrippedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return StripWitness(tx_it->second.first);\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetMalleatedTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, const GenTxid& gtxid)\n+{\n+    auto tx_it = txmap.find(gtxid.GetHash());\n+    if (tx_it != txmap.end()) {\n+        return tx_it->second.second;\n+    }\n+    return nullptr;\n+}\n+static CTransactionRef GetRandomTx(const std::map<uint256, std::pair<CTransactionRef, CTransactionRef>> txmap, FuzzedDataProvider& fuzzed_data_provider, bool correct_only = false)\n+{\n+    auto it = txmap.begin();\n+    // Jump forward a random number of times.\n+    for (size_t i = 0; i <= fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, txmap.size() - 1); ++i) it++;\n+    if (it == txmap.end()) return nullptr;\n+    return correct_only || fuzzed_data_provider.ConsumeBool() ? it->second.first : it->second.second;\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(txdownloadman_one_honest_peer, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count, true}};\n+    std::chrono::microseconds time{244466666};\n+\n+    // Decide the target transaction. Disallow selecting a witness-stripped or non-segwit\n+    // transaction because it can lead to false negatives. This test may mark a same-txid\n+    // transaction as invalid, and we don't want that to cause rejection of the target tx.\n+    const auto& target_tx = GetRandomTx(TRANSACTIONS, fuzzed_data_provider, /*correct_only=*/true);\n+    Assert(target_tx != nullptr);\n+    Assert(target_tx->HasWitness());\n+\n+    const auto& target_txid = target_tx->GetHash();\n+    const auto& target_wtxid = target_tx->GetWitnessHash();\n+\n+    // Decide what the peers are.\n+    std::vector<TestPeer> all_peers;\n+    // NodeId of the \"designated good peer\"\n+    // Other TestPeers may be \"good\" as well, but not guaranteed.\n+    NodeId honestid = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 7);\n+    // 8 outbound peers. NodeId = o. We indicate outbound using preferred=true\n+    for (unsigned int o = 0; o < 8; ++o) {\n+        bool good = (o == honestid) || fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, o, /*preferred=*/true, /*force_good=*/good));\n+    }\n+    // 0-120 inbound peers. NodeId = i. We indicate inbound using preferred=false\n+    auto num_inbound_peers = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 120);\n+    for (unsigned int i = 8; i < num_inbound_peers + 8; ++i) {\n+        bool good = fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, i, /*preferred=*/false, /*force_good=*/good));\n+    }\n+\n+    // Indexes for random peer iteration\n+    std::vector<size_t> indexes;\n+    indexes.resize(all_peers.size());\n+    std::iota(indexes.begin(), indexes.end(), 0);\n+\n+    // We are trying to ensure that we always download the tx as long as we have 1 good outbound\n+    // peer who is able to send it to us.\n+    bool got_tx{false};\n+\n+    // Keep track of how many iterations the loop has done to make sure the target transaction is\n+    // announced within the first 1000 rounds. Note that the good peer is guaranteed to connect\n+    // within the first round and will never be disconnected.\n+    int counter = 0;\n+\n+    LIMITED_WHILE(!got_tx, 100000)\n+    {\n+        FastRandomContext rng{ConsumeUInt256(fuzzed_data_provider)};\n+        std::shuffle(indexes.begin(), indexes.end(), rng);\n+        // For each peer in random order, mock a ProcessMessages + SendMessages\n+        for (const auto index : indexes) {\n+            auto& peer = all_peers.at(index);\n+            NodeId nodeid = peer.m_nodeid;\n+\n+            // Maybe connect the peer if we haven't already. Always connect if it's the good peer.\n+            if (nodeid == honestid ||\n+                (peer.m_connection_state == ConnectionState::NEVER_CONNECTED && fuzzed_data_provider.ConsumeBool())) {\n+                node::TxDownloadConnectionInfo info{peer.m_connection_preferred, peer.m_relay_permissions, peer.m_wtxid_relay};\n+                txdownloadman.ConnectedPeer(nodeid, info);\n+                peer.m_connection_state = ConnectionState::CONNECTED;\n+            }\n+\n+            if (peer.m_connection_state == ConnectionState::CONNECTED) {\n+                // Peer will do its own ProcessMessages, i.e. respond to the next item in its message queue\n+                // If the message queue is empty or it decides to send nothing, maybe_gtxid is\n+                // std::nullopt. Otherwise, maybe_gtxid must contain the gtxid we are responding to.\n+                const auto& [peer_response, maybe_gtxid] = peer.ProcessOneMessage(fuzzed_data_provider);\n+\n+                // Simulate a ProcessMessage.\n+                switch (peer_response) {\n+                    case PossibleResponse::TX_REAL:\n+                    {\n+                        // If the transaction exists, use ReceivedTx. Otherwise, maybe send notfound.\n+                        if (auto ptx{GetCorrectTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, ptx);\n+                            if (should_validate || package_to_validate.has_value()) {\n+                                if (ptx->GetWitnessHash() == target_wtxid) {\n+                                    // We received the target tx and decided to validate it! Win!\n+                                    got_tx = true;\n+                                } else {\n+                                    // If not the target tx, pick some failure reason.\n+                                    TxValidationState state;\n+                                    state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                                    txdownloadman.MempoolRejectedTx(ptx, state, nodeid, true);\n+                                }\n+                            } else {\n+                            }\n+                        } else {\n+                            Assert(!peer.m_good);\n+                            if (fuzzed_data_provider.ConsumeBool()) {\n+                                txdownloadman.ReceivedNotFound(nodeid, {maybe_gtxid.value().GetHash()});\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::TX_WITNESS_STRIPPED:\n+                    {\n+                        // Call ReceivedTx. If txdownloadman instructs us to validate the\n+                        // transaction, say the result was TX_WITNESS_STRIPPED.\n+                        if (auto stripped_tx{GetStrippedTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+                            const auto& [should_validate, package] = txdownloadman.ReceivedTx(nodeid, stripped_tx);\n+                            if (should_validate) {\n+                                TxValidationState state;\n+                                state.Invalid(TxValidationResult::TX_WITNESS_STRIPPED, \"\");\n+                                txdownloadman.MempoolRejectedTx(stripped_tx, state, nodeid, true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::TX_WITNESS_MALLEATED:\n+                    {\n+                        // Call ReceivedTx. If txdownloadman instructs us to validate the\n+                        // transaction, return some error.\n+                        if (auto malleated_tx{GetMalleatedTx(TRANSACTIONS, maybe_gtxid.value())}) {\n+\n+                            // Prevent accidental lose conditions.\n+                            if (malleated_tx == target_tx) break;\n+\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, malleated_tx);\n+                            if (should_validate) {\n+                                TxValidationState state;\n+                                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                                txdownloadman.MempoolRejectedTx(malleated_tx, state, nodeid, true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleResponse::NOTFOUND:\n+                    {\n+                        txdownloadman.ReceivedNotFound(nodeid, {maybe_gtxid.value().GetHash()});\n+                        break;\n+                    }\n+                    case PossibleResponse::NOTHING:\n+                    {\n+                        break;\n+                    }\n+                    case PossibleResponse::DEFER:\n+                    {\n+                        // bug\n+                        Assert(false);\n+                        break;\n+                    }\n+                }\n+\n+                // The peer may also send some unsolicited message. Simulate a ProcessMessage.\n+                // Ensure the good peer sends the inv within the first 1000 rounds.\n+                auto peer_unsolicited_message = peer.SendOneMessage(fuzzed_data_provider, /*force_announce=*/counter > 1000);\n+\n+                switch (peer_unsolicited_message) {\n+                    case PossibleMessage::NOTHING:\n+                    {\n+                        break;\n+                    }\n+                    case PossibleMessage::INV_REAL:\n+                    {\n+                        if (peer.m_wtxid_relay) {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Wtxid(target_wtxid), time, /*p2p_inv=*/true);\n+                        } else {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Txid(target_txid), time, /*p2p_inv=*/true);\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::INV_DIFFERENT:\n+                    {\n+                        // This may or may not be target_tx\n+                        if (auto random_tx{GetRandomTx(TRANSACTIONS, fuzzed_data_provider)}) {\n+                            if (peer.m_wtxid_relay) {\n+                                txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Txid(random_tx->GetHash()), time, /*p2p_inv=*/true);\n+                            } else {\n+                                txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Wtxid(random_tx->GetWitnessHash()), time, /*p2p_inv=*/true);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::INV_RANDOM:\n+                    {\n+                        auto random_txhash = ConsumeUInt256(fuzzed_data_provider);\n+                        if (peer.m_wtxid_relay) {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Wtxid(random_txhash), time, /*p2p_inv=*/true);\n+                        } else {\n+                            txdownloadman.AddTxAnnouncement(nodeid, GenTxid::Txid(random_txhash), time, /*p2p_inv=*/true);\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::TX_RANDOM:\n+                    {\n+                        if (auto random_tx{GetRandomTx(TRANSACTIONS, fuzzed_data_provider)}) {\n+                            // Disallow winning this way.\n+                            if (random_tx == target_tx) break;\n+                            const auto& [should_validate, package_to_validate] = txdownloadman.ReceivedTx(nodeid, random_tx);\n+                        }\n+                        break;\n+                    }\n+                    case PossibleMessage::NOTFOUND:\n+                    {\n+                        if (auto random_tx{GetRandomTx(TRANSACTIONS, fuzzed_data_provider)}) {\n+                            const auto txhash{fuzzed_data_provider.ConsumeBool() ? random_tx->GetHash().ToUint256() : random_tx->GetWitnessHash().ToUint256()};\n+                            txdownloadman.ReceivedNotFound(nodeid, {txhash});\n+                        }\n+                        break;\n+                    }\n+                }\n+\n+                // Simulate a SendMessages, which includes sending getdata to request transactions.\n+                for (const auto& gtxid : txdownloadman.GetRequestsToSend(nodeid, time)) {\n+                    peer.m_getdata_queue.push_back(gtxid);\n+                }\n+\n+                // Maybe disconnect the peer if we haven't already. Never disconnect the good peer.\n+                if (peer.m_connection_state == ConnectionState::CONNECTED && nodeid != honestid && fuzzed_data_provider.ConsumeBool()) {\n+                    peer.m_connection_state = ConnectionState::DISCONNECTED;\n+                    txdownloadman.DisconnectedPeer(nodeid);\n+                    txdownloadman.CheckIsEmpty(nodeid);\n+                }\n+                ++counter;\n+            }\n+        }\n+\n+        // Skip time by 100-300ms",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 512,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770564258,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-10-01T22:26:16Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783604666",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783604666"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 512,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783609907",
      "pull_request_review_id": 2341519109,
      "id": 1783609907,
      "node_id": "PRRC_kwDOABII585qT7oz",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman_impl.h>\n+#include <node/txdownloadman.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+// TxDownloadManager wrappers\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadManagerImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()\n+{\n+    m_impl->ActiveTipChange();\n+}\n+void TxDownloadManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_impl->BlockConnected(pblock);\n+}\n+void TxDownloadManager::BlockDisconnected()\n+{\n+    m_impl->BlockDisconnected();\n+}\n+void TxDownloadManager::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    m_impl->ConnectedPeer(nodeid, info);\n+}\n+void TxDownloadManager::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_impl->DisconnectedPeer(nodeid);\n+}\n+bool TxDownloadManager::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    return m_impl->AddTxAnnouncement(peer, gtxid, now, p2p_inv);\n+}\n+std::vector<GenTxid> TxDownloadManager::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    return m_impl->GetRequestsToSend(nodeid, current_time);\n+}\n+void TxDownloadManager::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    m_impl->ReceivedNotFound(nodeid, txhashes);\n+}\n+void TxDownloadManager::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    m_impl->MempoolAcceptedTx(tx);\n+}\n+RejectedTxTodo TxDownloadManager::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    return m_impl->MempoolRejectedTx(ptx, state, nodeid, first_time_failure);\n+}\n+void TxDownloadManager::MempoolRejectedPackage(const Package& package)\n+{\n+    m_impl->MempoolRejectedPackage(package);\n+}\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadManager::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    return m_impl->ReceivedTx(nodeid, ptx);\n+}\n+bool TxDownloadManager::HaveMoreWork(NodeId nodeid) const\n+{\n+    return m_impl->HaveMoreWork(nodeid);\n+}\n+CTransactionRef TxDownloadManager::GetTxToReconsider(NodeId nodeid)\n+{\n+    return m_impl->GetTxToReconsider(nodeid);\n+}\n+void TxDownloadManager::CheckIsEmpty() const\n+{\n+    return m_impl->CheckIsEmpty();\n+}\n+void TxDownloadManager::CheckIsEmpty(NodeId nodeid) const\n+{\n+    return m_impl->CheckIsEmpty(nodeid);\n+}\n+\n+// TxDownloadManagerImpl\n+void TxDownloadManagerImpl::ActiveTipChange()\n+{\n+    RecentRejectsFilter().reset();\n+    RecentRejectsReconsiderableFilter().reset();\n+}\n+\n+void TxDownloadManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        RecentConfirmedTransactionsFilter().insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            RecentConfirmedTransactionsFilter().insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadManagerImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    RecentConfirmedTransactionsFilter().reset();\n+}\n+\n+bool TxDownloadManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();\n+\n+    if (gtxid.IsWtxid()) {\n+        // Normal query by wtxid.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    } else {\n+        // Never query by txid: it is possible that the transaction in the orphanage has the same\n+        // txid but a different witness, which would give us a false positive result. If we decided\n+        // not to request the transaction based on this result, an attacker could prevent us from\n+        // downloading a transaction by intentionally creating a malleated version of it.  While\n+        // only one (or none!) of these transactions can ultimately be confirmed, we have no way of\n+        // discerning which one that is, so the orphanage can store multiple transactions with the\n+        // same txid.\n+        //\n+        // While we won't query by txid, we can try to \"guess\" what the wtxid is based on the txid.\n+        // A non-segwit transaction's txid == wtxid. Query this txid \"casted\" to a wtxid. This will\n+        // help us find non-segwit transactions, saving bandwidth, and should have no false positives.\n+        if (m_orphanage.HaveTx(Wtxid::FromUint256(hash))) return true;\n+    }\n+\n+    if (include_reconsiderable && RecentRejectsReconsiderableFilter().contains(hash)) return true;\n+\n+    if (RecentConfirmedTransactionsFilter().contains(hash)) return true;\n+\n+    return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n+}\n+\n+void TxDownloadManagerImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.contains(nodeid)) return;\n+\n+    m_peer_info.emplace(nodeid, PeerInfo(info));\n+    if (info.m_wtxid_relay) m_num_wtxid_peers += 1;\n+}\n+\n+void TxDownloadManagerImpl::DisconnectedPeer(NodeId nodeid)\n+{\n+    m_orphanage.EraseForPeer(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);\n+\n+    if (m_peer_info.contains(nodeid)) {\n+        if (m_peer_info.at(nodeid).m_connection_info.m_wtxid_relay) m_num_wtxid_peers -= 1;\n+        m_peer_info.erase(nodeid);\n+    }\n+}\n+\n+bool TxDownloadManagerImpl::AddTxAnnouncement(NodeId peer, const GenTxid& gtxid, std::chrono::microseconds now, bool p2p_inv)\n+{\n+    // If this is an inv received from a peer and we already have it, we can drop it.\n+    // If this is a request for the parent of an orphan, we don't drop transactions that we already have. In particular,\n+    // we *do* want to request parents that are in m_lazy_recent_rejects_reconsiderable, since they can be CPFP'd.\n+    if (p2p_inv && AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) return true;\n+\n+    if (m_peer_info.count(peer) == 0) return false;\n+    const auto& info = m_peer_info.at(peer).m_connection_info;\n+    if (!info.m_relay_permissions && m_txrequest.Count(peer) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements for this peer\n+        return false;\n+    }\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or NetPermissionFlags::NoBan permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for txid announcements while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from peers which have at least\n+    //     MAX_PEER_TX_REQUEST_IN_FLIGHT requests in flight (and don't have NetPermissionFlags::Relay).\n+    auto delay{0us};\n+    if (!info.m_preferred) delay += NONPREF_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && m_num_wtxid_peers > 0) delay += TXID_RELAY_DELAY;\n+    const bool overloaded = !info.m_relay_permissions && m_txrequest.CountInFlight(peer) >= MAX_PEER_TX_REQUEST_IN_FLIGHT;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+\n+    m_txrequest.ReceivedInv(peer, gtxid, info.m_preferred, now + delay);\n+\n+    return false;\n+}\n+\n+std::vector<GenTxid> TxDownloadManagerImpl::GetRequestsToSend(NodeId nodeid, std::chrono::microseconds current_time)\n+{\n+    std::vector<GenTxid> requests;\n+    std::vector<std::pair<NodeId, GenTxid>> expired;\n+    auto requestable = m_txrequest.GetRequestable(nodeid, current_time, &expired);\n+    for (const auto& entry : expired) {\n+        LogDebug(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n+            entry.second.GetHash().ToString(), entry.first);\n+    }\n+    for (const GenTxid& gtxid : requestable) {\n+        if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+            LogDebug(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n+                gtxid.GetHash().ToString(), nodeid);\n+            requests.emplace_back(gtxid);\n+            m_txrequest.RequestedTx(nodeid, gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n+        } else {\n+            // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n+            // this should already be called whenever a transaction becomes AlreadyHaveTx().\n+            m_txrequest.ForgetTxHash(gtxid.GetHash());\n+        }\n+    }\n+    return requests;\n+}\n+\n+void TxDownloadManagerImpl::ReceivedNotFound(NodeId nodeid, const std::vector<uint256>& txhashes)\n+{\n+    for (const auto& txhash : txhashes) {\n+        // If we receive a NOTFOUND message for a tx we requested, mark the announcement for it as\n+        // completed in TxRequestTracker.\n+        m_txrequest.ReceivedResponse(nodeid, txhash);\n+    }\n+}\n+\n+std::optional<PackageToValidate> TxDownloadManagerImpl::Find1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    Assume(RecentRejectsReconsiderableFilter().contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child, nodeid, nodeid};\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+    // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+    // create a bias that attackers can use to delay package acceptance.\n+    //\n+    // Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    std::shuffle(tx_indices.begin(), tx_indices.end(), m_opts.m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_lazy_recent_rejects_reconsiderable.\n+        const auto [child_tx, child_sender] = cpfp_candidates_different_peer.at(index);\n+        Package maybe_cpfp_package{ptx, child_tx};\n+        if (!RecentRejectsReconsiderableFilter().contains(GetPackageHash(maybe_cpfp_package))) {\n+            return PackageToValidate{ptx, child_tx, nodeid, child_sender};\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+void TxDownloadManagerImpl::MempoolAcceptedTx(const CTransactionRef& tx)\n+{\n+    // As this version of the transaction was acceptable, we can forget about any requests for it.\n+    // No-op if the tx is not in txrequest.\n+    m_txrequest.ForgetTxHash(tx->GetHash());\n+    m_txrequest.ForgetTxHash(tx->GetWitnessHash());\n+\n+    m_orphanage.AddChildrenToWorkSet(*tx);\n+    // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n+    m_orphanage.EraseTx(tx->GetWitnessHash());\n+}\n+\n+node::RejectedTxTodo TxDownloadManagerImpl::MempoolRejectedTx(const CTransactionRef& ptx, const TxValidationState& state, NodeId nodeid, bool first_time_failure)\n+{\n+    const CTransaction& tx{*ptx};\n+    // Results returned to caller\n+    // Whether we should call AddToCompactExtraTransactions at the end\n+    bool add_extra_compact_tx{first_time_failure};\n+    // Hashes to pass to AddKnownTx later\n+    std::vector<uint256> unique_parents;\n+    // Populated if failure is reconsiderable and eligible package is found.\n+    std::optional<node::PackageToValidate> package_to_validate;\n+\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+        // Only process a new orphan if this is a first time failure, as otherwise it must be either\n+        // already in orphanage or from 1p1c processing.\n+        if (first_time_failure && !RecentRejectsFilter().contains(ptx->GetWitnessHash().ToUint256())) {\n+            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+            // Deduplicate parent txids, so that we don't have to loop over\n+            // the same parent txid more than once down below.\n+            unique_parents.reserve(tx.vin.size());\n+            for (const CTxIn& txin : tx.vin) {\n+                // We start with all parents, and then remove duplicates below.\n+                unique_parents.push_back(txin.prevout.hash);\n+            }\n+            std::sort(unique_parents.begin(), unique_parents.end());\n+            unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+            // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 329,
      "original_position": 323,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770587752,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is part of a block of code that was moved from `PeerManagerImpl`. The members still have the same name, so I don't think this is incorrect.",
      "created_at": "2024-10-01T22:34:22Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783609907",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783609907"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 329,
      "original_line": 329,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783611446",
      "pull_request_review_id": 2341519109,
      "id": 1783611446,
      "node_id": "PRRC_kwDOABII585qT8A2",
      "diff_hunk": "@@ -5321,16 +4869,18 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n     if (msg_type == NetMsgType::NOTFOUND) {\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n-        if (vInv.size() <= MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-            LOCK(m_tx_download_mutex);\n+        std::vector<uint256> tx_invs;\n+        if (vInv.size() <= node::MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             for (CInv &inv : vInv) {",
      "path": "src/net_processing.cpp",
      "position": 832,
      "original_position": 832,
      "commit_id": "114a5405c41d25962cb895dbd864452e40af5fcc",
      "original_commit_id": "a69cdf87f13e24b20833cf0f021249dd9ffc74a3",
      "in_reply_to_id": 1770546568,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah, sorry for missing that. I'm not really convinced this is more efficient overall?",
      "created_at": "2024-10-01T22:36:53Z",
      "updated_at": "2024-10-02T01:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1783611446",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1783611446"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4874,
      "original_line": 4874,
      "side": "RIGHT"
    }
  ]
}