{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110",
    "id": 1870736226,
    "node_id": "PR_kwDOABII585vgSti",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30110",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30110.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30110.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/1d4e33e7f88162cf6fcd6aee0b63973015853591",
    "number": 30110,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "refactor: TxDownloadManager + fuzzing",
    "user": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Part of #27463.\r\n\r\nThis PR does 2 things:\r\n\r\n(1) It modularizes transaction download logic into a `TxDownloadManager`. Transaction download logic refers to the process of deciding what transactions to request, download, and validate.[1] There should be no behavior changes. Using `--color_moved=dimmed_zebra -w` may help.\r\n(2) It adds unit and fuzz (:magic_wand:) testing for transaction download.\r\n\r\nThere are several benefits to this interface, such as:\r\n- Unit test coverage and fuzzing for logic that currently isn't feasible to test as thoroughly (without lots of overhead) and/or currently only lightly tested through `assert_debug_log` (not good) in functional tests.\r\n- When we add more functionality (e.g. package relay messages, more robust orphan handling), the vast majority of it will be within `TxDownloadManager` instead of `PeerManager`, making it easier to review and test. See #28031 for what this looks like.\r\n- `PeerManager` will no longer know anything about / have access to `TxOrphanage`, `TxRequestTracker` or the rejection caches. Its primary interface with `TxDownloadManager` would be much simpler:\r\n    - Passing on  `ValidationInterface` callbacks\r\n    - Telling `txdownloadman` when a peer {connects, disconnects}\r\n    - Telling `txdownloadman`when a {transaction, package} is {accepted, rejected} from mempool\r\n    - Telling `txdownloadman` when invs, notfounds, and txs are received.\r\n    - Getting instructions on what to download.\r\n    - Getting instructions on what {transactions, packages, orphans} to validate.\r\n    - Get whether a peer `HaveMoreWork` for the `ProessMessages` loop\r\n- (todo) Thread-safety can be handled internally.\r\n\r\n[1]: This module is concerned with tx *download*, not upload. It excludes transaction announcements/gossip which happens after we download/accept a transaction. Txreconciliation (erlay) is excluded from this module, as it only relates to deciding which `inv`s to send or helping the other peer decide which `inv`s to send. It is independent from this logic.",
    "labels": [
      {
        "id": 135961,
        "node_id": "MDU6TGFiZWwxMzU5NjE=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
        "name": "Refactoring",
        "color": "E6F6D6",
        "default": false
      }
    ],
    "created_at": "2024-05-15T09:49:51Z",
    "updated_at": "2024-09-03T18:42:15Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "2d310d09234dbaeb4708f1f1a5f89de6c4f4dbf5",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "glozow:2024-05-txdownload",
      "ref": "2024-05-txdownload",
      "sha": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 244262754,
        "node_id": "MDEwOlJlcG9zaXRvcnkyNDQyNjI3NTQ=",
        "name": "bitcoin",
        "full_name": "glozow/bitcoin",
        "owner": {
          "login": "glozow",
          "id": 25183001,
          "node_id": "MDQ6VXNlcjI1MTgzMDAx",
          "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/glozow",
          "html_url": "https://github.com/glozow",
          "followers_url": "https://api.github.com/users/glozow/followers",
          "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
          "organizations_url": "https://api.github.com/users/glozow/orgs",
          "repos_url": "https://api.github.com/users/glozow/repos",
          "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/glozow/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/glozow/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/glozow/bitcoin",
        "archive_url": "https://api.github.com/repos/glozow/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/glozow/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/glozow/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/glozow/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/glozow/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/glozow/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/glozow/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/glozow/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/glozow/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/glozow/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/glozow/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/glozow/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/glozow/bitcoin/events",
        "forks_url": "https://api.github.com/repos/glozow/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/glozow/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/glozow/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/glozow/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/glozow/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/glozow/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/glozow/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/glozow/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/glozow/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/glozow/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/glozow/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/glozow/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/glozow/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/glozow/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/glozow/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/glozow/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:glozow/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/glozow/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/glozow/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/glozow/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/glozow/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/glozow/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/glozow/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/glozow/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/glozow/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/glozow/bitcoin/hooks",
        "svn_url": "https://github.com/glozow/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 4,
        "stargazers_count": 12,
        "watchers_count": 12,
        "size": 258660,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-09-02T18:34:59Z",
        "created_at": "2020-03-02T02:31:56Z",
        "updated_at": "2024-09-02T17:09:30Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "a74bdeea1b8e27b2335f0f7da78006e87ecfb235",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35814,
        "stargazers_count": 77787,
        "watchers_count": 77787,
        "size": 267569,
        "default_branch": "master",
        "open_issues_count": 673,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-09-03T11:15:32Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-09-03T17:33:04Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 2161,
    "deletions": 545,
    "changed_files": 11,
    "commits": 26,
    "review_comments": 101,
    "comments": 29
  },
  "events": [
    {
      "event": "labeled",
      "id": 12814520687,
      "node_id": "LE_lADOABII586I73RbzwAAAAL7zhFv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12814520687",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T09:49:51Z",
      "label": {
        "name": "Refactoring",
        "color": "E6F6D6"
      }
    },
    {
      "event": "commented",
      "id": 2112063126,
      "node_id": "IC_kwDOABII585944aW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2112063126",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T09:49:54Z",
      "updated_at": "2024-09-03T02:23:45Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30110).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [instagibbs](https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2266475743) |\n| Concept ACK | [theStack](https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2236038602) |\n| Approach ACK | [ismaelsadeeq](https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2266000970) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#30572](https://github.com/bitcoin/bitcoin/pull/30572) (Halt processing of unrequested transactions v2 by ariard)\n* [#30538](https://github.com/bitcoin/bitcoin/pull/30538) (Doc: add a comment referencing past vulnerability next to where it was fixed by darosior)\n* [#29492](https://github.com/bitcoin/bitcoin/pull/29492) (refactor: Remove redundant definitions by Empact)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2112063126",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12815424268,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL729sM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12815424268",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T10:56:42Z"
    },
    {
      "event": "labeled",
      "id": 12815426811,
      "node_id": "LE_lADOABII586I73RbzwAAAAL72-T7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12815426811",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T10:56:47Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2112197018,
      "node_id": "IC_kwDOABII58595ZGa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2112197018",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T10:56:48Z",
      "updated_at": "2024-05-15T10:56:48Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\nðŸš§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/24992798939</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2112197018",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12816213418,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL75-Wq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12816213418",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T11:48:55Z"
    },
    {
      "event": "labeled",
      "id": 12818928839,
      "node_id": "LE_lADOABII586I73RbzwAAAAL8EVTH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12818928839",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T14:29:43Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12820032462,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL8IivO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12820032462",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T15:41:54Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12820339471,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL8JtsP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12820339471",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T16:05:46Z"
    },
    {
      "event": "unlabeled",
      "id": 12820814985,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAL8LhyJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12820814985",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T16:46:41Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12850950471,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL9-fFH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12850950471",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T16:31:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12863629085,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL-u2cd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12863629085",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T09:21:52Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12864617124,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL-ynqk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12864617124",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T10:50:36Z"
    },
    {
      "event": "commented",
      "id": 2120203238,
      "node_id": "IC_kwDOABII585-X7vm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2120203238",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T10:55:50Z",
      "updated_at": "2024-05-20T10:55:50Z",
      "author_association": "MEMBER",
      "body": "Rebased for #29817 and added a \"ensure we can always download a tx as long as we have 1 good outbound peer\" fuzz test",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2120203238",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "reviewed",
      "id": 2066059450,
      "node_id": "PRR_kwDOABII5857JZC6",
      "url": null,
      "actor": null,
      "commit_id": "b1cc0c3006ca608f9ac3af2c50c4728cbbc07714",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2066059450",
      "submitted_at": "2024-05-20T12:32:10Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "unlabeled",
      "id": 12865893706,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAL-3fVK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12865893706",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T12:50:48Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12879661785,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAL_sArZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12879661785",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-21T12:44:01Z"
    },
    {
      "event": "labeled",
      "id": 13018644142,
      "node_id": "LE_lADOABII586I73RbzwAAAAMH-L6u",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13018644142",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-03T10:22:44Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13066058978,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAMKzDzi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13066058978",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T12:35:40Z"
    },
    {
      "event": "commented",
      "id": 2152299577,
      "node_id": "IC_kwDOABII586ASXw5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2152299577",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T12:36:07Z",
      "updated_at": "2024-06-06T12:36:07Z",
      "author_association": "MEMBER",
      "body": "rebased",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2152299577",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "unlabeled",
      "id": 13067048338,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAMK21WS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13067048338",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T13:44:06Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 13103488822,
      "node_id": "LE_lADOABII586I73RbzwAAAAMNB182",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13103488822",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-10T15:33:20Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13113775508,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAMNpFWU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13113775508",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T09:28:15Z"
    },
    {
      "event": "unlabeled",
      "id": 13114655329,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAMNscJh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13114655329",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T10:13:00Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2160481789,
      "node_id": "IC_kwDOABII586AxlX9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2160481789",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T11:13:28Z",
      "updated_at": "2024-06-11T11:13:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\nðŸš§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/26067441690</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2160481789",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "labeled",
      "id": 13115463860,
      "node_id": "LE_lADOABII586I73RbzwAAAAMNvhi0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13115463860",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T11:13:28Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13116090985,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAMNx6pp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13116090985",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T12:03:56Z"
    },
    {
      "event": "unlabeled",
      "id": 13118368318,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAMN6mo-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13118368318",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T14:38:23Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 13191777405,
      "node_id": "LE_lADOABII586I73RbzwAAAAMSSox9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13191777405",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-17T21:17:32Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2178131655,
      "node_id": "IC_kwDOABII586B06bH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2178131655",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-19T08:53:23Z",
      "updated_at": "2024-06-19T08:53:23Z",
      "author_association": "MEMBER",
      "body": "Planning to rebase on master along with #30111 when it's merged",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2178131655",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13522454088,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAMmAEZI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13522454088",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-16T14:44:21Z"
    },
    {
      "event": "labeled",
      "id": 13523802304,
      "node_id": "LE_lADOABII586I73RbzwAAAAMmFNjA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13523802304",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-16T16:06:58Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2231313948,
      "node_id": "IC_kwDOABII586E_yYc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2231313948",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-16T16:06:59Z",
      "updated_at": "2024-07-16T16:06:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/27514949081</sub>\n\n<details><summary>Hints</summary>\n\nMake sure to run all tests locally, according to the documentation.\n\nThe failure may happen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2231313948",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "unlabeled",
      "id": 13523893782,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAMmFj4W",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13523893782",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-16T16:14:49Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "referenced",
      "id": 13626848434,
      "node_id": "REFE_lADOABII586I73RbzwAAAAMsOTSy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13626848434",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "96072770322955ebf66fa643a419c3715cc15e35",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96072770322955ebf66fa643a419c3715cc15e35",
      "created_at": "2024-07-24T08:30:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13633560092,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAMsn54c",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13633560092",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-24T16:46:03Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13646084899,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAMtXrsj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13646084899",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T13:47:11Z"
    },
    {
      "event": "ready_for_review",
      "id": 13647909229,
      "node_id": "RFRE_lADOABII586I73RbzwAAAAMtepFt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13647909229",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T15:11:52Z"
    },
    {
      "event": "unlabeled",
      "id": 13651128824,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAMtq7H4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13651128824",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T18:00:09Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2252636668,
      "node_id": "IC_kwDOABII586GRIH8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2252636668",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-26T12:14:28Z",
      "updated_at": "2024-07-26T12:14:28Z",
      "author_association": "MEMBER",
      "body": "Rebased, ready for review.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2252636668",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "labeled",
      "id": 13723240266,
      "node_id": "LE_lADOABII586I73RbzwAAAAMx-AdK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13723240266",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-01T09:49:23Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13725930535,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAMyIRQn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13725930535",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-01T13:14:46Z"
    },
    {
      "event": "commented",
      "id": 2263048941,
      "node_id": "IC_kwDOABII586G42Lt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2263048941",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-01T13:29:12Z",
      "updated_at": "2024-08-01T13:29:12Z",
      "author_association": "MEMBER",
      "body": "Rebased for #30413",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2263048941",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "unlabeled",
      "id": 13726969808,
      "node_id": "UNLE_lADOABII586I73RbzwAAAAMyMO_Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13726969808",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-01T14:14:20Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "renamed",
      "id": 13806837983,
      "node_id": "RTE_lADOABII586I73RbzwAAAAM286Df",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13806837983",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-08T13:18:16Z",
      "rename": {
        "from": "refactor: TxDownloadManager",
        "to": "refactor: TxDownloadManager + fuzzing"
      }
    },
    {
      "event": "reviewed",
      "id": 2230413202,
      "node_id": "PRR_kwDOABII586E8WeS",
      "url": null,
      "actor": null,
      "commit_id": "b03c8c439fd3e93369b07d6d6e8eb44fef34c536",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "Theschorpioen",
        "id": 161136729,
        "node_id": "U_kgDOCZrAWQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/161136729?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Theschorpioen",
        "html_url": "https://github.com/Theschorpioen",
        "followers_url": "https://api.github.com/users/Theschorpioen/followers",
        "following_url": "https://api.github.com/users/Theschorpioen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Theschorpioen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Theschorpioen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Theschorpioen/subscriptions",
        "organizations_url": "https://api.github.com/users/Theschorpioen/orgs",
        "repos_url": "https://api.github.com/users/Theschorpioen/repos",
        "events_url": "https://api.github.com/users/Theschorpioen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Theschorpioen/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2230413202",
      "submitted_at": "2024-08-09T14:52:41Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "reviewed",
      "id": 2236038602,
      "node_id": "PRR_kwDOABII586FRz3K",
      "url": null,
      "actor": null,
      "commit_id": "b03c8c439fd3e93369b07d6d6e8eb44fef34c536",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nLightly reviewed about half of the refactoring commits, left some non-critical stuff and comments on the way below.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2236038602",
      "submitted_at": "2024-08-13T17:43:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13877476818,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAAM7KX3S",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13877476818",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-14T09:55:08Z"
    },
    {
      "event": "reviewed",
      "id": 2237602476,
      "node_id": "PRR_kwDOABII586FXxqs",
      "url": null,
      "actor": null,
      "commit_id": "04856ed32c17ce60e9c503d92b21092a0f9ac271",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Thanks @theStack!",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2237602476",
      "submitted_at": "2024-08-14T09:55:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "commented",
      "id": 2288403119,
      "node_id": "IC_kwDOABII586IZkKv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2288403119",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-14T10:32:53Z",
      "updated_at": "2024-08-14T10:32:53Z",
      "author_association": "MEMBER",
      "body": "Would it help if I put the test/fuzz changes in a separate PR from the refactoring changes? It would make the first PR less exciting to review, but perhaps easier to review?",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2288403119",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2288433763,
      "node_id": "IC_kwDOABII586IZrpj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2288433763",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-14T10:50:29Z",
      "updated_at": "2024-08-14T10:50:29Z",
      "author_association": "MEMBER",
      "body": "> Would it help if I put the test/fuzz changes in a separate PR from the refactoring changes? It would make the first PR less exciting to review, but perhaps easier to review?\r\n\r\nUp to you, but there is a small benefit of going with the fuzz tests first (if possible), in that they first run on master (and pass), and then on the refactor changes (and pass as well). For unit tests this can be achieved by just putting them in an early commit and then running the tests for all commits. For fuzz tests, it is a bit more difficult, because fuzz inputs need to exist. (Also, some fuzz task sanitizers are only run in external CI, because they take a long time)",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2288433763",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2288512730,
      "node_id": "IC_kwDOABII586IZ-7a",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2288512730",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-14T11:37:02Z",
      "updated_at": "2024-08-14T11:37:02Z",
      "author_association": "MEMBER",
      "body": "> Up to you, but there is a small benefit of going with the fuzz tests first (if possible)\r\n\r\nIt looks like the tests here mostly operate on the split out modules after the refactoring, as opposed to a implementation agnostic test through the p2p interface (which would be a giant pita to write). So splitting the fuzz test out would be fine as they don't directly assert that no behavior changes are made. It would of course be sad if we split them out and then only the refactoring lands (which has happened before).",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2288512730",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2288577940,
      "node_id": "IC_kwDOABII586IaO2U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2288577940",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-14T12:12:04Z",
      "updated_at": "2024-08-14T12:12:04Z",
      "author_association": "MEMBER",
      "body": "> > to you, but there is a small benefit of going with the fuzz tests first (if possible)\r\n> \r\n> It looks like the tests here mostly operate on the split out modules after the refactoring, as opposed to a implementation agnostic test through the p2p interface (which would be a giant pita to write).\r\n\r\nIndeed, all of these tests require the refactors (on master we'd have to create a chain to fire validation events + construct actual transactions with each type of invalidity).\r\n\r\n> So splitting the fuzz test out would be fine as they don't directly assert that no behavior changes are made. It would of course be sad if we split them out and then only the refactoring lands (which has happened before).\r\n\r\nIf people like the fuzz tests (concept acks would be nice), I'll split them off to make this PR smaller, and keep the unit tests in here. I just don't want to create 2 big PRs that nobody is interested in.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2288577940",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2288892100,
      "node_id": "IC_kwDOABII586IbbjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2288892100",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-14T14:11:41Z",
      "updated_at": "2024-08-14T14:11:41Z",
      "author_association": "MEMBER",
      "body": "personally speaking I'm unsure what is gained by moving the fuzz tests to their own PR since they depend on the refactors. I don't think we want to merge the other commits unless the fuzz harnesses are attached to it. I'm continuing to review either way.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2288892100",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2289016249,
      "node_id": "IC_kwDOABII586Ib525",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2289016249",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-14T14:45:11Z",
      "updated_at": "2024-08-15T10:18:46Z",
      "author_association": "MEMBER",
      "body": "> I don't think we want to merge the other commits unless the fuzz harnesses are attached to it. I'm continuing to review either way.\r\n\r\nOk sounds good, I'll leave as is. Just hoping to make review easier.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2289016249",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "labeled",
      "id": 13908953655,
      "node_id": "LE_lADOABII586I73RbzwAAAAM9Cco3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13908953655",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-16T10:06:47Z",
      "label": {
        "name": "Needs CMake port",
        "color": "0e8a16"
      }
    },
    {
      "event": "reviewed",
      "id": 2245996944,
      "node_id": "PRR_kwDOABII586F3zGQ",
      "url": null,
      "actor": null,
      "commit_id": "04856ed32c17ce60e9c503d92b21092a0f9ac271",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reviewed all refactorings through 388c2f5d7ee5f38cbefaff0c85cf298083127299\r\n\r\nPretty straight forward the whole way through.\r\n\r\ngoing to spend time reviewing/testing the fuzz portions next",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2245996944",
      "submitted_at": "2024-08-20T13:56:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "reviewed",
      "id": 2248150197,
      "node_id": "PRR_kwDOABII586GAAy1",
      "url": null,
      "actor": null,
      "commit_id": "04856ed32c17ce60e9c503d92b21092a0f9ac271",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ok I reviewed the unit and fuzz tests.\r\n\r\nFor the tx_download fuzz target there's a couple issues:\r\n\r\n1) the time could adversarially be moved forward only 1ms at a time, 100k iterations results in 100 seconds. I hacked the target to *only* allow the forced good peer to respond to the getdata. I got a case where the while loop exits when only 100 seconds have passed in simulated time. Stalling peer A refuses to send TX, then after 60 seconds, at the same time, an honest peer and stalling peer connect and offer the same INV. First INV times out, then second stalling peer gets chosen as next CANIDATE_BEST. Runs out of iterations 40 seconds later.\r\n\r\n2) More annoyingly, the case I found had instability. I *think* it's because TxRequests' `PriorityComputer` is not being set to deterministic random even when TxDownloadMan is. So sometimes the case was passing due to the ordering of the candidates based on this randomness.\r\n\r\nIn general I think this last fuzz target should try to target more on the end of \"only one good peer\", at least switch to that with a bool, since I think when allowing all peers to perhaps be somewhat good, it hides potential issues.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2248150197",
      "submitted_at": "2024-08-20T20:48:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13959246557,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANACTLd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13959246557",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-21T11:54:40Z"
    },
    {
      "event": "reviewed",
      "id": 2250344089,
      "node_id": "PRR_kwDOABII586GIYaZ",
      "url": null,
      "actor": null,
      "commit_id": "e6acb19b87473e9aaa9ec59a3f83b02ef06970b4",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Pushed to address the first batch of comments, going to work on test parts next",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2250344089",
      "submitted_at": "2024-08-21T11:55:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "commented",
      "id": 2301983925,
      "node_id": "IC_kwDOABII586JNXy1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2301983925",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-21T12:53:39Z",
      "updated_at": "2024-08-21T12:53:39Z",
      "author_association": "MEMBER",
      "body": "The naming of the files and tests is a bit inconsistent, I would suggest the following:\r\n\r\n* `txdownloadman.h`, `txdownloadman.cpp`, `txdownloadman_impl.h` and `txdownloadman_impl.cpp` with the classes: `TxDownloadManager` and `TxDownloadManagerImpl`\r\n* `fuzz/txdownloadman.cpp`: `txdownloadman` + `txdownloadman_impl`\r\n* `fuzz/txdownloadman_one_honest_peer.cpp`: `txdownloadman_one_honest_peer`\r\n\r\nI don't care about the specific names just the consistency, e.g. don't mix `tx_download` and `txdownload` or `txdownloadman` and `txdownload`. The test names should roughly convey what is being tested as well.\r\n\r\nI'm fuzzing all the harnesses atm, should have coverage reports up by tomorrow.",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2301983925",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "labeled",
      "id": 13960299449,
      "node_id": "LE_lADOABII586I73RbzwAAAANAGUO5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13960299449",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-21T13:12:55Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13961556845,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANALHNt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13961556845",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-21T14:38:57Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13961724534,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANALwJ2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13961724534",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-21T14:49:32Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13963352300,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANAR9js",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13963352300",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-21T16:26:37Z"
    },
    {
      "event": "unlabeled",
      "id": 13964244503,
      "node_id": "UNLE_lADOABII586I73RbzwAAAANAVXYX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13964244503",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-21T17:38:23Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2251681805,
      "node_id": "PRR_kwDOABII586GNfAN",
      "url": null,
      "actor": null,
      "commit_id": "bbec8e261467637ce26ecf551b528d9061cf4ffe",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reviewed through bbec8e261467637ce26ecf551b528d9061cf4ffe\r\n\r\nvia `git range-diff master 388c2f5d7ee5f38cbefaff0c85cf298083127299 bbec8e261467637ce26ecf551b528d9061cf4ffe`\r\n\r\nLGTM aside from waiting on fuzzer coverage results + fixes",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2251681805",
      "submitted_at": "2024-08-21T19:06:33Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "commented",
      "id": 2304631078,
      "node_id": "IC_kwDOABII586JXeEm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2304631078",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-22T13:08:22Z",
      "updated_at": "2024-08-22T13:08:22Z",
      "author_association": "MEMBER",
      "body": "Doesn't look like `ReceivedTx` ever returns a package to validate in any of the fuzz tests (500 CPU hours each):\r\n\r\n* http://bitcoind-fuzz.dergoegge.de:8000/bitcoin-pr30110/harnesses/txdownload_impl/coverage_report/coverage/workdir/bitcoin/src/test/fuzz/txdownloadman.cpp.html#L352\r\n* http://bitcoind-fuzz.dergoegge.de:8000/bitcoin-pr30110/harnesses/txdownloadman/coverage_report/coverage/workdir/bitcoin/src/test/fuzz/txdownloadman.cpp.html#L213\r\n* http://bitcoind-fuzz.dergoegge.de:8000/bitcoin-pr30110/harnesses/tx_download/coverage_report/coverage/workdir/bitcoin/src/test/fuzz/tx_download.cpp.html#L307",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2304631078",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2304734471,
      "node_id": "IC_kwDOABII586JX3UH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2304734471",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-22T13:53:36Z",
      "updated_at": "2024-08-22T13:53:36Z",
      "author_association": "MEMBER",
      "body": "> Doesn't look like ReceivedTx ever returns a package to validate in any of the fuzz tests (500 CPU hours each):\r\n\r\nAt a minimum `TESTED_TX_RESULTS` is missing `TxValidationResult::TX_RECONSIDERABLE`, so nothing is ever failing for the right reason to try a package.\r\n\r\nI restricted the set of possible transactions down to just a parent/child combo in TRANSACTIONS and was able to trigger it quickly, so it's likely reachable with that one change.\r\n",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2304734471",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "reviewed",
      "id": 2254802540,
      "node_id": "PRR_kwDOABII586GZY5s",
      "url": null,
      "actor": null,
      "commit_id": "0de01c034e2977516d11f370efa1495d9b9577b0",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2254802540",
      "submitted_at": "2024-08-22T15:02:42Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "commented",
      "id": 2304916648,
      "node_id": "IC_kwDOABII586JYjyo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2304916648",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-22T15:06:29Z",
      "updated_at": "2024-08-22T15:09:28Z",
      "author_association": "MEMBER",
      "body": "`3yTMzMzMzMzMzMzMzMw2lcV+LVVYVVX//y1maZY/xcWVxX5VWFVVVVUlugr///8tZmlVCg==` for txdownloadman target\r\n\r\nif you add `TX_RECONSIDERABLE` to the end of `TESTED_TX_RESULTS`, this should crash because it found a package to try\r\n\r\n",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2304916648",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13990719826,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANB6XFS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13990719826",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-23T09:32:00Z"
    },
    {
      "event": "commented",
      "id": 2306692234,
      "node_id": "IC_kwDOABII586JfVSK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2306692234",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-23T09:32:44Z",
      "updated_at": "2024-08-23T09:32:44Z",
      "author_association": "MEMBER",
      "body": "> TESTED_TX_RESULTS is missing TxValidationResult::TX_RECONSIDERABLE\r\n\r\nThat's an oversight, I've added that and UNKNOWN now which should mean we see packages.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2306692234",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "reviewed",
      "id": 2257071619,
      "node_id": "PRR_kwDOABII586GiC4D",
      "url": null,
      "actor": null,
      "commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2257071619",
      "submitted_at": "2024-08-23T12:07:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "reviewed",
      "id": 2257097696,
      "node_id": "PRR_kwDOABII586GiJPg",
      "url": null,
      "actor": null,
      "commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2257097696",
      "submitted_at": "2024-08-23T12:20:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "reviewed",
      "id": 2257108313,
      "node_id": "PRR_kwDOABII586GiL1Z",
      "url": null,
      "actor": null,
      "commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2257108313",
      "submitted_at": "2024-08-23T12:26:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "commented",
      "id": 2307077927,
      "node_id": "IC_kwDOABII586Jgzcn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2307077927",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-23T13:17:41Z",
      "updated_at": "2024-08-23T13:17:41Z",
      "author_association": "MEMBER",
      "body": "```\r\n$ FUZZ=txdownload_impl src/test/fuzz/fuzz solution-60b4aafd2c355198b269114d31545a12b9059fd6.txt\r\ntest/fuzz/txdownloadman.cpp:384 operator(): Assertion `!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256())' failed.\r\n```\r\n\r\n[solution-60b4aafd2c355198b269114d31545a12b9059fd6.txt](https://github.com/user-attachments/files/16729173/solution-60b4aafd2c355198b269114d31545a12b9059fd6.txt)",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2307077927",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "commented",
      "id": 2307124171,
      "node_id": "IC_kwDOABII586Jg-vL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2307124171",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-23T13:42:09Z",
      "updated_at": "2024-08-23T13:43:58Z",
      "author_association": "MEMBER",
      "body": "> [solution-60b4aafd2c355198b269114d31545a12b9059fd6.txt](https://github.com/user-attachments/files/16729173/solution-60b4aafd2c355198b269114d31545a12b9059fd6.txt)\r\n\r\n`Find1P1CPackage` doesn't actually check the normal reject filter at all with respect to the child, only reconsiderable, so that assertion gets hit. I suspect that's something we don't want it to do, even if it's not possible to hit inside net_processing.\r\n\r\nLGTM modulo existing concerns about the `tx_download_one_honest_peer` harness:\r\n\r\n1) no det rand for tx_request module in downloadman, leading to instability\r\n2) timesteps can be so small that the tx is never downloaded in 100 seconds\r\n3) scenario should flip a bool to *only* allow the good peer to hand over real tx\r\n\r\nreviewed via `git range-diff master bbec8e261467637ce26ecf551b528d9061cf4ffe 6a84ab77f36445fd37d46a08c71bd4373201d300`",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2307124171",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13994597009,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANCJJqR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13994597009",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-23T15:09:18Z"
    },
    {
      "event": "commented",
      "id": 2307287556,
      "node_id": "IC_kwDOABII586JhmoE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2307287556",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-23T15:09:46Z",
      "updated_at": "2024-08-23T15:09:46Z",
      "author_association": "MEMBER",
      "body": "> Find1P1CPackage doesn't actually check the normal reject filter at all with respect to the child, only reconsiderable, so that assertion gets hit. \r\n\r\nI think it might be more that `MempoolRejectedTx` doesn't remember if a tx failed for a different reason before considering an orphan?",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2307287556",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "reviewed",
      "id": 2257590987,
      "node_id": "PRR_kwDOABII586GkBrL",
      "url": null,
      "actor": null,
      "commit_id": "dda6a394fab46adbe5a37a5b93f64daf6f738b34",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Reviewed up to e164614e32010bc8061cc99ed486188235efa780 (i.e. everything modulo fuzz and unit tests in the last 3 commits), lgtm so far.\r\n\r\nSlightly off-topic, but: on some commits like 4e58d84da95d97d64f563b5c3e116769cd9ff89b `--color-moved=dimmed-zebra` didn't detect any lines as move-only for me (with 2-3 exceptions that seem completely arbitrary), any suggestions for advanced git options and/or recommendations for other fancy diff tools that can cope with that? (Or well, maybe I should just try with a newer git version.)",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2257590987",
      "submitted_at": "2024-08-23T16:24:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14027224767,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANEFna_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14027224767",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:45:07Z"
    },
    {
      "event": "commented",
      "id": 2312348384,
      "node_id": "IC_kwDOABII586J06Lg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2312348384",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:49:56Z",
      "updated_at": "2024-08-27T11:49:56Z",
      "author_association": "MEMBER",
      "body": "Thanks @dergoegge @theStack @instagibbs! Addressed all comments.\r\n\r\n> Slightly off-topic, but: on some commits like https://github.com/bitcoin/bitcoin/commit/4e58d84da95d97d64f563b5c3e116769cd9ff89b --color-moved=dimmed-zebra didn't detect any lines as move-only for me (with 2-3 exceptions that seem completely arbitrary), any suggestions for advanced git options and/or recommendations for other fancy diff tools that can cope with that?\r\n\r\nI see that happen too :( very annoying. Sometimes if I see there are indentation changes, adding a `-w` or manually (un)indenting helps the diff display better. Unfortunately I don't have any other tips.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2312348384",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "mentioned",
      "id": 14027288771,
      "node_id": "MEE_lADOABII586I73RbzwAAAANEF3DD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14027288771",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:49:57Z"
    },
    {
      "event": "subscribed",
      "id": 14027288788,
      "node_id": "SE_lADOABII586I73RbzwAAAANEF3DU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14027288788",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:49:57Z"
    },
    {
      "event": "mentioned",
      "id": 14027288811,
      "node_id": "MEE_lADOABII586I73RbzwAAAANEF3Dr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14027288811",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:49:57Z"
    },
    {
      "event": "subscribed",
      "id": 14027288827,
      "node_id": "SE_lADOABII586I73RbzwAAAANEF3D7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14027288827",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:49:58Z"
    },
    {
      "event": "mentioned",
      "id": 14027288843,
      "node_id": "MEE_lADOABII586I73RbzwAAAANEF3EL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14027288843",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:49:58Z"
    },
    {
      "event": "subscribed",
      "id": 14027288857,
      "node_id": "SE_lADOABII586I73RbzwAAAANEF3EZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14027288857",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T11:49:58Z"
    },
    {
      "event": "commented",
      "id": 2312603309,
      "node_id": "IC_kwDOABII586J14at",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2312603309",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T13:42:58Z",
      "updated_at": "2024-08-27T13:42:58Z",
      "author_association": "MEMBER",
      "body": "ACK 6f6fc1464ad2f2981e7c3ff5d6492f60f89a6504\r\n\r\nAttends to my concerns with the fuzz tests. Now in `txdownloadman_one_honest_peer` no \"non-good\" peer will ever deliver `TX_REAL`, ensuring that the test is actually testing what we want. Determinstic randomness was also given to the member txrequest modules. \r\n\r\nLastly, minimum time skips were increased to 100ms, meaning 100ms*100000=~166 minutes of simulated time. Since there are up to 8+120=128 peers, this means each peer can stall out the node for a full minute and we still have 40 minutes left for the honest peer to succeed in giving the tx.\r\n\r\nIf you touch this again, I might suggest adding some static asserts to the above effect in case people want to modify these values in the future.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2312603309",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "review_requested",
      "id": 14029086971,
      "node_id": "RRE_lADOABII586I73RbzwAAAANEMuD7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14029086971",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T13:43:03Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 2312787737,
      "node_id": "IC_kwDOABII586J2lcZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2312787737",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T14:51:57Z",
      "updated_at": "2024-08-27T14:54:47Z",
      "author_association": "MEMBER",
      "body": "Just posting in case someone else learns something. Not asking for any changes:\r\n\r\n> Lastly, minimum time skips were increased to 100ms, meaning 100ms*100000=~166 minutes of simulated time. Since there are up to 8+120=128 peers, this means each peer can stall out the node for a full minute and we still have 40 minutes left for the honest peer to succeed in giving the tx.\r\n\r\nAfter doing more study, I think this simulation \"only\" needs a little more than 7 minutes minimum time, since the internal PriorityComputer will always select outbounds(prefered) out of the set of `CANDIDATE_READY`s. Incoming connections will be passed over for the good(and outgoing) peer once the good peer sends `INV_REAL` when choosing new CANIDATE_BEST.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2312787737",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "reviewed",
      "id": 2266000970,
      "node_id": "PRR_kwDOABII586HEG5K",
      "url": null,
      "actor": null,
      "commit_id": "6f6fc1464ad2f2981e7c3ff5d6492f60f89a6504",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Approach ACK\r\n\r\n",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2266000970",
      "submitted_at": "2024-08-28T12:57:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14046697772,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANFP5ks",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14046697772",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-28T13:31:09Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14046876232,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANFQlJI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14046876232",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-28T13:42:11Z"
    },
    {
      "event": "commented",
      "id": 2315385164,
      "node_id": "IC_kwDOABII586KAflM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2315385164",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-28T13:53:50Z",
      "updated_at": "2024-08-28T13:53:50Z",
      "author_association": "MEMBER",
      "body": "Rebased for cmake",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2315385164",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "reviewed",
      "id": 2266475743,
      "node_id": "PRR_kwDOABII586HF6zf",
      "url": null,
      "actor": null,
      "commit_id": "2b387a156a1021ad782dc4de2fd34d5b5b81698a",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reACK 2b387a156a1021ad782dc4de2fd34d5b5b81698a\r\n\r\nvia `git range-diff master 6f6fc1464ad2f2981e7c3ff5d6492f60f89a6504 2b387a156a1021ad782dc4de2fd34d5b5b81698a`\r\n\r\nonly non-cmake changes I see were reordering the class renaming, and the added `ConnectedPeer` in unit tests.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#pullrequestreview-2266475743",
      "submitted_at": "2024-08-28T14:34:35Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
    },
    {
      "event": "review_requested",
      "id": 14047985399,
      "node_id": "RRE_lADOABII586I73RbzwAAAANFUz73",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14047985399",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-28T14:34:40Z",
      "requested_reviewer": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 2316022026,
      "node_id": "IC_kwDOABII586KC7EK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2316022026",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-28T18:40:09Z",
      "updated_at": "2024-08-28T18:40:09Z",
      "author_association": "MEMBER",
      "body": "Interesting proposal to review; note to self to look at why move peer dis(connection) logic.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2316022026",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    },
    {
      "event": "unlabeled",
      "id": 14059641724,
      "node_id": "UNLE_lADOABII586I73RbzwAAAANGBRt8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14059641724",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-29T10:43:43Z",
      "label": {
        "name": "Needs CMake port",
        "color": "0e8a16"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGVjYmJhZGYwZjc5YmIzMjczMGQ5ZTE0MDBkODRiODQ4OTNlMzVlNTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ecbbadf0f79bb32730d9e1400d84b84893e35e56",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ecbbadf0f79bb32730d9e1400d84b84893e35e56",
      "tree": {
        "sha": "52f7ccc4c3f40006f3d844e6dbbd5b082907538c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/52f7ccc4c3f40006f3d844e6dbbd5b082907538c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a74bdeea1b8e27b2335f0f7da78006e87ecfb235",
          "sha": "a74bdeea1b8e27b2335f0f7da78006e87ecfb235",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a74bdeea1b8e27b2335f0f7da78006e87ecfb235"
        }
      ],
      "message": "[refactor] add TxDownloadManager wrapping TxOrphanage, TxRequestTracker, and bloom filters\n\nThis module is going to be responsible for managing everything related\nto transaction download, including txrequest, orphan transactions and\npackage relay. It will be responsible for managing usage of the\nTxOrphanage and instructing PeerManager:\n- what tx or package-related messages to send to which peer\n- whether a tx or package-related message is allowed or useful\n- what transactions are available to try accepting to mempool\n\nFuture commits will consolidate the interface and re-delegate\ninteractions from PeerManager to TxDownloadManager.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:11:49Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2022-05-01T17:41:53Z"
      },
      "sha": "ecbbadf0f79bb32730d9e1400d84b84893e35e56"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGEyMDFiYjhhNWJjMDJhZTNmNWUyMTVjMGM5MzQ1NTMwZDBiMDhhYTk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a201bb8a5bc02ae3f5e215c0c9345530d0b08aa9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a201bb8a5bc02ae3f5e215c0c9345530d0b08aa9",
      "tree": {
        "sha": "3aa8582ed0d58a163d1929112b24673c950eb750",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3aa8582ed0d58a163d1929112b24673c950eb750"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ecbbadf0f79bb32730d9e1400d84b84893e35e56",
          "sha": "ecbbadf0f79bb32730d9e1400d84b84893e35e56",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ecbbadf0f79bb32730d9e1400d84b84893e35e56"
        }
      ],
      "message": "[refactor] move ValidationInterface functions to TxDownloadManager\n\nThis is move-only.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:11:51Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T14:31:35Z"
      },
      "sha": "a201bb8a5bc02ae3f5e215c0c9345530d0b08aa9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGI4OGI4MmZjMTFiODI2MTZhMzRjZGEzYTI3ZTYzYjE1ZDdkMWRhNTM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b88b82fc11b82616a34cda3a27e63b15d7d1da53",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b88b82fc11b82616a34cda3a27e63b15d7d1da53",
      "tree": {
        "sha": "4eeb568c2630a7c5b836d251bef9cf7952d79e39",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4eeb568c2630a7c5b836d251bef9cf7952d79e39"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a201bb8a5bc02ae3f5e215c0c9345530d0b08aa9",
          "sha": "a201bb8a5bc02ae3f5e215c0c9345530d0b08aa9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a201bb8a5bc02ae3f5e215c0c9345530d0b08aa9"
        }
      ],
      "message": "[txdownload] add read-only reference to mempool\n\nThis will become necessary in later commits that query mempool. We also\nintroduce the TxDownloadOptions in this commit to make the later diff\neasier to review.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:11:51Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T16:04:00Z"
      },
      "sha": "b88b82fc11b82616a34cda3a27e63b15d7d1da53"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU4ZDlmODMwNzk4OWJjZTM2OTVkZDliZGMyOTEyNDRkNDg0NTJmNzU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/58d9f8307989bce3695dd9bdc291244d48452f75",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/58d9f8307989bce3695dd9bdc291244d48452f75",
      "tree": {
        "sha": "fc08289c1d5c98dc798dc6dc43b17822efe7d60a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fc08289c1d5c98dc798dc6dc43b17822efe7d60a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b88b82fc11b82616a34cda3a27e63b15d7d1da53",
          "sha": "b88b82fc11b82616a34cda3a27e63b15d7d1da53",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b88b82fc11b82616a34cda3a27e63b15d7d1da53"
        }
      ],
      "message": "[refactor] move AlreadyHaveTx to TxDownload\n\nThis is move-only.\nAlso delete external RecentConfirmedTransactionsFilter() access since it\nis no longer necessary.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:14:01Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T16:06:56Z"
      },
      "sha": "58d9f8307989bce3695dd9bdc291244d48452f75"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGYyNjFmMDczMWFmNGY2M2YzMDU3MzM1ZDk3NGM3YjAwZTYwN2M4M2I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f261f0731af4f63f3057335d974c7b00e607c83b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f261f0731af4f63f3057335d974c7b00e607c83b",
      "tree": {
        "sha": "38fed13c40f32c5bd3610904f76aecd3b9a205b4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/38fed13c40f32c5bd3610904f76aecd3b9a205b4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/58d9f8307989bce3695dd9bdc291244d48452f75",
          "sha": "58d9f8307989bce3695dd9bdc291244d48452f75",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/58d9f8307989bce3695dd9bdc291244d48452f75"
        }
      ],
      "message": "[refactor] move peer (dis)connection logic to TxDownload\n\nThe information stored in TxDownloadConnectionInfo isn't used until the\nnext commit.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:14:02Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T15:46:36Z"
      },
      "sha": "f261f0731af4f63f3057335d974c7b00e607c83b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDMxYjE1MGM5MTU5YzI1NTNkNjlhMTk0MmE4NDdmYjA2ODI3ODlhZmI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/31b150c9159c2553d69a1942a847fb0682789afb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/31b150c9159c2553d69a1942a847fb0682789afb",
      "tree": {
        "sha": "9cc9d76032c79251f0fe4c39c3f30000cb07c398",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9cc9d76032c79251f0fe4c39c3f30000cb07c398"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f261f0731af4f63f3057335d974c7b00e607c83b",
          "sha": "f261f0731af4f63f3057335d974c7b00e607c83b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f261f0731af4f63f3057335d974c7b00e607c83b"
        }
      ],
      "message": "[refactor] rename maybe_add_extra_compact_tx to first_time_failure\n\nThe usage of this bool will increase in scope in the next commit.\nFor this commit, the value of this bool is accurate at each\nProcessInvalidTx callsite:\n- ProcessOrphanTx -> this tx is an orphan i.e. has been rejected before\n- ProcessPackageResult -> 1p1c only, each transaction is either an\n  orphan or in m_lazy_recent_rejects_reconsiderable\n- ProcessMessage -> tx was received over p2p and validated for the first\n  time",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:14:02Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-08-21T10:29:24Z"
      },
      "sha": "31b150c9159c2553d69a1942a847fb0682789afb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDNiZjZkNDMwYjFlYWJkMGE3OTJhMDg4MmRjNWRkYTQ3OTQ1NzdmMTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3bf6d430b1eabd0a792a0882dc5dda4794577f15",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/3bf6d430b1eabd0a792a0882dc5dda4794577f15",
      "tree": {
        "sha": "96f31ecfbc1d6243b111a48cc63fc6afbb45e360",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/96f31ecfbc1d6243b111a48cc63fc6afbb45e360"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/31b150c9159c2553d69a1942a847fb0682789afb",
          "sha": "31b150c9159c2553d69a1942a847fb0682789afb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/31b150c9159c2553d69a1942a847fb0682789afb"
        }
      ],
      "message": "[p2p] don't log tx invs when in IBD\n\nThese invs are ignored anyway, and this allows us to more easily move\nthe inv handling to TxDownloadManager in the next commit.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:15:13Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-08-14T09:33:21Z"
      },
      "sha": "3bf6d430b1eabd0a792a0882dc5dda4794577f15"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDUxNzE3NzkxYzdmOWFlYmQ0MmY0MjAzNzQxZWUzYjAwMWU2ZDY1NGQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/51717791c7f9aebd42f4203741ee3b001e6d654d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/51717791c7f9aebd42f4203741ee3b001e6d654d",
      "tree": {
        "sha": "c6b680d3bebebfa470c42e6b16b8c66056712fe2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c6b680d3bebebfa470c42e6b16b8c66056712fe2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3bf6d430b1eabd0a792a0882dc5dda4794577f15",
          "sha": "3bf6d430b1eabd0a792a0882dc5dda4794577f15",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/3bf6d430b1eabd0a792a0882dc5dda4794577f15"
        }
      ],
      "message": "[refactor] move tx inv/getdata handling to txdownload",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:17:06Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-25T10:43:04Z"
      },
      "sha": "51717791c7f9aebd42f4203741ee3b001e6d654d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGM0MGNiODU2NTk1MmY2MjczMmZhNjQ4NzVjOTllZjkwODJiOWE2ZjQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c40cb8565952f62732fa64875c99ef9082b9a6f4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c40cb8565952f62732fa64875c99ef9082b9a6f4",
      "tree": {
        "sha": "8756d9a451e8647a556d571313849bbb6e4d4c2f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8756d9a451e8647a556d571313849bbb6e4d4c2f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/51717791c7f9aebd42f4203741ee3b001e6d654d",
          "sha": "51717791c7f9aebd42f4203741ee3b001e6d654d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/51717791c7f9aebd42f4203741ee3b001e6d654d"
        }
      ],
      "message": "[refactor] move notfound processing to txdownload",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:17:06Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-25T10:48:43Z"
      },
      "sha": "c40cb8565952f62732fa64875c99ef9082b9a6f4"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGM0Yjk0ZjZiOTg1NTRjMjlmMDVmODQ5ODg3YzczY2FlMDE0MWIxZjM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c4b94f6b98554c29f05f849887c73cae0141b1f3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c4b94f6b98554c29f05f849887c73cae0141b1f3",
      "tree": {
        "sha": "8694c8ebf7acd3b167ef0a4e90016ba88e4c40fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8694c8ebf7acd3b167ef0a4e90016ba88e4c40fb"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c40cb8565952f62732fa64875c99ef9082b9a6f4",
          "sha": "c40cb8565952f62732fa64875c99ef9082b9a6f4",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c40cb8565952f62732fa64875c99ef9082b9a6f4"
        }
      ],
      "message": "[refactor] move some definitions\n\nProcessInvalidTx will return a PackageToValidate, so it needs to be\ndefined afterward.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:17:06Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-05-15T15:00:32Z"
      },
      "sha": "c4b94f6b98554c29f05f849887c73cae0141b1f3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGIzNTNmNWU0Yjg5MjBlOGY1YTc3YmUwMWY3ZTkyYjZmOTcxNmUxM2U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b353f5e4b8920e8f5a77be01f7e92b6f9716e13e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b353f5e4b8920e8f5a77be01f7e92b6f9716e13e",
      "tree": {
        "sha": "00f3a30570b0139ade30ad07cec35d060d709ede",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/00f3a30570b0139ade30ad07cec35d060d709ede"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c4b94f6b98554c29f05f849887c73cae0141b1f3",
          "sha": "c4b94f6b98554c29f05f849887c73cae0141b1f3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c4b94f6b98554c29f05f849887c73cae0141b1f3"
        }
      ],
      "message": "[refactor] move new orphan handling to ProcessInvalidTx",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:19:15Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-30T09:54:00Z"
      },
      "sha": "b353f5e4b8920e8f5a77be01f7e92b6f9716e13e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE3YTlmZjRjM2VjZjI4NDE1ODZjZmFkOGYyMDhiOGJiNWI0NWJjZmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/17a9ff4c3ecf2841586cfad8f208b8bb5b45bcfa",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/17a9ff4c3ecf2841586cfad8f208b8bb5b45bcfa",
      "tree": {
        "sha": "afaf71b246cb543ef9ea3d4fc04668e423f1bdf9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/afaf71b246cb543ef9ea3d4fc04668e423f1bdf9"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b353f5e4b8920e8f5a77be01f7e92b6f9716e13e",
          "sha": "b353f5e4b8920e8f5a77be01f7e92b6f9716e13e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b353f5e4b8920e8f5a77be01f7e92b6f9716e13e"
        }
      ],
      "message": "move Find1P1CPackage into ProcessInvalidTx",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:21:39Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-05-15T15:10:24Z"
      },
      "sha": "17a9ff4c3ecf2841586cfad8f208b8bb5b45bcfa"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU0ODNmMTYzOWI4YjVhOGNiZTc5MzA2Nzc2NjQ3YWI5MDhhMDM5YmM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5483f1639b8b5a8cbe79306776647ab908a039bc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5483f1639b8b5a8cbe79306776647ab908a039bc",
      "tree": {
        "sha": "696414b04be073887b392035eb7ca489e163281f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/696414b04be073887b392035eb7ca489e163281f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/17a9ff4c3ecf2841586cfad8f208b8bb5b45bcfa",
          "sha": "17a9ff4c3ecf2841586cfad8f208b8bb5b45bcfa",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/17a9ff4c3ecf2841586cfad8f208b8bb5b45bcfa"
        }
      ],
      "message": "[refactor] ProcessInvalidTx logic to put peerman tasks at the end",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:21:41Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-30T12:12:21Z"
      },
      "sha": "5483f1639b8b5a8cbe79306776647ab908a039bc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGVjMjQyZTdiNDliYjdhZTgwNmM0MjgzZDYxOGVlY2NjZmRjM2YzOTI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ec242e7b49bb7ae806c4283d618eecccfdc3f392",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ec242e7b49bb7ae806c4283d618eecccfdc3f392",
      "tree": {
        "sha": "41310592bfdeb98f0f6d448456bcaab1df36801a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/41310592bfdeb98f0f6d448456bcaab1df36801a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5483f1639b8b5a8cbe79306776647ab908a039bc",
          "sha": "5483f1639b8b5a8cbe79306776647ab908a039bc",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5483f1639b8b5a8cbe79306776647ab908a039bc"
        }
      ],
      "message": "[refactor] move Find1P1CPackage to txdownload\n\nMove-only.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:21:41Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-25T10:24:31Z"
      },
      "sha": "ec242e7b49bb7ae806c4283d618eecccfdc3f392"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU5M2Q3YjgwMTJhZmE5NmFmMjczYzZjNjBkN2RiN2I1N2MwODlmYjM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e93d7b8012afa96af273c6c60d7db7b57c089fb3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e93d7b8012afa96af273c6c60d7db7b57c089fb3",
      "tree": {
        "sha": "30aa237548955cbdff08142e9520b4101b14db6c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/30aa237548955cbdff08142e9520b4101b14db6c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ec242e7b49bb7ae806c4283d618eecccfdc3f392",
          "sha": "ec242e7b49bb7ae806c4283d618eecccfdc3f392",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ec242e7b49bb7ae806c4283d618eecccfdc3f392"
        }
      ],
      "message": "[refactor] move valid tx processing to TxDownload",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:21:41Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T14:45:33Z"
      },
      "sha": "e93d7b8012afa96af273c6c60d7db7b57c089fb3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDc3YzViODAzNzRlZDgyMWM1NmQ4MzQ4MjdjNTE1NzdhMmM0ODkxYWE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/77c5b80374ed821c56d834827c51577a2c4891aa",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/77c5b80374ed821c56d834827c51577a2c4891aa",
      "tree": {
        "sha": "a5611a31f40b92f854ccc2fccf4ec281c9f74703",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a5611a31f40b92f854ccc2fccf4ec281c9f74703"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e93d7b8012afa96af273c6c60d7db7b57c089fb3",
          "sha": "e93d7b8012afa96af273c6c60d7db7b57c089fb3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e93d7b8012afa96af273c6c60d7db7b57c089fb3"
        }
      ],
      "message": "[refactor] move invalid tx processing to TxDownload\n\nMove-only. Also delete external RecentRejectsFilter() access since it is\nno longer necessary.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:22:58Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T14:55:57Z"
      },
      "sha": "77c5b80374ed821c56d834827c51577a2c4891aa"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGI1YjRjODYzZjI1YzQzNzhhYjdmYjU5MjYzYThmZmEwNDU5YzUzNTg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b5b4c863f25c4378ab7fb59263a8ffa0459c5358",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b5b4c863f25c4378ab7fb59263a8ffa0459c5358",
      "tree": {
        "sha": "a26e43d33f553217ef6946441f9a1f3d5f95ae0d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a26e43d33f553217ef6946441f9a1f3d5f95ae0d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/77c5b80374ed821c56d834827c51577a2c4891aa",
          "sha": "77c5b80374ed821c56d834827c51577a2c4891aa",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/77c5b80374ed821c56d834827c51577a2c4891aa"
        }
      ],
      "message": "[refactor] move invalid package processing to TxDownload",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:23:01Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T15:35:07Z"
      },
      "sha": "b5b4c863f25c4378ab7fb59263a8ffa0459c5358"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGYzY2M2MzIyNzk4Y2E2MWEzMWY5MGIyYWQ3YTBjMzI0NzFkYjA0MTA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f3cc6322798ca61a31f90b2ad7a0c32471db0410",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f3cc6322798ca61a31f90b2ad7a0c32471db0410",
      "tree": {
        "sha": "2ea347eecada582db4d7d2536c02cbae4d8f3338",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ea347eecada582db4d7d2536c02cbae4d8f3338"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b5b4c863f25c4378ab7fb59263a8ffa0459c5358",
          "sha": "b5b4c863f25c4378ab7fb59263a8ffa0459c5358",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b5b4c863f25c4378ab7fb59263a8ffa0459c5358"
        }
      ],
      "message": "[refactor] move new tx logic to txdownload\n\nAlso delete external RecentRejectsReconsiderableFilter() access since it\nis no longer necessary.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:24:35Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T15:58:35Z"
      },
      "sha": "f3cc6322798ca61a31f90b2ad7a0c32471db0410"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDJiYzVjNGZkZDYyMTI5MzE0OTU0MWRlZWQwY2EzYzNiZWVmYjA4MDg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2bc5c4fdd621293149541deed0ca3c3beefb0808",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/2bc5c4fdd621293149541deed0ca3c3beefb0808",
      "tree": {
        "sha": "b8a8123e8491803e98a69972a39361279fac9f6b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b8a8123e8491803e98a69972a39361279fac9f6b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f3cc6322798ca61a31f90b2ad7a0c32471db0410",
          "sha": "f3cc6322798ca61a31f90b2ad7a0c32471db0410",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f3cc6322798ca61a31f90b2ad7a0c32471db0410"
        }
      ],
      "message": "[refactor] make AlreadyHaveTx and Find1P1CPackage private to TxDownloadImpl",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:24:36Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-05-15T15:57:03Z"
      },
      "sha": "2bc5c4fdd621293149541deed0ca3c3beefb0808"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGY4YjJlZGE2NTQzM2Y3NWYzY2Y1YTRiOWU3YWRmMGViNTg5YjA4MjA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f8b2eda65433f75f3cf5a4b9e7adf0eb589b0820",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f8b2eda65433f75f3cf5a4b9e7adf0eb589b0820",
      "tree": {
        "sha": "30e981af6f6b39082eb151acab88e8e004197c7c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/30e981af6f6b39082eb151acab88e8e004197c7c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2bc5c4fdd621293149541deed0ca3c3beefb0808",
          "sha": "2bc5c4fdd621293149541deed0ca3c3beefb0808",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/2bc5c4fdd621293149541deed0ca3c3beefb0808"
        }
      ],
      "message": "[refactor] wrap {Have,Get}TxToReconsider in txdownload",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:24:36Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-26T10:47:47Z"
      },
      "sha": "f8b2eda65433f75f3cf5a4b9e7adf0eb589b0820"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDcxNWNhYWQ0NTAyZjI1YWJmNjZiY2Q5MzZhNDIzMTdmMDkzNmRhNjA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/715caad4502f25abf66bcd936a42317f0936da60",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/715caad4502f25abf66bcd936a42317f0936da60",
      "tree": {
        "sha": "bd2e43c4726479d9e489e6d1f648246d005b1668",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bd2e43c4726479d9e489e6d1f648246d005b1668"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f8b2eda65433f75f3cf5a4b9e7adf0eb589b0820",
          "sha": "f8b2eda65433f75f3cf5a4b9e7adf0eb589b0820",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f8b2eda65433f75f3cf5a4b9e7adf0eb589b0820"
        }
      ],
      "message": "[refactor] add CheckIsEmpty and remove access to TxDownloadMan internals",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:24:36Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-26T10:56:24Z"
      },
      "sha": "715caad4502f25abf66bcd936a42317f0936da60"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQ3MmY2NmEzZmExMjc1YjgzNzBkNWUyMjExMDAwMzk0NTYyNGZmMWQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d72f66a3fa1275b8370d5e22110003945624ff1d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d72f66a3fa1275b8370d5e22110003945624ff1d",
      "tree": {
        "sha": "13cb688c0c87440673e1b61be911dc46fae25552",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/13cb688c0c87440673e1b61be911dc46fae25552"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/715caad4502f25abf66bcd936a42317f0936da60",
          "sha": "715caad4502f25abf66bcd936a42317f0936da60",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/715caad4502f25abf66bcd936a42317f0936da60"
        }
      ],
      "message": "[p2p] don't process orphan if in recent rejects\n\nThis should never happen normally, but just in case.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:24:36Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-08-23T15:05:19Z"
      },
      "sha": "d72f66a3fa1275b8370d5e22110003945624ff1d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk2MDI3NGJkNjM3N2UzZTgyYmFmMmVmZGJmYzgwOTNlNTRhOTdlMDM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/960274bd6377e3e82baf2efdbfc8093e54a97e03",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/960274bd6377e3e82baf2efdbfc8093e54a97e03",
      "tree": {
        "sha": "d30d2c5f2f972115ea04224db9236c32088fd4ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d30d2c5f2f972115ea04224db9236c32088fd4ae"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d72f66a3fa1275b8370d5e22110003945624ff1d",
          "sha": "d72f66a3fa1275b8370d5e22110003945624ff1d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d72f66a3fa1275b8370d5e22110003945624ff1d"
        }
      ],
      "message": "add TxDownloadOptions bool to make deterministic TxRequestTracker\n\nForward this bool to the TxRequestTracker ctor. This is needed for\nstablity in TxDownloadManager fuzzers",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:24:36Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-08-27T11:12:12Z"
      },
      "sha": "960274bd6377e3e82baf2efdbfc8093e54a97e03"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDJiZTc2ZTgwMGY1YTdmOTY0OWEyMzIyZmQwYTA5NjkwM2E3NTU1MGQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2be76e800f5a7f9649a2322fd0a096903a75550d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/2be76e800f5a7f9649a2322fd0a096903a75550d",
      "tree": {
        "sha": "9760ac029873d949ed72293a57911207ba7225e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9760ac029873d949ed72293a57911207ba7225e2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/960274bd6377e3e82baf2efdbfc8093e54a97e03",
          "sha": "960274bd6377e3e82baf2efdbfc8093e54a97e03",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/960274bd6377e3e82baf2efdbfc8093e54a97e03"
        }
      ],
      "message": "[fuzz] txdownloadman and txdownload_impl\n\nThe txdownload_impl is similar but allows us to check specific\ninvariants within its implementation. It will also change a lot more\nthan the external interface (txdownloadman) will, so we will add more to\nthis target later.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:25:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2023-09-29T14:43:16Z"
      },
      "sha": "2be76e800f5a7f9649a2322fd0a096903a75550d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ4YmMwOTU5OTg4MTY2ODg4ZmFlODZjMGNiNGM1MjVjMmFhZDlmMzg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/48bc0959988166888fae86c0cb4c525c2aad9f38",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/48bc0959988166888fae86c0cb4c525c2aad9f38",
      "tree": {
        "sha": "4ae7a7276287f49ddc5e5526b3a6fca2f467086d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4ae7a7276287f49ddc5e5526b3a6fca2f467086d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2be76e800f5a7f9649a2322fd0a096903a75550d",
          "sha": "2be76e800f5a7f9649a2322fd0a096903a75550d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/2be76e800f5a7f9649a2322fd0a096903a75550d"
        }
      ],
      "message": "[unit test] MempoolRejectedTx",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T17:25:55Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-29T10:58:54Z"
      },
      "sha": "48bc0959988166888fae86c0cb4c525c2aad9f38"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDFkNGUzM2U3Zjg4MTYyY2Y2ZmNkNmFlZTBiNjM5NzMwMTU4NTM1OTE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "tree": {
        "sha": "90cc8d4c5cdd060b6efdd914b98056d2f36aa015",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/90cc8d4c5cdd060b6efdd914b98056d2f36aa015"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/48bc0959988166888fae86c0cb4c525c2aad9f38",
          "sha": "48bc0959988166888fae86c0cb4c525c2aad9f38",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/48bc0959988166888fae86c0cb4c525c2aad9f38"
        }
      ],
      "message": "[fuzz] tx download succeeds as long as we have 1 good outbound",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-09-02T18:34:48Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-05-17T14:56:52Z"
      },
      "sha": "1d4e33e7f88162cf6fcd6aee0b63973015853591"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14106458095,
      "node_id": "HRFPE_lADOABII586I73RbzwAAAANIz3fv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14106458095",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-02T18:35:02Z"
    },
    {
      "event": "commented",
      "id": 2325191289,
      "node_id": "IC_kwDOABII586Kl5p5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2325191289",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-02T18:36:23Z",
      "updated_at": "2024-09-02T18:36:23Z",
      "author_association": "MEMBER",
      "body": "Rebased for autotools removal, and made the txdownloadman_one_honest_peer fuzzer more interesting. Dishonest peers now have a lot of different transactions/invs they can send that can fail for more reasons.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#issuecomment-2325191289",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30110"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1606683947",
      "pull_request_review_id": 2066059450,
      "id": 1606683947,
      "node_id": "PRRC_kwDOABII585fxA0r",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+// Copyright (c) 2022\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_NODE_TXDOWNLOAD_IMPL_H\n+#define BITCOIN_NODE_TXDOWNLOAD_IMPL_H\n+\n+#include <consensus/validation.h>\n+#include <kernel/chain.h>\n+#include <net.h>\n+#include <policy/packages.h>\n+#include <txorphanage.h>\n+#include <txrequest.h>\n+\n+class CTxMemPool;\n+namespace node {\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {",
      "path": "src/node/txdownload_impl.h",
      "position": null,
      "original_position": 32,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "b1cc0c3006ca608f9ac3af2c50c4728cbbc07714",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Structs that are part of the public interface should probably go into `txdownloadman.h`. Otherwise one needs to include the impl header, e.g. like `txdownloadman.h` does right now, which defeats the purpose of pimpling to some extend.",
      "created_at": "2024-05-20T11:55:23Z",
      "updated_at": "2024-05-20T12:32:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1606683947",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1606683947"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1606717505",
      "pull_request_review_id": 2066059450,
      "id": 1606717505,
      "node_id": "PRRC_kwDOABII585fxJBB",
      "diff_hunk": "@@ -0,0 +1,455 @@\n+// Copyright (c) 2023\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownload_impl.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+void TxDownloadImpl::UpdatedBlockTipSync()\n+{\n+    // If the chain tip has changed, previously rejected transactions might now be invalid, e.g. due\n+    // to a timelock. Reset the rejection filters to give those transactions another chance if we\n+    // see them again.\n+    m_recent_rejects.reset();\n+    m_recent_rejects_reconsiderable.reset();\n+}\n+\n+void TxDownloadImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        m_recent_confirmed_transactions.insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            m_recent_confirmed_transactions.insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+    }\n+    for (const auto& ptx : pblock->vtx) {\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    m_recent_confirmed_transactions.reset();\n+}\n+\n+bool TxDownloadImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 55,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "b1cc0c3006ca608f9ac3af2c50c4728cbbc07714",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Iiuc correctly, clearing the filters here has been removed as we don't want `TxDownloadManager` to depend on `ChainstateManager`.\r\n\r\nAn alternative to the new synchronous validation interface callback could be to preserve the previous behavior (clearing the filters in `AlreadyHaveTx` on a tip change) by introducing an interface for TxDownloadMan to fetch the latest tip hash. For example, `TxDownloadOptions` could be extended to hold a lambda that returns the latest tip hash, which in production simply fetches the hash from the `ChainstateManager` (and for tests it can be mocked). This might be easier to review since it preserves the previous mechanism? Although perhaps also more difficult w.r.t to lock inversion of `cs_main` and `m_tx_download_mutex`.\r\n\r\nAnother alternative could be to directly pass the current block hash as a param into the relevant `TxDownloadManager` methods.",
      "created_at": "2024-05-20T12:29:29Z",
      "updated_at": "2024-05-20T12:32:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1606717505",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1606717505"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1608263692",
      "pull_request_review_id": 2068531687,
      "id": 1608263692,
      "node_id": "PRRC_kwDOABII585f3CgM",
      "diff_hunk": "@@ -0,0 +1,455 @@\n+// Copyright (c) 2023\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownload_impl.h>\n+\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <logging.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace node {\n+void TxDownloadImpl::UpdatedBlockTipSync()\n+{\n+    // If the chain tip has changed, previously rejected transactions might now be invalid, e.g. due\n+    // to a timelock. Reset the rejection filters to give those transactions another chance if we\n+    // see them again.\n+    m_recent_rejects.reset();\n+    m_recent_rejects_reconsiderable.reset();\n+}\n+\n+void TxDownloadImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock)\n+{\n+    m_orphanage.EraseForBlock(*pblock);\n+\n+    for (const auto& ptx : pblock->vtx) {\n+        m_recent_confirmed_transactions.insert(ptx->GetHash().ToUint256());\n+        if (ptx->HasWitness()) {\n+            m_recent_confirmed_transactions.insert(ptx->GetWitnessHash().ToUint256());\n+        }\n+    }\n+    for (const auto& ptx : pblock->vtx) {\n+        m_txrequest.ForgetTxHash(ptx->GetHash());\n+        m_txrequest.ForgetTxHash(ptx->GetWitnessHash());\n+    }\n+}\n+\n+void TxDownloadImpl::BlockDisconnected()\n+{\n+    // To avoid relay problems with transactions that were previously\n+    // confirmed, clear our filter of recently confirmed transactions whenever\n+    // there's a reorg.\n+    // This means that in a 1-block reorg (where 1 block is disconnected and\n+    // then another block reconnected), our filter will drop to having only one\n+    // block's worth of transactions in it, but that should be fine, since\n+    // presumably the most common case of relaying a confirmed transaction\n+    // should be just after a new block containing it is found.\n+    m_recent_confirmed_transactions.reset();\n+}\n+\n+bool TxDownloadImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)\n+{\n+    const uint256& hash = gtxid.GetHash();",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 55,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "b1cc0c3006ca608f9ac3af2c50c4728cbbc07714",
      "in_reply_to_id": 1606717505,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think we'd ever need to make `TxDownloadManager` depend on `ChainstateManager` as we could just pass in the block hash, i.e.\r\n\r\n> Another alternative could be to directly pass the current block hash as a param into the relevant TxDownloadManager methods.\r\n\r\nThis would avoid the addition of `UpdateBlockTipSync` etc, as it's basically what we do now. I find this way of keeping synchronized with the chain tip pretty ugly - we'd need to hold `cs_main` and pass the blockhash to the `TxDownloadManager` all the time, bloating the interface. Subscribing to the validation interface and updating on every chain tip update seems much more sensible.",
      "created_at": "2024-05-21T12:43:55Z",
      "updated_at": "2024-05-21T12:43:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1608263692",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1608263692"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1608272072",
      "pull_request_review_id": 2068544653,
      "id": 1608272072,
      "node_id": "PRRC_kwDOABII585f3EjI",
      "diff_hunk": "@@ -0,0 +1,234 @@\n+// Copyright (c) 2022\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_NODE_TXDOWNLOAD_IMPL_H\n+#define BITCOIN_NODE_TXDOWNLOAD_IMPL_H\n+\n+#include <consensus/validation.h>\n+#include <kernel/chain.h>\n+#include <net.h>\n+#include <policy/packages.h>\n+#include <txorphanage.h>\n+#include <txrequest.h>\n+\n+class CTxMemPool;\n+namespace node {\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {",
      "path": "src/node/txdownload_impl.h",
      "position": null,
      "original_position": 32,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "b1cc0c3006ca608f9ac3af2c50c4728cbbc07714",
      "in_reply_to_id": 1606683947,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hm, in the previous setup, we can change any of txdownload_impl.cpp without net_processing.cpp noticing, but yeah maybe less clean to depend on txdownload_impl.h.\r\n\r\nI've updated with a new setup where I've added a txdownloadman.cpp depending on txdownload_impl.h, and txdownloadman.h is included by txdownload_impl.h instead of the other way around. And so net_processing.cpp no longer depends on txdownload_impl.h, which makes sense to me. Had to update `lint-circular-dependencies.py` but I do like that we can change txdownload_impl.h without recompiling everything. lmk if this seems better?",
      "created_at": "2024-05-21T12:49:45Z",
      "updated_at": "2024-05-21T12:49:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1608272072",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1608272072"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715592140",
      "pull_request_review_id": 2236038602,
      "id": 1715592140,
      "node_id": "PRRC_kwDOABII585mQdvM",
      "diff_hunk": "@@ -5,5 +5,45 @@\n #include <node/txdownload_impl.h>\n #include <node/txdownloadman.h>\n \n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n namespace node {\n+void TxDownloadImpl::ActiveTipChange()\n+{\n+    // If the chain tip has changed, previously rejected transactions might now be invalid, e.g. due",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 12,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "41080ff0e92120023d25ba08612b5181f353d1d4",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    // If the chain tip has changed, previously rejected transactions might now be valid, e.g. due\r\n```\r\nalso, this comment now exists both in `PeerManagerImpl::ActiveTipChange` and `TxDownloadImpl::ActiveTipChange`, probably one can be removed",
      "created_at": "2024-08-13T16:28:42Z",
      "updated_at": "2024-08-13T17:43:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1715592140",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715592140"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715600184",
      "pull_request_review_id": 2236038602,
      "id": 1715600184,
      "node_id": "PRRC_kwDOABII585mQfs4",
      "diff_hunk": "@@ -75,4 +76,23 @@ bool TxDownloadImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsider\n \n     return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n }\n+\n+void TxDownloadImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.count(nodeid) > 0) return;",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 16,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "6c70bc621ba14a1ddf3214f89c6367372924a01a",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "slightly-more-modern-nit (here and in `TxDownloadImpl::DisconnectedPeer` below):\r\n```suggestion\r\n    if (m_peer_info.contains(nodeid)) return;\r\n```",
      "created_at": "2024-08-13T16:33:18Z",
      "updated_at": "2024-08-13T17:43:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1715600184",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715600184"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 83,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715622227",
      "pull_request_review_id": 2236038602,
      "id": 1715622227,
      "node_id": "PRRC_kwDOABII585mQlFT",
      "diff_hunk": "@@ -4117,12 +4065,11 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     return;\n                 }\n                 const GenTxid gtxid = ToGenTxid(inv);\n-                const bool fAlreadyHave = m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true);\n-                LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n \n                 AddKnownTx(*peer, inv.hash);\n-                if (!fAlreadyHave && !m_chainman.IsInitialBlockDownload()) {\n-                    AddTxAnnouncement(pfrom, gtxid, current_time);\n+                if (!m_chainman.IsInitialBlockDownload()) {\n+                    const bool fAlreadyHave{m_txdownloadman.AddTxAnnouncement(pfrom.GetId(), gtxid, current_time, /*p2p_inv=*/true)};\n+                    LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n                 }",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 95,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "3f5dbd56da1e2434984c554ba3e24452d873bd07",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: strictly speaking this is not a pure refactor, as there is a change in logging behaviour (INV messages received during IBD now don't trigger the \"got inv\" log message any more). seems to make more sense though anyway, so feel free to ignore",
      "created_at": "2024-08-13T16:48:49Z",
      "updated_at": "2024-08-13T17:43:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1715622227",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715622227"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 4120,
      "start_side": "LEFT",
      "line": null,
      "original_line": 3942,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715630850",
      "pull_request_review_id": 2236038602,
      "id": 1715630850,
      "node_id": "PRRC_kwDOABII585mQnMC",
      "diff_hunk": "@@ -4531,7 +4478,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     AddKnownTx(*peer, parent_txid);\n                     // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n                     // previously rejected for being too low feerate. This orphan might CPFP it.\n-                    if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) AddTxAnnouncement(pfrom, gtxid, current_time);\n+                    if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+                        m_txdownloadman.AddTxAnnouncement(pfrom.GetId(), gtxid, current_time, /*p2p_inv=*/false);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 104,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "3f5dbd56da1e2434984c554ba3e24452d873bd07",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "small note: with this approach, `AlreadyHaveTx` is now called twice: once in the if condition, and the second time in the `AddTxAnnouncement` method (not sure if that's really a problem though)",
      "created_at": "2024-08-13T16:55:44Z",
      "updated_at": "2024-08-13T17:43:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1715630850",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1715630850"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 4481,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 4482,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716582838",
      "pull_request_review_id": 2237602476,
      "id": 1716582838,
      "node_id": "PRRC_kwDOABII585mUPm2",
      "diff_hunk": "@@ -5,5 +5,45 @@\n #include <node/txdownload_impl.h>\n #include <node/txdownloadman.h>\n \n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n namespace node {\n+void TxDownloadImpl::ActiveTipChange()\n+{\n+    // If the chain tip has changed, previously rejected transactions might now be invalid, e.g. due",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 12,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "41080ff0e92120023d25ba08612b5181f353d1d4",
      "in_reply_to_id": 1715592140,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah, that looks like a bad rebase - deleted the comment now, thanks",
      "created_at": "2024-08-14T09:13:54Z",
      "updated_at": "2024-08-14T09:55:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1716582838",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716582838"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716591125",
      "pull_request_review_id": 2237602476,
      "id": 1716591125,
      "node_id": "PRRC_kwDOABII585mURoV",
      "diff_hunk": "@@ -75,4 +76,23 @@ bool TxDownloadImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsider\n \n     return RecentRejectsFilter().contains(hash) || m_opts.m_mempool.exists(gtxid);\n }\n+\n+void TxDownloadImpl::ConnectedPeer(NodeId nodeid, const TxDownloadConnectionInfo& info)\n+{\n+    // If already connected (shouldn't happen in practice), exit early.\n+    if (m_peer_info.count(nodeid) > 0) return;",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 16,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "6c70bc621ba14a1ddf3214f89c6367372924a01a",
      "in_reply_to_id": 1715600184,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done :+1: ",
      "created_at": "2024-08-14T09:18:42Z",
      "updated_at": "2024-08-14T09:55:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1716591125",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716591125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 83,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716644034",
      "pull_request_review_id": 2237602476,
      "id": 1716644034,
      "node_id": "PRRC_kwDOABII585mUejC",
      "diff_hunk": "@@ -4117,12 +4065,11 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     return;\n                 }\n                 const GenTxid gtxid = ToGenTxid(inv);\n-                const bool fAlreadyHave = m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true);\n-                LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n \n                 AddKnownTx(*peer, inv.hash);\n-                if (!fAlreadyHave && !m_chainman.IsInitialBlockDownload()) {\n-                    AddTxAnnouncement(pfrom, gtxid, current_time);\n+                if (!m_chainman.IsInitialBlockDownload()) {\n+                    const bool fAlreadyHave{m_txdownloadman.AddTxAnnouncement(pfrom.GetId(), gtxid, current_time, /*p2p_inv=*/true)};\n+                    LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n                 }",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 95,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "3f5dbd56da1e2434984c554ba3e24452d873bd07",
      "in_reply_to_id": 1715622227,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right, I don't think it's problematic to not log tx invs during IBD since they are ignored anyway.\r\n\r\nI've moved the logging change to its own commit, to keep the pure refactoring-ness of this commit :+1: ",
      "created_at": "2024-08-14T09:55:25Z",
      "updated_at": "2024-08-14T09:55:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1716644034",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716644034"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 4120,
      "start_side": "LEFT",
      "line": null,
      "original_line": 3942,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716644076",
      "pull_request_review_id": 2237602476,
      "id": 1716644076,
      "node_id": "PRRC_kwDOABII585mUejs",
      "diff_hunk": "@@ -4531,7 +4478,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     AddKnownTx(*peer, parent_txid);\n                     // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n                     // previously rejected for being too low feerate. This orphan might CPFP it.\n-                    if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) AddTxAnnouncement(pfrom, gtxid, current_time);\n+                    if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+                        m_txdownloadman.AddTxAnnouncement(pfrom.GetId(), gtxid, current_time, /*p2p_inv=*/false);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 104,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "3f5dbd56da1e2434984c554ba3e24452d873bd07",
      "in_reply_to_id": 1715630850,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah, good observation. I've now gated the `AlreadyHaveTx` check inside of `AddTxAnnouncement` on `p2p_inv` so this is no longer happening.",
      "created_at": "2024-08-14T09:55:27Z",
      "updated_at": "2024-08-14T09:55:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1716644076",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1716644076"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 4481,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 4482,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722086417",
      "pull_request_review_id": 2245996944,
      "id": 1722086417,
      "node_id": "PRRC_kwDOABII585mpPQR",
      "diff_hunk": "@@ -44,4 +44,33 @@ void TxDownloadImpl::BlockDisconnected()\n     // should be just after a new block containing it is found.\n     RecentConfirmedTransactionsFilter().reset();\n }\n+\n+bool TxDownloadImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "3824d1f81ad9e4ff44ec46d07f4e8f86f27ce643",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "3824d1f81ad9e4ff44ec46d07f4e8f86f27ce643 decent time to rename the function since that's been a previous discussion point?",
      "created_at": "2024-08-19T16:53:28Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1722086417",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722086417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722183824",
      "pull_request_review_id": 2245996944,
      "id": 1722183824,
      "node_id": "PRRC_kwDOABII585mpnCQ",
      "diff_hunk": "@@ -3841,6 +3840,14 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                        tx_relay->m_next_inv_send_time == 0s));\n         }\n \n+        LOCK2(::cs_main, m_tx_download_mutex);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 14,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "af3647050a85e6f33f902b903207043f6f0c023c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "af3647050a85e6f33f902b903207043f6f0c023c preference for this to be inside own scope",
      "created_at": "2024-08-19T18:21:53Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1722183824",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722183824"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3843,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722205151",
      "pull_request_review_id": 2245996944,
      "id": 1722205151,
      "node_id": "PRRC_kwDOABII585mpsPf",
      "diff_hunk": "@@ -4531,7 +4478,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     AddKnownTx(*peer, parent_txid);\n                     // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n                     // previously rejected for being too low feerate. This orphan might CPFP it.\n-                    if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) AddTxAnnouncement(pfrom, gtxid, current_time);\n+                    if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+                        m_txdownloadman.AddTxAnnouncement(pfrom.GetId(), gtxid, current_time, /*p2p_inv=*/false);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 104,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "3f5dbd56da1e2434984c554ba3e24452d873bd07",
      "in_reply_to_id": 1715630850,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It may have been an issue since the `AddTxAnnouncement` invocation of AlreadyHaveTx included reconsiderable filter.\r\n\r\nSince there are only two call sites of `AddTxAnnouncement`, and each had a filtering `AlreadyHasTx` call, would it make sense to just do something like this instead?\r\n\r\n```\r\nif (AlreadyHaveTx(gtxid, /*include_reconsiderable=*/p2p_inv)) return true;\r\n```\r\n",
      "created_at": "2024-08-19T18:41:20Z",
      "updated_at": "2024-08-20T13:56:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1722205151",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722205151"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": 4481,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 4482,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722268907",
      "pull_request_review_id": 2245996944,
      "id": 1722268907,
      "node_id": "PRRC_kwDOABII585mp7zr",
      "diff_hunk": "@@ -2995,16 +2995,95 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n     AssertLockHeld(g_msgproc_mutex);\n     AssertLockHeld(m_tx_download_mutex);\n \n+    PeerRef peer{GetPeerRef(nodeid)};\n+\n     auto& m_orphanage = m_txdownloadman.GetOrphanageRef();\n     auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n+    const CTransaction& tx{*ptx};\n \n     LogDebug(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n         ptx->GetHash().ToString(),\n         ptx->GetWitnessHash().ToString(),\n         nodeid,\n         state.ToString());\n \n-    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+    // Only process a new orphan if maybe_add_extra_compact_tx, as otherwise it must be either",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 17,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "77560a690ce05697400dcbb73bcb4d89724a9e4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`maybe_add_extra_compact_tx` is starting to creep in usage vs its ostensible usage\r\n\r\nI'm also not quire sure I parse this sentence. I presume it's trying to say this is only used in regular situations when freshly received over p2p.",
      "created_at": "2024-08-19T19:44:39Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1722268907",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722268907"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3010,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722273831",
      "pull_request_review_id": 2245996944,
      "id": 1722273831,
      "node_id": "PRRC_kwDOABII585mp9An",
      "diff_hunk": "@@ -2995,16 +2995,95 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n     AssertLockHeld(g_msgproc_mutex);\n     AssertLockHeld(m_tx_download_mutex);\n \n+    PeerRef peer{GetPeerRef(nodeid)};\n+\n     auto& m_orphanage = m_txdownloadman.GetOrphanageRef();\n     auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n+    const CTransaction& tx{*ptx};\n \n     LogDebug(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n         ptx->GetHash().ToString(),\n         ptx->GetWitnessHash().ToString(),\n         nodeid,\n         state.ToString());\n \n-    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+    // Only process a new orphan if maybe_add_extra_compact_tx, as otherwise it must be either\n+    // already in orphanage or from 1p1c processing.\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS && maybe_add_extra_compact_tx) {\n+        bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+        // Deduplicate parent txids, so that we don't have to loop over\n+        // the same parent txid more than once down below.\n+        std::vector<uint256> unique_parents;\n+        unique_parents.reserve(tx.vin.size());\n+        for (const CTxIn& txin : tx.vin) {\n+            // We start with all parents, and then remove duplicates below.\n+            unique_parents.push_back(txin.prevout.hash);\n+        }\n+        std::sort(unique_parents.begin(), unique_parents.end());\n+        unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+        // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.\n+        // We can tolerate having up to 1 parent in m_lazy_recent_rejects_reconsiderable since we\n+        // submit 1p1c packages. However, fail immediately if any are in m_lazy_recent_rejects.\n+        std::optional<uint256> rejected_parent_reconsiderable;\n+        for (const uint256& parent_txid : unique_parents) {\n+            if (RecentRejectsFilter().contains(parent_txid)) {\n+                fRejectedParents = true;\n+                break;\n+            } else if (RecentRejectsReconsiderableFilter().contains(parent_txid) && !m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                // More than 1 parent in m_lazy_recent_rejects_reconsiderable: 1p1c will not be\n+                // sufficient to accept this package, so just give up here.\n+                if (rejected_parent_reconsiderable.has_value()) {\n+                    fRejectedParents = true;\n+                    break;\n+                }\n+                rejected_parent_reconsiderable = parent_txid;\n+            }\n+        }\n+        if (!fRejectedParents) {\n+            const auto current_time{GetTime<std::chrono::microseconds>()};\n+\n+            for (const uint256& parent_txid : unique_parents) {\n+                // Here, we only have the txid (and not wtxid) of the\n+                // inputs, so we only request in txid mode, even for\n+                // wtxidrelay peers.\n+                // Eventually we should replace this with an improved\n+                // protocol for getting all unconfirmed parents.\n+                const auto gtxid{GenTxid::Txid(parent_txid)};\n+                if (peer) AddKnownTx(*peer, parent_txid);\n+                // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n+                // previously rejected for being too low feerate. This orphan might CPFP it.\n+                if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+                    m_txdownloadman.AddTxAnnouncement(nodeid, gtxid, current_time, /*p2p_inv=*/false);\n+                }\n+            }\n+\n+            if (m_orphanage.AddTx(ptx, nodeid)) {\n+                AddToCompactExtraTransactions(ptx);\n+            }\n+\n+            // Once added to the orphan pool, a tx is considered AlreadyHave, and we shouldn't request it anymore.\n+            m_txrequest.ForgetTxHash(tx.GetHash());\n+            m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+\n+            // DoS prevention: do not allow m_orphanage to grow unbounded (see CVE-2012-3789)\n+            m_orphanage.LimitOrphans(m_opts.max_orphan_txs, m_rng);\n+        } else {\n+            LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s (wtxid=%s)\\n\",\n+                     tx.GetHash().ToString(),\n+                     tx.GetWitnessHash().ToString());\n+            // We will continue to reject this tx since it has rejected\n+            // parents so avoid re-requesting it from other peers.\n+            // Here we add both the txid and the wtxid, as we know that\n+            // regardless of what witness is provided, we will not accept\n+            // this, so we don't need to allow for redownload of this txid\n+            // from any of our non-wtxidrelay peers.\n+            RecentRejectsFilter().insert(tx.GetHash().ToUint256());",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "77560a690ce05697400dcbb73bcb4d89724a9e4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "unrelated to your move-only change, but if txid==wtxid, looks like we're doing two insertions anyways here",
      "created_at": "2024-08-19T19:49:13Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1722273831",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722273831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3082,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722276530",
      "pull_request_review_id": 2245996944,
      "id": 1722276530,
      "node_id": "PRRC_kwDOABII585mp9qy",
      "diff_hunk": "@@ -594,8 +604,8 @@ class PeerManagerImpl final : public PeerManager\n      *                                            Set to false if the tx has already been rejected before,\n      *                                            e.g. is an orphan, to avoid adding duplicate entries.\n      * Updates m_txrequest, m_lazy_recent_rejects, m_lazy_recent_rejects_reconsiderable, m_orphanage, and vExtraTxnForCompact. */\n-    void ProcessInvalidTx(NodeId nodeid, const CTransactionRef& tx, const TxValidationState& result,\n-                          bool maybe_add_extra_compact_tx)\n+    std::optional<PackageToValidate> ProcessInvalidTx(NodeId nodeid, const CTransactionRef& tx, const TxValidationState& result,",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 34,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "d3fb8ca103b32f6071790bf7a9471fe4f80f5479",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "d3fb8ca103b32f6071790bf7a9471fe4f80f5479\r\n\r\nnew ProcessInvalidTx return value needs to be documented",
      "created_at": "2024-08-19T19:51:09Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1722276530",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722276530"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 607,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722277826",
      "pull_request_review_id": 2245996944,
      "id": 1722277826,
      "node_id": "PRRC_kwDOABII585mp9_C",
      "diff_hunk": "@@ -3104,6 +3117,14 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n             // because we should not download or submit this transaction by itself again, but may\n             // submit it as part of a package later.\n             RecentRejectsReconsiderableFilter().insert(ptx->GetWitnessHash().ToUint256());\n+\n+            if (maybe_add_extra_compact_tx) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 72,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "d3fb8ca103b32f6071790bf7a9471fe4f80f5479",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "further definitional drift of `maybe_add_extra_compact_tx`, let's try to find something else to call this?",
      "created_at": "2024-08-19T19:52:39Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1722277826",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1722277826"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3121,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723275394",
      "pull_request_review_id": 2245996944,
      "id": 1723275394,
      "node_id": "PRRC_kwDOABII585mtxiC",
      "diff_hunk": "@@ -3129,17 +3129,7 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     AssertLockHeld(g_msgproc_mutex);\n     AssertLockHeld(m_tx_download_mutex);\n \n-    auto& m_orphanage = m_txdownloadman.GetOrphanageRef();\n-    auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n-\n-    // As this version of the transaction was acceptable, we can forget about any requests for it.\n-    // No-op if the tx is not in txrequest.\n-    m_txrequest.ForgetTxHash(tx->GetHash());\n-    m_txrequest.ForgetTxHash(tx->GetWitnessHash());\n-\n-    m_orphanage.AddChildrenToWorkSet(*tx);\n-    // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n-    m_orphanage.EraseTx(tx->GetWitnessHash());\n+    m_txdownloadman.MempoolAcceptedTx(tx);",
      "path": "src/net_processing.cpp",
      "position": 517,
      "original_position": 15,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "65d773feb7384a6893ee7e6a7b24dfa60f2d8d39",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "65d773feb7384a6893ee7e6a7b24dfa60f2d8d39\r\n\r\ncommit message seems grammatically incorrect:\r\n\r\n\"[refactor] move valid and tx processing to TxDownload\"",
      "created_at": "2024-08-20T13:01:52Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723275394",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723275394"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2998,
      "original_line": 2998,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723307535",
      "pull_request_review_id": 2245996944,
      "id": 1723307535,
      "node_id": "PRRC_kwDOABII585mt5YP",
      "diff_hunk": "@@ -4220,24 +4214,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         LOCK2(cs_main, m_tx_download_mutex);\n \n-        auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n-\n-        m_txrequest.ReceivedResponse(pfrom.GetId(), txid);\n-        if (tx.HasWitness()) m_txrequest.ReceivedResponse(pfrom.GetId(), wtxid);\n-\n-        // We do the AlreadyHaveTx() check using wtxid, rather than txid - in the\n-        // absence of witness malleation, this is strictly better, because the\n-        // recent rejects filter may contain the wtxid but rarely contains\n-        // the txid of a segwit transaction that has been rejected.\n-        // In the presence of witness malleation, it's possible that by only\n-        // doing the check with wtxid, we could overlook a transaction which\n-        // was confirmed with a different witness, or exists in our mempool\n-        // with a different witness, but this has limited downside:\n-        // mempool validation does its own lookup of whether we have the txid\n-        // already; and an adversary can already relay us old transactions\n-        // (older than our recency filter) if trying to DoS us, without any need\n-        // for witness malleation.\n-        if (m_txdownloadman.AlreadyHaveTx(GenTxid::Wtxid(wtxid), /*include_reconsiderable=*/true)) {\n+        const auto& [should_validate, package_to_validate] = m_txdownloadman.ReceivedTx(pfrom.GetId(), ptx);\n+        if (!should_validate) {",
      "path": "src/net_processing.cpp",
      "position": 682,
      "original_position": 36,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "ed96f3ef3dfb42fef4564aa5eedc636c2d6d8845",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "should `Assume` that package_to_validate is std::nullopt if `should_validate` is true",
      "created_at": "2024-08-20T13:22:39Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723307535",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723307535"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4234,
      "original_line": 4234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723318351",
      "pull_request_review_id": 2245996944,
      "id": 1723318351,
      "node_id": "PRRC_kwDOABII585mt8BP",
      "diff_hunk": "@@ -371,4 +371,58 @@ void TxDownloadImpl::MempoolRejectedPackage(const Package& package)\n {\n     RecentRejectsReconsiderableFilter().insert(GetPackageHash(package));\n }\n+\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadImpl::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    const uint256& txid = ptx->GetHash();\n+    const uint256& wtxid = ptx->GetWitnessHash();\n+\n+    // Mark that we have received a response\n+    m_txrequest.ReceivedResponse(nodeid, ptx->GetHash());\n+    if (ptx->HasWitness()) m_txrequest.ReceivedResponse(nodeid, ptx->GetWitnessHash());\n+\n+    // First check if we should drop this tx.\n+    // We do the AlreadyHaveTx() check using wtxid, rather than txid - in the\n+    // absence of witness malleation, this is strictly better, because the\n+    // recent rejects filter may contain the wtxid but rarely contains\n+    // the txid of a segwit transaction that has been rejected.\n+    // In the presence of witness malleation, it's possible that by only\n+    // doing the check with wtxid, we could overlook a transaction which\n+    // was confirmed with a different witness, or exists in our mempool\n+    // with a different witness, but this has limited downside:\n+    // mempool validation does its own lookup of whether we have the txid\n+    // already; and an adversary can already relay us old transactions\n+    // (older than our recency filter) if trying to DoS us, without any need\n+    // for witness malleation.\n+    if (AlreadyHaveTx(GenTxid::Wtxid(wtxid), /*include_reconsiderable=*/true)) {\n+\n+        if (RecentRejectsReconsiderableFilter().contains(wtxid)) {\n+            // When a transaction is already in m_lazy_recent_rejects_reconsiderable, we shouldn't submit\n+            // it by itself again. However, look for a matching child in the orphanage, as it is\n+            // possible that they succeed as a package.\n+            LogPrint(BCLog::TXPACKAGES, \"found tx %s (wtxid=%s) in reconsiderable rejects, looking for child in orphanage\\n\",\n+                     txid.ToString(), wtxid.ToString());\n+            return std::make_pair(false, Find1P1CPackage(ptx, nodeid));\n+        }\n+\n+        // If a tx is detected by m_lazy_recent_rejects it is ignored. Because we haven't",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 38,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "ed96f3ef3dfb42fef4564aa5eedc636c2d6d8845",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "just noting this moved comment is extremely verbose/old comment and can probably just have the last paragraph kept?",
      "created_at": "2024-08-20T13:29:21Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723318351",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723318351"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 408,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723349184",
      "pull_request_review_id": 2245996944,
      "id": 1723349184,
      "node_id": "PRRC_kwDOABII585muDjA",
      "diff_hunk": "@@ -425,4 +425,15 @@ std::pair<bool, std::optional<PackageToValidate>> TxDownloadImpl::ReceivedTx(Nod\n \n     return std::make_pair(true, std::nullopt);\n }\n+\n+bool TxDownloadImpl::HaveMoreWork(NodeId nodeid)",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "81f67607e811bcb5040142c401a51634b17bc3a8",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If the wrapper is named `HaveMoreWork`, maybe have `GetTxToReconsider` be called `GetMoreWork`? Otherwise they seem incongruous. ",
      "created_at": "2024-08-20T13:47:31Z",
      "updated_at": "2024-08-20T13:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723349184",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723349184"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 429,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723352509",
      "pull_request_review_id": 2245996944,
      "id": 1723352509,
      "node_id": "PRRC_kwDOABII585muEW9",
      "diff_hunk": "@@ -436,4 +436,13 @@ CTransactionRef TxDownloadImpl::GetTxToReconsider(NodeId nodeid)\n     return m_orphanage.GetTxToReconsider(nodeid);\n }\n \n+void TxDownloadImpl::CheckIsEmpty(NodeId nodeid)",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 4,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "388c2f5d7ee5f38cbefaff0c85cf298083127299",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "CheckRequestsEmpty?",
      "created_at": "2024-08-20T13:49:29Z",
      "updated_at": "2024-08-20T13:56:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723352509",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723352509"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 439,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723401360",
      "pull_request_review_id": 2248150197,
      "id": 1723401360,
      "node_id": "PRRC_kwDOABII585muQSQ",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 70,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "simplest is a blank CScript",
      "created_at": "2024-08-20T14:17:00Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723401360",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723401360"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723403236",
      "pull_request_review_id": 2248150197,
      "id": 1723403236,
      "node_id": "PRRC_kwDOABII585muQvk",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to\n+    // ensure uniqueness. Here, we want to avoid direct parent/child relationships between transactions.",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 87,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Here, we want to avoid direct parent/child relationships between transacti\r\n\r\ndoesn't a chain mean direct parent/child?",
      "created_at": "2024-08-20T14:18:07Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723403236",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723403236"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723414301",
      "pull_request_review_id": 2248150197,
      "id": 1723414301,
      "node_id": "PRRC_kwDOABII585muTcd",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to\n+    // ensure uniqueness. Here, we want to avoid direct parent/child relationships between transactions.\n+    const auto two_transactions{CreateTransactions(/*num_txns=*/2)};\n+    return two_transactions.back();\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+\n+    TxValidationState state;\n+\n+    for (const auto& [result, expected_behavior] : expected_behaviors) {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+        const auto ptx = GetNewTransaction();",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 101,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ptx/txid/wtxid can just be made once outside the loop since it's the same each time\r\n\r\nas well as nodeid, now",
      "created_at": "2024-08-20T14:24:39Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723414301",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723414301"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723435539",
      "pull_request_review_id": 2248150197,
      "id": 1723435539,
      "node_id": "PRRC_kwDOABII585muYoT",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 86,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "what is this chaining doing? I only see the ultimate tx being used anyways.\r\n\r\nIt might be useful to have the parent tx rejected optionally, to check that `TX_MISSING_INPUTS,` fills out txid and wtxid reject filters properly. ",
      "created_at": "2024-08-20T14:36:49Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723435539",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723435539"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723456852",
      "pull_request_review_id": 2248150197,
      "id": 1723456852,
      "node_id": "PRRC_kwDOABII585mud1U",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 168,
      "original_position": 154,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1 2, 3 4s, 5 6s\r\nwomp womp",
      "created_at": "2024-08-20T14:49:17Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723456852",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723456852"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 168,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723465940",
      "pull_request_review_id": 2248150197,
      "id": 1723465940,
      "node_id": "PRRC_kwDOABII585mugDU",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 177,
      "original_position": 163,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "500 outputs is probably too much unless you think it's gaining some meaningful coverage?",
      "created_at": "2024-08-20T14:54:52Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723465940",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723465940"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 177,
      "original_line": 177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723471572",
      "pull_request_review_id": 2248150197,
      "id": 1723471572,
      "node_id": "PRRC_kwDOABII585muhbU",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 215,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "m_senders.back() should be <= NUM_PEERS",
      "created_at": "2024-08-20T14:58:12Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723471572",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723471572"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723473284",
      "pull_request_review_id": 2248150197,
      "id": 1723473284,
      "node_id": "PRRC_kwDOABII585muh2E",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // If PackageToValidate is returned then should_validate = false.\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(GetPackageHash(package)));\n+                    // Neither is in m_lazy_recent_rejects\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                txdownload_impl.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownload_impl.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownload_impl.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                    Assert(txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(ptx->GetWitnessHash()), /*include_reconsiderable=*/false));\n+                    // Presumably we have validated this tx. Use \"missing inputs\" to keep it in the\n+                    // orphanage longer. Later iterations might call MempoolAcceptedTx or\n+                    // MempoolRejectedTx with a different error.\n+                    TxValidationState state_missing_inputs;\n+                    state_missing_inputs.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                    txdownload_impl.MempoolRejectedTx(ptx, state_missing_inputs, rand_peer, fuzzed_data_provider.ConsumeBool());\n+                }\n+            }\n+        );\n+\n+        // Jump ahead in time",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 414,
      "original_position": 392,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "not just ahead due to negative skips",
      "created_at": "2024-08-20T14:59:13Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723473284",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723473284"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 414,
      "original_line": 414,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723482380",
      "pull_request_review_id": 2248150197,
      "id": 1723482380,
      "node_id": "PRRC_kwDOABII585mukEM",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 323,
      "original_position": 305,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "iterate over all `TRANSACTIONS` and assert this?",
      "created_at": "2024-08-20T15:04:54Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723482380",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723482380"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 323,
      "original_line": 323,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723492507",
      "pull_request_review_id": 2248150197,
      "id": 1723492507,
      "node_id": "PRRC_kwDOABII585mumib",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 279,
      "original_position": 262,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n    }\r\n    txdownload_impl.m_txrequest.SanityCheck();\r\n```",
      "created_at": "2024-08-20T15:11:21Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723492507",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723492507"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 279,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723496334",
      "pull_request_review_id": 2248150197,
      "id": 1723496334,
      "node_id": "PRRC_kwDOABII585muneO",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 348,
      "original_position": 328,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`MempoolRejectedTx` should probably `Assume` that state is invalid at the top of its definition",
      "created_at": "2024-08-20T15:13:47Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723496334",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723496334"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 348,
      "original_line": 348,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723512996",
      "pull_request_review_id": 2248150197,
      "id": 1723512996,
      "node_id": "PRRC_kwDOABII585murik",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // If PackageToValidate is returned then should_validate = false.\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 380,
      "original_position": 358,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(maybe_package->m_txns.back()->GetWitnessHash().ToUint256()));`\r\n\r\nI considered this assertion, is it valid? Can we have something in our orphanage and reconsiderable filter?",
      "created_at": "2024-08-20T15:23:47Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723512996",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723512996"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 380,
      "original_line": 380,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723520777",
      "pull_request_review_id": 2248150197,
      "id": 1723520777,
      "node_id": "PRRC_kwDOABII585mutcJ",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // If PackageToValidate is returned then should_validate = false.\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(GetPackageHash(package)));\n+                    // Neither is in m_lazy_recent_rejects\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                txdownload_impl.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownload_impl.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownload_impl.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 396,
      "original_position": 374,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can you remind me of a case where this happens? Running with an erroneous assertion added and it's not seeming to hit.",
      "created_at": "2024-08-20T15:28:28Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723520777",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723520777"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 396,
      "original_line": 396,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723534366",
      "pull_request_review_id": 2248150197,
      "id": 1723534366,
      "node_id": "PRRC_kwDOABII585muwwe",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        // \"Good\" peers send the inv at most once, and otherwise will not send an unsolicited message.\n+        if (m_good) {\n+            if (!m_sent_inv && (force_announce || fuzzed_data_provider.ConsumeBool())) {\n+                m_sent_inv = true;\n+                return PossibleMessage::INV_REAL;\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // Non-good peers might send anything!\n+        auto message = fuzzed_data_provider.PickValueInArray(ALL_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    PossibleResponse ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return PossibleResponse::NOTHING;\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(ALL_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return PossibleResponse::NOTHING;\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return response;\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = false;\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();",
      "path": "src/test/fuzz/tx_download.cpp",
      "position": null,
      "original_position": 170,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "04856ed32c17ce60e9c503d92b21092a0f9ac271",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "maybe leave a comment why good peers do wtxid relay",
      "created_at": "2024-08-20T15:37:54Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723534366",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723534366"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723610455",
      "pull_request_review_id": 2248150197,
      "id": 1723610455,
      "node_id": "PRRC_kwDOABII585mvDVX",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};",
      "path": "src/test/fuzz/tx_download.cpp",
      "position": null,
      "original_position": 114,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "04856ed32c17ce60e9c503d92b21092a0f9ac271",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "seems to always be false?",
      "created_at": "2024-08-20T16:23:32Z",
      "updated_at": "2024-08-20T20:48:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1723610455",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1723610455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724756834",
      "pull_request_review_id": 2250308845,
      "id": 1724756834,
      "node_id": "PRRC_kwDOABII585mzbNi",
      "diff_hunk": "@@ -436,4 +436,13 @@ CTransactionRef TxDownloadImpl::GetTxToReconsider(NodeId nodeid)\n     return m_orphanage.GetTxToReconsider(nodeid);\n }\n \n+void TxDownloadImpl::CheckIsEmpty(NodeId nodeid)",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 4,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "388c2f5d7ee5f38cbefaff0c85cf298083127299",
      "in_reply_to_id": 1723352509,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`CheckIsEmpty()` seems a bit more future-proof. We'll check\r\n- no requests for this peer\r\n- no pending orphan resolutions for this peer\r\n- no orphans for this peer\r\netc.",
      "created_at": "2024-08-21T09:39:33Z",
      "updated_at": "2024-08-21T09:39:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724756834",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724756834"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 439,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724766037",
      "pull_request_review_id": 2250323920,
      "id": 1724766037,
      "node_id": "PRRC_kwDOABII585mzddV",
      "diff_hunk": "@@ -425,4 +425,15 @@ std::pair<bool, std::optional<PackageToValidate>> TxDownloadImpl::ReceivedTx(Nod\n \n     return std::make_pair(true, std::nullopt);\n }\n+\n+bool TxDownloadImpl::HaveMoreWork(NodeId nodeid)",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "81f67607e811bcb5040142c401a51634b17bc3a8",
      "in_reply_to_id": 1723349184,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I called it `HaveMoreWork` since its purpose is to tell `ThreadMessageHandler()` if there is more work to do (doesn't matter what kind of work):\r\nhttps://github.com/bitcoin/bitcoin/blob/3c0b66c2ece7695ab59f466d7b4d81a4c18ffd76/src/net_processing.cpp#L5083 \r\nhttps://github.com/bitcoin/bitcoin/blob/3c0b66c2ece7695ab59f466d7b4d81a4c18ffd76/src/net.cpp#L2902-L2903\r\n\r\n`GetTxToReconsider`'s user is peerman, in `ProcessOrphanTx`.\r\n\r\nI think scheduled reconsideration work could become more generic in the future, i.e. include packages. But I think  `ProcessOrphanTx` is probably more readable if the function name specifies we're getting 1 transaction to reconsider.",
      "created_at": "2024-08-21T09:46:13Z",
      "updated_at": "2024-08-21T09:46:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724766037",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724766037"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 429,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724778335",
      "pull_request_review_id": 2250344089,
      "id": 1724778335,
      "node_id": "PRRC_kwDOABII585mzgdf",
      "diff_hunk": "@@ -371,4 +371,58 @@ void TxDownloadImpl::MempoolRejectedPackage(const Package& package)\n {\n     RecentRejectsReconsiderableFilter().insert(GetPackageHash(package));\n }\n+\n+std::pair<bool, std::optional<PackageToValidate>> TxDownloadImpl::ReceivedTx(NodeId nodeid, const CTransactionRef& ptx)\n+{\n+    const uint256& txid = ptx->GetHash();\n+    const uint256& wtxid = ptx->GetWitnessHash();\n+\n+    // Mark that we have received a response\n+    m_txrequest.ReceivedResponse(nodeid, ptx->GetHash());\n+    if (ptx->HasWitness()) m_txrequest.ReceivedResponse(nodeid, ptx->GetWitnessHash());\n+\n+    // First check if we should drop this tx.\n+    // We do the AlreadyHaveTx() check using wtxid, rather than txid - in the\n+    // absence of witness malleation, this is strictly better, because the\n+    // recent rejects filter may contain the wtxid but rarely contains\n+    // the txid of a segwit transaction that has been rejected.\n+    // In the presence of witness malleation, it's possible that by only\n+    // doing the check with wtxid, we could overlook a transaction which\n+    // was confirmed with a different witness, or exists in our mempool\n+    // with a different witness, but this has limited downside:\n+    // mempool validation does its own lookup of whether we have the txid\n+    // already; and an adversary can already relay us old transactions\n+    // (older than our recency filter) if trying to DoS us, without any need\n+    // for witness malleation.\n+    if (AlreadyHaveTx(GenTxid::Wtxid(wtxid), /*include_reconsiderable=*/true)) {\n+\n+        if (RecentRejectsReconsiderableFilter().contains(wtxid)) {\n+            // When a transaction is already in m_lazy_recent_rejects_reconsiderable, we shouldn't submit\n+            // it by itself again. However, look for a matching child in the orphanage, as it is\n+            // possible that they succeed as a package.\n+            LogPrint(BCLog::TXPACKAGES, \"found tx %s (wtxid=%s) in reconsiderable rejects, looking for child in orphanage\\n\",\n+                     txid.ToString(), wtxid.ToString());\n+            return std::make_pair(false, Find1P1CPackage(ptx, nodeid));\n+        }\n+\n+        // If a tx is detected by m_lazy_recent_rejects it is ignored. Because we haven't",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 38,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "ed96f3ef3dfb42fef4564aa5eedc636c2d6d8845",
      "in_reply_to_id": 1723318351,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Seems fine to do, but won't add it to this PR because I want to limit its scope. Agree just the last paragraph is sufficient.",
      "created_at": "2024-08-21T09:55:18Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724778335",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724778335"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 408,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724779439",
      "pull_request_review_id": 2250344089,
      "id": 1724779439,
      "node_id": "PRRC_kwDOABII585mzguv",
      "diff_hunk": "@@ -44,4 +44,33 @@ void TxDownloadImpl::BlockDisconnected()\n     // should be just after a new block containing it is found.\n     RecentConfirmedTransactionsFilter().reset();\n }\n+\n+bool TxDownloadImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)",
      "path": "src/node/txdownload_impl.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "3824d1f81ad9e4ff44ec46d07f4e8f86f27ce643",
      "in_reply_to_id": 1722086417,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What should the new name be?",
      "created_at": "2024-08-21T09:56:02Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724779439",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724779439"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724806868",
      "pull_request_review_id": 2250344089,
      "id": 1724806868,
      "node_id": "PRRC_kwDOABII585mznbU",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to\n+    // ensure uniqueness. Here, we want to avoid direct parent/child relationships between transactions.",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 87,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": 1723403236,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "So the requirements are:\r\n- transactions need to be unique\r\n- they need to appear to not be related (i.e. no direct relationships)\r\n\r\nOne way to do this is to make unique utxos for each tx. But we also know from experience debugging fuzzers that sometimes the random outpoint's txid matches the hash of one of the transactions, which is annoying because it creates \"direct relationships\".\r\n\r\nIronically, since prevouts reference hashes, the easiest way to ensure transactions aren't directly related is to have them all be indirectly related.\r\n\r\nSo my quick and dirty method for creating n transactions is to generate 1 utxo and make 2*n transactions chaining off of it, then use every other tx. I don't need to know n ahead of time - I just make 2 at the bottom whenever I need one. They're guaranteed to be unique (because sha256) and to not look like they're spending each other (because sha256).",
      "created_at": "2024-08-21T10:15:29Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724806868",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724806868"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724818171",
      "pull_request_review_id": 2250344089,
      "id": 1724818171,
      "node_id": "PRRC_kwDOABII585mzqL7",
      "diff_hunk": "@@ -3841,6 +3840,14 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                        tx_relay->m_next_inv_send_time == 0s));\n         }\n \n+        LOCK2(::cs_main, m_tx_download_mutex);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 14,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "af3647050a85e6f33f902b903207043f6f0c023c",
      "in_reply_to_id": 1722183824,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-21T10:24:44Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724818171",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724818171"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3843,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724832923",
      "pull_request_review_id": 2250344089,
      "id": 1724832923,
      "node_id": "PRRC_kwDOABII585mztyb",
      "diff_hunk": "@@ -2995,16 +2995,95 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n     AssertLockHeld(g_msgproc_mutex);\n     AssertLockHeld(m_tx_download_mutex);\n \n+    PeerRef peer{GetPeerRef(nodeid)};\n+\n     auto& m_orphanage = m_txdownloadman.GetOrphanageRef();\n     auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n+    const CTransaction& tx{*ptx};\n \n     LogDebug(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n         ptx->GetHash().ToString(),\n         ptx->GetWitnessHash().ToString(),\n         nodeid,\n         state.ToString());\n \n-    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+    // Only process a new orphan if maybe_add_extra_compact_tx, as otherwise it must be either",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 17,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "77560a690ce05697400dcbb73bcb4d89724a9e4f",
      "in_reply_to_id": 1722268907,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Renamed it to `first_time_failure` in a preceding commit.\r\n\r\nYeah that's correct. Basically, if this is the first time a tx is being rejected from mempool, we consider putting it in `vExtraTxnForCompact`. If it's not the first time, we don't need to do it again, presumably because we don't want duplicates (it's a ring buffer).\r\n\r\nSame thing for adding something as an orphan. If this bool is false, it means the tx is already an orphan or it's the low feerate parent in a package. Either way we don't need to bother with the `unique_parents` and filter checking stuff.",
      "created_at": "2024-08-21T10:37:24Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724832923",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724832923"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3010,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724840174",
      "pull_request_review_id": 2250344089,
      "id": 1724840174,
      "node_id": "PRRC_kwDOABII585mzvju",
      "diff_hunk": "@@ -2995,16 +2995,95 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n     AssertLockHeld(g_msgproc_mutex);\n     AssertLockHeld(m_tx_download_mutex);\n \n+    PeerRef peer{GetPeerRef(nodeid)};\n+\n     auto& m_orphanage = m_txdownloadman.GetOrphanageRef();\n     auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n+    const CTransaction& tx{*ptx};\n \n     LogDebug(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n         ptx->GetHash().ToString(),\n         ptx->GetWitnessHash().ToString(),\n         nodeid,\n         state.ToString());\n \n-    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+    // Only process a new orphan if maybe_add_extra_compact_tx, as otherwise it must be either\n+    // already in orphanage or from 1p1c processing.\n+    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS && maybe_add_extra_compact_tx) {\n+        bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+\n+        // Deduplicate parent txids, so that we don't have to loop over\n+        // the same parent txid more than once down below.\n+        std::vector<uint256> unique_parents;\n+        unique_parents.reserve(tx.vin.size());\n+        for (const CTxIn& txin : tx.vin) {\n+            // We start with all parents, and then remove duplicates below.\n+            unique_parents.push_back(txin.prevout.hash);\n+        }\n+        std::sort(unique_parents.begin(), unique_parents.end());\n+        unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+        // Distinguish between parents in m_lazy_recent_rejects and m_lazy_recent_rejects_reconsiderable.\n+        // We can tolerate having up to 1 parent in m_lazy_recent_rejects_reconsiderable since we\n+        // submit 1p1c packages. However, fail immediately if any are in m_lazy_recent_rejects.\n+        std::optional<uint256> rejected_parent_reconsiderable;\n+        for (const uint256& parent_txid : unique_parents) {\n+            if (RecentRejectsFilter().contains(parent_txid)) {\n+                fRejectedParents = true;\n+                break;\n+            } else if (RecentRejectsReconsiderableFilter().contains(parent_txid) && !m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                // More than 1 parent in m_lazy_recent_rejects_reconsiderable: 1p1c will not be\n+                // sufficient to accept this package, so just give up here.\n+                if (rejected_parent_reconsiderable.has_value()) {\n+                    fRejectedParents = true;\n+                    break;\n+                }\n+                rejected_parent_reconsiderable = parent_txid;\n+            }\n+        }\n+        if (!fRejectedParents) {\n+            const auto current_time{GetTime<std::chrono::microseconds>()};\n+\n+            for (const uint256& parent_txid : unique_parents) {\n+                // Here, we only have the txid (and not wtxid) of the\n+                // inputs, so we only request in txid mode, even for\n+                // wtxidrelay peers.\n+                // Eventually we should replace this with an improved\n+                // protocol for getting all unconfirmed parents.\n+                const auto gtxid{GenTxid::Txid(parent_txid)};\n+                if (peer) AddKnownTx(*peer, parent_txid);\n+                // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n+                // previously rejected for being too low feerate. This orphan might CPFP it.\n+                if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n+                    m_txdownloadman.AddTxAnnouncement(nodeid, gtxid, current_time, /*p2p_inv=*/false);\n+                }\n+            }\n+\n+            if (m_orphanage.AddTx(ptx, nodeid)) {\n+                AddToCompactExtraTransactions(ptx);\n+            }\n+\n+            // Once added to the orphan pool, a tx is considered AlreadyHave, and we shouldn't request it anymore.\n+            m_txrequest.ForgetTxHash(tx.GetHash());\n+            m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+\n+            // DoS prevention: do not allow m_orphanage to grow unbounded (see CVE-2012-3789)\n+            m_orphanage.LimitOrphans(m_opts.max_orphan_txs, m_rng);\n+        } else {\n+            LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s (wtxid=%s)\\n\",\n+                     tx.GetHash().ToString(),\n+                     tx.GetWitnessHash().ToString());\n+            // We will continue to reject this tx since it has rejected\n+            // parents so avoid re-requesting it from other peers.\n+            // Here we add both the txid and the wtxid, as we know that\n+            // regardless of what witness is provided, we will not accept\n+            // this, so we don't need to allow for redownload of this txid\n+            // from any of our non-wtxidrelay peers.\n+            RecentRejectsFilter().insert(tx.GetHash().ToUint256());",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "77560a690ce05697400dcbb73bcb4d89724a9e4f",
      "in_reply_to_id": 1722273831,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "agree, though leaving out of this PR to limit its scope. Could add a nonsegwit parent + segwit child test to be added to p2p_orphan_handling.py. Maybe a good first issue.",
      "created_at": "2024-08-21T10:43:35Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724840174",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724840174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3082,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724863898",
      "pull_request_review_id": 2250344089,
      "id": 1724863898,
      "node_id": "PRRC_kwDOABII585mz1Wa",
      "diff_hunk": "@@ -3104,6 +3117,14 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n             // because we should not download or submit this transaction by itself again, but may\n             // submit it as part of a package later.\n             RecentRejectsReconsiderableFilter().insert(ptx->GetWitnessHash().ToUint256());\n+\n+            if (maybe_add_extra_compact_tx) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 72,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "d3fb8ca103b32f6071790bf7a9471fe4f80f5479",
      "in_reply_to_id": 1722277826,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-21T11:04:10Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724863898",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724863898"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3121,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724864056",
      "pull_request_review_id": 2250344089,
      "id": 1724864056,
      "node_id": "PRRC_kwDOABII585mz1Y4",
      "diff_hunk": "@@ -594,8 +604,8 @@ class PeerManagerImpl final : public PeerManager\n      *                                            Set to false if the tx has already been rejected before,\n      *                                            e.g. is an orphan, to avoid adding duplicate entries.\n      * Updates m_txrequest, m_lazy_recent_rejects, m_lazy_recent_rejects_reconsiderable, m_orphanage, and vExtraTxnForCompact. */\n-    void ProcessInvalidTx(NodeId nodeid, const CTransactionRef& tx, const TxValidationState& result,\n-                          bool maybe_add_extra_compact_tx)\n+    std::optional<PackageToValidate> ProcessInvalidTx(NodeId nodeid, const CTransactionRef& tx, const TxValidationState& result,",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 34,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "d3fb8ca103b32f6071790bf7a9471fe4f80f5479",
      "in_reply_to_id": 1722276530,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added",
      "created_at": "2024-08-21T11:04:18Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724864056",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724864056"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 607,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724880934",
      "pull_request_review_id": 2250344089,
      "id": 1724880934,
      "node_id": "PRRC_kwDOABII585mz5gm",
      "diff_hunk": "@@ -3129,17 +3129,7 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     AssertLockHeld(g_msgproc_mutex);\n     AssertLockHeld(m_tx_download_mutex);\n \n-    auto& m_orphanage = m_txdownloadman.GetOrphanageRef();\n-    auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n-\n-    // As this version of the transaction was acceptable, we can forget about any requests for it.\n-    // No-op if the tx is not in txrequest.\n-    m_txrequest.ForgetTxHash(tx->GetHash());\n-    m_txrequest.ForgetTxHash(tx->GetWitnessHash());\n-\n-    m_orphanage.AddChildrenToWorkSet(*tx);\n-    // If it came from the orphanage, remove it. No-op if the tx is not in txorphanage.\n-    m_orphanage.EraseTx(tx->GetWitnessHash());\n+    m_txdownloadman.MempoolAcceptedTx(tx);",
      "path": "src/net_processing.cpp",
      "position": 517,
      "original_position": 15,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "65d773feb7384a6893ee7e6a7b24dfa60f2d8d39",
      "in_reply_to_id": 1723275394,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed",
      "created_at": "2024-08-21T11:19:19Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724880934",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724880934"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2998,
      "original_line": 2998,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724882313",
      "pull_request_review_id": 2250344089,
      "id": 1724882313,
      "node_id": "PRRC_kwDOABII585mz52J",
      "diff_hunk": "@@ -4220,24 +4214,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         LOCK2(cs_main, m_tx_download_mutex);\n \n-        auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n-\n-        m_txrequest.ReceivedResponse(pfrom.GetId(), txid);\n-        if (tx.HasWitness()) m_txrequest.ReceivedResponse(pfrom.GetId(), wtxid);\n-\n-        // We do the AlreadyHaveTx() check using wtxid, rather than txid - in the\n-        // absence of witness malleation, this is strictly better, because the\n-        // recent rejects filter may contain the wtxid but rarely contains\n-        // the txid of a segwit transaction that has been rejected.\n-        // In the presence of witness malleation, it's possible that by only\n-        // doing the check with wtxid, we could overlook a transaction which\n-        // was confirmed with a different witness, or exists in our mempool\n-        // with a different witness, but this has limited downside:\n-        // mempool validation does its own lookup of whether we have the txid\n-        // already; and an adversary can already relay us old transactions\n-        // (older than our recency filter) if trying to DoS us, without any need\n-        // for witness malleation.\n-        if (m_txdownloadman.AlreadyHaveTx(GenTxid::Wtxid(wtxid), /*include_reconsiderable=*/true)) {\n+        const auto& [should_validate, package_to_validate] = m_txdownloadman.ReceivedTx(pfrom.GetId(), ptx);\n+        if (!should_validate) {",
      "path": "src/net_processing.cpp",
      "position": 682,
      "original_position": 36,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "ed96f3ef3dfb42fef4564aa5eedc636c2d6d8845",
      "in_reply_to_id": 1723307535,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added",
      "created_at": "2024-08-21T11:20:34Z",
      "updated_at": "2024-08-21T11:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724882313",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724882313"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4234,
      "original_line": 4234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724970034",
      "pull_request_review_id": 2250669642,
      "id": 1724970034,
      "node_id": "PRRC_kwDOABII585m0PQy",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 70,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": 1723401360,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-21T12:30:55Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724970034",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724970034"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724970656",
      "pull_request_review_id": 2250669642,
      "id": 1724970656,
      "node_id": "PRRC_kwDOABII585m0Pag",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to\n+    // ensure uniqueness. Here, we want to avoid direct parent/child relationships between transactions.\n+    const auto two_transactions{CreateTransactions(/*num_txns=*/2)};\n+    return two_transactions.back();\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+\n+    TxValidationState state;\n+\n+    for (const auto& [result, expected_behavior] : expected_behaviors) {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+        const auto ptx = GetNewTransaction();",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 101,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": 1723414301,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-21T12:31:22Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1724970656",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1724970656"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725039042",
      "pull_request_review_id": 2250782824,
      "id": 1725039042,
      "node_id": "PRRC_kwDOABII585m0gHC",
      "diff_hunk": "@@ -4220,24 +4214,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         LOCK2(cs_main, m_tx_download_mutex);\n \n-        auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n-\n-        m_txrequest.ReceivedResponse(pfrom.GetId(), txid);\n-        if (tx.HasWitness()) m_txrequest.ReceivedResponse(pfrom.GetId(), wtxid);\n-\n-        // We do the AlreadyHaveTx() check using wtxid, rather than txid - in the\n-        // absence of witness malleation, this is strictly better, because the\n-        // recent rejects filter may contain the wtxid but rarely contains\n-        // the txid of a segwit transaction that has been rejected.\n-        // In the presence of witness malleation, it's possible that by only\n-        // doing the check with wtxid, we could overlook a transaction which\n-        // was confirmed with a different witness, or exists in our mempool\n-        // with a different witness, but this has limited downside:\n-        // mempool validation does its own lookup of whether we have the txid\n-        // already; and an adversary can already relay us old transactions\n-        // (older than our recency filter) if trying to DoS us, without any need\n-        // for witness malleation.\n-        if (m_txdownloadman.AlreadyHaveTx(GenTxid::Wtxid(wtxid), /*include_reconsiderable=*/true)) {\n+        const auto& [should_validate, package_to_validate] = m_txdownloadman.ReceivedTx(pfrom.GetId(), ptx);\n+        if (!should_validate) {",
      "path": "src/net_processing.cpp",
      "position": 682,
      "original_position": 36,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "ed96f3ef3dfb42fef4564aa5eedc636c2d6d8845",
      "in_reply_to_id": 1723307535,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "think you added the other way, that if `should_validate` is false, it must have a package to validate, which is incorrect(and caught by our 1p1c tests)",
      "created_at": "2024-08-21T13:17:15Z",
      "updated_at": "2024-08-21T13:17:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725039042",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725039042"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4234,
      "original_line": 4234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725185420",
      "pull_request_review_id": 2250669642,
      "id": 1725185420,
      "node_id": "PRRC_kwDOABII585m1D2M",
      "diff_hunk": "@@ -4220,24 +4214,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         LOCK2(cs_main, m_tx_download_mutex);\n \n-        auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n-\n-        m_txrequest.ReceivedResponse(pfrom.GetId(), txid);\n-        if (tx.HasWitness()) m_txrequest.ReceivedResponse(pfrom.GetId(), wtxid);\n-\n-        // We do the AlreadyHaveTx() check using wtxid, rather than txid - in the\n-        // absence of witness malleation, this is strictly better, because the\n-        // recent rejects filter may contain the wtxid but rarely contains\n-        // the txid of a segwit transaction that has been rejected.\n-        // In the presence of witness malleation, it's possible that by only\n-        // doing the check with wtxid, we could overlook a transaction which\n-        // was confirmed with a different witness, or exists in our mempool\n-        // with a different witness, but this has limited downside:\n-        // mempool validation does its own lookup of whether we have the txid\n-        // already; and an adversary can already relay us old transactions\n-        // (older than our recency filter) if trying to DoS us, without any need\n-        // for witness malleation.\n-        if (m_txdownloadman.AlreadyHaveTx(GenTxid::Wtxid(wtxid), /*include_reconsiderable=*/true)) {\n+        const auto& [should_validate, package_to_validate] = m_txdownloadman.ReceivedTx(pfrom.GetId(), ptx);\n+        if (!should_validate) {",
      "path": "src/net_processing.cpp",
      "position": 682,
      "original_position": 36,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "ed96f3ef3dfb42fef4564aa5eedc636c2d6d8845",
      "in_reply_to_id": 1723307535,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "woops, fixed now",
      "created_at": "2024-08-21T14:44:48Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725185420",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725185420"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4234,
      "original_line": 4234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725187075",
      "pull_request_review_id": 2250669642,
      "id": 1725187075,
      "node_id": "PRRC_kwDOABII585m1EQD",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 168,
      "original_position": 154,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723456852,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">  womp womp\r\n\r\nCan you be a bit more specific :joy:",
      "created_at": "2024-08-21T14:45:46Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725187075",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725187075"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 168,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725358054",
      "pull_request_review_id": 2250669642,
      "id": 1725358054,
      "node_id": "PRRC_kwDOABII585m1t_m",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 177,
      "original_position": 163,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723465940,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It makes them potentially larger transactions?",
      "created_at": "2024-08-21T16:06:16Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725358054",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725358054"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 177,
      "original_line": 177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725359052",
      "pull_request_review_id": 2250669642,
      "id": 1725359052,
      "node_id": "PRRC_kwDOABII585m1uPM",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 215,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723471572,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-21T16:07:08Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725359052",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725359052"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725360295",
      "pull_request_review_id": 2250669642,
      "id": 1725360295,
      "node_id": "PRRC_kwDOABII585m1uin",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // If PackageToValidate is returned then should_validate = false.\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(GetPackageHash(package)));\n+                    // Neither is in m_lazy_recent_rejects\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                txdownload_impl.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownload_impl.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownload_impl.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                    Assert(txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(ptx->GetWitnessHash()), /*include_reconsiderable=*/false));\n+                    // Presumably we have validated this tx. Use \"missing inputs\" to keep it in the\n+                    // orphanage longer. Later iterations might call MempoolAcceptedTx or\n+                    // MempoolRejectedTx with a different error.\n+                    TxValidationState state_missing_inputs;\n+                    state_missing_inputs.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                    txdownload_impl.MempoolRejectedTx(ptx, state_missing_inputs, rand_peer, fuzzed_data_provider.ConsumeBool());\n+                }\n+            }\n+        );\n+\n+        // Jump ahead in time",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 414,
      "original_position": 392,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723473284,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I thought they were all positive?",
      "created_at": "2024-08-21T16:08:02Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725360295",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725360295"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 414,
      "original_line": 414,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725361353",
      "pull_request_review_id": 2250669642,
      "id": 1725361353,
      "node_id": "PRRC_kwDOABII585m1uzJ",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 323,
      "original_position": 305,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723482380,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-21T16:08:52Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725361353",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725361353"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 323,
      "original_line": 323,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725361680",
      "pull_request_review_id": 2250669642,
      "id": 1725361680,
      "node_id": "PRRC_kwDOABII585m1u4Q",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 279,
      "original_position": 262,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723492507,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added",
      "created_at": "2024-08-21T16:09:10Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725361680",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725361680"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 279,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725365000",
      "pull_request_review_id": 2250669642,
      "id": 1725365000,
      "node_id": "PRRC_kwDOABII585m1vsI",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // If PackageToValidate is returned then should_validate = false.\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 380,
      "original_position": 358,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723512996,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think something would be wrong then. It wouldn't be missing inputs if we knew what the fee was.",
      "created_at": "2024-08-21T16:11:44Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725365000",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725365000"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 380,
      "original_line": 380,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725367714",
      "pull_request_review_id": 2250669642,
      "id": 1725367714,
      "node_id": "PRRC_kwDOABII585m1wWi",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // If PackageToValidate is returned then should_validate = false.\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(GetPackageHash(package)));\n+                    // Neither is in m_lazy_recent_rejects\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                txdownload_impl.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownload_impl.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownload_impl.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 396,
      "original_position": 374,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723520777,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1. tx is added to workset\r\n2. tx is removed from orphanage\r\n3. peer workset is nonempty, but its wtxids correspond to stuff that isn't there anymore",
      "created_at": "2024-08-21T16:13:54Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725367714",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725367714"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 396,
      "original_line": 396,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725373422",
      "pull_request_review_id": 2250669642,
      "id": 1725373422,
      "node_id": "PRRC_kwDOABII585m1xvu",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};",
      "path": "src/test/fuzz/tx_download.cpp",
      "position": null,
      "original_position": 114,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "04856ed32c17ce60e9c503d92b21092a0f9ac271",
      "in_reply_to_id": 1723610455,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "changed to come from fuzzer",
      "created_at": "2024-08-21T16:18:32Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725373422",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725373422"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725373542",
      "pull_request_review_id": 2250669642,
      "id": 1725373542,
      "node_id": "PRRC_kwDOABII585m1xxm",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        // \"Good\" peers send the inv at most once, and otherwise will not send an unsolicited message.\n+        if (m_good) {\n+            if (!m_sent_inv && (force_announce || fuzzed_data_provider.ConsumeBool())) {\n+                m_sent_inv = true;\n+                return PossibleMessage::INV_REAL;\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // Non-good peers might send anything!\n+        auto message = fuzzed_data_provider.PickValueInArray(ALL_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    PossibleResponse ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return PossibleResponse::NOTHING;\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(ALL_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return PossibleResponse::NOTHING;\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return response;\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = false;\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();",
      "path": "src/test/fuzz/tx_download.cpp",
      "position": null,
      "original_position": 170,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "04856ed32c17ce60e9c503d92b21092a0f9ac271",
      "in_reply_to_id": 1723534366,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added",
      "created_at": "2024-08-21T16:18:38Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725373542",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725373542"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725374135",
      "pull_request_review_id": 2250669642,
      "id": 1725374135,
      "node_id": "PRRC_kwDOABII585m1x63",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 348,
      "original_position": 328,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723496334,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "should it? seems more complete if it handles all types, and we test them",
      "created_at": "2024-08-21T16:18:59Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725374135",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725374135"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 348,
      "original_line": 348,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725375345",
      "pull_request_review_id": 2250669642,
      "id": 1725375345,
      "node_id": "PRRC_kwDOABII585m1yNx",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 86,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": 1723435539,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added tests for orphans with rejected parents",
      "created_at": "2024-08-21T16:19:49Z",
      "updated_at": "2024-08-22T06:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725375345",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725375345"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725534553",
      "pull_request_review_id": 2251598808,
      "id": 1725534553,
      "node_id": "PRRC_kwDOABII585m2ZFZ",
      "diff_hunk": "@@ -2995,16 +2995,95 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n     AssertLockHeld(g_msgproc_mutex);\n     AssertLockHeld(m_tx_download_mutex);\n \n+    PeerRef peer{GetPeerRef(nodeid)};\n+\n     auto& m_orphanage = m_txdownloadman.GetOrphanageRef();\n     auto& m_txrequest = m_txdownloadman.GetTxRequestRef();\n+    const CTransaction& tx{*ptx};\n \n     LogDebug(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n         ptx->GetHash().ToString(),\n         ptx->GetWitnessHash().ToString(),\n         nodeid,\n         state.ToString());\n \n-    if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+    // Only process a new orphan if maybe_add_extra_compact_tx, as otherwise it must be either",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 17,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "77560a690ce05697400dcbb73bcb4d89724a9e4f",
      "in_reply_to_id": 1722268907,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "new name is better and makes flow easier to understand,thanks",
      "created_at": "2024-08-21T18:28:08Z",
      "updated_at": "2024-08-21T18:28:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725534553",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725534553"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3010,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725548581",
      "pull_request_review_id": 2251621214,
      "id": 1725548581,
      "node_id": "PRRC_kwDOABII585m2cgl",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to\n+    // ensure uniqueness. Here, we want to avoid direct parent/child relationships between transactions.",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 87,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": 1723403236,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ":facepalm: I was missing the `static` in front of `prevout_hash`. This is making a lot more sense now.",
      "created_at": "2024-08-21T18:41:03Z",
      "updated_at": "2024-08-21T18:41:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725548581",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725548581"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725548968",
      "pull_request_review_id": 2251621868,
      "id": 1725548968,
      "node_id": "PRRC_kwDOABII585m2cmo",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownload_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects, m_txid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects, m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon, m_txid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact, m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_txid, m_ignore_inv_txid);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid, m_ignore_inv_wtxid);\n+    }\n+};\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactions(size_t num_txns)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    // Simplest spk for every tx\n+    CScript spk = CScript() << OP_TRUE;\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction tx;\n+        tx.vin.emplace_back(prevout_hash, 0);\n+        // Ensure txid != wtxid\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vout.emplace_back(CENT, spk);\n+        auto ptx{MakeTransactionRef(tx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+static CTransactionRef GetNewTransaction()\n+{\n+    // Create 2 transactions and return the second one. Transactions are created as a chain to\n+    // ensure uniqueness. Here, we want to avoid direct parent/child relationships between transactions.",
      "path": "src/test/txdownload_tests.cpp",
      "position": null,
      "original_position": 87,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "c1609a92ce0d1c8d5afa62d463785f259f0691e5",
      "in_reply_to_id": 1723403236,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "might be worth a comment!",
      "created_at": "2024-08-21T18:41:24Z",
      "updated_at": "2024-08-21T18:41:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725548968",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725548968"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725592055",
      "pull_request_review_id": 2251681805,
      "id": 1725592055,
      "node_id": "PRRC_kwDOABII585m2nH3",
      "diff_hunk": "@@ -0,0 +1,248 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+\n+    // A new TxDownloadImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+\n+    for (const auto segwit_parent : {true, false}) {\n+        for (const auto segwit_child : {true, false}) {\n+            const auto ptx_parent = CreateTransactionChain(1, segwit_parent).front();\n+            const auto ptx_child = CreateTransactionChain(1, segwit_child).front();\n+            const auto& parent_txid = ptx_parent->GetHash().ToUint256();\n+            const auto& parent_wtxid = ptx_parent->GetWitnessHash().ToUint256();\n+            const auto& child_txid = ptx_child->GetHash().ToUint256();\n+            const auto& child_wtxid = ptx_child->GetWitnessHash().ToUint256();\n+\n+            for (const auto& [result, expected_behavior] : expected_behaviors) {\n+                node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+                // Parent failure\n+                state.Invalid(result, \"\");\n+                const auto& [keep, unique_txids, package_to_validate] = txdownload_impl.MempoolRejectedTx(ptx_parent, state, nodeid, /*first_time_failure=*/true);\n+\n+                // No distinction between txid and wtxid caching for nonsegwit transactions, so only test these specific\n+                // behaviors for segwit transactions.\n+                Behaviors actual_behavior{\n+                    /*txid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_txid),\n+                    /*wtxid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_wtxid),\n+                    /*txid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_txid),\n+                    /*wtxid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_wtxid),\n+                    /*keep=*/keep,\n+                    /*txid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Txid(parent_txid), now, /*p2p_inv=*/true),\n+                    /*wtxid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Wtxid(parent_wtxid), now, /*p2p_inv=*/true),\n+                };\n+                BOOST_TEST_MESSAGE(\"Testing behavior for \" << result << (segwit_parent ? \" segwit \" : \" nonsegwit\"));\n+                actual_behavior.CheckEqual(expected_behavior, /*segwit=*/segwit_parent);\n+\n+                // Later, a child of this transaction fails for missing inputs\n+                state.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                txdownload_impl.MempoolRejectedTx(ptx_child, state, nodeid, /*first_time_failure=*/true);\n+\n+                // If parent (by txid) was rejected, child is too.\n+                const bool parent_txid_rejected{segwit_parent ? expected_behavior.m_txid_in_rejects : expected_behavior.m_wtxid_in_rejects};\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_txid));\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_wtxid));\n+\n+                // Unless rejected, the child should be in orphanage.\n+                BOOST_CHECK_EQUAL(!parent_txid_rejected, txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+            }\n+        }\n+    }\n+\n+    // More specific examples of orphans with parent(s) that we have seen before.\n+    TxValidationState state_reconsiderable;\n+    state_reconsiderable.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"\");\n+\n+    TxValidationState state_orphan;\n+    state_orphan.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+\n+    const auto ptx_parent_1 = CreateTransactionChain(1, /*segwit=*/false).front();\n+    const auto ptx_parent_2 = CreateTransactionChain(1, /*segwit=*/false).front();\n+    CMutableTransaction mtx_child;\n+    mtx_child.vin.emplace_back(ptx_parent_1->GetHash(), 0);\n+    mtx_child.vin.emplace_back(ptx_parent_2->GetHash(), 0);\n+    mtx_child.vout.emplace_back(CENT, CScript());\n+    auto ptx_child = MakeTransactionRef(mtx_child);\n+    const std::vector<uint256> vec_parent_txids = {ptx_parent_1->GetHash(), ptx_parent_2->GetHash()};\n+\n+    // 1 reconsiderable parent\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Parent reconsiderable failure\n+        const auto& [p1_keep, p1_unique_txids, p1_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_1, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p1_keep);\n+        BOOST_CHECK(p1_unique_txids.empty());\n+        BOOST_CHECK(!p1_package.has_value());\n+\n+        // Child missing inputs, should be added to orphanage.\n+        const auto& [c_keep, c_unique_txids, c_package] = txdownload_impl.MempoolRejectedTx(ptx_child, state_orphan, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(c_keep);\n+        BOOST_CHECK(c_unique_txids == vec_parent_txids);\n+        BOOST_CHECK(!c_package.has_value());\n+        BOOST_CHECK(txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+    }\n+\n+    // 2 reconsiderable parents\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Parent reconsiderable failure\n+        const auto& [p1_keep, p1_unique_txids, p1_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_1, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p1_keep);\n+        BOOST_CHECK(p1_unique_txids.empty());\n+        BOOST_CHECK(!p1_package.has_value());\n+\n+        const auto& [p2_keep, p2_unique_txids, p2_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_2, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p2_keep);\n+        BOOST_CHECK(p2_unique_txids.empty());\n+        BOOST_CHECK(!p2_package.has_value());\n+\n+        // Child missing inputs. Not added to orphanage because only 1 reconsiderable rejected parent is tolerated.\n+        const auto& [c_keep, c_unique_txids, c_package] = txdownload_impl.MempoolRejectedTx(ptx_child, state_orphan, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(c_keep);\n+        BOOST_CHECK(c_unique_txids == vec_parent_txids);\n+        BOOST_CHECK(!c_package.has_value());\n+        BOOST_CHECK(!txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+    }\n+\n+    // 1 reconsiderable parent + 1 non-reconsiderable parent\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Parent reconsiderable failure\n+        const auto& [p1_keep, p1_unique_txids, p1_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_1, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p1_keep);\n+        BOOST_CHECK(p1_unique_txids.empty());\n+        BOOST_CHECK(!p1_package.has_value());\n+\n+        TxValidationState state_not_reconsiderable;\n+        state_not_reconsiderable.Invalid(TxValidationResult::TX_CONSENSUS, \"\");\n+\n+        const auto& [p2_keep, p2_unique_txids, p2_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_2, state_not_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p2_keep);\n+        BOOST_CHECK(p2_unique_txids.empty());\n+        BOOST_CHECK(!p2_package.has_value());\n+\n+        // Child missing inputs. Not added to orphanage because only 1 reconsiderable rejected parent is tolerated.\n+        const auto& [c_keep, c_unique_txids, c_package] = txdownload_impl.MempoolRejectedTx(ptx_child, state_orphan, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(c_keep);\n+        BOOST_CHECK(c_unique_txids == vec_parent_txids);\n+        BOOST_CHECK(!c_package.has_value());\n+        BOOST_CHECK(!txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+\n+    }\n+\n+    // Reconsiderable parent of a tx already in orphanage: the only time PackageToValidate is returned.\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Child missing inputs, should be added to orphanage.",
      "path": "src/test/txdownload_tests.cpp",
      "position": 238,
      "original_position": 232,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "8f5163e8a19e0963679a16c6fe7936af0536db26",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: just assert it's in orphanage instead",
      "created_at": "2024-08-21T19:00:29Z",
      "updated_at": "2024-08-21T19:06:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1725592055",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1725592055"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 238,
      "original_line": 238,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1726878944",
      "pull_request_review_id": 2254257168,
      "id": 1726878944,
      "node_id": "PRRC_kwDOABII585m7hTg",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 348,
      "original_position": 328,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723496334,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The fuzz target is always setting `state.Invalid`, so I don't see where this coverage would come from?",
      "created_at": "2024-08-22T11:29:10Z",
      "updated_at": "2024-08-22T11:29:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1726878944",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1726878944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 348,
      "original_line": 348,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1726881353",
      "pull_request_review_id": 2254260615,
      "id": 1726881353,
      "node_id": "PRRC_kwDOABII585m7h5J",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                }\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize a TxDownloadImpl\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = HasRelayPermissions(rand_peer),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownload_impl.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownload_impl.DisconnectedPeer(rand_peer);\n+                txdownload_impl.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownload_impl.ActiveTipChange();\n+                // After a block update, nothing should be in the rejection caches\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsFilter().contains(rand_tx->GetHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownload_impl.BlockConnected(std::make_shared<CBlock>(block));\n+                // Block transactions must be removed from orphanage\n+                Assert(!txdownload_impl.m_orphanage.HaveTx(rand_tx->GetWitnessHash()));\n+            },\n+            [&] {\n+                txdownload_impl.BlockDisconnected();\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                Assert(!txdownload_impl.RecentConfirmedTransactionsFilter().contains(rand_tx->GetHash().ToUint256()));\n+            },\n+            [&] {\n+                txdownload_impl.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownload_impl.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownload_impl.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                const auto getdata_requests = txdownload_impl.GetRequestsToSend(rand_peer, time);\n+                // TxDownloadManager should not be telling us to request things we already have.\n+                // Exclude m_lazy_recent_rejects_reconsiderable because it may request low-feerate parent of orphan.\n+                for (const auto& gtxid : getdata_requests) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false));\n+                }\n+            },\n+            [&] {\n+                const auto& [should_validate, maybe_package] = txdownload_impl.ReceivedTx(rand_peer, rand_tx);\n+                // If PackageToValidate is returned then should_validate = false.\n+                Assert(should_validate || !maybe_package.has_value());\n+                if (should_validate) {\n+                    Assert(!txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(rand_tx->GetWitnessHash()), /*include_reconsiderable=*/true));\n+                }\n+                if (maybe_package.has_value()) {\n+                    Assert(maybe_package->m_senders.size() == 2);\n+                    Assert(maybe_package->m_senders.front() == rand_peer);\n+\n+                    const auto& package = maybe_package->m_txns;\n+                    Assert(package.size() == 2);\n+                    // Parent is in m_lazy_recent_rejects_reconsiderable and child is in m_orphanage\n+                    Assert(txdownload_impl.RecentRejectsReconsiderableFilter().contains(rand_tx->GetWitnessHash().ToUint256()));\n+                    Assert(txdownload_impl.m_orphanage.HaveTx(maybe_package->m_txns.back()->GetWitnessHash()));\n+                    // Package has not been rejected\n+                    Assert(!txdownload_impl.RecentRejectsReconsiderableFilter().contains(GetPackageHash(package)));\n+                    // Neither is in m_lazy_recent_rejects\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.front()->GetWitnessHash().ToUint256()));\n+                    Assert(!txdownload_impl.RecentRejectsFilter().contains(package.back()->GetWitnessHash().ToUint256()));\n+                }\n+            },\n+            [&] {\n+                txdownload_impl.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownload_impl.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownload_impl.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                    Assert(txdownload_impl.AlreadyHaveTx(GenTxid::Wtxid(ptx->GetWitnessHash()), /*include_reconsiderable=*/false));\n+                    // Presumably we have validated this tx. Use \"missing inputs\" to keep it in the\n+                    // orphanage longer. Later iterations might call MempoolAcceptedTx or\n+                    // MempoolRejectedTx with a different error.\n+                    TxValidationState state_missing_inputs;\n+                    state_missing_inputs.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                    txdownload_impl.MempoolRejectedTx(ptx, state_missing_inputs, rand_peer, fuzzed_data_provider.ConsumeBool());\n+                }\n+            }\n+        );\n+\n+        // Jump ahead in time",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 414,
      "original_position": 392,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723473284,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "hmm, must have been referencing something else, nevermind",
      "created_at": "2024-08-22T11:30:52Z",
      "updated_at": "2024-08-22T11:30:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1726881353",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1726881353"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 414,
      "original_line": 414,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1727240719",
      "pull_request_review_id": 2254798839,
      "id": 1727240719,
      "node_id": "PRRC_kwDOABII585m85oP",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 168,
      "original_position": 154,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723456852,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No. I just had to google this magic number and felt slightly rickrolled ",
      "created_at": "2024-08-22T15:02:04Z",
      "updated_at": "2024-08-22T15:02:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1727240719",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1727240719"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 168,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1727243654",
      "pull_request_review_id": 2254802540,
      "id": 1727243654,
      "node_id": "PRRC_kwDOABII585m86WG",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 212,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "0de01c034e2977516d11f370efa1495d9b9577b0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "this fails if we have a package to validate...",
      "created_at": "2024-08-22T15:02:42Z",
      "updated_at": "2024-08-22T15:02:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1727243654",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1727243654"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1727249636",
      "pull_request_review_id": 2254810948,
      "id": 1727249636,
      "node_id": "PRRC_kwDOABII585m87zk",
      "diff_hunk": "@@ -0,0 +1,404 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownload_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": 168,
      "original_position": 154,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "2d6a41102e41251f87ac0e6ff48f0b53e35fcce1",
      "in_reply_to_id": 1723456852,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ohhh i get it now. i thought you found a crash and were giving a cryptic description of the input",
      "created_at": "2024-08-22T15:04:27Z",
      "updated_at": "2024-08-22T15:04:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1727249636",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1727249636"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 168,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728679985",
      "pull_request_review_id": 2256803176,
      "id": 1728679985,
      "node_id": "PRRC_kwDOABII585nCZAx",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                Assert(should_validate || !maybe_package.has_value());",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 212,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "0de01c034e2977516d11f370efa1495d9b9577b0",
      "in_reply_to_id": 1727243654,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I wrote the assertion incorrectly. The only combination that's not ok is both.",
      "created_at": "2024-08-23T09:32:55Z",
      "updated_at": "2024-08-23T09:32:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1728679985",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728679985"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728680149",
      "pull_request_review_id": 2256803329,
      "id": 1728680149,
      "node_id": "PRRC_kwDOABII585nCZDV",
      "diff_hunk": "@@ -0,0 +1,248 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+\n+    // A new TxDownloadImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+\n+    for (const auto segwit_parent : {true, false}) {\n+        for (const auto segwit_child : {true, false}) {\n+            const auto ptx_parent = CreateTransactionChain(1, segwit_parent).front();\n+            const auto ptx_child = CreateTransactionChain(1, segwit_child).front();\n+            const auto& parent_txid = ptx_parent->GetHash().ToUint256();\n+            const auto& parent_wtxid = ptx_parent->GetWitnessHash().ToUint256();\n+            const auto& child_txid = ptx_child->GetHash().ToUint256();\n+            const auto& child_wtxid = ptx_child->GetWitnessHash().ToUint256();\n+\n+            for (const auto& [result, expected_behavior] : expected_behaviors) {\n+                node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+                // Parent failure\n+                state.Invalid(result, \"\");\n+                const auto& [keep, unique_txids, package_to_validate] = txdownload_impl.MempoolRejectedTx(ptx_parent, state, nodeid, /*first_time_failure=*/true);\n+\n+                // No distinction between txid and wtxid caching for nonsegwit transactions, so only test these specific\n+                // behaviors for segwit transactions.\n+                Behaviors actual_behavior{\n+                    /*txid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_txid),\n+                    /*wtxid_rejects=*/txdownload_impl.RecentRejectsFilter().contains(parent_wtxid),\n+                    /*txid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_txid),\n+                    /*wtxid_recon=*/txdownload_impl.RecentRejectsReconsiderableFilter().contains(parent_wtxid),\n+                    /*keep=*/keep,\n+                    /*txid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Txid(parent_txid), now, /*p2p_inv=*/true),\n+                    /*wtxid_inv=*/txdownload_impl.AddTxAnnouncement(nodeid, GenTxid::Wtxid(parent_wtxid), now, /*p2p_inv=*/true),\n+                };\n+                BOOST_TEST_MESSAGE(\"Testing behavior for \" << result << (segwit_parent ? \" segwit \" : \" nonsegwit\"));\n+                actual_behavior.CheckEqual(expected_behavior, /*segwit=*/segwit_parent);\n+\n+                // Later, a child of this transaction fails for missing inputs\n+                state.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+                txdownload_impl.MempoolRejectedTx(ptx_child, state, nodeid, /*first_time_failure=*/true);\n+\n+                // If parent (by txid) was rejected, child is too.\n+                const bool parent_txid_rejected{segwit_parent ? expected_behavior.m_txid_in_rejects : expected_behavior.m_wtxid_in_rejects};\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_txid));\n+                BOOST_CHECK_EQUAL(parent_txid_rejected, txdownload_impl.RecentRejectsFilter().contains(child_wtxid));\n+\n+                // Unless rejected, the child should be in orphanage.\n+                BOOST_CHECK_EQUAL(!parent_txid_rejected, txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+            }\n+        }\n+    }\n+\n+    // More specific examples of orphans with parent(s) that we have seen before.\n+    TxValidationState state_reconsiderable;\n+    state_reconsiderable.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"\");\n+\n+    TxValidationState state_orphan;\n+    state_orphan.Invalid(TxValidationResult::TX_MISSING_INPUTS, \"\");\n+\n+    const auto ptx_parent_1 = CreateTransactionChain(1, /*segwit=*/false).front();\n+    const auto ptx_parent_2 = CreateTransactionChain(1, /*segwit=*/false).front();\n+    CMutableTransaction mtx_child;\n+    mtx_child.vin.emplace_back(ptx_parent_1->GetHash(), 0);\n+    mtx_child.vin.emplace_back(ptx_parent_2->GetHash(), 0);\n+    mtx_child.vout.emplace_back(CENT, CScript());\n+    auto ptx_child = MakeTransactionRef(mtx_child);\n+    const std::vector<uint256> vec_parent_txids = {ptx_parent_1->GetHash(), ptx_parent_2->GetHash()};\n+\n+    // 1 reconsiderable parent\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Parent reconsiderable failure\n+        const auto& [p1_keep, p1_unique_txids, p1_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_1, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p1_keep);\n+        BOOST_CHECK(p1_unique_txids.empty());\n+        BOOST_CHECK(!p1_package.has_value());\n+\n+        // Child missing inputs, should be added to orphanage.\n+        const auto& [c_keep, c_unique_txids, c_package] = txdownload_impl.MempoolRejectedTx(ptx_child, state_orphan, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(c_keep);\n+        BOOST_CHECK(c_unique_txids == vec_parent_txids);\n+        BOOST_CHECK(!c_package.has_value());\n+        BOOST_CHECK(txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+    }\n+\n+    // 2 reconsiderable parents\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Parent reconsiderable failure\n+        const auto& [p1_keep, p1_unique_txids, p1_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_1, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p1_keep);\n+        BOOST_CHECK(p1_unique_txids.empty());\n+        BOOST_CHECK(!p1_package.has_value());\n+\n+        const auto& [p2_keep, p2_unique_txids, p2_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_2, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p2_keep);\n+        BOOST_CHECK(p2_unique_txids.empty());\n+        BOOST_CHECK(!p2_package.has_value());\n+\n+        // Child missing inputs. Not added to orphanage because only 1 reconsiderable rejected parent is tolerated.\n+        const auto& [c_keep, c_unique_txids, c_package] = txdownload_impl.MempoolRejectedTx(ptx_child, state_orphan, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(c_keep);\n+        BOOST_CHECK(c_unique_txids == vec_parent_txids);\n+        BOOST_CHECK(!c_package.has_value());\n+        BOOST_CHECK(!txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+    }\n+\n+    // 1 reconsiderable parent + 1 non-reconsiderable parent\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Parent reconsiderable failure\n+        const auto& [p1_keep, p1_unique_txids, p1_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_1, state_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p1_keep);\n+        BOOST_CHECK(p1_unique_txids.empty());\n+        BOOST_CHECK(!p1_package.has_value());\n+\n+        TxValidationState state_not_reconsiderable;\n+        state_not_reconsiderable.Invalid(TxValidationResult::TX_CONSENSUS, \"\");\n+\n+        const auto& [p2_keep, p2_unique_txids, p2_package] = txdownload_impl.MempoolRejectedTx(ptx_parent_2, state_not_reconsiderable, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(p2_keep);\n+        BOOST_CHECK(p2_unique_txids.empty());\n+        BOOST_CHECK(!p2_package.has_value());\n+\n+        // Child missing inputs. Not added to orphanage because only 1 reconsiderable rejected parent is tolerated.\n+        const auto& [c_keep, c_unique_txids, c_package] = txdownload_impl.MempoolRejectedTx(ptx_child, state_orphan, nodeid, /*first_time_failure=*/true);\n+        BOOST_CHECK(c_keep);\n+        BOOST_CHECK(c_unique_txids == vec_parent_txids);\n+        BOOST_CHECK(!c_package.has_value());\n+        BOOST_CHECK(!txdownload_impl.m_orphanage.HaveTx(ptx_child->GetWitnessHash()));\n+\n+    }\n+\n+    // Reconsiderable parent of a tx already in orphanage: the only time PackageToValidate is returned.\n+    {\n+        node::TxDownloadImpl txdownload_impl{node::TxDownloadOptions{pool, det_rand, DEFAULT_MAX_ORPHAN_TRANSACTIONS}};\n+\n+        // Child missing inputs, should be added to orphanage.",
      "path": "src/test/txdownload_tests.cpp",
      "position": 238,
      "original_position": 232,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "8f5163e8a19e0963679a16c6fe7936af0536db26",
      "in_reply_to_id": 1725592055,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added",
      "created_at": "2024-08-23T09:33:00Z",
      "updated_at": "2024-08-23T09:33:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1728680149",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728680149"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 238,
      "original_line": 238,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728863544",
      "pull_request_review_id": 2257071619,
      "id": 1728863544,
      "node_id": "PRRC_kwDOABII585nDF04",
      "diff_hunk": "@@ -0,0 +1,157 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {\n+    /** Read-only reference to mempool. */\n+    const CTxMemPool& m_mempool;\n+    /** RNG provided by caller. */\n+    FastRandomContext& m_rng;\n+    /** Maximum number of transactions allowed in orphanage. */\n+    const uint32_t m_max_orphan_txs;\n+};\n+struct TxDownloadConnectionInfo {\n+    /** Whether this peer is preferred for transaction download. */\n+    const bool m_preferred;\n+    /** Whether this peer has Relay permissions. */\n+    const bool m_relay_permissions;\n+    /** Whether this peer supports wtxid relay. */\n+    const bool m_wtxid_relay;\n+};\n+struct PackageToValidate {\n+    Package m_txns;\n+    std::vector<NodeId> m_senders;\n+    /** Construct a 1-parent-1-child package. */\n+    explicit PackageToValidate(const CTransactionRef& parent,\n+                               const CTransactionRef& child,\n+                               NodeId parent_sender,\n+                               NodeId child_sender) :\n+        m_txns{parent, child},\n+        m_senders{parent_sender, child_sender}\n+    {}\n+\n+    // Move ctor\n+    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\n+    // Copy ctor\n+    PackageToValidate(const PackageToValidate& other) = default;\n+\n+    // Move assignment\n+    PackageToValidate& operator=(PackageToValidate&& other) {\n+        this->m_txns = std::move(other.m_txns);\n+        this->m_senders = std::move(other.m_senders);\n+        return *this;\n+    }\n+\n+    std::string ToString() const {\n+        Assume(m_txns.size() == 2);\n+        return strprintf(\"parent %s (wtxid=%s, sender=%d) + child %s (wtxid=%s, sender=%d)\",\n+                         m_txns.front()->GetHash().ToString(),\n+                         m_txns.front()->GetWitnessHash().ToString(),\n+                         m_senders.front(),\n+                         m_txns.back()->GetHash().ToString(),\n+                         m_txns.back()->GetWitnessHash().ToString(),\n+                         m_senders.back());\n+    }\n+};\n+struct RejectedTxTodo\n+{\n+    bool m_should_add_extra_compact_tx;\n+    std::vector<uint256> m_unique_parents;\n+    std::optional<PackageToValidate> m_package_to_validate;\n+};\n+\n+\n+class TxDownloadManager {\n+    const std::unique_ptr<TxDownloadImpl> m_impl;",
      "path": "src/node/txdownloadman.h",
      "position": null,
      "original_position": 101,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    const std::unique_ptr<TxDownloadManagerImpl> m_impl;\r\n```\r\n\r\nðŸ‘‰ðŸ‘ˆ",
      "created_at": "2024-08-23T12:05:18Z",
      "updated_at": "2024-08-23T12:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1728863544",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728863544"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728864031",
      "pull_request_review_id": 2257071619,
      "id": 1728864031,
      "node_id": "PRRC_kwDOABII585nDF8f",
      "diff_hunk": "@@ -0,0 +1,436 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        // \"Good\" peers send the inv at most once, and otherwise will not send an unsolicited message.\n+        if (m_good) {\n+            if (!m_sent_inv && (force_announce || fuzzed_data_provider.ConsumeBool())) {\n+                m_sent_inv = true;\n+                return PossibleMessage::INV_REAL;\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // Non-good peers might send anything!\n+        auto message = fuzzed_data_provider.PickValueInArray(ALL_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    PossibleResponse ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return PossibleResponse::NOTHING;\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(ALL_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return PossibleResponse::NOTHING;\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return response;\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{10};\n+COutPoint COINS[NUM_COINS];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(tx_download_one_honest_peer, .init = initialize)",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 226,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nFUZZ_TARGET(txdownloadman_one_honest_peer, .init = initialize)\r\n```\r\n\r\nðŸ‘‰ðŸ‘ˆ",
      "created_at": "2024-08-23T12:05:46Z",
      "updated_at": "2024-08-23T12:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1728864031",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728864031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728864722",
      "pull_request_review_id": 2257071619,
      "id": 1728864722,
      "node_id": "PRRC_kwDOABII585nDGHS",
      "diff_hunk": "@@ -0,0 +1,423 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (maybe_package.has_value()) CheckPackageToValidate(*maybe_package, rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+    txdownload_impl.m_txrequest.SanityCheck();\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 280,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nFUZZ_TARGET(txdownloadman_impl, .init = initialize)\r\n```\r\n\r\n(if you take the other naming suggestion)\r\n\r\nðŸ‘‰ðŸ‘ˆ",
      "created_at": "2024-08-23T12:06:24Z",
      "updated_at": "2024-08-23T12:07:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1728864722",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728864722"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728880703",
      "pull_request_review_id": 2257097696,
      "id": 1728880703,
      "node_id": "PRRC_kwDOABII585nDKA_",
      "diff_hunk": "@@ -0,0 +1,436 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        // \"Good\" peers send the inv at most once, and otherwise will not send an unsolicited message.\n+        if (m_good) {\n+            if (!m_sent_inv && (force_announce || fuzzed_data_provider.ConsumeBool())) {\n+                m_sent_inv = true;\n+                return PossibleMessage::INV_REAL;\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // Non-good peers might send anything!\n+        auto message = fuzzed_data_provider.PickValueInArray(ALL_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    PossibleResponse ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return PossibleResponse::NOTHING;\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(ALL_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return PossibleResponse::NOTHING;\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return response;\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{10};\n+COutPoint COINS[NUM_COINS];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(tx_download_one_honest_peer, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+\n+    // Make target transaction, malleated, and stripped\n+    auto target_tx{MakeTransactionSpending(\n+        {fuzzed_data_provider.PickValueInArray(COINS)},\n+        /*num_outputs=*/2,\n+        /*add_witness=*/fuzzed_data_provider.ConsumeBool())\n+    };\n+    auto malleated_tx = Malleate(target_tx);\n+    auto stripped_tx = StripWitness(target_tx);\n+    const auto& target_txid = target_tx->GetHash().ToUint256();\n+    const auto& target_wtxid = target_tx->GetWitnessHash().ToUint256();\n+    const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+    std::chrono::microseconds time{244466666};\n+\n+    // Decide what the peers are.\n+    std::vector<TestPeer> all_peers;\n+    // NodeId of the \"designated good peer\"\n+    // Other TestPeers may be \"good\" as well, but not guaranteed.\n+    NodeId honestid = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 7);\n+    // 8 outbound peers. NodeId = o. We indicate outbound using preferred=true\n+    for (unsigned int o = 0; o < 8; ++o) {\n+        bool good = (o == honestid) || fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, o, /*preferred=*/true, /*force_good=*/good));\n+    }\n+    // 0-120 inbound peers. NodeId = i. We indicate inbound using preferred=false\n+    auto num_inbound_peers = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 120);\n+    for (unsigned int i = 8; i < num_inbound_peers + 8; ++i) {\n+        bool good = fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, i, /*preferred=*/false, /*force_good=*/good));\n+    }\n+\n+    // Indexes for random peer iteration\n+    std::vector<size_t> indexes;\n+    indexes.resize(all_peers.size());\n+    std::iota(indexes.begin(), indexes.end(), 0);\n+\n+    // We are trying to ensure that we always download the tx as long as we have 1 good outbound\n+    // peer who is able to send it to us.\n+    bool got_tx{false};\n+\n+    // Keep track of how many iterations the loop has done to make sure the target transaction is\n+    // announced within the first 1000 rounds. Note that the good peer is guaranteed to connect\n+    // within the first round and will never be disconnected.\n+    int counter = 0;\n+\n+    LIMITED_WHILE(!got_tx, 100000)\n+    {\n+        std::shuffle(indexes.begin(), indexes.end(), det_rand);",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 284,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Any reason not to let the fuzzer decide the order?\r\n\r\nIf the order is interesting (i.e. a specific order might trigger a bug) then I think it'd make more sense to let the fuzzer choose the order.",
      "created_at": "2024-08-23T12:20:05Z",
      "updated_at": "2024-08-23T12:20:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1728880703",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728880703"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728887570",
      "pull_request_review_id": 2257108313,
      "id": 1728887570,
      "node_id": "PRRC_kwDOABII585nDLsS",
      "diff_hunk": "@@ -0,0 +1,81 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+\n+namespace node {\n+\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()",
      "path": "src/node/txdownloadman.cpp",
      "position": null,
      "original_position": 15,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "To avoid the circular dependency, you could get rid of this file and move its contents to `txdownloadman_impl.cpp`. ",
      "created_at": "2024-08-23T12:25:54Z",
      "updated_at": "2024-08-23T12:26:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1728887570",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1728887570"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729130184",
      "pull_request_review_id": 2257483519,
      "id": 1729130184,
      "node_id": "PRRC_kwDOABII585nEG7I",
      "diff_hunk": "@@ -0,0 +1,436 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        // \"Good\" peers send the inv at most once, and otherwise will not send an unsolicited message.\n+        if (m_good) {\n+            if (!m_sent_inv && (force_announce || fuzzed_data_provider.ConsumeBool())) {\n+                m_sent_inv = true;\n+                return PossibleMessage::INV_REAL;\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // Non-good peers might send anything!\n+        auto message = fuzzed_data_provider.PickValueInArray(ALL_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    PossibleResponse ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return PossibleResponse::NOTHING;\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(ALL_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return PossibleResponse::NOTHING;\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return response;\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{10};\n+COutPoint COINS[NUM_COINS];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(tx_download_one_honest_peer, .init = initialize)",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 226,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": 1728864031,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-23T15:09:57Z",
      "updated_at": "2024-08-23T15:09:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1729130184",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729130184"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729130331",
      "pull_request_review_id": 2257483749,
      "id": 1729130331,
      "node_id": "PRRC_kwDOABII585nEG9b",
      "diff_hunk": "@@ -0,0 +1,423 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+\n+constexpr size_t NUM_COINS{50};\n+COutPoint COINS[NUM_COINS];\n+\n+static TxValidationResult TESTED_TX_RESULTS[] = {\n+    // Skip TX_RESULT_UNSET\n+    TxValidationResult::TX_CONSENSUS,\n+    TxValidationResult::TX_RECENT_CONSENSUS_CHANGE,\n+    TxValidationResult::TX_INPUTS_NOT_STANDARD,\n+    TxValidationResult::TX_NOT_STANDARD,\n+    TxValidationResult::TX_MISSING_INPUTS,\n+    TxValidationResult::TX_PREMATURE_SPEND,\n+    TxValidationResult::TX_WITNESS_MUTATED,\n+    TxValidationResult::TX_WITNESS_STRIPPED,\n+    TxValidationResult::TX_CONFLICT,\n+    TxValidationResult::TX_MEMPOOL_POLICY,\n+    // Skip TX_NO_MEMPOOL\n+    TxValidationResult::TX_RECONSIDERABLE,\n+    TxValidationResult::TX_UNKNOWN,\n+};\n+\n+// Precomputed transactions. Some may conflict with each other.\n+std::vector<CTransactionRef> TRANSACTIONS;\n+\n+// Limit the total number of peers because we don't expect coverage to change much with lots more peers.\n+constexpr int NUM_PEERS = 16;\n+\n+// Precomputed random durations (positive and negative, each ~exponentially distributed).\n+std::chrono::microseconds TIME_SKIPS[128];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+    size_t outpoints_index = 0;\n+    // 2 transactions same txid different witness\n+    {\n+        auto tx1{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/false)};\n+        auto tx2{MakeTransactionSpending({COINS[outpoints_index]}, /*num_outputs=*/5, /*add_witness=*/true)};\n+        Assert(tx1->GetHash() == tx2->GetHash());\n+        TRANSACTIONS.emplace_back(tx1);\n+        TRANSACTIONS.emplace_back(tx2);\n+        outpoints_index += 1;\n+    }\n+    // 2 parents 1 child\n+    {\n+        auto tx_parent_1{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent_1);\n+        auto tx_parent_2{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/1, /*add_witness=*/false)};\n+        TRANSACTIONS.emplace_back(tx_parent_2);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent_1->GetHash(), 0}, COutPoint{tx_parent_2->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // 1 parent 2 children\n+    {\n+        auto tx_parent{MakeTransactionSpending({COINS[outpoints_index++]}, /*num_outputs=*/2, /*add_witness=*/true)};\n+        TRANSACTIONS.emplace_back(tx_parent);\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 0}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({COutPoint{tx_parent->GetHash(), 1}},\n+                                                            /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+    // chain of 5 segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/true)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // chain of 5 non-segwit\n+    {\n+        COutPoint& last_outpoint = COINS[outpoints_index++];\n+        for (auto i{0}; i < 5; ++i) {\n+            auto tx{MakeTransactionSpending({last_outpoint}, /*num_outputs=*/1, /*add_witness=*/false)};\n+            TRANSACTIONS.emplace_back(tx);\n+            last_outpoint = COutPoint{tx->GetHash(), 0};\n+        }\n+    }\n+    // Also create a loose tx for each outpoint. Some of these transactions conflict with the above\n+    // or have the same txid.\n+    for (const auto& outpoint : COINS) {\n+        TRANSACTIONS.emplace_back(MakeTransactionSpending({outpoint}, /*num_outputs=*/1, /*add_witness=*/true));\n+    }\n+\n+    // Create random-looking time jumps\n+    int i = 0;\n+    // TIME_SKIPS[N] for N=0..15 is just N microseconds.\n+    for (; i < 16; ++i) {\n+        TIME_SKIPS[i] = std::chrono::microseconds{i};\n+    }\n+    // TIME_SKIPS[N] for N=16..127 has randomly-looking but roughly exponentially increasing values up to\n+    // 198.416453 seconds.\n+    for (; i < 128; ++i) {\n+        int diff_bits = ((i - 10) * 2) / 9;\n+        uint64_t diff = 1 + (CSipHasher(0, 0).Write(i).Finalize() >> (64 - diff_bits));\n+        TIME_SKIPS[i] = TIME_SKIPS[i - 1] + std::chrono::microseconds{diff};\n+    }\n+}\n+\n+void CheckPackageToValidate(const node::PackageToValidate& package_to_validate, NodeId peer)\n+{\n+    Assert(package_to_validate.m_senders.size() == 2);\n+    Assert(package_to_validate.m_senders.front() == peer);\n+    Assert(package_to_validate.m_senders.back() <= NUM_PEERS);\n+\n+    // Package is a 1p1c\n+    const auto& package = package_to_validate.m_txns;\n+    Assert(IsChildWithParents(package));\n+    Assert(package.size() == 2);\n+}\n+\n+FUZZ_TARGET(txdownloadman, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+\n+    std::chrono::microseconds time{244466666};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000)\n+    {\n+        NodeId rand_peer = fuzzed_data_provider.ConsumeIntegralInRange<int64_t>(0, NUM_PEERS);\n+\n+        // Transaction can be one of the premade ones or a randomly generated one\n+        auto rand_tx = fuzzed_data_provider.ConsumeBool() ?\n+            MakeTransactionSpending({fuzzed_data_provider.PickValueInArray(COINS)},\n+                                    /*num_outputs=*/fuzzed_data_provider.ConsumeIntegralInRange(1, 500),\n+                                    /*add_witness=*/fuzzed_data_provider.ConsumeBool()) :\n+            TRANSACTIONS.at(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, TRANSACTIONS.size() - 1));\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                node::TxDownloadConnectionInfo info{\n+                    .m_preferred = fuzzed_data_provider.ConsumeBool(),\n+                    .m_relay_permissions = fuzzed_data_provider.ConsumeBool(),\n+                    .m_wtxid_relay = fuzzed_data_provider.ConsumeBool()\n+                };\n+                txdownloadman.ConnectedPeer(rand_peer, info);\n+            },\n+            [&] {\n+                txdownloadman.DisconnectedPeer(rand_peer);\n+                txdownloadman.CheckIsEmpty(rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ActiveTipChange();\n+            },\n+            [&] {\n+                CBlock block;\n+                block.vtx.push_back(rand_tx);\n+                txdownloadman.BlockConnected(std::make_shared<CBlock>(block));\n+            },\n+            [&] {\n+                txdownloadman.BlockDisconnected();\n+            },\n+            [&] {\n+                txdownloadman.MempoolAcceptedTx(rand_tx);\n+            },\n+            [&] {\n+                TxValidationState state;\n+                state.Invalid(fuzzed_data_provider.PickValueInArray(TESTED_TX_RESULTS), \"\");\n+                txdownloadman.MempoolRejectedTx(rand_tx, state, rand_peer, fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                GenTxid gtxid = fuzzed_data_provider.ConsumeBool() ?\n+                                GenTxid::Txid(rand_tx->GetHash()) :\n+                                GenTxid::Wtxid(rand_tx->GetWitnessHash());\n+                txdownloadman.AddTxAnnouncement(rand_peer, gtxid, time, /*p2p_inv=*/fuzzed_data_provider.ConsumeBool());\n+            },\n+            [&] {\n+                txdownloadman.GetRequestsToSend(rand_peer, time);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                const auto& [should_validate, maybe_package] = txdownloadman.ReceivedTx(rand_peer, rand_tx);\n+                // The only possible results should be:\n+                // - Don't validate the tx, no package.\n+                // - Don't validate the tx, package.\n+                // - Validate the tx, no package.\n+                // The only combination that doesn't make sense is validate both tx and package.\n+                Assert(!(should_validate && maybe_package.has_value()));\n+                if (maybe_package.has_value()) CheckPackageToValidate(*maybe_package, rand_peer);\n+            },\n+            [&] {\n+                txdownloadman.ReceivedNotFound(rand_peer, {rand_tx->GetWitnessHash()});\n+            },\n+            [&] {\n+                const bool expect_work{txdownloadman.HaveMoreWork(rand_peer)};\n+                const auto ptx = txdownloadman.GetTxToReconsider(rand_peer);\n+                // expect_work=true doesn't necessarily mean the next item from the workset isn't a\n+                // nullptr, as the transaction could have been removed from orphanage without being\n+                // removed from the peer's workset.\n+                if (ptx) {\n+                    // However, if there was a non-null tx in the workset, HaveMoreWork should have\n+                    // returned true.\n+                    Assert(expect_work);\n+                }\n+            }\n+        );\n+        time += fuzzed_data_provider.PickValueInArray(TIME_SKIPS);\n+    }\n+    // Disconnect everybody, check that all data structures are empty.\n+    for (NodeId nodeid = 0; nodeid <= NUM_PEERS; ++nodeid) {\n+        txdownloadman.DisconnectedPeer(nodeid);\n+        txdownloadman.CheckIsEmpty(nodeid);\n+    }\n+    txdownloadman.CheckIsEmpty();\n+}\n+\n+// Give node 0 relay permissions, and nobody else. This helps us remember who is a RelayPermissions\n+// peer without tracking anything (this is only for the txdownload_impl target).\n+static bool HasRelayPermissions(NodeId peer) { return peer == 0; }\n+\n+static void CheckInvariants(const node::TxDownloadImpl& txdownload_impl, size_t max_orphan_count)\n+{\n+    const TxOrphanage& orphanage = txdownload_impl.m_orphanage;\n+\n+    // Orphanage usage should never exceed what is allowed\n+    Assert(orphanage.Size() <= max_orphan_count);\n+\n+    // We should never have more than the maximum in-flight requests out for a peer.\n+    for (NodeId peer = 0; peer < NUM_PEERS; ++peer) {\n+        if (!HasRelayPermissions(peer)) {\n+            Assert(txdownload_impl.m_txrequest.CountInFlight(peer) <= node::MAX_PEER_TX_REQUEST_IN_FLIGHT);\n+        }\n+    }\n+    txdownload_impl.m_txrequest.SanityCheck();\n+}\n+\n+FUZZ_TARGET(txdownload_impl, .init = initialize)",
      "path": "src/test/fuzz/txdownloadman.cpp",
      "position": null,
      "original_position": 280,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": 1728864722,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-23T15:10:02Z",
      "updated_at": "2024-08-23T15:10:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1729130331",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729130331"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729130506",
      "pull_request_review_id": 2257484030,
      "id": 1729130506,
      "node_id": "PRRC_kwDOABII585nEHAK",
      "diff_hunk": "@@ -0,0 +1,436 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/hasher.h>\n+#include <util/rbf.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+namespace {\n+// What a peer may send proactively.\n+enum class PossibleMessage {\n+    /** Don't send anything */\n+    NOTHING,\n+    /** Announce the target transaction */\n+    INV_REAL,\n+    /** Announce a transaction with the same txid but different witness. May be announced by txid\n+     * depending on the peer's m_wtxid_relay. */\n+    INV_SAME_TXID_DIFF_WITNESS,\n+    /** Send the target transaction, perhaps unsolicited */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped, perhaps unsolicited */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated, perhaps unsolicited */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for something that may or may not have been requested */\n+    NOTFOUND,\n+};\n+\n+// What a peer may send in response to a getdata.\n+enum class PossibleResponse {\n+    /** Send the target transaction, in response to getdata */\n+    TX_REAL,\n+    /** Send a transaction with the witness stripped */\n+    TX_WITNESS_STRIPPED,\n+    /** Send a transaction with the witness malleated */\n+    TX_WITNESS_MALLEATED,\n+    /** Send a notfound for this getdata */\n+    NOTFOUND,\n+    /** Don't send anything (similar becoming unresponsive and/or stalling) */\n+    NOTHING,\n+    /** Push to the back of the message queue (similar to stalling and/or responding to messages out of order) */\n+    DEFER,\n+};\n+\n+// Possible states. Only possible state transitions are (start) NEVER_CONNECTED -> CONNECTED -> DISCONNECTED (terminal).\n+// Once a peer has disconnected, we won't reconnect them again within the test.\n+enum class ConnectionState {\n+    NEVER_CONNECTED = 0,\n+    CONNECTED,\n+    DISCONNECTED,\n+};\n+\n+static PossibleMessage ALL_MESSAGES[] = {\n+    PossibleMessage::NOTHING,\n+    PossibleMessage::INV_REAL,\n+    PossibleMessage::INV_SAME_TXID_DIFF_WITNESS,\n+    PossibleMessage::TX_REAL,\n+    PossibleMessage::TX_WITNESS_STRIPPED,\n+    PossibleMessage::TX_WITNESS_MALLEATED,\n+    PossibleMessage::NOTFOUND,\n+};\n+static PossibleResponse ALL_RESPONSES[] = {\n+    PossibleResponse::TX_REAL,\n+    PossibleResponse::TX_WITNESS_STRIPPED,\n+    PossibleResponse::TX_WITNESS_MALLEATED,\n+    PossibleResponse::NOTFOUND,\n+    PossibleResponse::NOTHING,\n+    PossibleResponse::DEFER,\n+};\n+\n+class TestPeer {\n+public:\n+    // Queue of getdats to respond to: process from front, add to back.\n+    std::deque<GenTxid> m_getdata_queue;\n+\n+    // Connection state\n+    ConnectionState m_connection_state{ConnectionState::NEVER_CONNECTED};\n+\n+    // NodeId even if not connected.\n+    NodeId m_nodeid;\n+\n+    // Whether this peer is \"good\"; the goal of this test is to verify that we can always download\n+    // a transaction as long as we have one such peer. We define a \"good\" peer as follows:\n+    // - only 2 possible unsolicited messages (NOTHING or INV_REAL exactly 1 time throughout the test)\n+    // - only 1 possible response to a getdata (TX_REAL)\n+    // - m_wtxid_relay=true\n+    // - never disconnects from us (at least while we're trying to download this transaction)\n+    //\n+    // A non-good peer can do everything the good peer might do, but also some other things.\n+    //\n+    // This definition is narrower than just being non-malicious in order to be useful. In real\n+    // life, an honest node may disconnect from us or forget a transaction (i.e. send a notfound).\n+    bool m_good;\n+\n+    // for TxDownloadConnectionInfo\n+    // Note that this is used to indicate when somebody is an outbound peer.\n+    bool m_connection_preferred{false};\n+    bool m_relay_permissions{false};\n+    bool m_wtxid_relay{true};\n+\n+    // Whether this peer has already sent announcement for the tx.\n+    bool m_sent_inv{false};\n+\n+    // Decide what kind of unsolicited message to send. This is the only place where we might decide\n+    // to announce the target transaction. Updates m_sent_inv if this happens.\n+    // When force_announce=true, if this is a \"good\" peer and the transaction hasn't already been\n+    // announced, always return INV_REAL.\n+    PossibleMessage SendOneMessage(FuzzedDataProvider& fuzzed_data_provider, bool force_announce = false) {\n+        // \"Good\" peers send the inv at most once, and otherwise will not send an unsolicited message.\n+        if (m_good) {\n+            if (!m_sent_inv && (force_announce || fuzzed_data_provider.ConsumeBool())) {\n+                m_sent_inv = true;\n+                return PossibleMessage::INV_REAL;\n+            }\n+            return PossibleMessage::NOTHING;\n+        }\n+\n+        // Non-good peers might send anything!\n+        auto message = fuzzed_data_provider.PickValueInArray(ALL_MESSAGES);\n+        if (message == PossibleMessage::INV_REAL) m_sent_inv = true;\n+        return message;\n+    }\n+\n+    // Process up to one message from the front of m_getdata_queue. The size of m_getdata_queue may\n+    // not change, as DEFER may just push it to the back again.\n+    PossibleResponse ProcessOneMessage(FuzzedDataProvider& fuzzed_data_provider) {\n+        // Nothing to do if no messages to process\n+        if (m_getdata_queue.empty()) return PossibleResponse::NOTHING;\n+\n+        auto request = m_getdata_queue.front();\n+        auto response{PossibleResponse::TX_REAL};\n+        if (!m_good) response = fuzzed_data_provider.PickValueInArray(ALL_RESPONSES);\n+\n+        // If DEFER, pop the request to the back of the queue and return nothing.\n+        // This simulates responding out of order and/or stalling.\n+        if (response == PossibleResponse::DEFER) {\n+            m_getdata_queue.push_back(request);\n+            m_getdata_queue.pop_front();\n+            return PossibleResponse::NOTHING;\n+        }\n+\n+        m_getdata_queue.pop_front();\n+        return response;\n+    }\n+};\n+\n+TestPeer RandomPeer(FuzzedDataProvider& fuzzed_data_provider, NodeId nodeid, bool preferred, bool force_good)\n+{\n+    TestPeer peer;\n+    peer.m_nodeid = nodeid;\n+    peer.m_good = force_good || fuzzed_data_provider.ConsumeBool();\n+    peer.m_connection_preferred = preferred;\n+    peer.m_relay_permissions = fuzzed_data_provider.ConsumeBool();\n+    // good peer should be at least WTXID_RELAY_VERSION\n+    peer.m_wtxid_relay = force_good || fuzzed_data_provider.ConsumeBool();\n+    return peer;\n+}\n+\n+const TestingSetup* g_setup;\n+constexpr size_t NUM_COINS{10};\n+COutPoint COINS[NUM_COINS];\n+\n+static CTransactionRef MakeTransactionSpending(const std::vector<COutPoint>& outpoints, size_t num_outputs, bool add_witness)\n+{\n+    CMutableTransaction tx;\n+    // If no outpoints are given, create a random one.\n+    for (const auto& outpoint : outpoints) {\n+        tx.vin.emplace_back(outpoint);\n+    }\n+    if (add_witness) {\n+        tx.vin[0].scriptWitness.stack.push_back({1});\n+    }\n+    tx.vout.emplace_back(CENT, P2WSH_OP_TRUE);\n+    return MakeTransactionRef(tx);\n+}\n+\n+static CTransactionRef Malleate(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.push_back({5});\n+    auto mutated_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == mutated_tx->GetHash());\n+    return mutated_tx;\n+}\n+\n+static CTransactionRef StripWitness(const CTransactionRef& ptx)\n+{\n+    CMutableTransaction tx(*ptx);\n+    tx.vin[0].scriptWitness.stack.clear();\n+    auto stripped_tx = MakeTransactionRef(tx);\n+    assert(ptx->GetHash() == stripped_tx->GetHash());\n+    return stripped_tx;\n+}\n+\n+void initialize()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{NUM_COINS}; ++i) {\n+        COINS[i] = COutPoint{Txid::FromUint256((HashWriter() << i).GetHash()), i};\n+    }\n+}\n+\n+// This test asserts that, as long as we have 1 good outbound peer, even if all other peers are\n+// malicious, we'll always be able to download a transaction.\n+// Connect to 8 outbounds and 0-120 inbound peers. 1 outbound is guaranteed to be good (see m_good\n+// above for definition), while the rest may or may not be.\n+// A non-good node has a superset of the actions available to a good node: it may stall a getdata,\n+// send a malleated or witness stripped tx/inv, send a notfound, etc.\n+FUZZ_TARGET(tx_download_one_honest_peer, .init = initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // Initialize txdownloadman\n+    bilingual_str error;\n+    CTxMemPool pool{MemPoolOptionsForTest(g_setup->m_node), error};\n+    const auto max_orphan_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 300);\n+    FastRandomContext det_rand{true};\n+\n+    // Make target transaction, malleated, and stripped\n+    auto target_tx{MakeTransactionSpending(\n+        {fuzzed_data_provider.PickValueInArray(COINS)},\n+        /*num_outputs=*/2,\n+        /*add_witness=*/fuzzed_data_provider.ConsumeBool())\n+    };\n+    auto malleated_tx = Malleate(target_tx);\n+    auto stripped_tx = StripWitness(target_tx);\n+    const auto& target_txid = target_tx->GetHash().ToUint256();\n+    const auto& target_wtxid = target_tx->GetWitnessHash().ToUint256();\n+    const auto& malleated_wtxid = malleated_tx->GetWitnessHash().ToUint256();\n+\n+    node::TxDownloadManager txdownloadman{node::TxDownloadOptions{pool, det_rand, max_orphan_count}};\n+    std::chrono::microseconds time{244466666};\n+\n+    // Decide what the peers are.\n+    std::vector<TestPeer> all_peers;\n+    // NodeId of the \"designated good peer\"\n+    // Other TestPeers may be \"good\" as well, but not guaranteed.\n+    NodeId honestid = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 7);\n+    // 8 outbound peers. NodeId = o. We indicate outbound using preferred=true\n+    for (unsigned int o = 0; o < 8; ++o) {\n+        bool good = (o == honestid) || fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, o, /*preferred=*/true, /*force_good=*/good));\n+    }\n+    // 0-120 inbound peers. NodeId = i. We indicate inbound using preferred=false\n+    auto num_inbound_peers = fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(0, 120);\n+    for (unsigned int i = 8; i < num_inbound_peers + 8; ++i) {\n+        bool good = fuzzed_data_provider.ConsumeBool();\n+        all_peers.emplace_back(RandomPeer(fuzzed_data_provider, i, /*preferred=*/false, /*force_good=*/good));\n+    }\n+\n+    // Indexes for random peer iteration\n+    std::vector<size_t> indexes;\n+    indexes.resize(all_peers.size());\n+    std::iota(indexes.begin(), indexes.end(), 0);\n+\n+    // We are trying to ensure that we always download the tx as long as we have 1 good outbound\n+    // peer who is able to send it to us.\n+    bool got_tx{false};\n+\n+    // Keep track of how many iterations the loop has done to make sure the target transaction is\n+    // announced within the first 1000 rounds. Note that the good peer is guaranteed to connect\n+    // within the first round and will never be disconnected.\n+    int counter = 0;\n+\n+    LIMITED_WHILE(!got_tx, 100000)\n+    {\n+        std::shuffle(indexes.begin(), indexes.end(), det_rand);",
      "path": "src/test/fuzz/txdownloadman_one_honest_peer.cpp",
      "position": null,
      "original_position": 284,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": 1728880703,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-23T15:10:10Z",
      "updated_at": "2024-08-23T15:10:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1729130506",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729130506"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729201357",
      "pull_request_review_id": 2257590987,
      "id": 1729201357,
      "node_id": "PRRC_kwDOABII585nEYTN",
      "diff_hunk": "@@ -3070,17 +3073,14 @@ std::optional<PeerManagerImpl::PackageToValidate> PeerManagerImpl::ProcessInvali\n                 // Eventually we should replace this with an improved\n                 // protocol for getting all unconfirmed parents.\n                 const auto gtxid{GenTxid::Txid(parent_txid)};\n-                if (peer) AddKnownTx(*peer, parent_txid);\n                 // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n                 // previously rejected for being too low feerate. This orphan might CPFP it.\n                 if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n                     m_txdownloadman.AddTxAnnouncement(nodeid, gtxid, current_time, /*p2p_inv=*/false);\n                 }\n             }\n \n-            if (m_orphanage.AddTx(ptx, nodeid)) {\n-                AddToCompactExtraTransactions(ptx);\n-            }\n+            add_extra_compact_tx &= m_orphanage.AddTx(ptx, nodeid);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 43,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "1468112dda32592a9fb5fdf177fc563d8f3e0aa1",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "just to be sure, was it intentional to use the bit-wise AND operator here, rather than the logical one (`&&=`), to avoid potential short-circuiting (see e.g. https://stackoverflow.com/questions/23107162/do-the-and-operators-for-bool-short-circuit)? IIUC, `add_extra_compact_tx` is always true at this point anyway (otherwise the if condition at the very top couldn't be true), so could also just do a regular assignment, I guess. But not sure what's better, one could argue that the current way is more future-proof.",
      "created_at": "2024-08-23T16:04:25Z",
      "updated_at": "2024-08-23T16:24:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1729201357",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1729201357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3083,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732688924",
      "pull_request_review_id": 2263061918,
      "id": 1732688924,
      "node_id": "PRRC_kwDOABII585nRrwc",
      "diff_hunk": "@@ -0,0 +1,157 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {\n+    /** Read-only reference to mempool. */\n+    const CTxMemPool& m_mempool;\n+    /** RNG provided by caller. */\n+    FastRandomContext& m_rng;\n+    /** Maximum number of transactions allowed in orphanage. */\n+    const uint32_t m_max_orphan_txs;\n+};\n+struct TxDownloadConnectionInfo {\n+    /** Whether this peer is preferred for transaction download. */\n+    const bool m_preferred;\n+    /** Whether this peer has Relay permissions. */\n+    const bool m_relay_permissions;\n+    /** Whether this peer supports wtxid relay. */\n+    const bool m_wtxid_relay;\n+};\n+struct PackageToValidate {\n+    Package m_txns;\n+    std::vector<NodeId> m_senders;\n+    /** Construct a 1-parent-1-child package. */\n+    explicit PackageToValidate(const CTransactionRef& parent,\n+                               const CTransactionRef& child,\n+                               NodeId parent_sender,\n+                               NodeId child_sender) :\n+        m_txns{parent, child},\n+        m_senders{parent_sender, child_sender}\n+    {}\n+\n+    // Move ctor\n+    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\n+    // Copy ctor\n+    PackageToValidate(const PackageToValidate& other) = default;\n+\n+    // Move assignment\n+    PackageToValidate& operator=(PackageToValidate&& other) {\n+        this->m_txns = std::move(other.m_txns);\n+        this->m_senders = std::move(other.m_senders);\n+        return *this;\n+    }\n+\n+    std::string ToString() const {\n+        Assume(m_txns.size() == 2);\n+        return strprintf(\"parent %s (wtxid=%s, sender=%d) + child %s (wtxid=%s, sender=%d)\",\n+                         m_txns.front()->GetHash().ToString(),\n+                         m_txns.front()->GetWitnessHash().ToString(),\n+                         m_senders.front(),\n+                         m_txns.back()->GetHash().ToString(),\n+                         m_txns.back()->GetWitnessHash().ToString(),\n+                         m_senders.back());\n+    }\n+};\n+struct RejectedTxTodo\n+{\n+    bool m_should_add_extra_compact_tx;\n+    std::vector<uint256> m_unique_parents;\n+    std::optional<PackageToValidate> m_package_to_validate;\n+};\n+\n+\n+class TxDownloadManager {\n+    const std::unique_ptr<TxDownloadImpl> m_impl;",
      "path": "src/node/txdownloadman.h",
      "position": null,
      "original_position": 101,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": 1728863544,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-27T11:45:20Z",
      "updated_at": "2024-08-27T11:45:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1732688924",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732688924"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732689092",
      "pull_request_review_id": 2263062110,
      "id": 1732689092,
      "node_id": "PRRC_kwDOABII585nRrzE",
      "diff_hunk": "@@ -0,0 +1,81 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txdownloadman.h>\n+#include <node/txdownloadman_impl.h>\n+\n+namespace node {\n+\n+TxDownloadManager::TxDownloadManager(const TxDownloadOptions& options) :\n+    m_impl{std::make_unique<TxDownloadImpl>(options)}\n+{}\n+TxDownloadManager::~TxDownloadManager() = default;\n+\n+void TxDownloadManager::ActiveTipChange()",
      "path": "src/node/txdownloadman.cpp",
      "position": null,
      "original_position": 15,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": 1728887570,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2024-08-27T11:45:25Z",
      "updated_at": "2024-08-27T11:45:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1732689092",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732689092"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732691023",
      "pull_request_review_id": 2263065206,
      "id": 1732691023,
      "node_id": "PRRC_kwDOABII585nRsRP",
      "diff_hunk": "@@ -3070,17 +3073,14 @@ std::optional<PeerManagerImpl::PackageToValidate> PeerManagerImpl::ProcessInvali\n                 // Eventually we should replace this with an improved\n                 // protocol for getting all unconfirmed parents.\n                 const auto gtxid{GenTxid::Txid(parent_txid)};\n-                if (peer) AddKnownTx(*peer, parent_txid);\n                 // Exclude m_lazy_recent_rejects_reconsiderable: the missing parent may have been\n                 // previously rejected for being too low feerate. This orphan might CPFP it.\n                 if (!m_txdownloadman.AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) {\n                     m_txdownloadman.AddTxAnnouncement(nodeid, gtxid, current_time, /*p2p_inv=*/false);\n                 }\n             }\n \n-            if (m_orphanage.AddTx(ptx, nodeid)) {\n-                AddToCompactExtraTransactions(ptx);\n-            }\n+            add_extra_compact_tx &= m_orphanage.AddTx(ptx, nodeid);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 43,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "1468112dda32592a9fb5fdf177fc563d8f3e0aa1",
      "in_reply_to_id": 1729201357,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, we don't want a short circuit, though in practice `add_extra_compact_tx` should always be true at this point in the code. I've added a comment describing what the expected changes can be.",
      "created_at": "2024-08-27T11:46:43Z",
      "updated_at": "2024-08-27T11:46:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1732691023",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732691023"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3083,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734517492",
      "pull_request_review_id": 2266000970,
      "id": 1734517492,
      "node_id": "PRRC_kwDOABII585nYqL0",
      "diff_hunk": "@@ -0,0 +1,34 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class TxOrphanage;\n+class TxRequestTracker;\n+class CRollingBloomFilter;\n+\n+namespace node {\n+class TxDownloadImpl;",
      "path": "src/node/txdownloadman.h",
      "position": null,
      "original_position": 16,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "58fb38c182906645161af04e84becc824dee2ba5",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "At first I was wondering if their is any benefit of not declaring the implementation class private to `TxDownloadManager` as recommended in https://en.cppreference.com/w/cpp/language/pimpl.\r\n\r\nBut then after the first pass of this PR, I think the reason is to make `TxDownloadManagerImpl` visible to the entire namespace in other to  allow for testing `TxDownloadManagerImpl` specific behaviors in fuzzing.\r\n\r\n",
      "created_at": "2024-08-28T11:36:34Z",
      "updated_at": "2024-08-28T12:57:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734517492",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734517492"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734535670",
      "pull_request_review_id": 2266000970,
      "id": 1734535670,
      "node_id": "PRRC_kwDOABII585nYun2",
      "diff_hunk": "@@ -0,0 +1,34 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 4,
      "original_position": 4,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "58fb38c182906645161af04e84becc824dee2ba5",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In 58fb38c182906645161af04e84becc824dee2ba5 \" [refactor] add TxDownloadManager wrapping TxOrphanage, TxRequestTracker, and bloom filters\"\r\n\r\n\r\nI think the file name should be txdownloadman.cpp ?\r\n`TxDownloadManager` is the public interface.",
      "created_at": "2024-08-28T11:48:46Z",
      "updated_at": "2024-08-28T12:57:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734535670",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734535670"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4,
      "original_line": 4,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734554084",
      "pull_request_review_id": 2266000970,
      "id": 1734554084,
      "node_id": "PRRC_kwDOABII585nYzHk",
      "diff_hunk": "@@ -1672,6 +1582,8 @@ void PeerManagerImpl::AddTxAnnouncement(const CNode& node, const GenTxid& gtxid,\n     AssertLockHeld(::cs_main); // for State\n     AssertLockHeld(m_tx_download_mutex); // For m_txrequest",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 146,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "58fb38c182906645161af04e84becc824dee2ba5",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    AssertLockHeld(m_tx_download_mutex); // For m_txdownloadman\r\n```",
      "created_at": "2024-08-28T12:03:24Z",
      "updated_at": "2024-08-28T12:57:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734554084",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734554084"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1583,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734565020",
      "pull_request_review_id": 2266000970,
      "id": 1734565020,
      "node_id": "PRRC_kwDOABII585nY1yc",
      "diff_hunk": "@@ -0,0 +1,157 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {\n+    /** Read-only reference to mempool. */\n+    const CTxMemPool& m_mempool;\n+    /** RNG provided by caller. */\n+    FastRandomContext& m_rng;\n+    /** Maximum number of transactions allowed in orphanage. */\n+    const uint32_t m_max_orphan_txs;\n+};\n+struct TxDownloadConnectionInfo {\n+    /** Whether this peer is preferred for transaction download. */\n+    const bool m_preferred;\n+    /** Whether this peer has Relay permissions. */\n+    const bool m_relay_permissions;\n+    /** Whether this peer supports wtxid relay. */\n+    const bool m_wtxid_relay;\n+};\n+struct PackageToValidate {\n+    Package m_txns;\n+    std::vector<NodeId> m_senders;\n+    /** Construct a 1-parent-1-child package. */\n+    explicit PackageToValidate(const CTransactionRef& parent,\n+                               const CTransactionRef& child,\n+                               NodeId parent_sender,\n+                               NodeId child_sender) :\n+        m_txns{parent, child},\n+        m_senders{parent_sender, child_sender}\n+    {}\n+\n+    // Move ctor\n+    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\n+    // Copy ctor\n+    PackageToValidate(const PackageToValidate& other) = default;\n+\n+    // Move assignment\n+    PackageToValidate& operator=(PackageToValidate&& other) {\n+        this->m_txns = std::move(other.m_txns);\n+        this->m_senders = std::move(other.m_senders);\n+        return *this;\n+    }\n+\n+    std::string ToString() const {\n+        Assume(m_txns.size() == 2);\n+        return strprintf(\"parent %s (wtxid=%s, sender=%d) + child %s (wtxid=%s, sender=%d)\",\n+                         m_txns.front()->GetHash().ToString(),\n+                         m_txns.front()->GetWitnessHash().ToString(),\n+                         m_senders.front(),\n+                         m_txns.back()->GetHash().ToString(),\n+                         m_txns.back()->GetWitnessHash().ToString(),\n+                         m_senders.back());\n+    }\n+};\n+struct RejectedTxTodo\n+{\n+    bool m_should_add_extra_compact_tx;\n+    std::vector<uint256> m_unique_parents;\n+    std::optional<PackageToValidate> m_package_to_validate;\n+};\n+\n+\n+class TxDownloadManager {\n+    const std::unique_ptr<TxDownloadImpl> m_impl;",
      "path": "src/node/txdownloadman.h",
      "position": null,
      "original_position": 101,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": 1728863544,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The update was effected in the second commit",
      "created_at": "2024-08-28T12:12:09Z",
      "updated_at": "2024-08-28T12:57:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734565020",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734565020"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734663166",
      "pull_request_review_id": 2266240226,
      "id": 1734663166,
      "node_id": "PRRC_kwDOABII585nZNv-",
      "diff_hunk": "@@ -0,0 +1,34 @@\n+// Copyright (c) 2024\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+",
      "path": "src/node/txdownloadman_impl.cpp",
      "position": 4,
      "original_position": 4,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "58fb38c182906645161af04e84becc824dee2ba5",
      "in_reply_to_id": 1734535670,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It contains the implementation for `TxDownloadManagerImpl` as well.",
      "created_at": "2024-08-28T13:18:31Z",
      "updated_at": "2024-08-28T13:18:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734663166",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734663166"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4,
      "original_line": 4,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734686231",
      "pull_request_review_id": 2266280167,
      "id": 1734686231,
      "node_id": "PRRC_kwDOABII585nZTYX",
      "diff_hunk": "@@ -1672,6 +1582,8 @@ void PeerManagerImpl::AddTxAnnouncement(const CNode& node, const GenTxid& gtxid,\n     AssertLockHeld(::cs_main); // for State\n     AssertLockHeld(m_tx_download_mutex); // For m_txrequest",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 146,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "58fb38c182906645161af04e84becc824dee2ba5",
      "in_reply_to_id": 1734554084,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Assuming this is on one of the earlier commits - the whole line is deleted in 0e6e135e303",
      "created_at": "2024-08-28T13:32:17Z",
      "updated_at": "2024-08-28T13:32:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734686231",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734686231"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1583,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734688133",
      "pull_request_review_id": 2266283496,
      "id": 1734688133,
      "node_id": "PRRC_kwDOABII585nZT2F",
      "diff_hunk": "@@ -0,0 +1,157 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXDOWNLOADMAN_H\n+#define BITCOIN_NODE_TXDOWNLOADMAN_H\n+\n+#include <net.h>\n+#include <policy/packages.h>\n+\n+#include <cstdint>\n+#include <memory>\n+\n+class CBlock;\n+class CBlockIndex;\n+class CRollingBloomFilter;\n+class CTxMemPool;\n+class GenTxid;\n+class TxOrphanage;\n+class TxRequestTracker;\n+enum class ChainstateRole;\n+namespace node {\n+class TxDownloadImpl;\n+\n+/** Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which\n+ *  point the OVERLOADED_PEER_TX_DELAY kicks in. */\n+static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n+/** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n+static constexpr auto TXID_RELAY_DELAY{2s};\n+/** How long to delay requesting transactions from non-preferred peers */\n+static constexpr auto NONPREF_PEER_TX_DELAY{2s};\n+/** How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). */\n+static constexpr auto OVERLOADED_PEER_TX_DELAY{2s};\n+/** How long to wait before downloading a transaction from an additional peer */\n+static constexpr auto GETDATA_TX_INTERVAL{60s};\n+struct TxDownloadOptions {\n+    /** Read-only reference to mempool. */\n+    const CTxMemPool& m_mempool;\n+    /** RNG provided by caller. */\n+    FastRandomContext& m_rng;\n+    /** Maximum number of transactions allowed in orphanage. */\n+    const uint32_t m_max_orphan_txs;\n+};\n+struct TxDownloadConnectionInfo {\n+    /** Whether this peer is preferred for transaction download. */\n+    const bool m_preferred;\n+    /** Whether this peer has Relay permissions. */\n+    const bool m_relay_permissions;\n+    /** Whether this peer supports wtxid relay. */\n+    const bool m_wtxid_relay;\n+};\n+struct PackageToValidate {\n+    Package m_txns;\n+    std::vector<NodeId> m_senders;\n+    /** Construct a 1-parent-1-child package. */\n+    explicit PackageToValidate(const CTransactionRef& parent,\n+                               const CTransactionRef& child,\n+                               NodeId parent_sender,\n+                               NodeId child_sender) :\n+        m_txns{parent, child},\n+        m_senders{parent_sender, child_sender}\n+    {}\n+\n+    // Move ctor\n+    PackageToValidate(PackageToValidate&& other) : m_txns{std::move(other.m_txns)}, m_senders{std::move(other.m_senders)} {}\n+    // Copy ctor\n+    PackageToValidate(const PackageToValidate& other) = default;\n+\n+    // Move assignment\n+    PackageToValidate& operator=(PackageToValidate&& other) {\n+        this->m_txns = std::move(other.m_txns);\n+        this->m_senders = std::move(other.m_senders);\n+        return *this;\n+    }\n+\n+    std::string ToString() const {\n+        Assume(m_txns.size() == 2);\n+        return strprintf(\"parent %s (wtxid=%s, sender=%d) + child %s (wtxid=%s, sender=%d)\",\n+                         m_txns.front()->GetHash().ToString(),\n+                         m_txns.front()->GetWitnessHash().ToString(),\n+                         m_senders.front(),\n+                         m_txns.back()->GetHash().ToString(),\n+                         m_txns.back()->GetWitnessHash().ToString(),\n+                         m_senders.back());\n+    }\n+};\n+struct RejectedTxTodo\n+{\n+    bool m_should_add_extra_compact_tx;\n+    std::vector<uint256> m_unique_parents;\n+    std::optional<PackageToValidate> m_package_to_validate;\n+};\n+\n+\n+class TxDownloadManager {\n+    const std::unique_ptr<TxDownloadImpl> m_impl;",
      "path": "src/node/txdownloadman.h",
      "position": null,
      "original_position": 101,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "6a84ab77f36445fd37d46a08c71bd4373201d300",
      "in_reply_to_id": 1728863544,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Woops, ran the script from `HEAD~24` instead of `HEAD~25`. Fixed now.",
      "created_at": "2024-08-28T13:33:25Z",
      "updated_at": "2024-08-28T13:33:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734688133",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734688133"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734804944",
      "pull_request_review_id": 2266475743,
      "id": 1734804944,
      "node_id": "PRRC_kwDOABII585nZwXQ",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+\n+    // A new TxDownloadManagerImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+    node::TxDownloadConnectionInfo connection_info{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};",
      "path": "src/test/txdownload_tests.cpp",
      "position": 99,
      "original_position": 99,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "caedaec23a7ffd08b1cb7f45966857148a25eeec",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "IIUC this would at least give more coverage to `AddTxAnnouncement` getting deeper during new orphan processing",
      "created_at": "2024-08-28T14:33:35Z",
      "updated_at": "2024-08-28T14:34:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734804944",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734804944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 99,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734817526",
      "pull_request_review_id": 2266495841,
      "id": 1734817526,
      "node_id": "PRRC_kwDOABII585nZzb2",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_processing.h>\n+#include <node/txdownloadman_impl.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <array>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txdownload_tests, TestingSetup)\n+\n+struct Behaviors {\n+    bool m_txid_in_rejects;\n+    bool m_wtxid_in_rejects;\n+    bool m_txid_in_rejects_recon;\n+    bool m_wtxid_in_rejects_recon;\n+    bool m_keep_for_compact;\n+    bool m_ignore_inv_txid;\n+    bool m_ignore_inv_wtxid;\n+\n+    // Constructor. We are passing and casting ints because they are more readable in a table (see all_expected_results).\n+    Behaviors(bool txid_rejects, bool wtxid_rejects, bool txid_recon, bool wtxid_recon, bool keep, bool txid_inv, bool wtxid_inv) :\n+        m_txid_in_rejects(txid_rejects),\n+        m_wtxid_in_rejects(wtxid_rejects),\n+        m_txid_in_rejects_recon(txid_recon),\n+        m_wtxid_in_rejects_recon(wtxid_recon),\n+        m_keep_for_compact(keep),\n+        m_ignore_inv_txid(txid_inv),\n+        m_ignore_inv_wtxid(wtxid_inv)\n+    {}\n+\n+    void CheckEqual(const Behaviors& other, bool segwit)\n+    {\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects,       m_wtxid_in_rejects);\n+        BOOST_CHECK_EQUAL(other.m_wtxid_in_rejects_recon, m_wtxid_in_rejects_recon);\n+        BOOST_CHECK_EQUAL(other.m_keep_for_compact,       m_keep_for_compact);\n+        BOOST_CHECK_EQUAL(other.m_ignore_inv_wtxid,       m_ignore_inv_wtxid);\n+\n+        // false negatives for nonsegwit transactions, since txid == wtxid.\n+        if (segwit) {\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects,        m_txid_in_rejects);\n+            BOOST_CHECK_EQUAL(other.m_txid_in_rejects_recon,  m_txid_in_rejects_recon);\n+            BOOST_CHECK_EQUAL(other.m_ignore_inv_txid,        m_ignore_inv_txid);\n+        }\n+    }\n+};\n+\n+// Map from failure reason to expected behavior for a segwit tx that fails\n+// Txid and Wtxid are assumed to be different here. For a nonsegwit transaction, use the wtxid results.\n+static std::map<TxValidationResult, Behaviors> expected_behaviors{\n+    {TxValidationResult::TX_CONSENSUS,               {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECENT_CONSENSUS_CHANGE, {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_INPUTS_NOT_STANDARD,     {/*txid_rejects*/1, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/1, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NOT_STANDARD,            {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MISSING_INPUTS,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_PREMATURE_SPEND,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_MUTATED,         {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_WITNESS_STRIPPED,        {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/0, /*txid_inv*/0, /*wtxid_inv*/0}},\n+    {TxValidationResult::TX_CONFLICT,                {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_MEMPOOL_POLICY,          {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_NO_MEMPOOL,              {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_RECONSIDERABLE,          {/*txid_rejects*/0, /*wtxid_rejects*/0, /*txid_recon*/0, /*wtxid_recon*/1, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+    {TxValidationResult::TX_UNKNOWN,                 {/*txid_rejects*/0, /*wtxid_rejects*/1, /*txid_recon*/0, /*wtxid_recon*/0, /*keep*/1, /*txid_inv*/0, /*wtxid_inv*/1}},\n+};\n+\n+static std::vector<CTransactionRef> CreateTransactionChain(size_t num_txns, bool segwit)\n+{\n+    // Ensure every transaction has a different txid by having each one spend the previous one.\n+    static Txid prevout_hash{};\n+\n+    std::vector<CTransactionRef> txns;\n+    txns.reserve(num_txns);\n+    for (uint32_t i = 0; i < num_txns; ++i) {\n+        CMutableTransaction mtx;\n+        mtx.vin.emplace_back(prevout_hash, 0);\n+        // This makes txid != wtxid\n+        if (segwit) mtx.vin[0].scriptWitness.stack.push_back({1});\n+        mtx.vout.emplace_back(CENT, CScript());\n+        auto ptx{MakeTransactionRef(mtx)};\n+        txns.emplace_back(ptx);\n+        prevout_hash = ptx->GetHash();\n+    }\n+    return txns;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(tx_rejection_types, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    FastRandomContext det_rand{true};\n+\n+    // A new TxDownloadManagerImpl is created for each tx so we can just reuse the same one.\n+    TxValidationState state;\n+    NodeId nodeid{0};\n+    std::chrono::microseconds now{GetTime()};\n+    node::TxDownloadConnectionInfo connection_info{/*m_preferred=*/false, /*m_relay_permissions=*/false, /*m_wtxid_relay=*/true};",
      "path": "src/test/txdownload_tests.cpp",
      "position": 99,
      "original_position": 99,
      "commit_id": "1d4e33e7f88162cf6fcd6aee0b63973015853591",
      "original_commit_id": "caedaec23a7ffd08b1cb7f45966857148a25eeec",
      "in_reply_to_id": 1734804944,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right. I'm also building my orphan resolution branch that effectively skips adding orphans for peers that aren't \"registered\" (we need to know their connection info to decide some params). These tests started failing there, so I had to add `ConnectPeer`. Figured it makes sense to do this now.",
      "created_at": "2024-08-28T14:40:28Z",
      "updated_at": "2024-08-28T14:40:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30110#discussion_r1734817526",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1734817526"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30110"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 99,
      "original_line": 99,
      "side": "RIGHT"
    }
  ]
}