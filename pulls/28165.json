{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
    "id": 1450858997,
    "node_id": "PR_kwDOABII585Weln1",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/28165",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/28165.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/28165.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28165",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28165/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/678809e00178b33e273f0775eea9635fecaf386a",
    "number": 28165,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "net: transport abstraction",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This PR furthers the P2P message serialization/deserialization abstraction introduced in #16202 and #16562, in preparation for introducing the BIP324 v2 transport (making this part of #27634). However, nothing in this PR is BIP324-specific, and it contains a number of independently useful improvements.\r\n\r\nThe overall idea is to have a single object in every `CNode` (called `m_transport`) that is responsible for converting sent messages to wire bytes, and for converting received wire bytes back to messages, while having as little as possible knowledge about this conversion process in higher-level net code. To accomplish that, there is an abstract `Transport` class with (currently) a single `V1Transport` implementation.\r\n\r\nStructurally, the above is accomplished by:\r\n* Merging the `TransportDeserializer` and `TransportSerializer` classes into a single `Transport` class, which encompasses both the sending and receiving side. For `V1Transport` these two sides are entirely separate, but this assumption doesn't hold for the BIP324 transport where e.g. the sending encryption key depends on the DH key negotiation data received from the other side. Merging the two means a future `V2Transport` can handle all this interaction without callers needing to be aware.\r\n* Removing the assumption that each message is sent using a computed header followed by (unmodified) data bytes. To achieve that, the sending side of `Transport` mirrors what the receiver side does: callers can set a message to be sent, then ask what bytes must be sent out, and then allowing them to transition to the next message.\r\n* Adding internal locks to protect the sending and receiving state of the `V1Transport` implementation. I believe these aren't strictly needed (opinions welcome) as there is no real way to use `Transport` objects in a multi-threaded fashion without some form of external synchronization (e.g. \"get next bytes to send\" isn't meaningful to call from multiple threads at the same time without mechanism to control the order they'll actually get sent). Still, I feel it's cleaner to make the object responsible for its own consistency (as we definitely do not want the entire object to be under a single external GUARDED_BY, as that'd prevent simultaneous sending and receiving).\r\n* Moving the conversion of messages to bytes on the sending side from `PushMessage` to `SocketSendData`, which is needed to deal with the fact that a transport may not immediately be able to send messages.\r\n\r\nThis PR is not a refactor, though some commits are. Among the semantic changes are:\r\n* Changing the send buffer pushback mechanism to trigger based on the memory usage of the buffer rather than the amount of bytes to be sent. This is both closer to the desired behavior, and makes the buffering independent from transport details (which is why it's included here).\r\n* When optimistic send is not applicable, the V1 message checksum calculation now runs in the net thread rather than the message handling thread. I believe that's generally an improvement, as the message handling thread is far more computationally bottlenecked already.\r\n* The checksum calculation now runs under the `CNode::cs_vSend` lock, which does mean no two checksum calculations for messages sent to the same node can run in parallel, even if running in separate threads. Despite that limitation, having the checksum for non-optimistic sends moved in the net thread is still an improvement, I believe.\r\n* Statistics for per-message-type sent bytes are now updated when the bytes are actually handed to the OS rather than in `PushMessage`. This is because the actual serialized sizes aren't known until they've gone through the transport object.\r\n\r\nA fuzz test of the entire `V1Transport` is included. More elaborate rationale for each of the changes can be found in the commit messages.",
    "labels": [
      {
        "id": 98298007,
        "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
        "name": "P2P",
        "color": "006b75",
        "default": false
      }
    ],
    "created_at": "2023-07-26T20:04:07Z",
    "updated_at": "2023-08-22T17:57:28Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "307cacbf0b07a4bdd878ad543f0fb327a2cfb135",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sipa:202307_merge_sers",
      "ref": "202307_merge_sers",
      "sha": "678809e00178b33e273f0775eea9635fecaf386a",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 22,
        "stargazers_count": 84,
        "watchers_count": 84,
        "size": 218650,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-21T22:25:02Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2023-08-21T21:10:58Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "ded687334031f4790ef6a36b999fb30a79dcf7b3",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35573,
        "stargazers_count": 71022,
        "watchers_count": 71022,
        "size": 237916,
        "default_branch": "master",
        "open_issues_count": 671,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-22T17:56:44Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-08-22T17:27:20Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 562,
    "deletions": 134,
    "changed_files": 8,
    "commits": 9,
    "review_comments": 106,
    "comments": 10
  },
  "events": [
    {
      "event": "commented",
      "id": 1652418427,
      "node_id": "IC_kwDOABII585ifed7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1652418427",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-26T20:04:10Z",
      "updated_at": "2023-08-22T15:08:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [vasild](https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1588883611), [Sjors](https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1688378806) |\n| Concept ACK | [dergoegge](https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1658115391), [jonatack](https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1662963276), [theStack](https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1566293438), [mzumsande](https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1573562580) |\n| Stale ACK | [vincenzopalazzo](https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1584989873) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1652418427",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28165"
    },
    {
      "event": "labeled",
      "id": 9928241366,
      "node_id": "LE_lADOABII585sqgK1zwAAAAJPxPDW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9928241366",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-26T20:04:11Z",
      "label": {
        "name": "P2P",
        "color": "006b75"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-26T20:06:23Z",
      "updated_at": "2023-07-26T20:06:23Z",
      "source": {
        "issue": {
          "id": 1707054771,
          "node_id": "I_kwDOABII585lv5az",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27634",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27634/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27634/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27634/events",
          "html_url": "https://github.com/bitcoin/bitcoin/issues/27634",
          "number": 27634,
          "state": "open",
          "state_reason": null,
          "title": "BIP324 tracking issue",
          "body": "This issue will be updated to reflect the current state of [BIP324](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki) integration.\r\n\r\nPRs ready for review:\r\n* #28165\r\n\r\nOverall plan:\r\n* [x] ElligatorSwift integration in Bitcoin Core: #27479 \r\n  * [x] Dependency: ElligatorSwift support in libsecp256k1: bitcoin-core/secp256k1#1129\r\n  * [x] Dependency: update libsecp256k1 subtree: currently part of 27479.\r\n* [x] Cipher suite implementation (formerly 25361):\r\n  * [x] Support for not wasting ChaCha20 stream bytes: #26153\r\n  * [x] Support for RFC8439 variant of ChaCha20: #27985\r\n  * [x] Support for incremental Poly1305 computation: #27993\r\n  * [x] Cipher suite: #28008\r\n* [ ] P2P v2 connection support (formerly 23561, 23233, 24545):\r\n  * [ ] P2P transport abstraction: #28165\r\n  * [ ] BIP324 connection support: #28196\r\n* [ ] P2P v2 signalling integration (formerly 24545): no PR yet\r\n* [ ] BIP324 functional tests: #24748:\r\n   * [x] Dependency: ElligatorSwift support in functional tests: #24005\r\n   * [x] Dependency: Field element support in functional tests: #26222\r\n* [ ] P2P_V2 service flag support in DNS seeder: sipa/bitcoin-seeder#102\r\n* [x] Prehistory:\r\n  * [x] Old ChaCha20Poly1305@Bitcoin cipher: #15649\r\n  * [x] Preparing for multiple transport layers: #16202 and #16562\r\n  * [x] Miscellaneous fixes: #22331 #23271\r\n  * [x] ChaCha20 performance: #24946 \r\n",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 1,
          "created_at": "2023-05-12T07:00:54Z",
          "updated_at": "2023-08-14T12:04:35Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-27T05:39:20Z",
      "updated_at": "2023-07-27T05:39:20Z",
      "source": {
        "issue": {
          "id": 1775568246,
          "node_id": "PR_kwDOABII585T9n4e",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27981",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27981/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27981/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27981/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27981",
          "number": 27981,
          "state": "closed",
          "state_reason": null,
          "title": "Fix potential network stalling bug",
          "body": "See https://github.com/ElementsProject/elements/issues/1233. There, it has been observed that if both sides of a P2P connection have a significant amount of data to send, a stall can occur, where both try to drain their own send queue before trying to receive. The same issue seems to apply to the current Bitcoin Core codebase, though I don't know whether it's a frequent issue for us.\r\n\r\nThe core issue is that whenever our optimistic send fails to fully send a message, we do subsequently not even select() for receiving; if it then turns out that sending is not possible either, no progress is made at all. To address this, the solution used in this PR is to still select() for both sending and receiving when an optimistic send fails, but skip receiving if sending succeeded, and (still) doesn't fully drain the send queue.\r\n\r\nThis is a significant reduction in how aggressive the \"receive pushback\" mechanism is, because now it will only mildly push back while sending progress is made; if the other side stops receiving entirely, the pushback disappears. I don't think that's a serious problem though:\r\n* We still have a pushback mechanism at the application buffer level (when the application receive buffer overflows, receiving is paused until messages in the buffer get processed; waiting on our own net_processing thread, not on the remote party).\r\n* There are cases where the existing mechanism is too aggressive; e.g. when the send queue is non-empty, but tiny, and can be sent with a single send() call. In that case, I think we'd prefer to still receive within the same processing loop of the network thread.\r\n",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 16,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27981",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27981",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27981.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27981.patch"
          },
          "closed_at": "2023-08-17T12:15:55Z",
          "created_at": "2023-06-26T20:37:36Z",
          "updated_at": "2023-08-18T15:42:00Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-27T08:33:42Z",
      "updated_at": "2023-07-27T08:33:42Z",
      "source": {
        "issue": {
          "id": 1652089479,
          "node_id": "PR_kwDOABII585Nfb4D",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27407",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27407/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27407/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27407/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27407",
          "number": 27407,
          "state": "closed",
          "state_reason": null,
          "title": "net, refactor: Privatise CNode send queue",
          "body": "The send queue members on `CNode` should not be part of the public interface. This PR makes all of them private and creates a clear interface for the send queue.\r\n\r\nThe interface after this PR consists of:\r\n* `CNode::PushMessage` for appending a message onto the send queue\r\n* `CNode::SocketSendData` for pushing as many messages from the send queue as possible onto the wire\r\n* `CNode::IsSendQueueEmpty` for checking if the send queue is empty\r\n* (`CNode::TestOnlyClearSendQueue` a test-only utility for clearing the send queue)",
          "user": {
            "login": "dergoegge",
            "id": 8077169,
            "node_id": "MDQ6VXNlcjgwNzcxNjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dergoegge",
            "html_url": "https://github.com/dergoegge",
            "followers_url": "https://api.github.com/users/dergoegge/followers",
            "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
            "organizations_url": "https://api.github.com/users/dergoegge/orgs",
            "repos_url": "https://api.github.com/users/dergoegge/repos",
            "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dergoegge/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 1,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27407",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27407",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27407.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27407.patch"
          },
          "closed_at": "2023-08-07T14:02:48Z",
          "created_at": "2023-04-03T13:36:50Z",
          "updated_at": "2023-08-07T14:02:48Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9955413836,
      "node_id": "HRFPE_lADOABII585sqgK1zwAAAAJRY49M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9955413836",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-29T20:56:43Z"
    },
    {
      "event": "commented",
      "id": 1658115391,
      "node_id": "IC_kwDOABII585i1NU_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1658115391",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-31T10:41:11Z",
      "updated_at": "2023-07-31T10:41:11Z",
      "author_association": "MEMBER",
      "body": "Concept ACK\r\n\r\n> Merging the two means a future V2Transport can handle all this interaction without callers needing to be aware.\r\n\r\nðŸš€",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1658115391",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28165"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9966489038,
      "node_id": "HRFPE_lADOABII585sqgK1zwAAAAJSDI3O",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9966489038",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-31T16:54:25Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T17:56:59Z",
      "updated_at": "2023-08-01T17:56:59Z",
      "source": {
        "issue": {
          "id": 1831769418,
          "node_id": "PR_kwDOABII585W74nW",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/28196",
          "number": 28196,
          "state": "open",
          "state_reason": null,
          "title": "BIP324 connection support",
          "body": "Builds on top of #28165, and part of #27634. Draft while dependencies and (more) tests are missing.\r\n\r\nThis implements the BIP324 v2 transport and application layer. It is currently only accessible through the test-only `-bip324=` command-line option, which specifies IPs, host names, or subnets for which to use BIP324 connections. This option is only added in order to make experimentation possible; I don't expect it will be supported long-term (or should even remain in this PR).\r\n\r\nStill missing features are:\r\n* Support for the `NODE_P2P_V2` service flag.\r\n* Automatically trying V2 connections when the service flag is set.\r\n* Retrying downgrade to V1 when attempted outbound V2 connections immediately fail.\r\n* P2P functional tests (only a fuzz test for the transport is included, and a few bitcoind-to-bitcoind functional tests)\r\n\r\nOther than that, support for V2 connections is functionally complete, including:\r\n* Autodetection of incoming V1 connections.\r\n* Garbage, both sending and receiving.\r\n* Short message type IDs, both sending and receiving.\r\n* Ignore packets (receiving only, and untested).\r\n* Session IDs are visible in `getpeerinfo` output (for manual comparison).\r\n",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 1,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/28196",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/28196.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/28196.patch"
          },
          "created_at": "2023-08-01T17:56:58Z",
          "updated_at": "2023-08-22T09:59:23Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1662963276,
      "node_id": "IC_kwDOABII585jHs5M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662963276",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T21:04:45Z",
      "updated_at": "2023-08-02T21:04:45Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1662963276",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28165"
    },
    {
      "event": "reviewed",
      "id": 1560842698,
      "node_id": "PRR_kwDOABII585dCJHK",
      "url": null,
      "actor": null,
      "commit_id": "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK\r\n\r\nMostly happy with b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e. Minor inline suggestions and/or making sure I understand what the code is doing.\r\n\r\nI also checked that all intermediate commits compile and ran the new fuzzer for several hours (but didn't study it very carefully).\r\n\r\n* 1937a5fcf795149c44b7f4f016c05000ac3adaf9: `-maxsendbuffer` help could be changed to say \"Maximum per-connection memory use for the send buffer\"\r\n* 68e48a0185751d24eecb194b8efd7028c8b590f3: can you elaborate a bit in the commit description why `nSendOffset` can be dropped?",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1560842698",
      "submitted_at": "2023-08-03T17:07:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
    },
    {
      "event": "commented",
      "id": 1664651486,
      "node_id": "IC_kwDOABII585jOJDe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1664651486",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-03T21:09:23Z",
      "updated_at": "2023-08-03T21:10:26Z",
      "author_association": "MEMBER",
      "body": "> https://github.com/bitcoin/bitcoin/commit/68e48a0185751d24eecb194b8efd7028c8b590f3: can you elaborate a bit in the commit description why nSendOffset can be dropped?\r\n\r\nIn the current codebase, the send buffering (= remembering the to-be-sent bytes which we haven't managed to send yet) is done using `vSendMsg` (a queue of *byte arrays*) + `nSendOffset` (the position within `vSendMsg[0]` up to where we've sent things). After this PR, `vSendMsg` is turned into a queue of *messages*, which have not yet been converted to bytes-on-the-wire; this conversion is now handled by `m_transport`, and it's the transport that remembers what/how much has been sent yet.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1664651486",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28165"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-05T20:31:01Z",
      "updated_at": "2023-08-05T20:31:01Z",
      "source": {
        "issue": {
          "id": 1837671308,
          "node_id": "PR_kwDOABII585XPvx_",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28222/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28222/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28222/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/28222",
          "number": 28222,
          "state": "open",
          "state_reason": null,
          "title": "Use shared_ptr for CNode inside CConnman",
          "body": "Switch to using smart pointers to `CNode`s inside of `CConnman`.\r\n\r\nCurrently we are manually refcounting CNodes which is potentially error-prone and makes operations such as deleting them from multiple threads difficult without introducing new locks or other synchronisation operations (see https://github.com/bitcoin/bitcoin/pull/27912).\r\n\r\nSwitch to using `std::shared_ptr` references to `CNode`s inside of `m_nodes` and `m_nodes_disconnected` to give us better memory safety today, and in the future allow `AttemptToEvictConnection` (and optionally other sites) to safely synchronously disconnect nodes when needed.\r\n\r\nOpening as draft for now as I want to both gauge feedback on the approach, and see which PRs this may conflict with (#27213?) before moving it forwards.\r\n\r\nCC @vasild ",
          "user": {
            "login": "willcl-ark",
            "id": 6606587,
            "node_id": "MDQ6VXNlcjY2MDY1ODc=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/willcl-ark",
            "html_url": "https://github.com/willcl-ark",
            "followers_url": "https://api.github.com/users/willcl-ark/followers",
            "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
            "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
            "repos_url": "https://api.github.com/users/willcl-ark/repos",
            "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            },
            {
              "id": 5334691551,
              "node_id": "LA_kwDOABII588AAAABPfju3w",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
              "name": "CI failed",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 12,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28222",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/28222",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/28222.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/28222.patch"
          },
          "created_at": "2023-08-05T09:45:10Z",
          "updated_at": "2023-08-17T13:49:24Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1566293438,
      "node_id": "PRR_kwDOABII585dW72-",
      "url": null,
      "actor": null,
      "commit_id": "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nSlowly working my way through, reviewed up to f97adbf3e93e89b1e8ce1dc212e84ac6b2879463 (commit 3/8), looks good so far.\r\nOne potential code deduplication nit (though I'm not sure if it gains that much in readability): seems like for V1Transport,  `HaveBytesToSend()` and `DoneSendingMessage()` are in an inverse relation (or however one would call that), so one could be expressed through the other, e.g.:\r\n```diff\r\nindex 887669e32b..af0fa5c603 100644\r\n--- a/src/net.cpp\r\n+++ b/src/net.cpp\r\n@@ -863,8 +863,7 @@ void V1Transport::SetMessageToSend(CSerializedNetMsg&& msg) noexcept\r\n \r\n bool V1Transport::HaveBytesToSend() const noexcept\r\n {\r\n-    LOCK(m_cs_send);\r\n-    return m_sending_header || m_bytes_sent != m_message_to_send.data.size();\r\n+    return !DoneSendingMessage();\r\n }\r\n \r\n Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\r\n```",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1566293438",
      "submitted_at": "2023-08-08T00:09:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
    },
    {
      "event": "reviewed",
      "id": 1575433253,
      "node_id": "PRR_kwDOABII585d5zQl",
      "url": null,
      "actor": null,
      "commit_id": "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "Concept ACK till https://github.com/bitcoin/bitcoin/pull/28165/commits/1937a5fcf795149c44b7f4f016c05000ac3adaf9\r\n\r\nI will continue later on it",
      "user": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1575433253",
      "submitted_at": "2023-08-12T21:25:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
    },
    {
      "event": "reviewed",
      "id": 1573562580,
      "node_id": "PRR_kwDOABII585dyqjU",
      "url": null,
      "actor": null,
      "commit_id": "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1573562580",
      "submitted_at": "2023-08-14T18:19:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10102087935,
      "node_id": "HRFPE_lADOABII585sqgK1zwAAAAJaIaD_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10102087935",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-15T22:28:48Z"
    },
    {
      "event": "commented",
      "id": 1679726704,
      "node_id": "IC_kwDOABII585kHphw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1679726704",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-15T22:47:45Z",
      "updated_at": "2023-08-15T22:47:45Z",
      "author_association": "MEMBER",
      "body": "I've made some significant changes to this PR:\r\n* `DoneSendingMessage` is gone (the caller can just call `SetMessageToSend` directly, which will fail if nothing can be sent at that time).\r\n* `HaveBytesToSend` is gone (the caller can just call `GetBytesToSend`, which will report an empty span if nothing is to be sent).\r\n* `GetBytesToSend` now takes a `have_next_message` as input, which lets its prediction for whether there are more bytes to send afterwards be more accurate (letting it take into account a future `SetMessageToSend`). This prediction is also tested now, through an `Assume` in the net code directly, and inside the transport simulation fuzz test.\r\n* A lot more comments and documentation.\r\n* More sanity checks in the added fuzz test.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1679726704",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28165"
    },
    {
      "event": "labeled",
      "id": 10103489194,
      "node_id": "LE_lADOABII585sqgK1zwAAAAJaNwKq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10103489194",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-16T03:58:04Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1580205899,
      "node_id": "PRR_kwDOABII585eMAdL",
      "url": null,
      "actor": null,
      "commit_id": "f9f69aac771c9479a6611d4699711b8c271fc20f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "The new approach in 384c798cc3836558463e88ec7f563b236f50bf22 is a nice improvement.\r\n\r\nI'll continue reviewing from 09972b518bed5809d37c79fb0ddef034dce27ba0 onwards after you've had a chance to comment on my `more` comment.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1580205899",
      "submitted_at": "2023-08-16T12:59:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10112857978,
      "node_id": "HRFPE_lADOABII585sqgK1zwAAAAJaxfd6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10112857978",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-16T21:22:31Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10113462805,
      "node_id": "HRFPE_lADOABII585sqgK1zwAAAAJazzIV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10113462805",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-16T23:22:31Z"
    },
    {
      "event": "unlabeled",
      "id": 10114326033,
      "node_id": "UNLE_lADOABII585sqgK1zwAAAAJa3F4R",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10114326033",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-17T02:58:50Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 10119764263,
      "node_id": "LE_lADOABII585sqgK1zwAAAAJbL1kn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10119764263",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-17T13:49:47Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1582634664,
      "node_id": "PRR_kwDOABII585eVRao",
      "url": null,
      "actor": null,
      "commit_id": "d9a91ba9606f828ef3846d2877ec56313653a109",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK d9a91ba9606f828ef3846d2877ec56313653a109 just in time for the #27981 rebase :-(",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1582634664",
      "submitted_at": "2023-08-17T15:00:22Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10122607254,
      "node_id": "HRFPE_lADOABII585sqgK1zwAAAAJbWrqW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10122607254",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-17T18:18:09Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10122976024,
      "node_id": "HRFPE_lADOABII585sqgK1zwAAAAJbYFsY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10122976024",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-17T19:01:28Z"
    },
    {
      "event": "unlabeled",
      "id": 10123451894,
      "node_id": "UNLE_lADOABII585sqgK1zwAAAAJbZ532",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10123451894",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-17T20:02:33Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10125452959,
      "node_id": "HRFPE_lADOABII585sqgK1zwAAAAJbhiaf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10125452959",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T02:51:24Z"
    },
    {
      "event": "labeled",
      "id": 10125453241,
      "node_id": "LE_lADOABII585sqgK1zwAAAAJbhie5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10125453241",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T02:51:29Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10129993529,
      "node_id": "HRFPE_lADOABII585sqgK1zwAAAAJby285",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10129993529",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T13:20:16Z"
    },
    {
      "event": "commented",
      "id": 1683968332,
      "node_id": "IC_kwDOABII585kX1FM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1683968332",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T14:02:12Z",
      "updated_at": "2023-08-18T14:02:12Z",
      "author_association": "MEMBER",
      "body": "re-ACK 07cb6c4\r\n\r\nThe rebase on #27981 looks good to me. I didn't look at the fuzzer changes. Otherwise it's just some extra comments.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1683968332",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28165"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10130405362,
      "node_id": "HRFPE_lADOABII585sqgK1zwAAAAJb0bfy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10130405362",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T14:03:56Z"
    },
    {
      "event": "commented",
      "id": 1683975067,
      "node_id": "IC_kwDOABII585kX2ub",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1683975067",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T14:07:18Z",
      "updated_at": "2023-08-18T14:07:41Z",
      "author_association": "MEMBER",
      "body": "Updates since a few days ago:\r\n* Moved the introduction of the `have_next_message` argument of `GetBytesToSend`, and testing thereof, to #28196.\r\n* Rebased after merge of #27981 (sorry @Sjors, the earlier rebase was incorrect, it only looked at `vSendMsg.empty()` for the returned `data_left` in `SocketSendData()`).\r\n* Added a few more comments.\r\n* Some performance improvements to the fuzz test.\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1683975067",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28165"
    },
    {
      "event": "mentioned",
      "id": 10130438595,
      "node_id": "MEE_lADOABII585sqgK1zwAAAAJb0jnD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10130438595",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T14:07:18Z"
    },
    {
      "event": "subscribed",
      "id": 10130438616,
      "node_id": "SE_lADOABII585sqgK1zwAAAAJb0jnY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10130438616",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T14:07:18Z"
    },
    {
      "event": "commented",
      "id": 1684124388,
      "node_id": "IC_kwDOABII585kYbLk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1684124388",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T16:01:25Z",
      "updated_at": "2023-08-18T16:01:25Z",
      "author_association": "MEMBER",
      "body": "> * (sorry @Sjors, the earlier rebase was incorrect, it only looked at `vSendMsg.empty()` for the returned `data_left` in `SocketSendData()`).\r\n\r\nIs there a test you can add that would catch this difference?",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1684124388",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28165"
    },
    {
      "event": "mentioned",
      "id": 10131478760,
      "node_id": "MEE_lADOABII585sqgK1zwAAAAJb4hjo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10131478760",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T16:01:26Z"
    },
    {
      "event": "subscribed",
      "id": 10131478785,
      "node_id": "SE_lADOABII585sqgK1zwAAAAJb4hkB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10131478785",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T16:01:26Z"
    },
    {
      "event": "commented",
      "id": 1684170559,
      "node_id": "IC_kwDOABII585kYmc_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1684170559",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T16:40:55Z",
      "updated_at": "2023-08-18T16:40:55Z",
      "author_association": "MEMBER",
      "body": "@Sjors I don't think so, or not easily. Giving the wrong \"data_left\" result just causes the #27981 heuristic to be wrong, but outside of some edge cases, that's unlikely to be noticeable in practice.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1684170559",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28165"
    },
    {
      "event": "mentioned",
      "id": 10131776715,
      "node_id": "MEE_lADOABII585sqgK1zwAAAAJb5qTL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10131776715",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T16:40:55Z"
    },
    {
      "event": "subscribed",
      "id": 10131776724,
      "node_id": "SE_lADOABII585sqgK1zwAAAAJb5qTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10131776724",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T16:40:56Z"
    },
    {
      "event": "reviewed",
      "id": 1584963289,
      "node_id": "PRR_kwDOABII585eeJ7Z",
      "url": null,
      "actor": null,
      "commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "re-ACK d99269058922af5fdc14d7fcc88f132060b4b57a",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1584963289",
      "submitted_at": "2023-08-18T17:57:17Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
    },
    {
      "event": "reviewed",
      "id": 1584989873,
      "node_id": "PRR_kwDOABII585eeQax",
      "url": null,
      "actor": null,
      "commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "ACK https://github.com/bitcoin/bitcoin/pull/28165/commits/d99269058922af5fdc14d7fcc88f132060b4b57a\r\n\r\nI like the abstraction of the Transport concept, it is close to a person's mental model of this kind of system!",
      "user": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1584989873",
      "submitted_at": "2023-08-18T17:58:48Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
    },
    {
      "event": "unlabeled",
      "id": 10132810885,
      "node_id": "UNLE_lADOABII585sqgK1zwAAAAJb9myF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10132810885",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T19:00:46Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1585628948,
      "node_id": "PRR_kwDOABII585egscU",
      "url": null,
      "actor": null,
      "commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Posting review midway, reviewed up to 57e9bb0ffd (incl).",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1585628948",
      "submitted_at": "2023-08-21T16:50:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDc4YWEzZGRiOGJmNjFhNGI5ZGQwMjkwNTNkOGI1ZDdlNzk2Zjg3M2E",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/78aa3ddb8bf61a4b9dd029053d8b5d7e796f873a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/78aa3ddb8bf61a4b9dd029053d8b5d7e796f873a",
      "tree": {
        "sha": "1ed3c3d3291879751a5ecbbb0ed32b0945f0b645",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1ed3c3d3291879751a5ecbbb0ed32b0945f0b645"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ded687334031f4790ef6a36b999fb30a79dcf7b3",
          "sha": "ded687334031f4790ef6a36b999fb30a79dcf7b3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ded687334031f4790ef6a36b999fb30a79dcf7b3"
        }
      ],
      "message": "refactor: merge transport serializer and deserializer into Transport class\n\nThis allows state that is shared between both directions to be encapsulated\ninto a single object. Specifically the v2 transport protocol introduced by\nBIP324 has sending state (the encryption keys) that depends on received\nmessages (the DH key exchange). Having a single object for both means it can\nhide logic from callers related to the key exchange.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-21T17:13:28Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-07-05T20:22:52Z"
      },
      "sha": "78aa3ddb8bf61a4b9dd029053d8b5d7e796f873a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDM3MDllNmY0YTAzOTdhM2M0ZWIwMWYxM2ExYjc4MTliNDE4ODgzOTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3709e6f4a0397a3c4eb01f13a1b7819b41888395",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/3709e6f4a0397a3c4eb01f13a1b7819b41888395",
      "tree": {
        "sha": "6d98e7c729fd3d2a38bdf57326ad2b5e8be70e19",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6d98e7c729fd3d2a38bdf57326ad2b5e8be70e19"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/78aa3ddb8bf61a4b9dd029053d8b5d7e796f873a",
          "sha": "78aa3ddb8bf61a4b9dd029053d8b5d7e796f873a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/78aa3ddb8bf61a4b9dd029053d8b5d7e796f873a"
        }
      ],
      "message": "net: add V1Transport lock protecting receive state\n\nRather than relying on the caller to prevent concurrent calls to the\nvarious receive-side functions of Transport, introduce a private m_cs_recv\ninside the implementation to protect the lock state.\n\nOf course, this does not remove the need for callers to synchronize calls\nentirely, as it is a stateful object, and e.g. the order in which Receive(),\nComplete(), and GetMessage() are called matters. It seems impossible to use\na Transport object in a meaningful way in a multi-threaded way without some\nform of external synchronization, but it still feels safer to make the\ntransport object itself responsible for protecting its internal state.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-21T17:21:29Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-07-26T17:19:31Z"
      },
      "sha": "3709e6f4a0397a3c4eb01f13a1b7819b41888395"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDM3Y2FlZjQxODIwNWQ0ODVkNTViNjZkNjlkYmZjNTJjZThjNjIwMmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/37caef418205d485d55b66d69dbfc52ce8c6202a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/37caef418205d485d55b66d69dbfc52ce8c6202a",
      "tree": {
        "sha": "859dbd479863acac27af959515381be5123c1890",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/859dbd479863acac27af959515381be5123c1890"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3709e6f4a0397a3c4eb01f13a1b7819b41888395",
          "sha": "3709e6f4a0397a3c4eb01f13a1b7819b41888395",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/3709e6f4a0397a3c4eb01f13a1b7819b41888395"
        }
      ],
      "message": "refactor: rename Transport class receive functions\n\nNow that the Transport class deals with both the sending and receiving side\nof things, make the receive side have function names that clearly indicate\nthey're about receiving.\n\n* Transport::Read() -> Transport::ReceivedBytes()\n* Transport::Complete() -> Transport::ReceivedMessageComplete()\n* Transport::GetMessage() -> Transport::GetReceivedMessage()\n* Transport::SetVersion() -> Transport::SetReceiveVersion()",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-21T17:25:08Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-14T20:37:05Z"
      },
      "sha": "37caef418205d485d55b66d69dbfc52ce8c6202a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDMxOWNlYWE1YzgwOTUxZTZiNDU0YmYyZjYzNjdhYWM3ODA2ODlkMmY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/319ceaa5c80951e6b454bf2f6367aac780689d2f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/319ceaa5c80951e6b454bf2f6367aac780689d2f",
      "tree": {
        "sha": "ff1db4e4ec114f1d214270efb5c5c62148efda2c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ff1db4e4ec114f1d214270efb5c5c62148efda2c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/37caef418205d485d55b66d69dbfc52ce8c6202a",
          "sha": "37caef418205d485d55b66d69dbfc52ce8c6202a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/37caef418205d485d55b66d69dbfc52ce8c6202a"
        }
      ],
      "message": "net: abstract sending side of transport serialization further\n\nThis makes the sending side of P2P transports mirror the receiver side: caller provides\nmessage (consisting of type and payload) to be sent, and then asks what bytes must be\nsent. Once the message has been fully sent, a new message can be provided.\n\nThis removes the assumption that P2P serialization of messages follows a strict structure\nof header (a function of type and payload), followed by (unmodified) payload, and instead\nlets transports decide the structure themselves.\n\nIt also removes the assumption that a message must always be sent at once, or that no\nbytes are even sent on the wire when there is no message. This opens the door for\nsupporting traffic shaping mechanisms in the future.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-21T18:49:04Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-07-21T20:31:59Z"
      },
      "sha": "319ceaa5c80951e6b454bf2f6367aac780689d2f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA4NjlmYmRlZDE4MWE1NTRiZDUzNjJhZDdlMTM5MTI5MWMyMTg4YTE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0869fbded181a554bd5362ad7e1391291c2188a1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0869fbded181a554bd5362ad7e1391291c2188a1",
      "tree": {
        "sha": "bf0b7e453e1f706a4b6424e218e828a2793c5b17",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bf0b7e453e1f706a4b6424e218e828a2793c5b17"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/319ceaa5c80951e6b454bf2f6367aac780689d2f",
          "sha": "319ceaa5c80951e6b454bf2f6367aac780689d2f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/319ceaa5c80951e6b454bf2f6367aac780689d2f"
        }
      ],
      "message": "net: make V1Transport implicitly use current chainparams\n\nThe rest of net.cpp already uses Params() to determine chainparams in many\nplaces (and even V1Transport itself does so in some places).\n\nSince the only chainparams dependency is through the message start characters,\njust store those directly in the transport.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-21T18:55:41Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-07-27T19:35:41Z"
      },
      "sha": "0869fbded181a554bd5362ad7e1391291c2188a1"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA3YmFiN2FkOGE1MzMwYWUzZTAxYTI5M2M5M2YzMWU1NGIzOTc1NWU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/07bab7ad8a5330ae3e01a293c93f31e54b39755e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/07bab7ad8a5330ae3e01a293c93f31e54b39755e",
      "tree": {
        "sha": "c363af1eb79b94e3dce5437a02c48b9ceda448cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c363af1eb79b94e3dce5437a02c48b9ceda448cb"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0869fbded181a554bd5362ad7e1391291c2188a1",
          "sha": "0869fbded181a554bd5362ad7e1391291c2188a1",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0869fbded181a554bd5362ad7e1391291c2188a1"
        }
      ],
      "message": "fuzz: add bidirectional fragmented transport test\n\nThis adds a simulation test, with two V1Transport objects, which send messages\nto each other, with sending and receiving fragmented into multiple pieces that\nmay be interleaved. It primarily verifies that the sending and receiving side\nare compatible with each other, plus a few sanity checks.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-21T19:27:20Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-07-25T21:38:32Z"
      },
      "sha": "07bab7ad8a5330ae3e01a293c93f31e54b39755e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDMxYmRiNjgzZmVmNTU4OGZlNGJiZjM5Mjc4MGQ2Nzc4MWI2NWU1MzY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/31bdb683fef5588fe4bbf392780d67781b65e536",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/31bdb683fef5588fe4bbf392780d67781b65e536",
      "tree": {
        "sha": "906d2b05eed5b9a53c41d0eddc3903859662705b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/906d2b05eed5b9a53c41d0eddc3903859662705b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/07bab7ad8a5330ae3e01a293c93f31e54b39755e",
          "sha": "07bab7ad8a5330ae3e01a293c93f31e54b39755e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/07bab7ad8a5330ae3e01a293c93f31e54b39755e"
        }
      ],
      "message": "net: measure send buffer fullness based on memory usage\n\nThis more accurately captures the intent of limiting send buffer size, as\nmany small messages can have a larger overhead that is not counted with the\ncurrent approach.\n\nIt also means removing the dependency on the header size (which will become\na function of the transport choice) from the send buffer calculations.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-21T19:27:25Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-07-24T17:23:39Z"
      },
      "sha": "31bdb683fef5588fe4bbf392780d67781b65e536"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10149686316,
      "node_id": "HRFPE_lADOABII585sqgK1zwAAAAJc9-ws",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10149686316",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-21T19:27:59Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDY5ZjRiMzQwYzA2ODA3OGNjYTdiNjhhYTA0MzYwYWFhN2MwZmQxMmI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/69f4b340c068078cca7b68aa04360aaa7c0fd12b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/69f4b340c068078cca7b68aa04360aaa7c0fd12b",
      "tree": {
        "sha": "ad0d1943ad0d4b6e7163f933b99c4a6aeb8ab8e0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad0d1943ad0d4b6e7163f933b99c4a6aeb8ab8e0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/31bdb683fef5588fe4bbf392780d67781b65e536",
          "sha": "31bdb683fef5588fe4bbf392780d67781b65e536",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/31bdb683fef5588fe4bbf392780d67781b65e536"
        }
      ],
      "message": "net: move message serialization from PushMessage to SocketSendData\n\nThis furthers transport abstraction by removing the assumption that a message\ncan always immediately be converted to wire bytes. This assumption does not hold\nfor the v2 transport proposed by BIP324, as no messages can be sent before the\nhandshake completes.\n\nThis is done by only keeping (complete) CSerializedNetMsg objects in vSendMsg,\nrather than the resulting bytes (for header and payload) that need to be sent.\nIn SocketSendData, these objects are handed to the transport as permitted by it,\nand sending out the bytes the transport tells us to send. This also removes the\nnSendOffset member variable in CNode, as keeping track of how much has been sent\nis now a responsability of the transport.\n\nThis is not a pure refactor, and has the following effects even for the current\nv1 transport:\n\n* Checksum calculation now happens in SocketSendData rather than PushMessage.\n  For non-optimistic-send messages, that means this computation now happens in\n  the network thread rather than the message handler thread (generally a good\n  thing, as the message handler thread is more of a computational bottleneck).\n* Checksum calculation now happens while holding the cs_vSend lock. This is\n  technically unnecessary for the v1 transport, as messages are encoded\n  independent from one another, but is untenable for the v2 transport anyway.\n* Statistics updates about per-message sent bytes now happen when those bytes\n  are actually handed to the OS, rather than at PushMessage time.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-21T19:30:29Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-16T17:31:50Z"
      },
      "sha": "69f4b340c068078cca7b68aa04360aaa7c0fd12b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDY3ODgwOWUwMDE3OGIzM2UyNzNmMDc3NWVlYTk2MzVmZWNhZjM4NmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/678809e00178b33e273f0775eea9635fecaf386a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/678809e00178b33e273f0775eea9635fecaf386a",
      "tree": {
        "sha": "882108bcaaeed54523b2204b7c86c160c5cce8a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/882108bcaaeed54523b2204b7c86c160c5cce8a4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/69f4b340c068078cca7b68aa04360aaa7c0fd12b",
          "sha": "69f4b340c068078cca7b68aa04360aaa7c0fd12b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/69f4b340c068078cca7b68aa04360aaa7c0fd12b"
        }
      ],
      "message": "refactor: make Transport::ReceivedBytes just return success/fail",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-21T19:30:54Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-07-29T17:59:35Z"
      },
      "sha": "678809e00178b33e273f0775eea9635fecaf386a"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10149730244,
      "node_id": "HRFPE_lADOABII585sqgK1zwAAAAJc-JfE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10149730244",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-21T19:33:07Z"
    },
    {
      "event": "reviewed",
      "id": 1588883611,
      "node_id": "PRR_kwDOABII585etHCb",
      "url": null,
      "actor": null,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 678809e00178b33e273f0775eea9635fecaf386a\r\n\r\nSome things may be improved, see comments below, but no blockers (thus ACK).",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1588883611",
      "submitted_at": "2023-08-22T13:14:50Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
    },
    {
      "event": "review_requested",
      "id": 10158472226,
      "node_id": "RRE_lADOABII585sqgK1zwAAAAJdffwi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10158472226",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T13:14:58Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10158472386,
      "node_id": "RRE_lADOABII585sqgK1zwAAAAJdffzC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10158472386",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T13:14:59Z",
      "requested_reviewer": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10158473035,
      "node_id": "RRRE_lADOABII585sqgK1zwAAAAJdff9L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10158473035",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T13:15:02Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10158473187,
      "node_id": "RRE_lADOABII585sqgK1zwAAAAJdff_j",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10158473187",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T13:15:03Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10159508078,
      "node_id": "RRRE_lADOABII585sqgK1zwAAAAJdjcpu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159508078",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T14:38:16Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10159508343,
      "node_id": "RRE_lADOABII585sqgK1zwAAAAJdjct3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159508343",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T14:38:17Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10159703491,
      "node_id": "RRRE_lADOABII585sqgK1zwAAAAJdkMXD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159703491",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T14:54:21Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10159703853,
      "node_id": "RRE_lADOABII585sqgK1zwAAAAJdkMct",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159703853",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T14:54:23Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10159729527,
      "node_id": "RRRE_lADOABII585sqgK1zwAAAAJdkSt3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159729527",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T14:56:22Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10159729803,
      "node_id": "RRE_lADOABII585sqgK1zwAAAAJdkSyL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159729803",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T14:56:24Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10159845788,
      "node_id": "RRRE_lADOABII585sqgK1zwAAAAJdkvGc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159845788",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T15:04:55Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10159846096,
      "node_id": "RRE_lADOABII585sqgK1zwAAAAJdkvLQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159846096",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T15:04:57Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10159877410,
      "node_id": "RRRE_lADOABII585sqgK1zwAAAAJdk20i",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159877410",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T15:07:34Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10159877638,
      "node_id": "RRE_lADOABII585sqgK1zwAAAAJdk24G",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159877638",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T15:07:35Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 1688378806,
      "node_id": "IC_kwDOABII585kop22",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1688378806",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T15:08:03Z",
      "updated_at": "2023-08-22T15:08:03Z",
      "author_association": "MEMBER",
      "body": "re-ACK 678809e00178b33e273f0775eea9635fecaf386a",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1688378806",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28165"
    },
    {
      "event": "review_request_removed",
      "id": 10159883828,
      "node_id": "RRRE_lADOABII585sqgK1zwAAAAJdk4Y0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159883828",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T15:08:08Z",
      "requested_reviewer": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10159883837,
      "node_id": "RRRE_lADOABII585sqgK1zwAAAAJdk4Y9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159883837",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T15:08:08Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10159883993,
      "node_id": "RRE_lADOABII585sqgK1zwAAAAJdk4bZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159883993",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T15:08:09Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10159923807,
      "node_id": "RRRE_lADOABII585sqgK1zwAAAAJdlCJf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159923807",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T15:11:24Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10159923950,
      "node_id": "RRE_lADOABII585sqgK1zwAAAAJdlCLu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159923950",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T15:11:25Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10159959463,
      "node_id": "RRRE_lADOABII585sqgK1zwAAAAJdlK2n",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159959463",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T15:14:38Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10159959591,
      "node_id": "RRE_lADOABII585sqgK1zwAAAAJdlK4n",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10159959591",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T15:14:39Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10161467496,
      "node_id": "RRRE_lADOABII585sqgK1zwAAAAJdq7Bo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10161467496",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T17:48:23Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10161467660,
      "node_id": "RRE_lADOABII585sqgK1zwAAAAJdq7EM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10161467660",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T17:48:24Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1589955318,
      "node_id": "PRR_kwDOABII585exMr2",
      "url": null,
      "actor": null,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1589955318",
      "submitted_at": "2023-08-22T17:57:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
    },
    {
      "event": "review_request_removed",
      "id": 10161551878,
      "node_id": "RRRE_lADOABII585sqgK1zwAAAAJdrPoG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10161551878",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T17:57:23Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10161551993,
      "node_id": "RRE_lADOABII585sqgK1zwAAAAJdrPp5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10161551993",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T17:57:24Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10161552448,
      "node_id": "RRRE_lADOABII585sqgK1zwAAAAJdrPxA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10161552448",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T17:57:27Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10161552563,
      "node_id": "RRE_lADOABII585sqgK1zwAAAAJdrPyz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10161552563",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T17:57:28Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283037011",
      "pull_request_review_id": 1560842698,
      "id": 1283037011,
      "node_id": "PRRC_kwDOABII585MeZdT",
      "diff_hunk": "@@ -306,29 +307,38 @@ class V1Transport final : public Transport\n         hasher.Reset();\n     }\n \n+    bool CompleteInternal() const noexcept EXCLUSIVE_LOCKS_REQUIRED(m_cs_recv)",
      "path": "src/net.h",
      "position": null,
      "original_position": 40,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "c7720844a4357aa497362fd5b481bc1a9c27687d",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c7720844a4357aa497362fd5b481bc1a9c27687d: I assume this separation of `CompleteInternal()` is because `EXCLUSIVE_LOCKS_REQUIRED` is only set for `V1Transport` rather than on `Transport`?",
      "created_at": "2023-08-03T11:03:06Z",
      "updated_at": "2023-08-03T17:07:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283037011",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283037011"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283084032",
      "pull_request_review_id": 1560842698,
      "id": 1283084032,
      "node_id": "PRRC_kwDOABII585Mek8A",
      "diff_hunk": "@@ -783,6 +783,8 @@ CNetMessage V1Transport::GetMessage(const std::chrono::microseconds time, bool&\n {\n     // Initialize out parameter\n     reject_message = false;\n+\n+    LOCK(m_cs_recv);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463 this `LOCK` should have been moved in the previous commit. Otherwise it gives a thread safety warning.",
      "created_at": "2023-08-03T11:48:42Z",
      "updated_at": "2023-08-03T17:07:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283084032",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283084032"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283202700",
      "pull_request_review_id": 1560842698,
      "id": 1283202700,
      "node_id": "PRRC_kwDOABII585MfB6M",
      "diff_hunk": "@@ -271,10 +271,26 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n-\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+    // Callers must guarantee that none of these functions are called concurrently w.r.t. one\n+    // another.\n+\n+    /** Whether the last provided message has been sent, and a new one can be provided. */\n+    virtual bool DoneSendingMessage() const noexcept = 0;",
      "path": "src/net.h",
      "position": null,
      "original_position": 13,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463: `NoPendingSend()` ? That makes it more clear this method doesn't mark something done. Also it applies before the first message too.",
      "created_at": "2023-08-03T13:25:31Z",
      "updated_at": "2023-08-03T17:07:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283202700",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283202700"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283265993",
      "pull_request_review_id": 1560842698,
      "id": 1283265993,
      "node_id": "PRRC_kwDOABII585MfRXJ",
      "diff_hunk": "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 98,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463: this new `assert` and the one below had me a bit worried, but they disappear in 68e48a0185751d24eecb194b8efd7028c8b590f3.\r\n\r\nI think they're ok here though:\r\n\r\n1. The very first message it's trivially clear this won't be a problem: `m_sending_header` starts out `false`, `m_bytes_sent` at `0` and `m_message_to_send.data` is initialised empty.\r\n2. `MarkBytesSent` sets these things back when (exactly) all bytes have been put in the send buffer (`vSendMsg`). In v1 this is always the case after the second (header only) or third call to `GetBytesToSend()`, after which we leave the while loop.",
      "created_at": "2023-08-03T14:11:11Z",
      "updated_at": "2023-08-03T17:09:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283265993",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283265993"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2919,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283288152",
      "pull_request_review_id": 1560842698,
      "id": 1283288152,
      "node_id": "PRRC_kwDOABII585MfWxY",
      "diff_hunk": "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 101,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463: could add a comment here:\r\n\r\n```cpp\r\n// In v1 transport GetBytesToSend first returns a header and next the data (if any).\r\n```",
      "created_at": "2023-08-03T14:26:56Z",
      "updated_at": "2023-08-03T17:07:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283288152",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283288152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2922,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283297036",
      "pull_request_review_id": 1560842698,
      "id": 1283297036,
      "node_id": "PRRC_kwDOABII585MfY8M",
      "diff_hunk": "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {\n+            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n+            if (bytes.empty()) break;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 103,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463: Since we're notifying two different things about these sent bytes - and also setting `nSendSize` - I suggested some extra comments...\r\n\r\n```cpp\r\n// Update statistics per message type\r\n```",
      "created_at": "2023-08-03T14:32:34Z",
      "updated_at": "2023-08-03T17:07:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283297036",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283297036"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2924,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283298309",
      "pull_request_review_id": 1560842698,
      "id": 1283298309,
      "node_id": "PRRC_kwDOABII585MfZQF",
      "diff_hunk": "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {\n+            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n+            if (bytes.empty()) break;\n+            pnode->AccountForSentBytes(msg_type, bytes.size());\n+            pnode->nSendSize += bytes.size();\n+            if (pnode->nSendSize > nSendBufferMaxSize) pnode->fPauseSend = true;\n+            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 107,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463\r\n\r\n```cpp\r\n// Notify Transport that bytes have been processed\r\n```\r\n",
      "created_at": "2023-08-03T14:33:28Z",
      "updated_at": "2023-08-03T17:07:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283298309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283298309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2928,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283301879",
      "pull_request_review_id": 1560842698,
      "id": 1283301879,
      "node_id": "PRRC_kwDOABII585MfaH3",
      "diff_hunk": "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {\n+            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n+            if (bytes.empty()) break;\n+            pnode->AccountForSentBytes(msg_type, bytes.size());",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 104,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463\r\n\r\n```cpp\r\n// Update bytes in send buffer\r\n```\r\n\r\n(becomes \"Update memory use of send buffer\" in the next commit)",
      "created_at": "2023-08-03T14:36:03Z",
      "updated_at": "2023-08-03T17:07:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283301879",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283301879"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2925,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283305145",
      "pull_request_review_id": 1560842698,
      "id": 1283305145,
      "node_id": "PRRC_kwDOABII585Mfa65",
      "diff_hunk": "@@ -271,10 +271,26 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n-\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+    // Callers must guarantee that none of these functions are called concurrently w.r.t. one\n+    // another.\n+\n+    /** Whether the last provided message has been sent, and a new one can be provided. */\n+    virtual bool DoneSendingMessage() const noexcept = 0;\n+    /** Set a message to send (only allowed if DoneSendingMessage()). */\n+    virtual void SetMessageToSend(CSerializedNetMsg&& msg) noexcept = 0;\n+    /** Whether there are bytes to send on the wire. */\n+    virtual bool HaveBytesToSend() const noexcept = 0;\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t>: span of bytes to be sent over the wire (empty if !HaveBytesToSend())\n+     *  - bool: whether more bytes to be sent follow after the ones in the span have been sent\n+     *  - const std::string&: message type on behalf of which this is being sent (or \"\" if n/a)\n+     */\n+    using BytesToSend = std::tuple<Span<const uint8_t>, bool, const std::string&>;\n+    /** Get bytes to send on the wire. */\n+    virtual BytesToSend GetBytesToSend() const noexcept = 0;\n+    /** Report how many bytes returned by GetBytesToSend() have been sent. No effect if 0. */\n+    virtual void MarkBytesSent(size_t bytes_sent) noexcept = 0;",
      "path": "src/net.h",
      "position": 85,
      "original_position": 27,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463: could we just assume bytes will get sent this if `GetBytesToSend()` has been called? Afaik there's no way to handle a failure anyway. But I guess it's safer to track it explicitly.\r\n\r\nUpdate: in 68e48a0185751d24eecb194b8efd7028c8b590f3 this function becomes more important, and is used to track when not all bytes are sent.",
      "created_at": "2023-08-03T14:38:24Z",
      "updated_at": "2023-08-03T17:12:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283305145",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283305145"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 318,
      "original_line": 318,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283320253",
      "pull_request_review_id": 1560842698,
      "id": 1283320253,
      "node_id": "PRRC_kwDOABII585Mfem9",
      "diff_hunk": "@@ -827,8 +834,46 @@ void V1Transport::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsign\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);",
      "path": "src/net.cpp",
      "position": 131,
      "original_position": 36,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463 this `reserve` wasn't useful?",
      "created_at": "2023-08-03T14:49:03Z",
      "updated_at": "2023-08-03T17:07:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283320253",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283320253"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 832,
      "original_line": 832,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283352376",
      "pull_request_review_id": 1560842698,
      "id": 1283352376,
      "node_id": "PRRC_kwDOABII585Mfmc4",
      "diff_hunk": "@@ -2923,11 +2940,11 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n             const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n             if (bytes.empty()) break;\n             pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->nSendSize += bytes.size();\n-            if (pnode->nSendSize > nSendBufferMaxSize) pnode->fPauseSend = true;\n             pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n+            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n             pnode->m_transport->MarkBytesSent(bytes.size());\n         }\n+        if (pnode->m_send_memusage + pnode->m_transport->GetSendMemoryUsage() > nSendBufferMaxSize) pnode->fPauseSend = true;",
      "path": "src/net.cpp",
      "position": 322,
      "original_position": 70,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "1937a5fcf795149c44b7f4f016c05000ac3adaf9",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1937a5fcf795149c44b7f4f016c05000ac3adaf9  Isn't `>m_transport->GetSendMemoryUsage()` 0 since we just sent the message and cleared it?\r\n\r\n(but that changes in the next commit 68e48a0185751d24eecb194b8efd7028c8b590f3)",
      "created_at": "2023-08-03T15:13:16Z",
      "updated_at": "2023-08-03T17:07:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283352376",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283352376"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3018,
      "original_line": 3018,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283416754",
      "pull_request_review_id": 1560842698,
      "id": 1283416754,
      "node_id": "PRRC_kwDOABII585Mf2Ky",
      "diff_hunk": "@@ -2931,23 +2936,12 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n-\n-        assert(pnode->m_transport->DoneSendingMessage());\n-        pnode->m_transport->SetMessageToSend(std::move(msg));\n+        bool optimisticSend{pnode->vSendMsg.empty() && pnode->m_transport->DoneSendingMessage()};\n \n-        while (true) {\n-            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n-            if (bytes.empty()) break;\n-            pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n-            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n-            pnode->m_transport->MarkBytesSent(bytes.size());\n-        }\n+        pnode->m_send_memusage += msg.GetMemoryUsage();",
      "path": "src/net.cpp",
      "position": 321,
      "original_position": 104,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "68e48a0185751d24eecb194b8efd7028c8b590f3: this is much readable than the intermediate calculation introduced in 1937a5fcf795149c44b7f4f016c05000ac3adaf9. It might be worth moving that commit after here.",
      "created_at": "2023-08-03T16:03:02Z",
      "updated_at": "2023-08-03T17:07:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283416754",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283416754"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3017,
      "original_line": 3017,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283427444",
      "pull_request_review_id": 1560842698,
      "id": 1283427444,
      "node_id": "PRRC_kwDOABII585Mf4x0",
      "diff_hunk": "@@ -2931,23 +2936,12 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n-\n-        assert(pnode->m_transport->DoneSendingMessage());\n-        pnode->m_transport->SetMessageToSend(std::move(msg));\n+        bool optimisticSend{pnode->vSendMsg.empty() && pnode->m_transport->DoneSendingMessage()};\n \n-        while (true) {\n-            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n-            if (bytes.empty()) break;\n-            pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n-            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n-            pnode->m_transport->MarkBytesSent(bytes.size());\n-        }\n+        pnode->m_send_memusage += msg.GetMemoryUsage();\n+        pnode->vSendMsg.push_back(std::move(msg));\n         if (pnode->m_send_memusage + pnode->m_transport->GetSendMemoryUsage() > nSendBufferMaxSize) pnode->fPauseSend = true;\n \n-        assert(pnode->m_transport->DoneSendingMessage());\n-\n         // If write queue empty, attempt \"optimistic write\"",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 110,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "68e48a0185751d24eecb194b8efd7028c8b590f3: This could be a good time to document what optimistic send actually is. From 1817398b397afebcc857c40a16d201c84878cb89:\r\n\r\n```cpp\r\n// Because the poll/select loop may pause for 100msec before actually doing a\r\n// send, and we have no way to force the loop awake, try sending from the calling\r\n// thread if the queue is empty.\r\n```\r\n\r\nOr shorter: `// which avoids a delay of up to SELECT_TIMEOUT_MILLISECONDS.`\r\n",
      "created_at": "2023-08-03T16:12:01Z",
      "updated_at": "2023-08-03T17:07:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283427444",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283427444"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2945,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283440338",
      "pull_request_review_id": 1560842698,
      "id": 1283440338,
      "node_id": "PRRC_kwDOABII585Mf77S",
      "diff_hunk": "@@ -1298,7 +1301,9 @@ Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\n         bool select_send;\n         {\n             LOCK(pnode->cs_vSend);\n-            select_send = !pnode->vSendMsg.empty();\n+            // This relies on optimistic send to make sure the transport always has a message to\n+            // send if there are any.",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 81,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "68e48a0185751d24eecb194b8efd7028c8b590f3 Is the above comment still correct? \"As this only happens when optimistic write failed\"",
      "created_at": "2023-08-03T16:23:16Z",
      "updated_at": "2023-08-03T17:07:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283440338",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283440338"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1305,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283461349",
      "pull_request_review_id": 1560842698,
      "id": 1283461349,
      "node_id": "PRRC_kwDOABII585MgBDl",
      "diff_hunk": "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "path": "src/net.cpp",
      "position": 216,
      "original_position": 21,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "68e48a0185751d24eecb194b8efd7028c8b590f3\r\n\r\n```cpp\r\n// Leave message in the transport for when the socket is available.\r\n// v2 transport would also require waiting for the handshake to complete\r\n```\r\n\r\nWith v2 I assume we can't even call `GetBytesToSend` before the handshake?",
      "created_at": "2023-08-03T16:41:56Z",
      "updated_at": "2023-08-03T17:07:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283461349",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283461349"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 938,
      "original_line": 938,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283605312",
      "pull_request_review_id": 1561694994,
      "id": 1283605312,
      "node_id": "PRRC_kwDOABII585MgkNA",
      "diff_hunk": "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "path": "src/net.cpp",
      "position": 216,
      "original_position": 21,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": 1283461349,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We can - In fact the handshake itself is sent this way (that's the nice part about this abstraction, the caller doesn't know or care whether bytes being sent are on behalf of a message we're trying to send or something else).",
      "created_at": "2023-08-03T19:02:32Z",
      "updated_at": "2023-08-03T19:02:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283605312",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283605312"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 938,
      "original_line": 938,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283606280",
      "pull_request_review_id": 1561696448,
      "id": 1283606280,
      "node_id": "PRRC_kwDOABII585MgkcI",
      "diff_hunk": "@@ -2923,11 +2940,11 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n             const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n             if (bytes.empty()) break;\n             pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->nSendSize += bytes.size();\n-            if (pnode->nSendSize > nSendBufferMaxSize) pnode->fPauseSend = true;\n             pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n+            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n             pnode->m_transport->MarkBytesSent(bytes.size());\n         }\n+        if (pnode->m_send_memusage + pnode->m_transport->GetSendMemoryUsage() > nSendBufferMaxSize) pnode->fPauseSend = true;",
      "path": "src/net.cpp",
      "position": 322,
      "original_position": 70,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "1937a5fcf795149c44b7f4f016c05000ac3adaf9",
      "in_reply_to_id": 1283352376,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, it should be 0 at this point, but that won't remain with the next commit. A temporary explanation message could be added to explain that here.",
      "created_at": "2023-08-03T19:03:41Z",
      "updated_at": "2023-08-03T19:03:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283606280",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283606280"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3018,
      "original_line": 3018,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283610490",
      "pull_request_review_id": 1561702502,
      "id": 1283610490,
      "node_id": "PRRC_kwDOABII585Mgld6",
      "diff_hunk": "@@ -306,29 +307,38 @@ class V1Transport final : public Transport\n         hasher.Reset();\n     }\n \n+    bool CompleteInternal() const noexcept EXCLUSIVE_LOCKS_REQUIRED(m_cs_recv)",
      "path": "src/net.h",
      "position": null,
      "original_position": 40,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "c7720844a4357aa497362fd5b481bc1a9c27687d",
      "in_reply_to_id": 1283037011,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's because I don't want a recursive lock, and I'm introducing a caller of `CompleteInternal()` that already holds `m_cs_recv`.",
      "created_at": "2023-08-03T19:08:23Z",
      "updated_at": "2023-08-03T19:08:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283610490",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283610490"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283633525",
      "pull_request_review_id": 1561737078,
      "id": 1283633525,
      "node_id": "PRRC_kwDOABII585MgrF1",
      "diff_hunk": "@@ -271,10 +271,26 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n-\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+    // Callers must guarantee that none of these functions are called concurrently w.r.t. one\n+    // another.\n+\n+    /** Whether the last provided message has been sent, and a new one can be provided. */\n+    virtual bool DoneSendingMessage() const noexcept = 0;\n+    /** Set a message to send (only allowed if DoneSendingMessage()). */\n+    virtual void SetMessageToSend(CSerializedNetMsg&& msg) noexcept = 0;\n+    /** Whether there are bytes to send on the wire. */\n+    virtual bool HaveBytesToSend() const noexcept = 0;\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t>: span of bytes to be sent over the wire (empty if !HaveBytesToSend())\n+     *  - bool: whether more bytes to be sent follow after the ones in the span have been sent\n+     *  - const std::string&: message type on behalf of which this is being sent (or \"\" if n/a)\n+     */\n+    using BytesToSend = std::tuple<Span<const uint8_t>, bool, const std::string&>;\n+    /** Get bytes to send on the wire. */\n+    virtual BytesToSend GetBytesToSend() const noexcept = 0;\n+    /** Report how many bytes returned by GetBytesToSend() have been sent. No effect if 0. */\n+    virtual void MarkBytesSent(size_t bytes_sent) noexcept = 0;",
      "path": "src/net.h",
      "position": 85,
      "original_position": 27,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": 1283305145,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In general, it's true that the new sending interface is overly complicated for how it is used initially, and then it only becomes apparent in the next commit. \r\n\r\nHere specifically, indeed, everything returned by `GetBytesToSend` is initially always marked sent, but in the next commit that changes, as the buffering responsibility is moved from `vSendMsg` to `m_transport`. I'm happy to add (possibly temporary) comments to explain what's happening.",
      "created_at": "2023-08-03T19:29:45Z",
      "updated_at": "2023-08-03T19:29:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283633525",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283633525"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 318,
      "original_line": 318,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283660977",
      "pull_request_review_id": 1561776670,
      "id": 1283660977,
      "node_id": "PRRC_kwDOABII585Mgxyx",
      "diff_hunk": "@@ -2931,23 +2936,12 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n-\n-        assert(pnode->m_transport->DoneSendingMessage());\n-        pnode->m_transport->SetMessageToSend(std::move(msg));\n+        bool optimisticSend{pnode->vSendMsg.empty() && pnode->m_transport->DoneSendingMessage()};\n \n-        while (true) {\n-            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n-            if (bytes.empty()) break;\n-            pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n-            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n-            pnode->m_transport->MarkBytesSent(bytes.size());\n-        }\n+        pnode->m_send_memusage += msg.GetMemoryUsage();",
      "path": "src/net.cpp",
      "position": 321,
      "original_position": 104,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": 1283416754,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't reordering works without (even) more intermediary complexity. The issue is \"net: move message serialization from PushMessage to SocketSendData\" changes the data type of `vSendMsg` from bytes-to-be-sent to messages-to-be-sent, and the latter just don't have a known size-on-the-wire (unless an additional API to transports is added for that, or hardcoding the V1 message encoding size rules). That's why this PR first changes the notion of send buffer size: the old notion just doesn't really make sense anymore after the buffer changes introduced here.",
      "created_at": "2023-08-03T20:00:47Z",
      "updated_at": "2023-08-03T20:00:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283660977",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283660977"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3017,
      "original_line": 3017,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283674053",
      "pull_request_review_id": 1561795385,
      "id": 1283674053,
      "node_id": "PRRC_kwDOABII585Mg0_F",
      "diff_hunk": "@@ -271,10 +271,26 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n-\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+    // Callers must guarantee that none of these functions are called concurrently w.r.t. one\n+    // another.\n+\n+    /** Whether the last provided message has been sent, and a new one can be provided. */\n+    virtual bool DoneSendingMessage() const noexcept = 0;",
      "path": "src/net.h",
      "position": null,
      "original_position": 13,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": 1283202700,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Actually, that name would be confusing for V2, where it's possible that there is no pending message, but also no message can be provided (yet) because the handshake has not completed.\r\n\r\nPerhaps `CanSetNewMessageToSend()` is better? (let the bikesheddening begin!)",
      "created_at": "2023-08-03T20:15:35Z",
      "updated_at": "2023-08-03T20:15:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283674053",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283674053"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1284194811",
      "pull_request_review_id": 1562506904,
      "id": 1284194811,
      "node_id": "PRRC_kwDOABII585Mi0H7",
      "diff_hunk": "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "path": "src/net.cpp",
      "position": 216,
      "original_position": 21,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": 1283461349,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I guess it's not entirely clear to me whose responsibility it is to ensure the handshake has been done: https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283674053 (I assume it will be in the main PR)",
      "created_at": "2023-08-04T09:22:28Z",
      "updated_at": "2023-08-04T09:22:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1284194811",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1284194811"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 938,
      "original_line": 938,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1284382381",
      "pull_request_review_id": 1562808679,
      "id": 1284382381,
      "node_id": "PRRC_kwDOABII585Mjh6t",
      "diff_hunk": "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "path": "src/net.cpp",
      "position": 216,
      "original_position": 21,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": 1283461349,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "My view is that anything that is different between v1 and v2 connections ought to be handled by the respective transport class.\n\nIn V2 there are multiple stages a connection goes through (pubkey, garbage+terminator, garbage authentication packet, version negotiation packet, and finally application data during which bitcoin P2P messages can be sent); this will be implemented using a finite state machine on sender and receiver side to control what state we are in. Only during the last phase (application data) can `SetMessageToSend` be called.\n\n`GetBytesToSend` can always be called. If there is nothing to send, it'll return empty. If there is, (at least) some part of it will be returned.\n* For V1, `GetBytesToSend()` is non-empty whenever there is a header or a payload to be sent.\n* For V2, `GetBytesToSend()` is non-empty whenever there are handshake bytes (pubkey, garbage, garbage auth, version packet) or an application packet (encoding a message) to be sent.",
      "created_at": "2023-08-04T12:50:49Z",
      "updated_at": "2023-08-04T14:14:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1284382381",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1284382381"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 938,
      "original_line": 938,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1286479195",
      "pull_request_review_id": 1566293059,
      "id": 1286479195,
      "node_id": "PRRC_kwDOABII585Mrh1b",
      "diff_hunk": "@@ -271,10 +271,26 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n-\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+    // Callers must guarantee that none of these functions are called concurrently w.r.t. one\n+    // another.\n+\n+    /** Whether the last provided message has been sent, and a new one can be provided. */\n+    virtual bool DoneSendingMessage() const noexcept = 0;",
      "path": "src/net.h",
      "position": null,
      "original_position": 13,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": 1283202700,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "FWIW, I agree that the `Done` prefix of the method name is quite confusing, for both the reasons Sjors lined out. `CanSetNewMessageToSend()` sounds much better to me (maybe even just `CanSetMessageToSend`, to have the full name of the method included which can be called if `true` is returned?).",
      "created_at": "2023-08-08T00:08:50Z",
      "updated_at": "2023-08-08T00:08:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1286479195",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1286479195"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291310726",
      "pull_request_review_id": 1573562580,
      "id": 1291310726,
      "node_id": "PRRC_kwDOABII585M99aG",
      "diff_hunk": "@@ -253,24 +253,31 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload). Callers must guarantee that none of these\n+    // functions are called concurrently w.r.t. one another.\n+\n     // returns true if the current deserialization is complete\n     virtual bool Complete() const = 0;",
      "path": "src/net.h",
      "position": null,
      "original_position": 19,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "8f5c65a464b7ed47939a055a4b65286d20a5b126",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "commit 8f5c65a464b7ed47939a055a4b65286d20a5b126:\r\nCould rename to `Complete()` to `DeserComplete()`, `DoneReceivingMessage()` or somthing similar to make it clearer that this function refers to deserialization side, now that both direction are in one class.",
      "created_at": "2023-08-11T12:59:29Z",
      "updated_at": "2023-08-14T18:19:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1291310726",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291310726"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 266,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1292498404",
      "pull_request_review_id": 1575430346,
      "id": 1292498404,
      "node_id": "PRRC_kwDOABII585NCfXk",
      "diff_hunk": "@@ -827,8 +834,46 @@ void V1Transport::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsign\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);",
      "path": "src/net.cpp",
      "position": 131,
      "original_position": 36,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": 1283320253,
      "user": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Mh looks like that `header` is no longer used?",
      "created_at": "2023-08-12T21:20:11Z",
      "updated_at": "2023-08-12T21:20:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1292498404",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1292498404"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 832,
      "original_line": 832,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1292945676",
      "pull_request_review_id": 1576023745,
      "id": 1292945676,
      "node_id": "PRRC_kwDOABII585NEMkM",
      "diff_hunk": "@@ -827,8 +834,46 @@ void V1Transport::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsign\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);",
      "path": "src/net.cpp",
      "position": 131,
      "original_position": 36,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": 1283320253,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The `header` argument no longer exists (as the caller doesn't have any notion of headers anymore, that's local to the transport implementation). Instead there is an `m_header_to_send` variable, but it's reused across messages, so (repeated) reserving makes no sense.",
      "created_at": "2023-08-14T03:49:59Z",
      "updated_at": "2023-08-14T03:50:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1292945676",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1292945676"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 832,
      "original_line": 832,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293749015",
      "pull_request_review_id": 1573562580,
      "id": 1293749015,
      "node_id": "PRRC_kwDOABII585NHQsX",
      "diff_hunk": "@@ -87,8 +87,15 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n \n     {\n         LOCK(dummyNode1.cs_vSend);\n-        BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n+        BOOST_CHECK(!dummyNode1.vSendMsg.empty() || dummyNode1.m_transport->HaveBytesToSend());",
      "path": "src/test/denialofservice_tests.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why the second condition within the context of this unit test - It's not like it could have sent the message partially before? (same for the other Check below)",
      "created_at": "2023-08-14T17:12:15Z",
      "updated_at": "2023-08-14T18:19:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1293749015",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293749015"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293814156",
      "pull_request_review_id": 1573562580,
      "id": 1293814156,
      "node_id": "PRRC_kwDOABII585NHgmM",
      "diff_hunk": "@@ -72,6 +72,12 @@ void ConnmanTestMsg::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_by\n \n bool ConnmanTestMsg::ReceiveMsgFrom(CNode& node, CSerializedNetMsg&& ser_msg) const\n {\n+    /* Flush out any unsent bytes from previous messages. */\n+    while (node.m_transport->HaveBytesToSend()) {",
      "path": "src/test/util/net.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It seems confusing and not ideal that a function called `ReceiveMsgFrom` has so much code dealing with the Send part, and also the side effect of flushing the send message buffer, when the goal is just to create a header for `ser_msg` to be able to receive that, but not to send anything. For example, it should be possible to call `ReceiveMsgFrom` in situations where the send buffer has unrelated contents. Maybe it'd be better to just have the relevant code (i.e. the old `prepareForTransport` duplicated here to extract the header instead of changing the send parts of `m_transport`?)",
      "created_at": "2023-08-14T18:15:12Z",
      "updated_at": "2023-08-14T18:19:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1293814156",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293814156"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208216",
      "pull_request_review_id": 1579558676,
      "id": 1295208216,
      "node_id": "PRRC_kwDOABII585NM08Y",
      "diff_hunk": "@@ -783,6 +783,8 @@ CNetMessage V1Transport::GetMessage(const std::chrono::microseconds time, bool&\n {\n     // Initialize out parameter\n     reject_message = false;\n+\n+    LOCK(m_cs_recv);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": 1283084032,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-08-15T22:29:10Z",
      "updated_at": "2023-08-15T22:29:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295208216",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208216"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208716",
      "pull_request_review_id": 1579559347,
      "id": 1295208716,
      "node_id": "PRRC_kwDOABII585NM1EM",
      "diff_hunk": "@@ -271,10 +271,26 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n-\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+    // Callers must guarantee that none of these functions are called concurrently w.r.t. one\n+    // another.\n+\n+    /** Whether the last provided message has been sent, and a new one can be provided. */\n+    virtual bool DoneSendingMessage() const noexcept = 0;",
      "path": "src/net.h",
      "position": null,
      "original_position": 13,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": 1283202700,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've made some significant changes to the code, and `DoneSendingMessage` is now gone: instead the caller just tries `SetMessageToSend`, and it'll fail if the message can't be set. This avoids a virtual function call in some cases, doing both at once.",
      "created_at": "2023-08-15T22:30:04Z",
      "updated_at": "2023-08-15T22:30:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295208716",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208716"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208895",
      "pull_request_review_id": 1579559594,
      "id": 1295208895,
      "node_id": "PRRC_kwDOABII585NM1G_",
      "diff_hunk": "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 98,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": 1283265993,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`DoneSendingMessage` is gone.",
      "created_at": "2023-08-15T22:30:23Z",
      "updated_at": "2023-08-15T22:30:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295208895",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208895"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2919,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208988",
      "pull_request_review_id": 1579559734,
      "id": 1295208988,
      "node_id": "PRRC_kwDOABII585NM1Ic",
      "diff_hunk": "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 101,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": 1283288152,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added a comment to this effect.",
      "created_at": "2023-08-15T22:30:36Z",
      "updated_at": "2023-08-15T22:30:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295208988",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2922,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209060",
      "pull_request_review_id": 1579559831,
      "id": 1295209060,
      "node_id": "PRRC_kwDOABII585NM1Jk",
      "diff_hunk": "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {\n+            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n+            if (bytes.empty()) break;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 103,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": 1283297036,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-08-15T22:30:45Z",
      "updated_at": "2023-08-15T22:30:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209060",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209060"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2924,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209148",
      "pull_request_review_id": 1579559914,
      "id": 1295209148,
      "node_id": "PRRC_kwDOABII585NM1K8",
      "diff_hunk": "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {\n+            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n+            if (bytes.empty()) break;\n+            pnode->AccountForSentBytes(msg_type, bytes.size());\n+            pnode->nSendSize += bytes.size();\n+            if (pnode->nSendSize > nSendBufferMaxSize) pnode->fPauseSend = true;\n+            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 107,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": 1283298309,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-08-15T22:30:52Z",
      "updated_at": "2023-08-15T22:30:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209148",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209148"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2928,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209305",
      "pull_request_review_id": 1579560120,
      "id": 1295209305,
      "node_id": "PRRC_kwDOABII585NM1NZ",
      "diff_hunk": "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {\n+            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n+            if (bytes.empty()) break;\n+            pnode->AccountForSentBytes(msg_type, bytes.size());",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 104,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": 1283301879,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done (and also updated the one in the next commit).",
      "created_at": "2023-08-15T22:31:07Z",
      "updated_at": "2023-08-15T22:31:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209305",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209305"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2925,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209655",
      "pull_request_review_id": 1579560583,
      "id": 1295209655,
      "node_id": "PRRC_kwDOABII585NM1S3",
      "diff_hunk": "@@ -271,10 +271,26 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n-\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+    // Callers must guarantee that none of these functions are called concurrently w.r.t. one\n+    // another.\n+\n+    /** Whether the last provided message has been sent, and a new one can be provided. */\n+    virtual bool DoneSendingMessage() const noexcept = 0;\n+    /** Set a message to send (only allowed if DoneSendingMessage()). */\n+    virtual void SetMessageToSend(CSerializedNetMsg&& msg) noexcept = 0;\n+    /** Whether there are bytes to send on the wire. */\n+    virtual bool HaveBytesToSend() const noexcept = 0;\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t>: span of bytes to be sent over the wire (empty if !HaveBytesToSend())\n+     *  - bool: whether more bytes to be sent follow after the ones in the span have been sent\n+     *  - const std::string&: message type on behalf of which this is being sent (or \"\" if n/a)\n+     */\n+    using BytesToSend = std::tuple<Span<const uint8_t>, bool, const std::string&>;\n+    /** Get bytes to send on the wire. */\n+    virtual BytesToSend GetBytesToSend() const noexcept = 0;\n+    /** Report how many bytes returned by GetBytesToSend() have been sent. No effect if 0. */\n+    virtual void MarkBytesSent(size_t bytes_sent) noexcept = 0;",
      "path": "src/net.h",
      "position": 85,
      "original_position": 27,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "in_reply_to_id": 1283305145,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added some more comments in various places hopefully addresses this complexity, foreshadowing that some added code will be removed in a future commit.",
      "created_at": "2023-08-15T22:31:46Z",
      "updated_at": "2023-08-15T22:31:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209655",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209655"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 318,
      "original_line": 318,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209819",
      "pull_request_review_id": 1579560792,
      "id": 1295209819,
      "node_id": "PRRC_kwDOABII585NM1Vb",
      "diff_hunk": "@@ -2923,11 +2940,11 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n             const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n             if (bytes.empty()) break;\n             pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->nSendSize += bytes.size();\n-            if (pnode->nSendSize > nSendBufferMaxSize) pnode->fPauseSend = true;\n             pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n+            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n             pnode->m_transport->MarkBytesSent(bytes.size());\n         }\n+        if (pnode->m_send_memusage + pnode->m_transport->GetSendMemoryUsage() > nSendBufferMaxSize) pnode->fPauseSend = true;",
      "path": "src/net.cpp",
      "position": 322,
      "original_position": 70,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "1937a5fcf795149c44b7f4f016c05000ac3adaf9",
      "in_reply_to_id": 1283352376,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added a comment to explain this better.",
      "created_at": "2023-08-15T22:32:03Z",
      "updated_at": "2023-08-15T22:32:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209819",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209819"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3018,
      "original_line": 3018,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209963",
      "pull_request_review_id": 1579561007,
      "id": 1295209963,
      "node_id": "PRRC_kwDOABII585NM1Xr",
      "diff_hunk": "@@ -2931,23 +2936,12 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n-\n-        assert(pnode->m_transport->DoneSendingMessage());\n-        pnode->m_transport->SetMessageToSend(std::move(msg));\n+        bool optimisticSend{pnode->vSendMsg.empty() && pnode->m_transport->DoneSendingMessage()};\n \n-        while (true) {\n-            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n-            if (bytes.empty()) break;\n-            pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n-            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n-            pnode->m_transport->MarkBytesSent(bytes.size());\n-        }\n+        pnode->m_send_memusage += msg.GetMemoryUsage();\n+        pnode->vSendMsg.push_back(std::move(msg));\n         if (pnode->m_send_memusage + pnode->m_transport->GetSendMemoryUsage() > nSendBufferMaxSize) pnode->fPauseSend = true;\n \n-        assert(pnode->m_transport->DoneSendingMessage());\n-\n         // If write queue empty, attempt \"optimistic write\"",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 110,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": 1283427444,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not done yet; will do on a future push.",
      "created_at": "2023-08-15T22:32:21Z",
      "updated_at": "2023-08-15T22:32:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209963",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209963"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2945,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295210296",
      "pull_request_review_id": 1579561468,
      "id": 1295210296,
      "node_id": "PRRC_kwDOABII585NM1c4",
      "diff_hunk": "@@ -1298,7 +1301,9 @@ Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\n         bool select_send;\n         {\n             LOCK(pnode->cs_vSend);\n-            select_send = !pnode->vSendMsg.empty();\n+            // This relies on optimistic send to make sure the transport always has a message to\n+            // send if there are any.",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 81,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": 1283440338,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The comment is gone (due to significant changes; the code also works differently now).",
      "created_at": "2023-08-15T22:32:58Z",
      "updated_at": "2023-08-15T22:32:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295210296",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295210296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1305,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295210753",
      "pull_request_review_id": 1579562084,
      "id": 1295210753,
      "node_id": "PRRC_kwDOABII585NM1kB",
      "diff_hunk": "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "path": "src/net.cpp",
      "position": 216,
      "original_position": 21,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": 1283461349,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I haven't added a comment here as I'm not entirely sure under what scenarios `if (!node.m_sock)` triggers; it's code that existed beforehand, and is untouched by this PR.",
      "created_at": "2023-08-15T22:33:48Z",
      "updated_at": "2023-08-15T22:33:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295210753",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295210753"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 938,
      "original_line": 938,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295211040",
      "pull_request_review_id": 1579562475,
      "id": 1295211040,
      "node_id": "PRRC_kwDOABII585NM1og",
      "diff_hunk": "@@ -253,24 +253,31 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload). Callers must guarantee that none of these\n+    // functions are called concurrently w.r.t. one another.\n+\n     // returns true if the current deserialization is complete\n     virtual bool Complete() const = 0;",
      "path": "src/net.h",
      "position": null,
      "original_position": 19,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "8f5c65a464b7ed47939a055a4b65286d20a5b126",
      "in_reply_to_id": 1291310726,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added a commit that renames all receive-side functions to have \"Receive\" somewhere in the name.",
      "created_at": "2023-08-15T22:34:24Z",
      "updated_at": "2023-08-15T22:34:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295211040",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295211040"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 266,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295211509",
      "pull_request_review_id": 1579563131,
      "id": 1295211509,
      "node_id": "PRRC_kwDOABII585NM1v1",
      "diff_hunk": "@@ -87,8 +87,15 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n \n     {\n         LOCK(dummyNode1.cs_vSend);\n-        BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n+        BOOST_CHECK(!dummyNode1.vSendMsg.empty() || dummyNode1.m_transport->HaveBytesToSend());",
      "path": "src/test/denialofservice_tests.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": 1293749015,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It can be (and is), due to optimistic send logic triggering SocketSendData, which now moves `vSendMsg` objects into the transport.",
      "created_at": "2023-08-15T22:35:18Z",
      "updated_at": "2023-08-15T22:35:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295211509",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295211509"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295214603",
      "pull_request_review_id": 1579567550,
      "id": 1295214603,
      "node_id": "PRRC_kwDOABII585NM2gL",
      "diff_hunk": "@@ -72,6 +72,12 @@ void ConnmanTestMsg::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_by\n \n bool ConnmanTestMsg::ReceiveMsgFrom(CNode& node, CSerializedNetMsg&& ser_msg) const\n {\n+    /* Flush out any unsent bytes from previous messages. */\n+    while (node.m_transport->HaveBytesToSend()) {",
      "path": "src/test/util/net.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": 1293814156,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's complicated. You're right that duplicating the old `prepareForTransport` here would work, but I feel that's not really the right approach, as it's kind of hiding what's really going on. It'd also be incompatible with a potential future upgrade to using v2 transports inside the affected unit and fuzz tests.\r\n\r\nWhat's really going on is that we're using the CNode's own *sending* infrastructure to construct bytes, which are then fed to the same CNode's *receive* infrastructure. But there is also \"normal\" non-test sending logic (e.g. sending of version/verack automatically) that uses the same sending infrastucture (however, failing as there is no real socket to send anything on). The flushing here was necessary to wipe the non-test messages that enter the same transport.\r\n\r\nI have for now tried to address your concern here by introducing a more explicit `FlushSendBuffer` call, and adding it where necessary to make tests pass, making it clear where and what is being flushed away, however I think the more proper solution would involve:\r\n* Somehow prevent the sending of non-test messages entirely in test connmans (rather that hacking them away after the fact).\r\n* Give the test connman dedicated per-receive-node send transports which are just used for the test messages sent there. That would make it compatible with v2 operation too.\r\n\r\nDoing those things here feel out of scope, though.\r\n\r\n",
      "created_at": "2023-08-15T22:41:25Z",
      "updated_at": "2023-08-15T22:48:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295214603",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295214603"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295642780",
      "pull_request_review_id": 1580205899,
      "id": 1295642780,
      "node_id": "PRRC_kwDOABII585NOfCc",
      "diff_hunk": "@@ -270,10 +270,48 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n \n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<Span<const uint8_t>, bool, const std::string&>;\n+\n+    /** Get bytes to send on the wire.\n+     *\n+     * The have_next_message value controls whether the \"more\" return value indicates more bytes to\n+     * be sent before (have_next_message=false) or after (have_next_message=true) a potential\n+     * SetMessageToSend immediately afterwards. It is set by the caller when they know they have\n+     * another message ready to send. The have_next_message argument only affects this \"more\"\n+     * return value and nothing else.\n+     *\n+     * As a const function, it does not modify the transport's observable state, and is thus safe\n+     * to be called multiple times.\n+     *\n+     * The bytes returned by this function act as a stream which can only be appended to. This\n+     * means that with the exception of MarkBytesSent, operations on the transport can only append\n+     * to what is being returned.\n+     */\n+    virtual BytesToSend GetBytesToSend(bool have_next_message) const noexcept = 0;",
      "path": "src/net.h",
      "position": null,
      "original_position": 40,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "384c798cc3836558463e88ec7f563b236f50bf22",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "384c798cc3836558463e88ec7f563b236f50bf22\r\n\r\nThe `have_next_message` argument is confusing and seems contradictory to the goal of separating the bytes stream from messages.\r\n\r\n> It is set by the caller when they know they have\r\n>     * another message ready to send.\r\n\r\nIn this commit it's always `false`, so if we need it at all, maybe delay its introduction to 09972b518bed5809d37c79fb0ddef034dce27ba0? That's a better place to explain how it relates to setting `Sock::SEND` (if it can't be in its own commit).",
      "created_at": "2023-08-16T09:40:02Z",
      "updated_at": "2023-08-16T12:59:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295642780",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295642780"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 306,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295649173",
      "pull_request_review_id": 1580205899,
      "id": 1295649173,
      "node_id": "PRRC_kwDOABII585NOgmV",
      "diff_hunk": "@@ -270,10 +270,48 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n \n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<Span<const uint8_t>, bool, const std::string&>;",
      "path": "src/net.h",
      "position": null,
      "original_position": 23,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "384c798cc3836558463e88ec7f563b236f50bf22",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "384c798cc3836558463e88ec7f563b236f50bf22 could we annotate the tuple?\r\n\r\n```cpp\r\nstd::tuple<Span<const uint8_t> /*to_send*/, bool /*more*/, const std::string& /* m_type */>\r\n```",
      "created_at": "2023-08-16T09:45:31Z",
      "updated_at": "2023-08-16T12:59:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295649173",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295649173"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 292,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296525115",
      "pull_request_review_id": 1581555151,
      "id": 1296525115,
      "node_id": "PRRC_kwDOABII585NR2c7",
      "diff_hunk": "@@ -2931,23 +2936,12 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n-\n-        assert(pnode->m_transport->DoneSendingMessage());\n-        pnode->m_transport->SetMessageToSend(std::move(msg));\n+        bool optimisticSend{pnode->vSendMsg.empty() && pnode->m_transport->DoneSendingMessage()};\n \n-        while (true) {\n-            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n-            if (bytes.empty()) break;\n-            pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n-            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n-            pnode->m_transport->MarkBytesSent(bytes.size());\n-        }\n+        pnode->m_send_memusage += msg.GetMemoryUsage();\n+        pnode->vSendMsg.push_back(std::move(msg));\n         if (pnode->m_send_memusage + pnode->m_transport->GetSendMemoryUsage() > nSendBufferMaxSize) pnode->fPauseSend = true;\n \n-        assert(pnode->m_transport->DoneSendingMessage());\n-\n         // If write queue empty, attempt \"optimistic write\"",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 110,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": 1283427444,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-08-16T23:15:34Z",
      "updated_at": "2023-08-16T23:15:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1296525115",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296525115"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2945,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296525550",
      "pull_request_review_id": 1581555848,
      "id": 1296525550,
      "node_id": "PRRC_kwDOABII585NR2ju",
      "diff_hunk": "@@ -87,8 +87,15 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n \n     {\n         LOCK(dummyNode1.cs_vSend);\n-        BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n+        BOOST_CHECK(!dummyNode1.vSendMsg.empty() || dummyNode1.m_transport->HaveBytesToSend());",
      "path": "src/test/denialofservice_tests.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": 1293749015,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Actually just the second condition suffices (the entire expected message is moved to the transport). I've simplified the code accordingly.",
      "created_at": "2023-08-16T23:16:22Z",
      "updated_at": "2023-08-16T23:16:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1296525550",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296525550"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296526306",
      "pull_request_review_id": 1581557041,
      "id": 1296526306,
      "node_id": "PRRC_kwDOABII585NR2vi",
      "diff_hunk": "@@ -270,10 +270,48 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n \n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<Span<const uint8_t>, bool, const std::string&>;\n+\n+    /** Get bytes to send on the wire.\n+     *\n+     * The have_next_message value controls whether the \"more\" return value indicates more bytes to\n+     * be sent before (have_next_message=false) or after (have_next_message=true) a potential\n+     * SetMessageToSend immediately afterwards. It is set by the caller when they know they have\n+     * another message ready to send. The have_next_message argument only affects this \"more\"\n+     * return value and nothing else.\n+     *\n+     * As a const function, it does not modify the transport's observable state, and is thus safe\n+     * to be called multiple times.\n+     *\n+     * The bytes returned by this function act as a stream which can only be appended to. This\n+     * means that with the exception of MarkBytesSent, operations on the transport can only append\n+     * to what is being returned.\n+     */\n+    virtual BytesToSend GetBytesToSend(bool have_next_message) const noexcept = 0;",
      "path": "src/net.h",
      "position": null,
      "original_position": 40,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "384c798cc3836558463e88ec7f563b236f50bf22",
      "in_reply_to_id": 1295642780,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've moved the introduction of `have_next_message` to (a separate commit in) #28196, as it's not really necessary in this PR yet.",
      "created_at": "2023-08-16T23:17:22Z",
      "updated_at": "2023-08-16T23:17:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1296526306",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296526306"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 306,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296528645",
      "pull_request_review_id": 1581560290,
      "id": 1296528645,
      "node_id": "PRRC_kwDOABII585NR3UF",
      "diff_hunk": "@@ -270,10 +270,48 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n \n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<Span<const uint8_t>, bool, const std::string&>;",
      "path": "src/net.h",
      "position": null,
      "original_position": 23,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "384c798cc3836558463e88ec7f563b236f50bf22",
      "in_reply_to_id": 1295649173,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-08-16T23:22:34Z",
      "updated_at": "2023-08-16T23:22:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1296528645",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296528645"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 292,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297229209",
      "pull_request_review_id": 1582634664,
      "id": 1297229209,
      "node_id": "PRRC_kwDOABII585NUiWZ",
      "diff_hunk": "@@ -2989,42 +2999,19 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        const bool queue_was_empty{pnode->vSendMsg.empty()};\n-\n-        // Give the message to the transport, and add all bytes it wants us to send out as byte\n-        // vectors to vSendMsg. This is temporary code that exists to support the new transport\n-        // sending interface using the old way of queueing data. In a future commit vSendMsg will\n-        // be replaced with a queue of CSerializedNetMsg objects to be sent instead, and this code\n-        // will disappear.\n-        bool queued = pnode->m_transport->SetMessageToSend(msg);\n-        assert(queued);\n-        // In the current transport (V1Transport), GetBytesToSend first returns a header to send,\n-        // and then the payload data (if any), necessitating a loop.\n-        while (true) {\n-            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n-            if (bytes.empty()) break;\n-            // Update statistics per message type.\n-            pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n-            // Update memory usage of send buffer. For now, use static + dynamic memory usage of\n-            // byte vectors in vSendMsg as send memory. In a future commit, vSendMsg will be\n-            // replaced with a queue of CSerializedNetMsg objects, and we'll use their memory usage\n-            // instead.\n-            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n-            // Notify transport that bytes have been processed (they're not actually sent yet,\n-            // but pushed onto the vSendMsg queue of bytes to send).\n-            pnode->m_transport->MarkBytesSent(bytes.size());\n-        }\n-        // At this point, m_transport->GetSendMemoryUsage() isn't very interesting as the\n-        // transport's message is fully flushed (and converted to byte arrays). It's still included\n-        // here for correctness, and will become relevant in a future commit when a queued message\n-        // inside the transport may survive PushMessage calls.\n+        const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\n+        const bool queue_was_empty{to_send.empty() && pnode->vSendMsg.empty()};",
      "path": "src/net.cpp",
      "position": 315,
      "original_position": 111,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "58cb50cdc60df5d7e42466213f213cf7ab54db45",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "58cb50cdc60df5d7e42466213f213cf7ab54db45: IIUC in v1 `&& pnode->vSendMsg.empty()` is always `true` when `GetBytesToSend()` just told us there's nothing to send? But in v2 we might be waiting for a handshake.",
      "created_at": "2023-08-17T13:32:45Z",
      "updated_at": "2023-08-17T15:00:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1297229209",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297229209"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3014,
      "original_line": 3014,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297349342",
      "pull_request_review_id": 1582634664,
      "id": 1297349342,
      "node_id": "PRRC_kwDOABII585NU_re",
      "diff_hunk": "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "path": "src/net.cpp",
      "position": 216,
      "original_position": 21,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": 1283461349,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think `!node.m_sock` can only happen when when we've disconnected in another thread, using `CloseSocketDisconnect()` (and during tests). That's also what the documentation of `m_sock_mutex` says. cc @vasild ",
      "created_at": "2023-08-17T14:57:31Z",
      "updated_at": "2023-08-17T15:00:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1297349342",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297349342"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 938,
      "original_line": 938,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297598582",
      "pull_request_review_id": 1583240845,
      "id": 1297598582,
      "node_id": "PRRC_kwDOABII585NV8h2",
      "diff_hunk": "@@ -2989,42 +2999,19 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        const bool queue_was_empty{pnode->vSendMsg.empty()};\n-\n-        // Give the message to the transport, and add all bytes it wants us to send out as byte\n-        // vectors to vSendMsg. This is temporary code that exists to support the new transport\n-        // sending interface using the old way of queueing data. In a future commit vSendMsg will\n-        // be replaced with a queue of CSerializedNetMsg objects to be sent instead, and this code\n-        // will disappear.\n-        bool queued = pnode->m_transport->SetMessageToSend(msg);\n-        assert(queued);\n-        // In the current transport (V1Transport), GetBytesToSend first returns a header to send,\n-        // and then the payload data (if any), necessitating a loop.\n-        while (true) {\n-            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n-            if (bytes.empty()) break;\n-            // Update statistics per message type.\n-            pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n-            // Update memory usage of send buffer. For now, use static + dynamic memory usage of\n-            // byte vectors in vSendMsg as send memory. In a future commit, vSendMsg will be\n-            // replaced with a queue of CSerializedNetMsg objects, and we'll use their memory usage\n-            // instead.\n-            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n-            // Notify transport that bytes have been processed (they're not actually sent yet,\n-            // but pushed onto the vSendMsg queue of bytes to send).\n-            pnode->m_transport->MarkBytesSent(bytes.size());\n-        }\n-        // At this point, m_transport->GetSendMemoryUsage() isn't very interesting as the\n-        // transport's message is fully flushed (and converted to byte arrays). It's still included\n-        // here for correctness, and will become relevant in a future commit when a queued message\n-        // inside the transport may survive PushMessage calls.\n+        const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\n+        const bool queue_was_empty{to_send.empty() && pnode->vSendMsg.empty()};",
      "path": "src/net.cpp",
      "position": 315,
      "original_position": 111,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "58cb50cdc60df5d7e42466213f213cf7ab54db45",
      "in_reply_to_id": 1297229209,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I believe that's true, though only due to optimistic send itself (which guarantees that as soon as something is added to `vSendMsg`, it's immediately at least attempted to be moved to the transport). Without it, if there were two consecutive `PushMessage` without intervening `SocketSendData`, `vSendMsg` would already have something in it on the second one.\r\n\r\nBecause of that, I think it's more \"obviously correct\" to do the full check here.",
      "created_at": "2023-08-17T18:32:53Z",
      "updated_at": "2023-08-17T18:32:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1297598582",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297598582"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3014,
      "original_line": 3014,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297627349",
      "pull_request_review_id": 1583287057,
      "id": 1297627349,
      "node_id": "PRRC_kwDOABII585NWDjV",
      "diff_hunk": "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "path": "src/net.cpp",
      "position": 216,
      "original_position": 21,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": 1283461349,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right, so I think `!node.m_sock` only happens when the node is already disconnected, or will never actually be connected to anything (in tests). I've added the following comment:\r\n\r\n> There is no socket in case we've already disconnected, or in test cases without real connections. In these cases, we bail out immediately and just leave things in the send queue and transport.\r\n\r\nFurther up, above the `SetMessageToSend` call, I've added:\r\n\r\n> This fails when there is an existing message still being sent.\r\n\r\nwhich in #28196 is extended to say:\r\n\r\n> This fails when there is an existing message still being sent, or (for v2 transports) when the\r\nhandshake has not yet completed.\r\n\r\n",
      "created_at": "2023-08-17T19:04:02Z",
      "updated_at": "2023-08-17T19:04:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1297627349",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297627349"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 938,
      "original_line": 938,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298700651",
      "pull_request_review_id": 1584963289,
      "id": 1298700651,
      "node_id": "PRRC_kwDOABII585NaJlr",
      "diff_hunk": "@@ -906,36 +906,50 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool have_unsent_data{false};",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 8,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "8d1a91f6394f00b880613268a9f2f3164ef914e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "8d1a91f6394f00b880613268a9f2f3164ef914e2: `data_left` is more consistent with the header",
      "created_at": "2023-08-18T17:38:25Z",
      "updated_at": "2023-08-18T17:57:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1298700651",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298700651"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 918,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298709287",
      "pull_request_review_id": 1584963289,
      "id": 1298709287,
      "node_id": "PRRC_kwDOABII585NaLsn",
      "diff_hunk": "@@ -906,36 +906,50 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool have_unsent_data{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }",
      "path": "src/net.cpp",
      "position": 206,
      "original_position": 19,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "8d1a91f6394f00b880613268a9f2f3164ef914e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "8d1a91f6394f00b880613268a9f2f3164ef914e2: IIUC even though `!node.vSendMsg.empty()`, we don't want `else { have_unsent_data = true }` here because:\r\n\r\n1. `SetMessageToSend` _may_ return `false` for other reasons (though afaik it can't at the moment)\r\n2. If it does return `false`, then `GetBytesToSend` below populates `data`, tries to send it and then updates `have_unsent_data` appropriately.",
      "created_at": "2023-08-18T17:49:13Z",
      "updated_at": "2023-08-18T17:57:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1298709287",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298709287"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 929,
      "original_line": 929,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298710893",
      "pull_request_review_id": 1584963289,
      "id": 1298710893,
      "node_id": "PRRC_kwDOABII585NaMFt",
      "diff_hunk": "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "path": "src/net.cpp",
      "position": 216,
      "original_position": 21,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": 1283461349,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "8d1a91f6394f00b880613268a9f2f3164ef914e2: technically `have_unsent_data` should be set to `true` here, but since we just disconnected it doesn't matter.",
      "created_at": "2023-08-18T17:51:23Z",
      "updated_at": "2023-08-18T17:57:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1298710893",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298710893"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 938,
      "original_line": 938,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298717971",
      "pull_request_review_id": 1584991522,
      "id": 1298717971,
      "node_id": "PRRC_kwDOABII585NaN0T",
      "diff_hunk": "@@ -906,36 +906,50 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool have_unsent_data{false};",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 8,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "8d1a91f6394f00b880613268a9f2f3164ef914e2",
      "in_reply_to_id": 1298700651,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Or perhaps something like `return {nSentSize, !message_queue_empty || !transport_empty};`",
      "created_at": "2023-08-18T18:00:08Z",
      "updated_at": "2023-08-18T18:10:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1298717971",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298717971"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 918,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299172882",
      "pull_request_review_id": 1585628948,
      "id": 1299172882,
      "node_id": "PRRC_kwDOABII585Nb84S",
      "diff_hunk": "@@ -24,9 +25,10 @@ void initialize_p2p_transport_serialization()\n \n FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serialization)\n {\n-    // Construct deserializer, with a dummy NodeId\n-    V1TransportDeserializer deserializer{Params(), NodeId{0}, SER_NETWORK, INIT_PROTO_VERSION};\n-    V1TransportSerializer serializer{};\n+    // Construct transports for both sides, with dummy NodeIds.\n+    V1Transport recv_transport{NodeId{0}, SER_NETWORK, INIT_PROTO_VERSION};\n+    V1Transport send_transport{NodeId{1}, SER_NETWORK, INIT_PROTO_VERSION};",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": 33,
      "original_position": 17,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is it not possible to use a single transport here?",
      "created_at": "2023-08-19T11:10:03Z",
      "updated_at": "2023-08-21T16:50:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1299172882",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299172882"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": 38,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 39,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299174503",
      "pull_request_review_id": 1585628948,
      "id": 1299174503,
      "node_id": "PRRC_kwDOABII585Nb9Rn",
      "diff_hunk": "@@ -253,42 +256,88 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload).\n+\n     // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    virtual bool ReceivedMessageComplete() const = 0;\n+    // set the deserialization context version\n+    virtual void SetReceiveVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer. Return false is invalid. */\n+    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;\n     // decomposes a message from the context\n-    virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n-    virtual ~TransportDeserializer() {}\n+    virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n+\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<\n+        Span<const uint8_t> /*to_send*/,\n+        bool /*more*/,\n+        const std::string& /*m_type*/\n+    >;\n+\n+    /** Get bytes to send on the wire.\n+     *\n+     * As a const function, it does not modify the transport's observable state, and is thus safe\n+     * to be called multiple times.\n+     *\n+     * The bytes returned by this function act as a stream which can only be appended to. This\n+     * means that with the exception of MarkBytesSent, operations on the transport can only append\n+     * to what is being returned.\n+     */\n+    virtual BytesToSend GetBytesToSend() const noexcept = 0;\n+\n+    /** Report how many bytes returned by the last GetBytesToSend() have been sent.\n+     *\n+     * bytes_sent cannot exceed to_send.size() of the last GetBytesToSend() result.\n+     *\n+     * If bytes_sent=0, this call has no effect.\n+     */\n+    virtual void MarkBytesSent(size_t bytes_sent) noexcept = 0;\n+\n+    /** Return the memory usage of this transport attributable to buffered data to send. */\n+    virtual size_t GetSendMemoryUsage() const noexcept = 0;\n };\n \n-class V1TransportDeserializer final : public TransportDeserializer\n+class V1Transport final : public Transport\n {\n private:\n-    const CChainParams& m_chain_params;\n+    CMessageHeader::MessageStartChars m_magic_bytes;\n     const NodeId m_node_id; // Only for logging\n-    mutable CHash256 hasher;\n-    mutable uint256 data_hash;\n-    bool in_data;                   // parsing header (false) or data (true)\n-    CDataStream hdrbuf;             // partially received header\n-    CMessageHeader hdr;             // complete header\n-    CDataStream vRecv;              // received message data\n-    unsigned int nHdrPos;\n-    unsigned int nDataPos;\n-\n-    const uint256& GetMessageHash() const;\n-    int readHeader(Span<const uint8_t> msg_bytes);\n-    int readData(Span<const uint8_t> msg_bytes);\n-\n-    void Reset() {\n+    mutable Mutex m_cs_recv; //!< Lock for receive state",
      "path": "src/net.h",
      "position": null,
      "original_position": 109,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Aren't mutexes supposed to be named like `m_foo_mutex`, rather than `m_cs_foo` in new code? I don't think there is written convention, feel free to ignore.",
      "created_at": "2023-08-19T11:26:09Z",
      "updated_at": "2023-08-21T16:50:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1299174503",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299174503"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 326,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299175706",
      "pull_request_review_id": 1585628948,
      "id": 1299175706,
      "node_id": "PRRC_kwDOABII585Nb9ka",
      "diff_hunk": "@@ -299,52 +348,55 @@ class V1TransportDeserializer final : public TransportDeserializer\n         hasher.Reset();\n     }\n \n-public:\n-    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n-        : m_chain_params(chain_params),\n-          m_node_id(node_id),\n-          hdrbuf(nTypeIn, nVersionIn),\n-          vRecv(nTypeIn, nVersionIn)\n+    bool CompleteInternal() const noexcept EXCLUSIVE_LOCKS_REQUIRED(m_cs_recv)\n     {\n-        Reset();\n+        if (!in_data) return false;\n+        return hdr.nMessageSize == nDataPos;\n     }\n \n-    bool Complete() const override\n+    /** Lock for sending state. */\n+    mutable Mutex m_cs_send;\n+    /** The header of the message currently being sent. */\n+    std::vector<uint8_t> m_header_to_send GUARDED_BY(m_cs_send);\n+    /** The data of the message currently being sent. */\n+    CSerializedNetMsg m_message_to_send GUARDED_BY(m_cs_send);\n+    /** Whether we're currently sending header bytes or message bytes. */\n+    bool m_sending_header GUARDED_BY(m_cs_send) {false};\n+    /** How many bytes have been sent so far (from m_header_to_send, or from m_message_to_send.data). */\n+    size_t m_bytes_sent GUARDED_BY(m_cs_send) {0};\n+\n+public:\n+    V1Transport(const NodeId node_id, int nTypeIn, int nVersionIn) noexcept;\n+\n+    bool ReceivedMessageComplete() const override EXCLUSIVE_LOCKS_REQUIRED(!m_cs_recv)\n     {\n-        if (!in_data)\n-            return false;\n-        return (hdr.nMessageSize == nDataPos);\n+        return WITH_LOCK(m_cs_recv, return CompleteInternal());\n     }\n-    void SetVersion(int nVersionIn) override\n+\n+    void SetReceiveVersion(int nVersionIn) override EXCLUSIVE_LOCKS_REQUIRED(!m_cs_recv)\n     {\n+        LOCK(m_cs_recv);",
      "path": "src/net.h",
      "position": null,
      "original_position": 170,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "According to `developer-notes.md` annotations in function declaration (`EXCLUSIVE_LOCKS_REQUIRED(!m_cs_recv)`) should be combined with run-time asserts in function definitions (`AssertLockNotHeld(m_cs_recv)`). So, this code should be:\r\n\r\n```cpp\r\nvoid SetReceiveVersion(int nVersionIn) override EXCLUSIVE_LOCKS_REQUIRED(!m_cs_recv)\r\n{\r\n    AssertLockNotHeld(m_cs_recv);\r\n    LOCK(m_cs_recv);\r\n```\r\n\r\nI opened https://github.com/bitcoin/bitcoin/pull/27116 to relax that since it is redundant.",
      "created_at": "2023-08-19T11:38:28Z",
      "updated_at": "2023-08-21T16:50:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1299175706",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299175706"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": 376,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 378,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299189317",
      "pull_request_review_id": 1585628948,
      "id": 1299189317,
      "node_id": "PRRC_kwDOABII585NcA5F",
      "diff_hunk": "@@ -253,42 +256,88 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload).\n+\n     // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    virtual bool ReceivedMessageComplete() const = 0;\n+    // set the deserialization context version\n+    virtual void SetReceiveVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer. Return false is invalid. */\n+    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;\n     // decomposes a message from the context\n-    virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n-    virtual ~TransportDeserializer() {}\n+    virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n+\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<\n+        Span<const uint8_t> /*to_send*/,\n+        bool /*more*/,\n+        const std::string& /*m_type*/\n+    >;",
      "path": "src/net.h",
      "position": 63,
      "original_position": 63,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe mention something about the lifetime of `to_send` and `msg_type` since they refer to data inside the transport. IIRC will be invalidated by the next `SetMessageToSend()` call.",
      "created_at": "2023-08-19T13:55:37Z",
      "updated_at": "2023-08-21T16:50:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1299189317",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299189317"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": 286,
      "original_start_line": 286,
      "start_side": "RIGHT",
      "line": 296,
      "original_line": 296,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299996446",
      "pull_request_review_id": 1585628948,
      "id": 1299996446,
      "node_id": "PRRC_kwDOABII585NfF8e",
      "diff_hunk": "@@ -717,7 +726,15 @@ bool CNode::ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete)\n     return true;\n }\n \n-int V1TransportDeserializer::readHeader(Span<const uint8_t> msg_bytes)\n+V1Transport::V1Transport(const NodeId node_id, int nTypeIn, int nVersionIn) noexcept :\n+    m_node_id(node_id), hdrbuf(nTypeIn, nVersionIn), vRecv(nTypeIn, nVersionIn)\n+{\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_magic_bytes);",
      "path": "src/net.cpp",
      "position": 53,
      "original_position": 52,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is unbounded copy. Maybe check that it will not cause buffer overflow? E.g.\r\n\r\n```cpp\r\n    const auto& src = Params().MessageStart();\r\n    const auto& src_begin = std::begin(src);                             \r\n    const auto& src_end = std::end(src);\r\n    assert(std::distance(src_begin, src_end) <= std::distance(std::begin(m_magic_bytes), std::end(m_magic_bytes)));\r\n    std::copy(src_begin, src_end, m_magic_bytes);\r\n```",
      "created_at": "2023-08-21T11:41:47Z",
      "updated_at": "2023-08-21T16:50:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1299996446",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299996446"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 733,
      "original_line": 733,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300286463",
      "pull_request_review_id": 1587284906,
      "id": 1300286463,
      "node_id": "PRRC_kwDOABII585NgMv_",
      "diff_hunk": "@@ -906,36 +906,50 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool have_unsent_data{false};",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 8,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "8d1a91f6394f00b880613268a9f2f3164ef914e2",
      "in_reply_to_id": 1298700651,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Will address when I retouch.",
      "created_at": "2023-08-21T15:29:45Z",
      "updated_at": "2023-08-21T15:29:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300286463",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300286463"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 918,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300299930",
      "pull_request_review_id": 1585628948,
      "id": 1300299930,
      "node_id": "PRRC_kwDOABII585NgQCa",
      "diff_hunk": "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 74,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit:\r\n\r\n```suggestion\r\n    // Two vectors representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\r\n    std::array<std::vector<uint8_t>, 2> in_flight;\r\n```",
      "created_at": "2023-08-21T15:41:08Z",
      "updated_at": "2023-08-21T16:50:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300299930",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300299930"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": 110,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 120,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300311165",
      "pull_request_review_id": 1585628948,
      "id": 1300311165,
      "node_id": "PRRC_kwDOABII585NgSx9",
      "diff_hunk": "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 93,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is this some form of locale independent `isprint(3)`?\r\n\r\nIf the purpose is to generate random (including invalid) message types then why not just `provider.ConsumeBytesAsString(CMessageHeader::COMMAND_SIZE)`,  or if the purpose is to generate only valid message types, then pick a random value from `getAllNetMessageTypes()`?",
      "created_at": "2023-08-21T15:50:20Z",
      "updated_at": "2023-08-21T16:50:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300311165",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300311165"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300343322",
      "pull_request_review_id": 1585628948,
      "id": 1300343322,
      "node_id": "PRRC_kwDOABII585Ngaoa",
      "diff_hunk": "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    unsigned iter = 0;\n+    while (iter < 1000 && provider.remaining_bytes()) {",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 229,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    LIMITED_WHILE(provider.remaining_bytes(), 1000) {\r\n```",
      "created_at": "2023-08-21T16:14:37Z",
      "updated_at": "2023-08-21T16:50:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300343322",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300343322"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": 265,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 266,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300352209",
      "pull_request_review_id": 1585628948,
      "id": 1300352209,
      "node_id": "PRRC_kwDOABII585NgczR",
      "diff_hunk": "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    unsigned iter = 0;\n+    while (iter < 1000 && provider.remaining_bytes()) {\n+        uint8_t code = provider.ConsumeIntegral<uint8_t>();\n+        // Lowest bit identifies the sender side of the operation.\n+        int side = code & 1;\n+        switch ((side >> 1) % 3) {",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 233,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Given that `side` is `0` or `1`, then `side >> 1` will always be `0`, no? Did you mean `code >> 1`? I find this less cryptic:\r\n\r\n```cpp\r\nsize_t side = provider.ConsumeBool();\r\nswitch (provider.ConsumeIntegralInRange(0, 2)) {\r\n    case 0: ...\r\n    case 1: ...\r\n    case 2: ...\r\n}",
      "created_at": "2023-08-21T16:21:22Z",
      "updated_at": "2023-08-21T16:50:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300352209",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300352209"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": 269,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 270,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300362306",
      "pull_request_review_id": 1585628948,
      "id": 1300362306,
      "node_id": "PRRC_kwDOABII585NgfRC",
      "diff_hunk": "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    unsigned iter = 0;\n+    while (iter < 1000 && provider.remaining_bytes()) {\n+        uint8_t code = provider.ConsumeIntegral<uint8_t>();\n+        // Lowest bit identifies the sender side of the operation.\n+        int side = code & 1;\n+        switch ((side >> 1) % 3) {\n+        // The other bits (mod 3) identify the operation:\n+        case 0:\n+            // (Try to) give the next message to the transport.\n+            new_msg_fn(side);\n+            break;\n+        case 1:\n+            // (Try to) send some bytes from the transport to the network.\n+            send_fn(side);\n+            break;\n+        case 2:\n+            // (Try to) receive bytes from the network, converting to messages.\n+            recv_fn(side);\n+            break;\n+        }\n+        ++iter;\n+    }\n+\n+    // When we're done, perform sends and receives of existing messages to flush anything already\n+    // in flight.\n+    while (true) {\n+        bool any = false;\n+        if (send_fn(0, true)) any = true;\n+        if (send_fn(1, true)) any = true;\n+        if (recv_fn(0, true)) any = true;\n+        if (recv_fn(1, true)) any = true;\n+        if (!any) break;\n     }\n+\n+    // Make sure nothing is left in flight.\n+    assert(in_flight[0].empty());\n+    assert(in_flight[1].empty());\n+\n+    // Make sure all expected messages were received.\n+    assert(expected[0].empty());\n+    assert(expected[1].empty());\n+}\n+\n+std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n+{\n+    return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(p2p_transport_bidirectional, .init = initialize_p2p_transport_serialization)\n+{\n+    // Test with two V1 transports talking to each other.\n+    FuzzedDataProvider provider{buffer.data(), buffer.size()};\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>());\n+    auto t1 = MakeV1Transport(NodeId{0});\n+    auto t2 = MakeV1Transport(NodeId{1});\n+    if (!t1 || !t2) return;\n+    SimulationTest(*t1, *t2, rng, provider);",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": 300,
      "original_position": 286,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is there a reason to use pointers? The following seems to be simpler:\r\n\r\n```cpp\r\n    V1Transport t0{NodeId{0}, SER_NETWORK, INIT_PROTO_VERSION};\r\n    V1Transport t1{NodeId{1}, SER_NETWORK, INIT_PROTO_VERSION};\r\n    SimulationTest(t0, t1, rng, provider);\r\n```\r\nand remove `MakeV1Transport()`?\r\n",
      "created_at": "2023-08-21T16:30:05Z",
      "updated_at": "2023-08-21T16:50:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300362306",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300362306"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": 327,
      "original_start_line": 320,
      "start_side": "RIGHT",
      "line": 330,
      "original_line": 330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300365030",
      "pull_request_review_id": 1585628948,
      "id": 1300365030,
      "node_id": "PRRC_kwDOABII585Ngf7m",
      "diff_hunk": "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 154,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The return value of `new_msg_fn()` is ignored by the caller.\r\n```suggestion\r\n```",
      "created_at": "2023-08-21T16:32:40Z",
      "updated_at": "2023-08-21T16:50:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300365030",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300365030"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": 190,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300421324",
      "pull_request_review_id": 1587510023,
      "id": 1300421324,
      "node_id": "PRRC_kwDOABII585NgtrM",
      "diff_hunk": "@@ -24,9 +25,10 @@ void initialize_p2p_transport_serialization()\n \n FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serialization)\n {\n-    // Construct deserializer, with a dummy NodeId\n-    V1TransportDeserializer deserializer{Params(), NodeId{0}, SER_NETWORK, INIT_PROTO_VERSION};\n-    V1TransportSerializer serializer{};\n+    // Construct transports for both sides, with dummy NodeIds.\n+    V1Transport recv_transport{NodeId{0}, SER_NETWORK, INIT_PROTO_VERSION};\n+    V1Transport send_transport{NodeId{1}, SER_NETWORK, INIT_PROTO_VERSION};",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": 33,
      "original_position": 17,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": 1299172882,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I believe so, though I think it's cleaner to use two (the test isn't actually trying to model a node talking to itself).",
      "created_at": "2023-08-21T17:13:05Z",
      "updated_at": "2023-08-21T17:13:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300421324",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300421324"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": 38,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 39,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300560292",
      "pull_request_review_id": 1587727302,
      "id": 1300560292,
      "node_id": "PRRC_kwDOABII585NhPmk",
      "diff_hunk": "@@ -906,36 +906,50 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool have_unsent_data{false};",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 8,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "8d1a91f6394f00b880613268a9f2f3164ef914e2",
      "in_reply_to_id": 1298700651,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-08-21T19:33:11Z",
      "updated_at": "2023-08-21T19:33:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300560292",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300560292"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 918,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300562912",
      "pull_request_review_id": 1587732122,
      "id": 1300562912,
      "node_id": "PRRC_kwDOABII585NhQPg",
      "diff_hunk": "@@ -253,42 +256,88 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload).\n+\n     // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    virtual bool ReceivedMessageComplete() const = 0;\n+    // set the deserialization context version\n+    virtual void SetReceiveVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer. Return false is invalid. */\n+    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;\n     // decomposes a message from the context\n-    virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n-    virtual ~TransportDeserializer() {}\n+    virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n+\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<\n+        Span<const uint8_t> /*to_send*/,\n+        bool /*more*/,\n+        const std::string& /*m_type*/\n+    >;\n+\n+    /** Get bytes to send on the wire.\n+     *\n+     * As a const function, it does not modify the transport's observable state, and is thus safe\n+     * to be called multiple times.\n+     *\n+     * The bytes returned by this function act as a stream which can only be appended to. This\n+     * means that with the exception of MarkBytesSent, operations on the transport can only append\n+     * to what is being returned.\n+     */\n+    virtual BytesToSend GetBytesToSend() const noexcept = 0;\n+\n+    /** Report how many bytes returned by the last GetBytesToSend() have been sent.\n+     *\n+     * bytes_sent cannot exceed to_send.size() of the last GetBytesToSend() result.\n+     *\n+     * If bytes_sent=0, this call has no effect.\n+     */\n+    virtual void MarkBytesSent(size_t bytes_sent) noexcept = 0;\n+\n+    /** Return the memory usage of this transport attributable to buffered data to send. */\n+    virtual size_t GetSendMemoryUsage() const noexcept = 0;\n };\n \n-class V1TransportDeserializer final : public TransportDeserializer\n+class V1Transport final : public Transport\n {\n private:\n-    const CChainParams& m_chain_params;\n+    CMessageHeader::MessageStartChars m_magic_bytes;\n     const NodeId m_node_id; // Only for logging\n-    mutable CHash256 hasher;\n-    mutable uint256 data_hash;\n-    bool in_data;                   // parsing header (false) or data (true)\n-    CDataStream hdrbuf;             // partially received header\n-    CMessageHeader hdr;             // complete header\n-    CDataStream vRecv;              // received message data\n-    unsigned int nHdrPos;\n-    unsigned int nDataPos;\n-\n-    const uint256& GetMessageHash() const;\n-    int readHeader(Span<const uint8_t> msg_bytes);\n-    int readData(Span<const uint8_t> msg_bytes);\n-\n-    void Reset() {\n+    mutable Mutex m_cs_recv; //!< Lock for receive state",
      "path": "src/net.h",
      "position": null,
      "original_position": 109,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": 1299174503,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ok, renamed to `m_send_mutex` and `m_recv_mutex`.",
      "created_at": "2023-08-21T19:34:26Z",
      "updated_at": "2023-08-21T19:34:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300562912",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300562912"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 326,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300563521",
      "pull_request_review_id": 1587733048,
      "id": 1300563521,
      "node_id": "PRRC_kwDOABII585NhQZB",
      "diff_hunk": "@@ -299,52 +348,55 @@ class V1TransportDeserializer final : public TransportDeserializer\n         hasher.Reset();\n     }\n \n-public:\n-    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n-        : m_chain_params(chain_params),\n-          m_node_id(node_id),\n-          hdrbuf(nTypeIn, nVersionIn),\n-          vRecv(nTypeIn, nVersionIn)\n+    bool CompleteInternal() const noexcept EXCLUSIVE_LOCKS_REQUIRED(m_cs_recv)\n     {\n-        Reset();\n+        if (!in_data) return false;\n+        return hdr.nMessageSize == nDataPos;\n     }\n \n-    bool Complete() const override\n+    /** Lock for sending state. */\n+    mutable Mutex m_cs_send;\n+    /** The header of the message currently being sent. */\n+    std::vector<uint8_t> m_header_to_send GUARDED_BY(m_cs_send);\n+    /** The data of the message currently being sent. */\n+    CSerializedNetMsg m_message_to_send GUARDED_BY(m_cs_send);\n+    /** Whether we're currently sending header bytes or message bytes. */\n+    bool m_sending_header GUARDED_BY(m_cs_send) {false};\n+    /** How many bytes have been sent so far (from m_header_to_send, or from m_message_to_send.data). */\n+    size_t m_bytes_sent GUARDED_BY(m_cs_send) {0};\n+\n+public:\n+    V1Transport(const NodeId node_id, int nTypeIn, int nVersionIn) noexcept;\n+\n+    bool ReceivedMessageComplete() const override EXCLUSIVE_LOCKS_REQUIRED(!m_cs_recv)\n     {\n-        if (!in_data)\n-            return false;\n-        return (hdr.nMessageSize == nDataPos);\n+        return WITH_LOCK(m_cs_recv, return CompleteInternal());\n     }\n-    void SetVersion(int nVersionIn) override\n+\n+    void SetReceiveVersion(int nVersionIn) override EXCLUSIVE_LOCKS_REQUIRED(!m_cs_recv)\n     {\n+        LOCK(m_cs_recv);",
      "path": "src/net.h",
      "position": null,
      "original_position": 170,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": 1299175706,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added `AssertLockHeld` and `AssertLockNotHeld` everywhere. It's easy to delete some of them later if #27116 would get accepted.",
      "created_at": "2023-08-21T19:35:06Z",
      "updated_at": "2023-08-21T19:35:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300563521",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300563521"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": 376,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 378,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300563612",
      "pull_request_review_id": 1587733194,
      "id": 1300563612,
      "node_id": "PRRC_kwDOABII585NhQac",
      "diff_hunk": "@@ -253,42 +256,88 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload).\n+\n     // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    virtual bool ReceivedMessageComplete() const = 0;\n+    // set the deserialization context version\n+    virtual void SetReceiveVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer. Return false is invalid. */\n+    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;\n     // decomposes a message from the context\n-    virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n-    virtual ~TransportDeserializer() {}\n+    virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n+\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<\n+        Span<const uint8_t> /*to_send*/,\n+        bool /*more*/,\n+        const std::string& /*m_type*/\n+    >;",
      "path": "src/net.h",
      "position": 63,
      "original_position": 63,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": 1299189317,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-08-21T19:35:13Z",
      "updated_at": "2023-08-21T19:35:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300563612",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300563612"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": 286,
      "original_start_line": 286,
      "start_side": "RIGHT",
      "line": 296,
      "original_line": 296,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300563987",
      "pull_request_review_id": 1587733769,
      "id": 1300563987,
      "node_id": "PRRC_kwDOABII585NhQgT",
      "diff_hunk": "@@ -717,7 +726,15 @@ bool CNode::ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete)\n     return true;\n }\n \n-int V1TransportDeserializer::readHeader(Span<const uint8_t> msg_bytes)\n+V1Transport::V1Transport(const NodeId node_id, int nTypeIn, int nVersionIn) noexcept :\n+    m_node_id(node_id), hdrbuf(nTypeIn, nVersionIn), vRecv(nTypeIn, nVersionIn)\n+{\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_magic_bytes);",
      "path": "src/net.cpp",
      "position": 53,
      "original_position": 52,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": 1299996446,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added an assertion equivalent to this.",
      "created_at": "2023-08-21T19:35:42Z",
      "updated_at": "2023-08-21T19:35:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300563987",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300563987"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 733,
      "original_line": 733,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300564065",
      "pull_request_review_id": 1587733919,
      "id": 1300564065,
      "node_id": "PRRC_kwDOABII585NhQhh",
      "diff_hunk": "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 74,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": 1300299930,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-08-21T19:35:48Z",
      "updated_at": "2023-08-21T19:35:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300564065",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300564065"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": 110,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 120,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300564947",
      "pull_request_review_id": 1587735388,
      "id": 1300564947,
      "node_id": "PRRC_kwDOABII585NhQvT",
      "diff_hunk": "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 93,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": 1300311165,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No, it's matching the message type validity criteria from `CMessageHeader::IsCommandValid()`.\r\n\r\nI've reworked this a bit (making it also select from valid messages, which is useful for a follow-up PR anyway), and added comments.",
      "created_at": "2023-08-21T19:36:56Z",
      "updated_at": "2023-08-21T19:36:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300564947",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300564947"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300565046",
      "pull_request_review_id": 1587735534,
      "id": 1300565046,
      "node_id": "PRRC_kwDOABII585NhQw2",
      "diff_hunk": "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    unsigned iter = 0;\n+    while (iter < 1000 && provider.remaining_bytes()) {",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 229,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": 1300343322,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-08-21T19:37:03Z",
      "updated_at": "2023-08-21T19:37:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300565046",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300565046"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": 265,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 266,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300565964",
      "pull_request_review_id": 1587737089,
      "id": 1300565964,
      "node_id": "PRRC_kwDOABII585NhQ_M",
      "diff_hunk": "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    unsigned iter = 0;\n+    while (iter < 1000 && provider.remaining_bytes()) {\n+        uint8_t code = provider.ConsumeIntegral<uint8_t>();\n+        // Lowest bit identifies the sender side of the operation.\n+        int side = code & 1;\n+        switch ((side >> 1) % 3) {",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 233,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": 1300352209,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ouch, that was a serious problem with the fuzz test.\r\n\r\nI've instead replaced it with\r\n\r\n```c++\r\n    LIMITED_WHILE(provider.remaining_bytes(), 1000) {\r\n        CallOneOf(provider,\r\n            // (Try to) give the next message to the transport.\r\n            [&] { new_msg_fn(0); },\r\n            [&] { new_msg_fn(1); },\r\n            // (Try to) send some bytes from the transport to the network.\r\n            [&] { send_fn(0); },\r\n            [&] { send_fn(1); },\r\n            // (Try to) receive bytes from the network, converting to messages.\r\n            [&] { recv_fn(0); },\r\n            [&] { recv_fn(1); }\r\n        );\r\n    }\r\n```\r\n\r\nwhich is hopefully as clear as your suggestion, but doesn't waste 2 bytes of input to pick one of 6 values.",
      "created_at": "2023-08-21T19:38:08Z",
      "updated_at": "2023-08-21T19:38:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300565964",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300565964"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": 269,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 270,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300567446",
      "pull_request_review_id": 1587739350,
      "id": 1300567446,
      "node_id": "PRRC_kwDOABII585NhRWW",
      "diff_hunk": "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    unsigned iter = 0;\n+    while (iter < 1000 && provider.remaining_bytes()) {\n+        uint8_t code = provider.ConsumeIntegral<uint8_t>();\n+        // Lowest bit identifies the sender side of the operation.\n+        int side = code & 1;\n+        switch ((side >> 1) % 3) {\n+        // The other bits (mod 3) identify the operation:\n+        case 0:\n+            // (Try to) give the next message to the transport.\n+            new_msg_fn(side);\n+            break;\n+        case 1:\n+            // (Try to) send some bytes from the transport to the network.\n+            send_fn(side);\n+            break;\n+        case 2:\n+            // (Try to) receive bytes from the network, converting to messages.\n+            recv_fn(side);\n+            break;\n+        }\n+        ++iter;\n+    }\n+\n+    // When we're done, perform sends and receives of existing messages to flush anything already\n+    // in flight.\n+    while (true) {\n+        bool any = false;\n+        if (send_fn(0, true)) any = true;\n+        if (send_fn(1, true)) any = true;\n+        if (recv_fn(0, true)) any = true;\n+        if (recv_fn(1, true)) any = true;\n+        if (!any) break;\n     }\n+\n+    // Make sure nothing is left in flight.\n+    assert(in_flight[0].empty());\n+    assert(in_flight[1].empty());\n+\n+    // Make sure all expected messages were received.\n+    assert(expected[0].empty());\n+    assert(expected[1].empty());\n+}\n+\n+std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n+{\n+    return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(p2p_transport_bidirectional, .init = initialize_p2p_transport_serialization)\n+{\n+    // Test with two V1 transports talking to each other.\n+    FuzzedDataProvider provider{buffer.data(), buffer.size()};\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>());\n+    auto t1 = MakeV1Transport(NodeId{0});\n+    auto t2 = MakeV1Transport(NodeId{1});\n+    if (!t1 || !t2) return;\n+    SimulationTest(*t1, *t2, rng, provider);",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": 300,
      "original_position": 286,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": 1300362306,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I could do that here, but the test gets extended in #28196 with versions that let a V1 transport talk to a V2, and a V2 to a V2 (see https://github.com/bitcoin/bitcoin/blob/b23b1d0700e0cffc0d0d2c624222142f211e04be/src/test/fuzz/p2p_transport_serialization.cpp#L377L408). For consistency, I think the code here is better, though if you want I can delay the introduction to that PR.",
      "created_at": "2023-08-21T19:40:01Z",
      "updated_at": "2023-08-21T19:54:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300567446",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300567446"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": 327,
      "original_start_line": 320,
      "start_side": "RIGHT",
      "line": 330,
      "original_line": 330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300567550",
      "pull_request_review_id": 1587739495,
      "id": 1300567550,
      "node_id": "PRRC_kwDOABII585NhRX-",
      "diff_hunk": "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 154,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": 1300365030,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-08-21T19:40:08Z",
      "updated_at": "2023-08-21T19:40:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300567550",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300567550"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": 190,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301151636",
      "pull_request_review_id": 1588656803,
      "id": 1301151636,
      "node_id": "PRRC_kwDOABII585Njf-U",
      "diff_hunk": "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "path": "src/net.cpp",
      "position": 216,
      "original_position": 21,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "in_reply_to_id": 1283461349,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right, if `CNode::m_sock` is empty `shared_ptr`, that means `CNode::CloseSocketDisconnect()` has been called and this is a one-way street, it is not coming back, so all communication structs and data for this peer can be dropped.\r\n\r\nOr, during tests an empty `shared_ptr` may be supplied to the `CNode` constructor. My understanding is that in those tests the code that uses the socket is not supposed to be reached/executed. Other tests provide a mocked socket, that returns either fuzzed data or static/hardcoded contents upon read in order to entertain the code that receives from the socket.",
      "created_at": "2023-08-22T07:30:45Z",
      "updated_at": "2023-08-22T07:30:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301151636",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301151636"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 938,
      "original_line": 938,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301169095",
      "pull_request_review_id": 1588684364,
      "id": 1301169095,
      "node_id": "PRRC_kwDOABII585NjkPH",
      "diff_hunk": "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    unsigned iter = 0;\n+    while (iter < 1000 && provider.remaining_bytes()) {\n+        uint8_t code = provider.ConsumeIntegral<uint8_t>();\n+        // Lowest bit identifies the sender side of the operation.\n+        int side = code & 1;\n+        switch ((side >> 1) % 3) {\n+        // The other bits (mod 3) identify the operation:\n+        case 0:\n+            // (Try to) give the next message to the transport.\n+            new_msg_fn(side);\n+            break;\n+        case 1:\n+            // (Try to) send some bytes from the transport to the network.\n+            send_fn(side);\n+            break;\n+        case 2:\n+            // (Try to) receive bytes from the network, converting to messages.\n+            recv_fn(side);\n+            break;\n+        }\n+        ++iter;\n+    }\n+\n+    // When we're done, perform sends and receives of existing messages to flush anything already\n+    // in flight.\n+    while (true) {\n+        bool any = false;\n+        if (send_fn(0, true)) any = true;\n+        if (send_fn(1, true)) any = true;\n+        if (recv_fn(0, true)) any = true;\n+        if (recv_fn(1, true)) any = true;\n+        if (!any) break;\n     }\n+\n+    // Make sure nothing is left in flight.\n+    assert(in_flight[0].empty());\n+    assert(in_flight[1].empty());\n+\n+    // Make sure all expected messages were received.\n+    assert(expected[0].empty());\n+    assert(expected[1].empty());\n+}\n+\n+std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n+{\n+    return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(p2p_transport_bidirectional, .init = initialize_p2p_transport_serialization)\n+{\n+    // Test with two V1 transports talking to each other.\n+    FuzzedDataProvider provider{buffer.data(), buffer.size()};\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>());\n+    auto t1 = MakeV1Transport(NodeId{0});\n+    auto t2 = MakeV1Transport(NodeId{1});\n+    if (!t1 || !t2) return;\n+    SimulationTest(*t1, *t2, rng, provider);",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": 300,
      "original_position": 286,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "in_reply_to_id": 1300362306,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It is ok as it is - there is _some_ reason for using pointers.",
      "created_at": "2023-08-22T07:45:44Z",
      "updated_at": "2023-08-22T07:45:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301169095",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301169095"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": 327,
      "original_start_line": 320,
      "start_side": "RIGHT",
      "line": 330,
      "original_line": 330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301295281",
      "pull_request_review_id": 1588883611,
      "id": 1301295281,
      "node_id": "PRRC_kwDOABII585NkDCx",
      "diff_hunk": "@@ -253,42 +256,92 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload).\n+\n     // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    virtual bool ReceivedMessageComplete() const = 0;\n+    // set the deserialization context version\n+    virtual void SetReceiveVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer. Return false is invalid. */\n+    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;\n     // decomposes a message from the context\n-    virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n-    virtual ~TransportDeserializer() {}\n+    virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n+\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<\n+        Span<const uint8_t> /*to_send*/,\n+        bool /*more*/,\n+        const std::string& /*m_type*/\n+    >;\n+\n+    /** Get bytes to send on the wire.\n+     *\n+     * As a const function, it does not modify the transport's observable state, and is thus safe\n+     * to be called multiple times.\n+     *\n+     * The bytes returned by this function act as a stream which can only be appended to. This\n+     * means that with the exception of MarkBytesSent, operations on the transport can only append\n+     * to what is being returned.\n+     *\n+     * Note that the m_type value returned is a reference, and calling any non-const function on",
      "path": "src/net.h",
      "position": 74,
      "original_position": 74,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: and `to_send` too\r\n```suggestion\r\n     * Note that m_type and to_send refer to data that is internal to the transport, and calling any non-const function on\r\n```",
      "created_at": "2023-08-22T08:59:59Z",
      "updated_at": "2023-08-22T13:14:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301295281",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301295281"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 307,
      "original_line": 307,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301317614",
      "pull_request_review_id": 1588883611,
      "id": 1301317614,
      "node_id": "PRRC_kwDOABII585NkIfu",
      "diff_hunk": "@@ -63,22 +74,258 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n         }\n     }\n }\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    const std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two vectors representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        uint8_t v = provider.ConsumeIntegral<uint8_t>();\n+        if (v <= 12) {\n+            // If v is in range 0..12, construct a valid (but possibly unknown) message type of",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": 108,
      "original_position": 108,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit:\r\n```suggestion\r\n        if (v <= CMessageHeader::COMMAND_SIZE) {\r\n            // If v is below the maximum command size, construct a valid (but possibly unknown) message type of\r\n```",
      "created_at": "2023-08-22T09:14:03Z",
      "updated_at": "2023-08-22T13:14:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301317614",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301317614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": 137,
      "original_start_line": 137,
      "start_side": "RIGHT",
      "line": 138,
      "original_line": 138,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301329839",
      "pull_request_review_id": 1588883611,
      "id": 1301329839,
      "node_id": "PRRC_kwDOABII585NkLev",
      "diff_hunk": "@@ -63,22 +74,258 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n         }\n     }\n }\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    const std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two vectors representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        uint8_t v = provider.ConsumeIntegral<uint8_t>();\n+        if (v <= 12) {\n+            // If v is in range 0..12, construct a valid (but possibly unknown) message type of\n+            // that length from the fuzz data.\n+            std::string ret;\n+            while (ret.size() < v) {\n+                char c = provider.ConsumeIntegral<char>();\n+                // Match the allowed characters in CMessageHeader::IsCommandValid().\n+                if (c < ' ' || c > 0x7E) break;\n+                ret += c;\n+            }\n+            return ret;\n+        } else {\n+            // Otherwise, use it as index into the list of known messages.\n+            return g_all_messages[(v - 13) % g_all_messages.size()];",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": 120,
      "original_position": 120,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I guess the following would achieve the same, no need to subtract 13?\r\n\r\n```suggestion\r\n            return g_all_messages[v % g_all_messages.size()];\r\n```",
      "created_at": "2023-08-22T09:20:31Z",
      "updated_at": "2023-08-22T13:14:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301329839",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301329839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 150,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301356016",
      "pull_request_review_id": 1588883611,
      "id": 1301356016,
      "node_id": "PRRC_kwDOABII585NkR3w",
      "diff_hunk": "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.\n                 break;\n             }\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n #ifdef MSG_MORE\n-            if (it + 1 != node.vSendMsg.end()) {\n+            // We have more to send if either the transport itself has more, or if we have more\n+            // messages to send.\n+            if (more || it != node.vSendMsg.end()) {\n                 flags |= MSG_MORE;\n             }\n #endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, flags);\n+            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n         }\n         if (nBytes > 0) {\n             node.m_last_send = GetTime<std::chrono::seconds>();\n             node.nSendBytes += nBytes;\n-            node.nSendOffset += nBytes;\n+            // Notify transport that bytes have been processed.\n+            node.m_transport->MarkBytesSent(nBytes);\n+            // Update statistics per message type.\n+            node.AccountForSentBytes(msg_type, nBytes);\n             nSentSize += nBytes;\n-            if (node.nSendOffset == data.size()) {\n-                node.nSendOffset = 0;\n-                node.nSendSize -= data.size();\n-                node.fPauseSend = node.nSendSize > nSendBufferMaxSize;",
      "path": "src/net.cpp",
      "position": 244,
      "original_position": 244,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In the old code it was really strange to check whether `nSendSize` is too big after _decrementing_ it. Good that this is gone now.",
      "created_at": "2023-08-22T09:35:20Z",
      "updated_at": "2023-08-22T13:14:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301356016",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301356016"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": 865,
      "original_start_line": 865,
      "start_side": "LEFT",
      "line": 866,
      "original_line": 866,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301442058",
      "pull_request_review_id": 1588883611,
      "id": 1301442058,
      "node_id": "PRRC_kwDOABII585Nkm4K",
      "diff_hunk": "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.",
      "path": "src/net.cpp",
      "position": 217,
      "original_position": 217,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit:\r\n```suggestion\r\n                // Don't set data_left here; we won't ever send anything anymore.\r\n```",
      "created_at": "2023-08-22T10:32:01Z",
      "updated_at": "2023-08-22T13:14:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301442058",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301442058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 939,
      "original_line": 939,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301450436",
      "pull_request_review_id": 1588883611,
      "id": 1301450436,
      "node_id": "PRRC_kwDOABII585Nko7E",
      "diff_hunk": "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.\n                 break;\n             }\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n #ifdef MSG_MORE\n-            if (it + 1 != node.vSendMsg.end()) {\n+            // We have more to send if either the transport itself has more, or if we have more\n+            // messages to send.\n+            if (more || it != node.vSendMsg.end()) {\n                 flags |= MSG_MORE;\n             }\n #endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, flags);\n+            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n         }\n         if (nBytes > 0) {\n             node.m_last_send = GetTime<std::chrono::seconds>();\n             node.nSendBytes += nBytes;\n-            node.nSendOffset += nBytes;\n+            // Notify transport that bytes have been processed.\n+            node.m_transport->MarkBytesSent(nBytes);\n+            // Update statistics per message type.\n+            node.AccountForSentBytes(msg_type, nBytes);\n             nSentSize += nBytes;\n-            if (node.nSendOffset == data.size()) {\n-                node.nSendOffset = 0;\n-                node.nSendSize -= data.size();\n-                node.fPauseSend = node.nSendSize > nSendBufferMaxSize;\n-                it++;\n-            } else {\n+            if ((size_t)nBytes != data.size()) {\n                 // could not send full message; stop sending more\n+                data_left = true;",
      "path": "src/net.cpp",
      "position": 249,
      "original_position": 249,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`more` and `data_left` mean similar things and I find the names a bit confusing or difficult to distinguish which one means what. Maybe consider something like `more_in_transport` and `more_in_data`.\r\n\r\nEdit: wait, they mean the same thing. I thought that `data_left` would be used to retry with the remaining from the `data` variable, but this is not the case. Evey time we set `data_left` to `true` we break from the loop, getting `data` out of scope and losing it. In this case the data remains in the transport.\r\n\r\nIs it possible to use just one variable, something like the following?\r\n\r\n<details>\r\n<summary>[patch] just one variable to designate more data remains for sending</summary>\r\n\r\n```diff\r\n--- i/src/net.cpp\r\n+++ w/src/net.cpp\r\n@@ -925,13 +925,14 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\r\n             if (node.m_transport->SetMessageToSend(*it)) {\r\n                 // Update memory usage of send buffer (as *it will be deleted).\r\n                 node.m_send_memusage -= memusage;\r\n                 ++it;\r\n             }\r\n         }\r\n-        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\r\n+        const auto& [data, _data_left, msg_type] = node.m_transport->GetBytesToSend();\r\n+        data_left = _data_left;\r\n         int nBytes = 0;\r\n         if (!data.empty()) {\r\n             LOCK(node.m_sock_mutex);\r\n             // There is no socket in case we've already disconnected, or in test cases without\r\n             // real connections. In these cases, we bail out immediately and just leave things\r\n             // in the send queue and transport.\r\n@@ -940,13 +941,13 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\r\n                 break;\r\n             }\r\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\r\n #ifdef MSG_MORE\r\n             // We have more to send if either the transport itself has more, or if we have more\r\n             // messages to send.\r\n-            if (more || it != node.vSendMsg.end()) {\r\n+            if (data_left || it != node.vSendMsg.end()) {\r\n                 flags |= MSG_MORE;\r\n             }\r\n #endif\r\n             nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\r\n         }\r\n         if (nBytes > 0) {\r\n@@ -969,13 +970,15 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\r\n                 if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS) {\r\n                     LogPrint(BCLog::NET, \"socket send error for peer=%d: %s\\n\", node.GetId(), NetworkErrorString(nErr));\r\n                     node.CloseSocketDisconnect();\r\n                 }\r\n             }\r\n             // couldn't send anything at all\r\n-            data_left = !data.empty();\r\n+            if (!data.empty()) {\r\n+                data_left = true;\r\n+            }\r\n             break;\r\n         }\r\n     }\r\n \r\n     node.fPauseSend = node.m_send_memusage + node.m_transport->GetSendMemoryUsage() > nSendBufferMaxSize;\r\n \r\n```\r\n</details>",
      "created_at": "2023-08-22T10:40:14Z",
      "updated_at": "2023-08-22T13:14:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301450436",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301450436"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 962,
      "original_line": 962,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301471895",
      "pull_request_review_id": 1588883611,
      "id": 1301471895,
      "node_id": "PRRC_kwDOABII585NkuKX",
      "diff_hunk": "@@ -1227,7 +1322,14 @@ Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\n \n     for (CNode* pnode : nodes) {\n         bool select_recv = !pnode->fPauseRecv;\n-        bool select_send = WITH_LOCK(pnode->cs_vSend, return !pnode->vSendMsg.empty());\n+        bool select_send;\n+        {\n+            LOCK(pnode->cs_vSend);\n+            // Sending is possible if either there are bytes to send right now, or if there will be\n+            // once a potential message from vSendMsg is handed to the transport.\n+            const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();",
      "path": "src/net.cpp",
      "position": 285,
      "original_position": 285,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Since the last two seem to be irrelevant and unused, if there is no other reason to show some meaningful names, then:\r\n\r\n```suggestion\r\n            const auto& [to_send, std::ignore, std::ignore] = pnode->m_transport->GetBytesToSend();\r\n```\r\n\r\n(same in `CConnman::PushMessage()` and in the tests)",
      "created_at": "2023-08-22T11:00:06Z",
      "updated_at": "2023-08-22T13:14:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301471895",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301471895"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1330,
      "original_line": 1330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301566071",
      "pull_request_review_id": 1588883611,
      "id": 1301566071,
      "node_id": "PRRC_kwDOABII585NlFJ3",
      "diff_hunk": "@@ -2906,27 +3007,24 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_serializer->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n+        const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\n+        const bool queue_was_empty{to_send.empty() && pnode->vSendMsg.empty()};",
      "path": "src/net.cpp",
      "position": 315,
      "original_position": 315,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This logic is used also in `CConnman::GenerateWaitSockets()` but negated: `select_send = !to_send.empty() || !pnode->vSendMsg.empty();` is it worth introducing `bool CNode::SendQueueEmpty()` and using it in both places?\r\n\r\n<details>\r\n<summary>[patch] CNode::SendQueueEmpty()</summary>\r\n\r\n```diff\r\n--- i/src/net.cpp\r\n+++ w/src/net.cpp\r\n@@ -1319,20 +1319,13 @@ Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\r\n     for (const ListenSocket& hListenSocket : vhListenSocket) {\r\n         events_per_sock.emplace(hListenSocket.sock, Sock::Events{Sock::RECV});\r\n     }\r\n \r\n     for (CNode* pnode : nodes) {\r\n         bool select_recv = !pnode->fPauseRecv;\r\n-        bool select_send;\r\n-        {\r\n-            LOCK(pnode->cs_vSend);\r\n-            // Sending is possible if either there are bytes to send right now, or if there will be\r\n-            // once a potential message from vSendMsg is handed to the transport.\r\n-            const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\r\n-            select_send = !to_send.empty() || !pnode->vSendMsg.empty();\r\n-        }\r\n+        bool select_send = WITH_LOCK(pnode->cs_vSend, !pnode->SendQueueEmpty());\r\n         if (!select_recv && !select_send) continue;\r\n \r\n         LOCK(pnode->m_sock_mutex);\r\n         if (pnode->m_sock) {\r\n             Sock::Event event = (select_send ? Sock::SEND : 0) | (select_recv ? Sock::RECV : 0);\r\n             events_per_sock.emplace(pnode->m_sock, Sock::Events{event});\r\n@@ -3007,14 +3000,13 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\r\n         msg.data.data()\r\n     );\r\n \r\n     size_t nBytesSent = 0;\r\n     {\r\n         LOCK(pnode->cs_vSend);\r\n-        const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\r\n-        const bool queue_was_empty{to_send.empty() && pnode->vSendMsg.empty()};\r\n+        const bool queue_was_empty{pnode->SendQueueEmpty()};\r\n \r\n         // Update memory usage of send buffer.\r\n         pnode->m_send_memusage += msg.GetMemoryUsage();\r\n         if (pnode->m_send_memusage + pnode->m_transport->GetSendMemoryUsage() > nSendBufferMaxSize) pnode->fPauseSend = true;\r\n         // Move message to vSendMsg queue.\r\n         pnode->vSendMsg.push_back(std::move(msg));\r\n```\r\n</details>",
      "created_at": "2023-08-22T12:25:13Z",
      "updated_at": "2023-08-22T13:14:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301566071",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301566071"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3014,
      "original_line": 3014,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301596054",
      "pull_request_review_id": 1588883611,
      "id": 1301596054,
      "node_id": "PRRC_kwDOABII585NlMeW",
      "diff_hunk": "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();",
      "path": "src/net.cpp",
      "position": 189,
      "original_position": 189,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Just a comment and a question.\r\n\r\nWrt the title of the commit message 69f4b340c068078cca7b68aa04360aaa7c0fd12b `net: move message serialization from PushMessage to SocketSendData`\r\n\r\nBy \"serialization\" you mean creating/serializing the header and concatenating it with the bytes of the already serialized payload? I find this a bit confusing as I would assume that once we have `CSerializedNetMsg` then serialization has already happened (both of the header and of the payload). It should be done by `CNetMsgMaker::Make()` which takes the high-level data and produces `CSerializedNetMsg`.\r\n\r\nWhy in the first place, even in `master` do we need to have the header bytes serialized in another place than the payload? Why was it not done so that `CNetMsgMaker::Make()` would produce both serialized header bytes plus serialized payload bytes, concatenate them and return a single byte array?",
      "created_at": "2023-08-22T12:48:31Z",
      "updated_at": "2023-08-22T13:14:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301596054",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301596054"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 916,
      "original_line": 916,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301621484",
      "pull_request_review_id": 1588883611,
      "id": 1301621484,
      "node_id": "PRRC_kwDOABII585NlSrs",
      "diff_hunk": "@@ -253,42 +256,92 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload).\n+\n     // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    virtual bool ReceivedMessageComplete() const = 0;\n+    // set the deserialization context version\n+    virtual void SetReceiveVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer. Return false is invalid. */\n+    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;",
      "path": "src/net.h",
      "position": 37,
      "original_position": 37,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`s/false is invalid/false if invalid/` or even better, tell doxygen about it:\r\n\r\n```suggestion\r\n    /**\r\n     * Read and deserialize data, advance msg_bytes data pointer.\r\n     * @return false if invalid.\r\n     */\r\n    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;\r\n```",
      "created_at": "2023-08-22T13:07:22Z",
      "updated_at": "2023-08-22T13:14:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301621484",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301621484"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": 271,
      "original_start_line": 271,
      "start_side": "RIGHT",
      "line": 272,
      "original_line": 272,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301625342",
      "pull_request_review_id": 1588883611,
      "id": 1301625342,
      "node_id": "PRRC_kwDOABII585NlTn-",
      "diff_hunk": "@@ -681,16 +690,16 @@ bool CNode::ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete)\n     nRecvBytes += msg_bytes.size();\n     while (msg_bytes.size() > 0) {\n         // absorb network data\n-        int handled = m_deserializer->Read(msg_bytes);\n-        if (handled < 0) {\n+        bool handled = m_transport->ReceivedBytes(msg_bytes);\n+        if (!handled) {",
      "path": "src/net.cpp",
      "position": 30,
      "original_position": 30,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit (`handled` is not used afterwards):\r\n```suggestion\r\n        if (!m_transport->ReceivedBytes(msg_bytes)) {\r\n```\r\n(same in `p2p_transport_serialization.cpp`)",
      "created_at": "2023-08-22T13:10:12Z",
      "updated_at": "2023-08-22T13:14:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301625342",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301625342"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": 693,
      "original_start_line": 693,
      "start_side": "RIGHT",
      "line": 694,
      "original_line": 694,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301752779",
      "pull_request_review_id": 1589613663,
      "id": 1301752779,
      "node_id": "PRRC_kwDOABII585NlyvL",
      "diff_hunk": "@@ -681,16 +690,16 @@ bool CNode::ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete)\n     nRecvBytes += msg_bytes.size();\n     while (msg_bytes.size() > 0) {\n         // absorb network data\n-        int handled = m_deserializer->Read(msg_bytes);\n-        if (handled < 0) {\n+        bool handled = m_transport->ReceivedBytes(msg_bytes);\n+        if (!handled) {",
      "path": "src/net.cpp",
      "position": 30,
      "original_position": 30,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": 1301625342,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't mind keeping `handled` around, to make it more clear that receiving 0 bytes is also \"handled\".",
      "created_at": "2023-08-22T14:38:11Z",
      "updated_at": "2023-08-22T14:38:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301752779",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301752779"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": 693,
      "original_start_line": 693,
      "start_side": "RIGHT",
      "line": 694,
      "original_line": 694,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301776903",
      "pull_request_review_id": 1589654378,
      "id": 1301776903,
      "node_id": "PRRC_kwDOABII585Nl4oH",
      "diff_hunk": "@@ -2906,27 +3007,24 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_serializer->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n+        const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\n+        const bool queue_was_empty{to_send.empty() && pnode->vSendMsg.empty()};",
      "path": "src/net.cpp",
      "position": 315,
      "original_position": 315,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": 1301566071,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Didn't check, but that looks like a nice simplification indeed.",
      "created_at": "2023-08-22T14:54:17Z",
      "updated_at": "2023-08-22T14:54:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301776903",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301776903"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3014,
      "original_line": 3014,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301780539",
      "pull_request_review_id": 1589659238,
      "id": 1301780539,
      "node_id": "PRRC_kwDOABII585Nl5g7",
      "diff_hunk": "@@ -1227,7 +1322,14 @@ Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\n \n     for (CNode* pnode : nodes) {\n         bool select_recv = !pnode->fPauseRecv;\n-        bool select_send = WITH_LOCK(pnode->cs_vSend, return !pnode->vSendMsg.empty());\n+        bool select_send;\n+        {\n+            LOCK(pnode->cs_vSend);\n+            // Sending is possible if either there are bytes to send right now, or if there will be\n+            // once a potential message from vSendMsg is handed to the transport.\n+            const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();",
      "path": "src/net.cpp",
      "position": 285,
      "original_position": 285,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": 1301471895,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Optionally annotate the return values if the fact that we're ignoring them is potentially interesting / strange. `[to_send, /*more=*/std::ignore, /*msg_type=*/std::ignore] = pnode->â€¦`",
      "created_at": "2023-08-22T14:56:17Z",
      "updated_at": "2023-08-22T14:56:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301780539",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301780539"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1330,
      "original_line": 1330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301793247",
      "pull_request_review_id": 1589679118,
      "id": 1301793247,
      "node_id": "PRRC_kwDOABII585Nl8nf",
      "diff_hunk": "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.\n                 break;\n             }\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n #ifdef MSG_MORE\n-            if (it + 1 != node.vSendMsg.end()) {\n+            // We have more to send if either the transport itself has more, or if we have more\n+            // messages to send.\n+            if (more || it != node.vSendMsg.end()) {\n                 flags |= MSG_MORE;\n             }\n #endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, flags);\n+            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n         }\n         if (nBytes > 0) {\n             node.m_last_send = GetTime<std::chrono::seconds>();\n             node.nSendBytes += nBytes;\n-            node.nSendOffset += nBytes;\n+            // Notify transport that bytes have been processed.\n+            node.m_transport->MarkBytesSent(nBytes);\n+            // Update statistics per message type.\n+            node.AccountForSentBytes(msg_type, nBytes);\n             nSentSize += nBytes;\n-            if (node.nSendOffset == data.size()) {\n-                node.nSendOffset = 0;\n-                node.nSendSize -= data.size();\n-                node.fPauseSend = node.nSendSize > nSendBufferMaxSize;",
      "path": "src/net.cpp",
      "position": 244,
      "original_position": 244,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": 1301356016,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "FWIW, this line is (was) for turning `fPauseSend` **off** again after the buffer level dropped.",
      "created_at": "2023-08-22T15:04:51Z",
      "updated_at": "2023-08-22T15:04:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301793247",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301793247"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": 865,
      "original_start_line": 865,
      "start_side": "LEFT",
      "line": 866,
      "original_line": 866,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301796779",
      "pull_request_review_id": 1589684797,
      "id": 1301796779,
      "node_id": "PRRC_kwDOABII585Nl9er",
      "diff_hunk": "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.\n                 break;\n             }\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n #ifdef MSG_MORE\n-            if (it + 1 != node.vSendMsg.end()) {\n+            // We have more to send if either the transport itself has more, or if we have more\n+            // messages to send.\n+            if (more || it != node.vSendMsg.end()) {\n                 flags |= MSG_MORE;\n             }\n #endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, flags);\n+            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n         }\n         if (nBytes > 0) {\n             node.m_last_send = GetTime<std::chrono::seconds>();\n             node.nSendBytes += nBytes;\n-            node.nSendOffset += nBytes;\n+            // Notify transport that bytes have been processed.\n+            node.m_transport->MarkBytesSent(nBytes);\n+            // Update statistics per message type.\n+            node.AccountForSentBytes(msg_type, nBytes);\n             nSentSize += nBytes;\n-            if (node.nSendOffset == data.size()) {\n-                node.nSendOffset = 0;\n-                node.nSendSize -= data.size();\n-                node.fPauseSend = node.nSendSize > nSendBufferMaxSize;\n-                it++;\n-            } else {\n+            if ((size_t)nBytes != data.size()) {\n                 // could not send full message; stop sending more\n+                data_left = true;",
      "path": "src/net.cpp",
      "position": 249,
      "original_position": 249,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": 1301450436,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I would use `data_in_transport` instead of `_data_left` (see https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1298717971).\r\n\r\nAnd then drop `data_left = _data_left;`. \r\n\r\nThen below:\r\n\r\n```cpp\r\nbool message_queue_empty = it == node.vSendMsg.end()`\r\nif (data_in_transport || !message_queue_empty) {\r\n  flags |= MSG_MORE;\r\n```\r\n\r\nAnd:\r\n\r\n```\r\n// couldn't send anything at all\r\nif (!data.empty()) {\r\n  data_in_transport = true\r\n}\r\n```\r\n\r\nAnd then finally return `!message_queue_empty || data_in_transport` instead of `data_left`.",
      "created_at": "2023-08-22T15:07:29Z",
      "updated_at": "2023-08-22T15:07:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301796779",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301796779"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 962,
      "original_line": 962,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301802100",
      "pull_request_review_id": 1589692782,
      "id": 1301802100,
      "node_id": "PRRC_kwDOABII585Nl-x0",
      "diff_hunk": "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.\n                 break;\n             }\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n #ifdef MSG_MORE\n-            if (it + 1 != node.vSendMsg.end()) {\n+            // We have more to send if either the transport itself has more, or if we have more\n+            // messages to send.\n+            if (more || it != node.vSendMsg.end()) {\n                 flags |= MSG_MORE;\n             }\n #endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, flags);\n+            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n         }\n         if (nBytes > 0) {\n             node.m_last_send = GetTime<std::chrono::seconds>();\n             node.nSendBytes += nBytes;\n-            node.nSendOffset += nBytes;\n+            // Notify transport that bytes have been processed.\n+            node.m_transport->MarkBytesSent(nBytes);\n+            // Update statistics per message type.\n+            node.AccountForSentBytes(msg_type, nBytes);\n             nSentSize += nBytes;\n-            if (node.nSendOffset == data.size()) {\n-                node.nSendOffset = 0;\n-                node.nSendSize -= data.size();\n-                node.fPauseSend = node.nSendSize > nSendBufferMaxSize;\n-                it++;\n-            } else {\n+            if ((size_t)nBytes != data.size()) {\n                 // could not send full message; stop sending more\n+                data_left = true;",
      "path": "src/net.cpp",
      "position": 249,
      "original_position": 249,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": 1301450436,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't find this easier to reason about, as the two variables do mean something different (one is whether more bytes follow *after* `to_send`, and the other is a return value saying whether `SocketSendData` didn't send everything).\r\n\r\nThere is another (even) shorter solution, I think:\r\n\r\n```diff\r\n\r\n--- i/src/net.cpp\r\n+++ w/src/net.cpp\r\n@@ -925,13 +925,14 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\r\n             if (node.m_transport->SetMessageToSend(*it)) {\r\n                 // Update memory usage of send buffer (as *it will be deleted).\r\n                 node.m_send_memusage -= memusage;\r\n                 ++it;\r\n             }\r\n         }\r\n         const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\r\n+        data_left = !data.empty(); // will be overwritten on the next loop if we send data in full.\r\n         int nBytes = 0;\r\n         if (!data.empty()) {\r\n             LOCK(node.m_sock_mutex);\r\n             // There is no socket in case we've already disconnected, or in test cases without\r\n             // real connections. In these cases, we bail out immediately and just leave things\r\n             // in the send queue and transport.\r\n@@ -940,13 +941,13 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\r\n                 break;\r\n             }\r\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\r\n #ifdef MSG_MORE\r\n             // We have more to send if either the transport itself has more, or if we have more\r\n             // messages to send.\r\n             if (more || it != node.vSendMsg.end()) {\r\n                 flags |= MSG_MORE;\r\n             }\r\n #endif\r\n             nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\r\n         }\r\n         if (nBytes > 0) {\r\n@@ -969,13 +970,15 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\r\n                 if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS) {\r\n                     LogPrint(BCLog::NET, \"socket send error for peer=%d: %s\\n\", node.GetId(), NetworkErrorString(nErr));\r\n                     node.CloseSocketDisconnect();\r\n                 }\r\n             }\r\n             // couldn't send anything at all\r\n             break;\r\n         }\r\n     }\r\n \r\n     node.fPauseSend = node.m_send_memusage + node.m_transport->GetSendMemoryUsage() > nSendBufferMaxSize;\r\n```\r\n\r\nDo you think that's better?",
      "created_at": "2023-08-22T15:11:18Z",
      "updated_at": "2023-08-22T15:11:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301802100",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301802100"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 962,
      "original_line": 962,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301806332",
      "pull_request_review_id": 1589699419,
      "id": 1301806332,
      "node_id": "PRRC_kwDOABII585Nl_z8",
      "diff_hunk": "@@ -1227,7 +1322,14 @@ Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\n \n     for (CNode* pnode : nodes) {\n         bool select_recv = !pnode->fPauseRecv;\n-        bool select_send = WITH_LOCK(pnode->cs_vSend, return !pnode->vSendMsg.empty());\n+        bool select_send;\n+        {\n+            LOCK(pnode->cs_vSend);\n+            // Sending is possible if either there are bytes to send right now, or if there will be\n+            // once a potential message from vSendMsg is handed to the transport.\n+            const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();",
      "path": "src/net.cpp",
      "position": 285,
      "original_position": 285,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": 1301471895,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is not valid C++. `std::ignore` can be used as an argument to `std::tie`, but not in structured bindings. The `_` in front is supposed to indicate the variables are unused, instead (which also documents their name).",
      "created_at": "2023-08-22T15:14:29Z",
      "updated_at": "2023-08-22T15:14:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301806332",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301806332"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1330,
      "original_line": 1330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301958961",
      "pull_request_review_id": 1589955318,
      "id": 1301958961,
      "node_id": "PRRC_kwDOABII585NmlEx",
      "diff_hunk": "@@ -2910,27 +2957,40 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n-\n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n-\n-        if (pnode->nSendSize > nSendBufferMaxSize) pnode->fPauseSend = true;\n-        pnode->vSendMsg.push_back(std::move(serializedHeader));\n-        if (nMessageSize) pnode->vSendMsg.push_back(std::move(msg.data));\n-\n-        // If write queue empty, attempt \"optimistic write\"\n-        bool data_left;\n-        if (optimisticSend) std::tie(nBytesSent, data_left) = SocketSendData(*pnode);\n+        const bool queue_was_empty{pnode->vSendMsg.empty()};\n+\n+        // Give the message to the transport, and add all bytes it wants us to send out as byte\n+        // vectors to vSendMsg. This is temporary code that exists to support the new transport\n+        // sending interface using the old way of queueing data. In a future commit vSendMsg will\n+        // be replaced with a queue of CSerializedNetMsg objects to be sent instead, and this code\n+        // will disappear.\n+        bool queued = pnode->m_transport->SetMessageToSend(msg);\n+        assert(queued);\n+        // In the current transport (V1Transport), GetBytesToSend first returns a header to send,\n+        // and then the payload data (if any), necessitating a loop.\n+        while (true) {\n+            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 105,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "319ceaa5c80951e6b454bf2f6367aac780689d2f",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "tiny-indicate-unused-nit:\r\n```suggestion\r\n            const auto& [bytes, _more, msg_type] = pnode->m_transport->GetBytesToSend();\r\n```\r\n(probably not worth retouching as that code is replaced in a later commit anyways)",
      "created_at": "2023-08-22T17:14:59Z",
      "updated_at": "2023-08-22T17:57:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301958961",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301958961"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2975,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301992679",
      "pull_request_review_id": 1590009522,
      "id": 1301992679,
      "node_id": "PRRC_kwDOABII585NmtTn",
      "diff_hunk": "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.\n                 break;\n             }\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n #ifdef MSG_MORE\n-            if (it + 1 != node.vSendMsg.end()) {\n+            // We have more to send if either the transport itself has more, or if we have more\n+            // messages to send.\n+            if (more || it != node.vSendMsg.end()) {\n                 flags |= MSG_MORE;\n             }\n #endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, flags);\n+            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n         }\n         if (nBytes > 0) {\n             node.m_last_send = GetTime<std::chrono::seconds>();\n             node.nSendBytes += nBytes;\n-            node.nSendOffset += nBytes;\n+            // Notify transport that bytes have been processed.\n+            node.m_transport->MarkBytesSent(nBytes);\n+            // Update statistics per message type.\n+            node.AccountForSentBytes(msg_type, nBytes);\n             nSentSize += nBytes;\n-            if (node.nSendOffset == data.size()) {\n-                node.nSendOffset = 0;\n-                node.nSendSize -= data.size();\n-                node.fPauseSend = node.nSendSize > nSendBufferMaxSize;\n-                it++;\n-            } else {\n+            if ((size_t)nBytes != data.size()) {\n                 // could not send full message; stop sending more\n+                data_left = true;",
      "path": "src/net.cpp",
      "position": 249,
      "original_position": 249,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": 1301450436,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm only seeing an _extra_ line hereâ€¦? But something along those lines could be worth a shot.",
      "created_at": "2023-08-22T17:48:19Z",
      "updated_at": "2023-08-22T17:48:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301992679",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301992679"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 962,
      "original_line": 962,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301998730",
      "pull_request_review_id": 1589955318,
      "id": 1301998730,
      "node_id": "PRRC_kwDOABII585NmuyK",
      "diff_hunk": "@@ -681,16 +690,16 @@ bool CNode::ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete)\n     nRecvBytes += msg_bytes.size();\n     while (msg_bytes.size() > 0) {\n         // absorb network data\n-        int handled = m_deserializer->Read(msg_bytes);\n-        if (handled < 0) {\n+        bool handled = m_transport->ReceivedBytes(msg_bytes);\n+        if (!handled) {",
      "path": "src/net.cpp",
      "position": 30,
      "original_position": 30,
      "commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "original_commit_id": "678809e00178b33e273f0775eea9635fecaf386a",
      "in_reply_to_id": 1301625342,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: if `handled` is decided to be kept, it should be declared as `const`.",
      "created_at": "2023-08-22T17:54:45Z",
      "updated_at": "2023-08-22T17:57:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301998730",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301998730"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
        }
      },
      "start_line": 693,
      "original_start_line": 693,
      "start_side": "RIGHT",
      "line": 694,
      "original_line": 694,
      "side": "RIGHT"
    }
  ]
}