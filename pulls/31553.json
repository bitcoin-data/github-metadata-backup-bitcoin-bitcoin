{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553",
    "id": 2248495552,
    "node_id": "PR_kwDOABII586GBVHA",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/31553",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/31553.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/31553.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/2b2df98747fdb6380588991167ce2e8cb92f3bfb",
    "number": 31553,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "cluster mempool: add TxGraph reorg functionality",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Part of cluster mempool (#30289).\r\n\r\nDuring reorganisations, it is possible that dependencies get added which would result in clusters that violate policy limits (cluster count, cluster weight), when linking the new from-block transactions to the old from-mempool transactions. Unlike RBF scenarios, we cannot simply reject the changes when they are due to received blocks. To accommodate this, add a `TxGraph::Trim()`, which removes some subset of transactions (including descendants) in order to make all resulting clusters satisfy the limits.\r\n\r\nConceptually, the way this is done is by defining a rudimentary linearization for the entire would-be too-large cluster, iterating it from beginning to end, and reasoning about the counts and weights of the clusters that would be reached using transactions up to that point. If a transaction is encountered whose addition would violate the limit, it is removed, together with all its descendants.\r\n\r\nThis rudimentary linearization is like a merge sort of the chunks of the clusters being combined, but respecting topology. More specifically, it is continuously picking the highest-chunk-feerate remaining transaction among those which have no unmet dependencies left. For efficiency, this rudimentary linearization is computed lazily, by putting all viable transactions in a heap, sorted by chunk feerate, and adding new transactions to it as they become viable.\r\n\r\nThe `Trim()` function is rather unusual compared to the `TxGraph` functionality added in previous PRs, in that `Trim()` makes it own decisions about what the resulting graph contents will be, without good specification of how it makes that decision - it is just a best-effort attempt (which is improved in the last commit). All other `TxGraph` mutators are simply to inform the graph about changes the calling mempool code decided on; this one lets the decision be made by txgraph.\r\n\r\nAs part of this, the \"oversized\" property is expanded to also encompass a configurable cluster weight limit (in addition to cluster count limit). \r\n",
    "labels": [
      {
        "id": 164208572,
        "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
        "name": "Mempool",
        "color": "fef2c0",
        "default": false
      }
    ],
    "created_at": "2024-12-22T19:06:05Z",
    "updated_at": "2025-07-01T20:39:03Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "c15c4b23265301432c2822b34e13b916c0fb4e7f",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sipa:202412_txgraph_trim",
      "ref": "202412_txgraph_trim",
      "sha": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 20,
        "stargazers_count": 90,
        "watchers_count": 90,
        "size": 268847,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-07-01T17:20:03Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2025-02-27T11:11:39Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "5e6dbfd14ea9eace1c7e5ee76b140be46a0ec855",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 37452,
        "stargazers_count": 84375,
        "watchers_count": 84375,
        "size": 288548,
        "default_branch": "master",
        "open_issues_count": 751,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-07-01T20:59:02Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-07-01T20:59:09Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 898,
    "deletions": 60,
    "changed_files": 5,
    "commits": 7,
    "review_comments": 103,
    "comments": 26
  },
  "events": [
    {
      "event": "commented",
      "id": 2558561140,
      "node_id": "IC_kwDOABII586YgIt0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2558561140",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-22T19:06:08Z",
      "updated_at": "2025-06-18T15:54:05Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/31553.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [instagibbs](https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2984802550) |\n| Stale ACK | [ismaelsadeeq](https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2919520179) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2558561140",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "labeled",
      "id": 15798589053,
      "node_id": "LE_lADOABII586kMugSzwAAAAOtq1Z9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15798589053",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-02T13:05:14Z",
      "label": {
        "name": "Mempool",
        "color": "fef2c0"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15861077490,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOxZNXy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15861077490",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3e809fa9e6c0fc025ad180fe2d47e03cb9e6da4b",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/3e809fa9e6c0fc025ad180fe2d47e03cb9e6da4b",
      "created_at": "2025-01-08T23:27:48Z"
    },
    {
      "event": "labeled",
      "id": 15861624638,
      "node_id": "LE_lADOABII586kMugSzwAAAAOxbS8-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15861624638",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T00:52:10Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2578976969,
      "node_id": "IC_kwDOABII586ZuBDJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2578976969",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T00:52:11Z",
      "updated_at": "2025-01-09T00:52:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/35343429418</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2578976969",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15861756974,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOxbzQu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15861756974",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "75c675702ae91a234eca58a8733f69ebcf21eef4",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/75c675702ae91a234eca58a8733f69ebcf21eef4",
      "created_at": "2025-01-09T01:12:51Z"
    },
    {
      "event": "unlabeled",
      "id": 15862045073,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAOxc5mR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15862045073",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T02:34:45Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15868145094,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOx0K3G",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15868145094",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5a6550f8cafae8317eccf7bfc797669189176924",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/5a6550f8cafae8317eccf7bfc797669189176924",
      "created_at": "2025-01-09T13:41:37Z"
    },
    {
      "event": "reviewed",
      "id": 2540686525,
      "node_id": "PRR_kwDOABII586Xb8y9",
      "url": null,
      "actor": null,
      "commit_id": "5a6550f8cafae8317eccf7bfc797669189176924",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Very quick and shallow pass through the initial impl commit. This PR is a lot to get through :)",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2540686525",
      "submitted_at": "2025-01-09T20:03:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15873846189,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOyJ6ut",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15873846189",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fa14d0679f9362024cf5513e498b969cd74819a2",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/fa14d0679f9362024cf5513e498b969cd74819a2",
      "created_at": "2025-01-09T21:34:39Z"
    },
    {
      "event": "labeled",
      "id": 15874780470,
      "node_id": "LE_lADOABII586kMugSzwAAAAOyNe02",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15874780470",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T23:22:13Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2581434615,
      "node_id": "IC_kwDOABII586Z3ZD3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2581434615",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T23:22:14Z",
      "updated_at": "2025-01-09T23:22:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/35398283653</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2581434615",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15875391286,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOyPz82",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15875391286",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ab08987564dee21f805f8bc789b717e71eece9b7",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/ab08987564dee21f805f8bc789b717e71eece9b7",
      "created_at": "2025-01-10T01:19:28Z"
    },
    {
      "event": "unlabeled",
      "id": 15875791692,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAOyRVtM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15875791692",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-10T02:22:43Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15876195420,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOyS4Rc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15876195420",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fbd6568f6590726a3f786577628df1e6bcf971cc",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/fbd6568f6590726a3f786577628df1e6bcf971cc",
      "created_at": "2025-01-10T03:34:07Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15967733445,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAO3wEbF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15967733445",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9046cbf9ed4426ff8d2b9bec06f2ca72378f644c",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/9046cbf9ed4426ff8d2b9bec06f2ca72378f644c",
      "created_at": "2025-01-16T21:13:01Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16034249752,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAO7tzwY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16034249752",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e4a2fd900cdf417b231dc6cca33d0532adf1e9d4",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/e4a2fd900cdf417b231dc6cca33d0532adf1e9d4",
      "created_at": "2025-01-22T20:02:02Z"
    },
    {
      "event": "reviewed",
      "id": 2572752495,
      "node_id": "PRR_kwDOABII586ZWRZv",
      "url": null,
      "actor": null,
      "commit_id": "6cb99b067cf9028777a2036a8a3240c2511a3caf",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2572752495",
      "submitted_at": "2025-01-24T14:10:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16064776329,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAO9iQiJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16064776329",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a312648704640dc946939dfe42f21ebfcd62ae92",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/a312648704640dc946939dfe42f21ebfcd62ae92",
      "created_at": "2025-01-24T22:11:35Z"
    },
    {
      "event": "commented",
      "id": 2613488644,
      "node_id": "IC_kwDOABII586bxqwE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2613488644",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-24T22:14:46Z",
      "updated_at": "2025-01-24T22:14:46Z",
      "author_association": "MEMBER",
      "body": "Some changes:\r\n* As a result of dropping `Cleanup` in the base PR, `Trim` now reports which transactions it removed, as it becomes the caller's responsibility of destroying Refs.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2613488644",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "labeled",
      "id": 16065345293,
      "node_id": "LE_lADOABII586kMugSzwAAAAO9kbcN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16065345293",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-24T23:23:36Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2613584141,
      "node_id": "IC_kwDOABII586byCEN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2613584141",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-24T23:23:37Z",
      "updated_at": "2025-01-24T23:23:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/36148923463</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2613584141",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16068867983,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAO9x3eP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16068867983",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "52c4105a1c341a7a82dab3e792a2f8f5b9ca51b4",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/52c4105a1c341a7a82dab3e792a2f8f5b9ca51b4",
      "created_at": "2025-01-26T04:37:22Z"
    },
    {
      "event": "commented",
      "id": 2614209321,
      "node_id": "IC_kwDOABII586b0asp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2614209321",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-26T04:42:19Z",
      "updated_at": "2025-01-26T04:42:19Z",
      "author_association": "MEMBER",
      "body": "* Add support for calling `AddTransaction` with a feerate whose size already violates the cluster size limit.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2614209321",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "unlabeled",
      "id": 16070110443,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAO92mzr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16070110443",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-26T13:42:29Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16070941633,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAO95xvB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16070941633",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "df7185517f2d9ecae9a7c0114bf4a33ca73638a0",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/df7185517f2d9ecae9a7c0114bf4a33ca73638a0",
      "created_at": "2025-01-26T19:57:25Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16131781541,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPBh3Ol",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16131781541",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "265ad9efa9401c4cbe4395b88370c778fc5e6ae3",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/265ad9efa9401c4cbe4395b88370c778fc5e6ae3",
      "created_at": "2025-01-30T23:46:30Z"
    },
    {
      "event": "commented",
      "id": 2626051202,
      "node_id": "IC_kwDOABII586chlyC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2626051202",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T01:01:46Z",
      "updated_at": "2025-01-31T01:01:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/36451226624</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2626051202",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "labeled",
      "id": 16132409137,
      "node_id": "LE_lADOABII586kMugSzwAAAAPBkQcx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16132409137",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T01:01:46Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16134011538,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPBqXqS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16134011538",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e9b4cb1e9bd6309717372c4cc9d0dea3bb4010fa",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/e9b4cb1e9bd6309717372c4cc9d0dea3bb4010fa",
      "created_at": "2025-01-31T05:00:00Z"
    },
    {
      "event": "unlabeled",
      "id": 16134472638,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAPBsIO-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16134472638",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T06:09:40Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16146246231,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPCZCpX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16146246231",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2cac7317b6d799e276ccb3536c30d7b84fb2a765",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/2cac7317b6d799e276ccb3536c30d7b84fb2a765",
      "created_at": "2025-01-31T22:01:28Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16148263464,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPCgvIo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16148263464",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "42d725960c70c22c2ad7d94cb02dc12c407ae111",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/42d725960c70c22c2ad7d94cb02dc12c407ae111",
      "created_at": "2025-02-01T03:43:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16181709103,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPEgUkv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16181709103",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c4f31251b0e85079f6abfe776a23fecb2c832317",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/c4f31251b0e85079f6abfe776a23fecb2c832317",
      "created_at": "2025-02-04T16:18:01Z"
    },
    {
      "event": "labeled",
      "id": 16184169710,
      "node_id": "LE_lADOABII586kMugSzwAAAAPEptTu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16184169710",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-04T19:32:57Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 16186256526,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAPExqyO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16186256526",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-04T23:03:25Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16204090793,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPF1s2p",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16204090793",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9618a33eb754443a6bd7d1504d60896013d3a102",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/9618a33eb754443a6bd7d1504d60896013d3a102",
      "created_at": "2025-02-06T04:28:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16271005473,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPJ09ch",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16271005473",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9da91b512cc1c0ff1df657473b601ff6d1a4786c",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/9da91b512cc1c0ff1df657473b601ff6d1a4786c",
      "created_at": "2025-02-11T20:33:09Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16287907888,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPK1cAw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16287907888",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "created_at": "2025-02-12T22:29:24Z"
    },
    {
      "event": "commented",
      "id": 2655103200,
      "node_id": "IC_kwDOABII586eQajg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2655103200",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T23:49:28Z",
      "updated_at": "2025-02-12T23:49:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/37128455883</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2655103200",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "labeled",
      "id": 16288507322,
      "node_id": "LE_lADOABII586kMugSzwAAAAPK3uW6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16288507322",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T23:49:28Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16290332108,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPK-r3M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16290332108",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "490981ff0b9c745793fc6edf43cc28954386fab5",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/490981ff0b9c745793fc6edf43cc28954386fab5",
      "created_at": "2025-02-13T04:33:43Z"
    },
    {
      "event": "unlabeled",
      "id": 16290929989,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAPLA91F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16290929989",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-13T05:52:05Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16318032388,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPMoWoE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16318032388",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1dfe3ca0f712e8effaff9cb4b1f22a3e1377f160",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/1dfe3ca0f712e8effaff9cb4b1f22a3e1377f160",
      "created_at": "2025-02-14T22:27:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16386455066,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPQtXYa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16386455066",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e1e90c7004327e9bde8de4fabcd78fc75361362c",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/e1e90c7004327e9bde8de4fabcd78fc75361362c",
      "created_at": "2025-02-20T17:20:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16407979573,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPR_eY1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16407979573",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e43f6ca3b80cff2e05f88223ee9de3e2fe014243",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/e43f6ca3b80cff2e05f88223ee9de3e2fe014243",
      "created_at": "2025-02-21T22:09:24Z"
    },
    {
      "event": "reviewed",
      "id": 2638575710,
      "node_id": "PRR_kwDOABII586dRXhe",
      "url": null,
      "actor": null,
      "commit_id": "e43f6ca3b80cff2e05f88223ee9de3e2fe014243",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2638575710",
      "submitted_at": "2025-02-24T22:20:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "reviewed",
      "id": 2638627438,
      "node_id": "PRR_kwDOABII586dRkJu",
      "url": null,
      "actor": null,
      "commit_id": "e43f6ca3b80cff2e05f88223ee9de3e2fe014243",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2638627438",
      "submitted_at": "2025-02-24T22:48:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16541382065,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPZ8XWx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16541382065",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8400928ba1d0e89547c480482a41e05edda05126",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/8400928ba1d0e89547c480482a41e05edda05126",
      "created_at": "2025-03-03T21:51:21Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16878631671,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPuC3r3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16878631671",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a6ac3751048b4ee3b52de54f38fac338c7a5834b",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/a6ac3751048b4ee3b52de54f38fac338c7a5834b",
      "created_at": "2025-03-19T20:28:57Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16879645092,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPuGvGk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16879645092",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7e7a49cd2e3b456b95fbc5c75cb5b62472f7d908",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/7e7a49cd2e3b456b95fbc5c75cb5b62472f7d908",
      "created_at": "2025-03-19T21:06:28Z"
    },
    {
      "event": "labeled",
      "id": 16879645757,
      "node_id": "LE_lADOABII586kMugSzwAAAAPuGvQ9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16879645757",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T21:06:33Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2738113567,
      "node_id": "IC_kwDOABII586jNEwf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2738113567",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T21:06:34Z",
      "updated_at": "2025-03-19T21:06:34Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/39067440822</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2738113567",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16880113528,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPuIhd4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16880113528",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "created_at": "2025-03-19T21:23:32Z"
    },
    {
      "event": "unlabeled",
      "id": 16883487972,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAPuVZTk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16883487972",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T00:05:26Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 16899699546,
      "node_id": "LE_lADOABII586kMugSzwAAAAPvTPNa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16899699546",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T10:14:09Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16909702100,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPv5ZPU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16909702100",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c82139ec96573bef6383c974a7c91b8c17954359",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/c82139ec96573bef6383c974a7c91b8c17954359",
      "created_at": "2025-03-20T13:38:12Z"
    },
    {
      "event": "labeled",
      "id": 16909783228,
      "node_id": "LE_lADOABII586kMugSzwAAAAPv5tC8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16909783228",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T13:42:34Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2740502028,
      "node_id": "IC_kwDOABII586jWL4M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2740502028",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T13:42:40Z",
      "updated_at": "2025-03-20T13:42:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/39111492257</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2740502028",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16909798709,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPv5w01",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16909798709",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d9502966c05cc9bf8ff0530066305e7b2e59d797",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/d9502966c05cc9bf8ff0530066305e7b2e59d797",
      "created_at": "2025-03-20T13:43:26Z"
    },
    {
      "event": "unlabeled",
      "id": 16912137947,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAPwCr7b",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16912137947",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T14:35:22Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 16915115505,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAPwOC3x",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16915115505",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T17:24:35Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16937113482,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPxh9eK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16937113482",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "57b885db51557330f63230fa6f73f6d826ae37f4",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/57b885db51557330f63230fa6f73f6d826ae37f4",
      "created_at": "2025-03-22T00:06:33Z"
    },
    {
      "event": "labeled",
      "id": 16937719527,
      "node_id": "LE_lADOABII586kMugSzwAAAAPxkRbn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16937719527",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-22T01:23:05Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2744862487,
      "node_id": "IC_kwDOABII586jm0cX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2744862487",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-22T01:23:06Z",
      "updated_at": "2025-03-22T01:23:06Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/39212785621</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2744862487",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16938297667,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPxmelD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16938297667",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d0863b0274e6f223aefaa7f8fd2ec3eb321ec261",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/d0863b0274e6f223aefaa7f8fd2ec3eb321ec261",
      "created_at": "2025-03-22T03:36:19Z"
    },
    {
      "event": "unlabeled",
      "id": 16938715289,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAPxoEiZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16938715289",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-22T04:59:48Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16945221320,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPyA47I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16945221320",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ed024431a3db758ea9cf21692abc4cd76a693ee9",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/ed024431a3db758ea9cf21692abc4cd76a693ee9",
      "created_at": "2025-03-23T17:53:30Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16956606117,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPysUal",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16956606117",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2205de3abbfffb268cf913dd3a46ecd8eca3df5b",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/2205de3abbfffb268cf913dd3a46ecd8eca3df5b",
      "created_at": "2025-03-24T14:05:50Z"
    },
    {
      "event": "referenced",
      "id": 17000519298,
      "node_id": "REFE_lADOABII586kMugSzwAAAAP1T1aC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17000519298",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f1d129d96340503ec5f6b347c2fdf6a6901b1f7e",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1d129d96340503ec5f6b347c2fdf6a6901b1f7e",
      "created_at": "2025-03-26T21:43:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17004233253,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAP1iAIl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17004233253",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ca69204b7496ebcb5fff1efe051157b42601fec8",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/ca69204b7496ebcb5fff1efe051157b42601fec8",
      "created_at": "2025-03-27T03:46:33Z"
    },
    {
      "event": "commented",
      "id": 2756541999,
      "node_id": "IC_kwDOABII586kTX4v",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2756541999",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-27T03:49:57Z",
      "updated_at": "2025-03-27T03:49:57Z",
      "author_association": "MEMBER",
      "body": "Rebased after merge of #31363, and on top of #32151.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2756541999",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17015944390,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAP2OrTG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17015944390",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fe21d19d3693a5f0d5a888ac4b27a925b1aed168",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/fe21d19d3693a5f0d5a888ac4b27a925b1aed168",
      "created_at": "2025-03-27T15:15:47Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17021106491,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAP2iXk7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17021106491",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8d600a0b89d629d6d96c555dc0e9f0b5f6d3bfcf",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/8d600a0b89d629d6d96c555dc0e9f0b5f6d3bfcf",
      "created_at": "2025-03-27T19:49:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17025229967,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAP2yGSP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17025229967",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "79b0aded221618e186442ddef3d64f2debe4d7a0",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/79b0aded221618e186442ddef3d64f2debe4d7a0",
      "created_at": "2025-03-28T03:52:58Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17033522057,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAP3RuuJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17033522057",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "22cc58dc0d26927f4aca1c8f8409a1aa1fdb46a5",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/22cc58dc0d26927f4aca1c8f8409a1aa1fdb46a5",
      "created_at": "2025-03-28T14:23:06Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17038791248,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAP3l1JQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17038791248",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "deaa870b2c3b54ddd5520e5af54dbd25fa5b4636",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/deaa870b2c3b54ddd5520e5af54dbd25fa5b4636",
      "created_at": "2025-03-28T20:58:28Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17134231822,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAP9R6EO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17134231822",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "597a4fb2da55a49208563f470bda80fa080345f8",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/597a4fb2da55a49208563f470bda80fa080345f8",
      "created_at": "2025-04-04T18:16:44Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17135880170,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAP9YMfq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17135880170",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "516e4621ffa7cfcfb1582608ef13c42b1945cdf5",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/516e4621ffa7cfcfb1582608ef13c42b1945cdf5",
      "created_at": "2025-04-04T21:09:20Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17154021384,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAP-dZgI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17154021384",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5d0ab95dda09d45491aa82ef0d4b7f28575184d0",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/5d0ab95dda09d45491aa82ef0d4b7f28575184d0",
      "created_at": "2025-04-07T13:39:30Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17157249366,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAP-ptlW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17157249366",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "acab35f29e51faa5760bcf6a2e8acb2bb820a0ba",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/acab35f29e51faa5760bcf6a2e8acb2bb820a0ba",
      "created_at": "2025-04-07T16:50:10Z"
    },
    {
      "event": "labeled",
      "id": 17310623665,
      "node_id": "LE_lADOABII586kMugSzwAAAAQHyyex",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17310623665",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-17T19:02:34Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17312268115,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAQH5D9T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17312268115",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "03ba813edf927233e7990bc40b8cb50f4c942460",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/03ba813edf927233e7990bc40b8cb50f4c942460",
      "created_at": "2025-04-17T21:57:30Z"
    },
    {
      "event": "unsubscribed",
      "id": 17312320887,
      "node_id": "UE_lADOABII586kMugSzwAAAAQH5Q13",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17312320887",
      "actor": {
        "login": "Hasnainkhan14",
        "id": 190982247,
        "node_id": "U_kgDOC2IoZw",
        "avatar_url": "https://avatars.githubusercontent.com/u/190982247?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Hasnainkhan14",
        "html_url": "https://github.com/Hasnainkhan14",
        "followers_url": "https://api.github.com/users/Hasnainkhan14/followers",
        "following_url": "https://api.github.com/users/Hasnainkhan14/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Hasnainkhan14/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Hasnainkhan14/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Hasnainkhan14/subscriptions",
        "organizations_url": "https://api.github.com/users/Hasnainkhan14/orgs",
        "repos_url": "https://api.github.com/users/Hasnainkhan14/repos",
        "events_url": "https://api.github.com/users/Hasnainkhan14/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Hasnainkhan14/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-17T22:03:16Z"
    },
    {
      "event": "unlabeled",
      "id": 17312832585,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAQH7NxJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17312832585",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-17T23:19:27Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17360140983,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAQKvrq3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17360140983",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3566dca6c92e4e35ed63fba6fa1c9854e272ed2f",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/3566dca6c92e4e35ed63fba6fa1c9854e272ed2f",
      "created_at": "2025-04-22T20:51:23Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17475263605,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAQRm1x1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17475263605",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b004e9d8d75925cd461f9c4a084f794021c28bb5",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/b004e9d8d75925cd461f9c4a084f794021c28bb5",
      "created_at": "2025-04-30T15:25:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17624308358,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAQafZqG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17624308358",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "0ee96747f27ba32199cc048cbb553035efa1d174",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/0ee96747f27ba32199cc048cbb553035efa1d174",
      "created_at": "2025-05-12T21:13:01Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17642259382,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAQbj4O2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17642259382",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "acb2b6a90a47567773268a024bcf2f1ddfcc60df",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/acb2b6a90a47567773268a024bcf2f1ddfcc60df",
      "created_at": "2025-05-13T20:32:25Z"
    },
    {
      "event": "commented",
      "id": 2877875187,
      "node_id": "IC_kwDOABII586riOPz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2877875187",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-13T20:33:26Z",
      "updated_at": "2025-05-13T20:33:26Z",
      "author_association": "MEMBER",
      "body": "Now ready for review, with #31444 merged.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2877875187",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "reviewed",
      "id": 2840518650,
      "node_id": "PRR_kwDOABII586pTt_6",
      "url": null,
      "actor": null,
      "commit_id": "acb2b6a90a47567773268a024bcf2f1ddfcc60df",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "acb2b6a90a47567773268a024bcf2f1ddfcc60df\r\n\r\nfocused on motivation/structure/approach and test coverage for first pass. Haven't validated the actual trimming logic yet.\r\n\r\n",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2840518650",
      "submitted_at": "2025-05-19T20:26:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17759585110,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAQijcNW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17759585110",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3259cfe7569bc092f5cb8f55290e6330f300040f",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/3259cfe7569bc092f5cb8f55290e6330f300040f",
      "created_at": "2025-05-21T19:14:31Z"
    },
    {
      "event": "reviewed",
      "id": 2860445285,
      "node_id": "PRR_kwDOABII586qfu5l",
      "url": null,
      "actor": null,
      "commit_id": "3259cfe7569bc092f5cb8f55290e6330f300040f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Code review up to 412a9e0e69ccf461554660b7c622b768cfb8ccb3\r\n\r\nAlso did some fuzzing and mutate the new code added and tests, craches occur as expected.\r\n\r\n> If a transaction is encountered whose addition would violate the limit, it is removed, together with all its descendants.\r\n\r\nIn real-world scenarios it is unlikely we encounter those transactions that will exceed the cluster count limit, however when it occur I assume that the newly connected block will have similar transaction with the reorged block. I think maintaining an in-memory data structure for these transactions removed due to the limit seperate from mempool will reduce bandwidth from re-questing the tx again and also avoid non-contextual checks?\r\n\r\nWe can get rid of them after the reorg is complete and they arent included in any block.\r\n",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2860445285",
      "submitted_at": "2025-05-22T14:30:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17778730644,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAQjseaU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17778730644",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ab9b3e946faef487732a38b862405d25f30c5221",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/ab9b3e946faef487732a38b862405d25f30c5221",
      "created_at": "2025-05-22T19:51:15Z"
    },
    {
      "event": "reviewed",
      "id": 2862413711,
      "node_id": "PRR_kwDOABII586qnPeP",
      "url": null,
      "actor": null,
      "commit_id": "ab9b3e946faef487732a38b862405d25f30c5221",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "> In real-world scenarios it is unlikely we encounter those transactions that will exceed the cluster count limit, however when it occur I assume that the newly connected block will have similar transaction with the reorged block. I think maintaining an in-memory data structure for these transactions removed due to the limit seperate from mempool will reduce bandwidth from re-questing the tx again and also avoid non-contextual checks?\r\n\r\nIn theory, almost the entire mempool could be trimmed away (in a pathological case where the re-added block transactions link all mempool transaction together), so any approach for doing this would need to be able to handle picking just an acceptable-sized subset. It may make sense to just throw them into the compact block reconstruction extrapool though, up to a certain limit.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2862413711",
      "submitted_at": "2025-05-22T20:02:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17781075025,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAQj1axR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17781075025",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "538e9ff804f8dfba6f6a808e83572fdeab145ab8",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/538e9ff804f8dfba6f6a808e83572fdeab145ab8",
      "created_at": "2025-05-22T23:49:31Z"
    },
    {
      "event": "reviewed",
      "id": 2868754066,
      "node_id": "PRR_kwDOABII586q_baS",
      "url": null,
      "actor": null,
      "commit_id": "538e9ff804f8dfba6f6a808e83572fdeab145ab8",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "light code review ACK 538e9ff804f8dfba6f6a808e83572fdeab145ab8",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2868754066",
      "submitted_at": "2025-05-26T15:18:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "reviewed",
      "id": 2854383890,
      "node_id": "PRR_kwDOABII586qInES",
      "url": null,
      "actor": null,
      "commit_id": "538e9ff804f8dfba6f6a808e83572fdeab145ab8",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Reviewed through 538e9ff804f8dfba6f6a808e83572fdeab145ab8\r\n\r\nLast big Q is about the cycles being generated in the implied graph, and what if anything we should do differently about it.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2854383890",
      "submitted_at": "2025-05-27T14:46:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17842229075,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAQnes9T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17842229075",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "13393818de14bc699e98fb043ac8f90c091976e3",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/13393818de14bc699e98fb043ac8f90c091976e3",
      "created_at": "2025-05-28T03:25:07Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17842294631,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAQne89n",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17842294631",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e23210d941ed7b381f9f323e1ef24431d669b677",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/e23210d941ed7b381f9f323e1ef24431d669b677",
      "created_at": "2025-05-28T03:32:39Z"
    },
    {
      "event": "labeled",
      "id": 17842296706,
      "node_id": "LE_lADOABII586kMugSzwAAAAQne9eC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17842296706",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-28T03:32:57Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2914788239,
      "node_id": "IC_kwDOABII586tvCOP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2914788239",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-28T03:32:59Z",
      "updated_at": "2025-05-28T03:32:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Task `ARM, unit tests, no functional tests`: https://github.com/bitcoin/bitcoin/runs/43009654762</sub>\n<sub>LLM reason (âœ¨ experimental): The failure is caused by a type mismatch in the call to std::max due to incompatible argument types.</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2914788239",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "unlabeled",
      "id": 17842858916,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAQnhGuk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17842858916",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-28T04:38:32Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17850145499,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAQn85rb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17850145499",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e1f501cab224608004e3a1eee7a48eec3cea25fc",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/e1f501cab224608004e3a1eee7a48eec3cea25fc",
      "created_at": "2025-05-28T12:42:54Z"
    },
    {
      "event": "commented",
      "id": 2916512903,
      "node_id": "IC_kwDOABII586t1nSH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2916512903",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-28T14:13:04Z",
      "updated_at": "2025-05-28T14:13:04Z",
      "author_association": "MEMBER",
      "body": "ACK https://github.com/bitcoin/bitcoin/pull/31553/commits/e1f501cab224608004e3a1eee7a48eec3cea25fc\r\n\r\nI appreciate the additional coverage added; I know it's not particularly blackbox but should catch the most basic regressions going forward.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2916512903",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "review_requested",
      "id": 17852011506,
      "node_id": "RRE_lADOABII586kMugSzwAAAAQoEBPy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17852011506",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-28T14:13:09Z",
      "requested_reviewer": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "commented",
      "id": 2919520179,
      "node_id": "IC_kwDOABII586uBFez",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2919520179",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-29T14:05:53Z",
      "updated_at": "2025-05-29T14:05:53Z",
      "author_association": "MEMBER",
      "body": "reACK e1f501cab224608004e3a1eee7a48eec3cea25fc [deab145ab8..e1f501cab2](https://github.com/bitcoin/bitcoin/compare/538e9ff804f8dfba6f6a808e83572fdeab145ab8..e1f501cab224608004e3a1eee7a48eec3cea25fc)\r\n\r\nFollowing the last light ACK, review comments by @instagibbs were addressed:\r\n- Increased fuzz test coverage\r\n- Clearer and corrected comments\r\n- An Assume statement was added\r\n",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2919520179",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "mentioned",
      "id": 17869201634,
      "node_id": "MEE_lADOABII586kMugSzwAAAAQpFmDi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17869201634",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-29T14:05:54Z"
    },
    {
      "event": "subscribed",
      "id": 17869201650,
      "node_id": "SE_lADOABII586kMugSzwAAAAQpFmDy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17869201650",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-29T14:05:54Z"
    },
    {
      "event": "reviewed",
      "id": 2926551924,
      "node_id": "PRR_kwDOABII586ub6N0",
      "url": null,
      "actor": null,
      "commit_id": "e1f501cab224608004e3a1eee7a48eec3cea25fc",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Small doc things for now, still reviewing",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2926551924",
      "submitted_at": "2025-06-17T17:14:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18195336742,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAQ8hs4m",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18195336742",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "cbf701d021e8306a6e0f015cade380edc01fc95b",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/cbf701d021e8306a6e0f015cade380edc01fc95b",
      "created_at": "2025-06-17T17:26:11Z"
    },
    {
      "event": "reviewed",
      "id": 2936518483,
      "node_id": "PRR_kwDOABII586vB7dT",
      "url": null,
      "actor": null,
      "commit_id": "cbf701d021e8306a6e0f015cade380edc01fc95b",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Addressed nit, and improved comments here and there.\r\n\r\nAlso two bigger changes:\r\n* There was a bug in the second Trim commit (the one that added UF), resulting in it not achieving the desired quality (if anyone has ideas for tests that exercise the improved quality UF brings, I'm all ears).\r\n* I've changed the conversion of unincluded transactions to singleton UF partitions to happen at the time they are *popped* from the heap, rather than when they are added. I think this makes more sense, as it means the heap is purely for unincluded but includable transactions, and the UF structure purely for included or rejected transactions.\r\n\r\n---\r\n\r\nEffect of the bugfix, in a benchmark that creates a merge-the-whole-mempool scenario (not included in the PR, because it doesn't really fit in our bench framework):\r\n\r\nBefore fix:\r\n* Benchmarks (in ms):\r\n  * block_build: 21.7986\r\n  * oversize: 7.12257\r\n  * block_linearize: 33.0116\r\n  * mempool_build: 0.0691267\r\n  * trim: 10.4955\r\n  * final_linearize: 1.5371\r\n  * reset: 0.308329\r\n* Transaction counts:\r\n  * before trim: 64011\r\n  * after trim: 38743\r\n\r\nAfter fix:\r\n* Benchmarks (in ms):\r\n  * block_build: 23.3451\r\n  * oversize: 7.70649\r\n  * block_linearize: 34.05\r\n  * mempool_build: 0.0766003\r\n  * trim: 12.6596\r\n  * final_linearize: 0.0175771\r\n  * reset: 0.371984\r\n* Transaction counts:\r\n  * before trim: 64011\r\n  * after trim: 63994",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2936518483",
      "submitted_at": "2025-06-17T17:33:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "reviewed",
      "id": 2936759464,
      "node_id": "PRR_kwDOABII586vC2So",
      "url": null,
      "actor": null,
      "commit_id": "cbf701d021e8306a6e0f015cade380edc01fc95b",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "> if anyone has ideas for tests that exercise the improved quality UF brings, I'm all ears\r\n\r\nMaybe a starting point, I wrote a unit test to see the difference in trimming with 0b59916271c43cbedd14aafe88e5baf2dec2d97d: https://github.com/glozow/bitcoin/commits/2025-06-31553-test/\r\n\r\nOne test is a bunch of singleton transactions (e.g. from disconnected blocks) connected by 1 transaction (e.g. in the mempool).\r\n- Initial `Trim` implementation: trims all but the top `max_cluster_count` transactions of the parents\r\n- With union-find tracking multiple: just trims the child, which leaves everything as singleton clusters\r\n\r\nThe other test is a trellis (e.g. parents all from disconnected blocks, children all already in mempool)\r\n- Initial `Trim` implementation: trims half of the trellis (top and bottom), leaving just the prefix that is within `max_cluster_count` size\r\n- With union-find tracking multiple: just trims the middle transaction, splitting it into 2 trellises\r\n\r\n> There was a bug in the second Trim commit\r\n\r\nI haven't fully grokked this commit (there's something wrong with my eyesight whenever I look at the code), but before the last push, the trellis test was evicting 1/4 of the transactions: https://github.com/glozow/bitcoin/commits/2025-06-31553-trellis/",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2936759464",
      "submitted_at": "2025-06-17T18:54:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDIwY2QzMjRmMTNhNDJmYmQzYjU2NWMyZDIwMjczZjU5ZDc5ZGYxNGU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/20cd324f13a42fbd3b565c2d20273f59d79df14e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/20cd324f13a42fbd3b565c2d20273f59d79df14e",
      "tree": {
        "sha": "e79f5519a7ab760bd925380eba8c853915bcd3a3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e79f5519a7ab760bd925380eba8c853915bcd3a3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5e6dbfd14ea9eace1c7e5ee76b140be46a0ec855",
          "sha": "5e6dbfd14ea9eace1c7e5ee76b140be46a0ec855",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5e6dbfd14ea9eace1c7e5ee76b140be46a0ec855"
        }
      ],
      "message": "txgraph: Add ability to configure maximum cluster size/weight (feature)\n\nThis is integrated with the oversized property: the graph is oversized when\nany connected component within it contains more than the cluster count limit\nmany transactions, or when their combined size/weight exceeds the cluster size\nlimit.\n\nIt becomes disallowed to call AddTransaction with a size larger than this limit,\nthough this limit will be lifted in the next commit.\n\nIn addition, SetTransactionFeeRate becomes SetTransactionFee, so that we do not\nneed to deal with the case that a call to this function might affect the\noversizedness.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-06-17T19:16:57Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-17T13:13:25Z"
      },
      "sha": "20cd324f13a42fbd3b565c2d20273f59d79df14e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDhiM2IwNTgyNmE3OWRjYjU4OTEyYzM4NmY1ODBkNTMyN2Q1NWVlZTA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8b3b05826a79dcb58912c386f580d5327d55eee0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8b3b05826a79dcb58912c386f580d5327d55eee0",
      "tree": {
        "sha": "2ea1e3bad23ebf3ffc8a9589ee6721bacd2bad5a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ea1e3bad23ebf3ffc8a9589ee6721bacd2bad5a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/20cd324f13a42fbd3b565c2d20273f59d79df14e",
          "sha": "20cd324f13a42fbd3b565c2d20273f59d79df14e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/20cd324f13a42fbd3b565c2d20273f59d79df14e"
        }
      ],
      "message": "txgraph: Permit transactions that exceed cluster size limit (feature)\n\nThis removes the restriction added in the previous commit that individual\ntransactions do not exceed the max cluster size limit.\n\nWith this change, the responsibility for enforcing cluster size limits can\nbe localized purely in TxGraph, without callers (and in particular, tests)\nneeding to duplicate the enforcement for individual transactions.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-06-17T19:16:57Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-25T19:24:41Z"
      },
      "sha": "8b3b05826a79dcb58912c386f580d5327d55eee0"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGVjYWE0ZWNlOTllMzhlZDJmNzk5YmQ0YWY1OGNkODhkZjFkZmE3YzU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ecaa4ece99e38ed2f799bd4af58cd88df1dfa7c5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ecaa4ece99e38ed2f799bd4af58cd88df1dfa7c5",
      "tree": {
        "sha": "a379dfdc0aa0829e8cd7cb892f28074db43eb50d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a379dfdc0aa0829e8cd7cb892f28074db43eb50d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8b3b05826a79dcb58912c386f580d5327d55eee0",
          "sha": "8b3b05826a79dcb58912c386f580d5327d55eee0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8b3b05826a79dcb58912c386f580d5327d55eee0"
        }
      ],
      "message": "txgraph: remove unnecessary m_group_oversized (simplification)",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-06-17T19:16:57Z"
      },
      "author": {
        "name": "Greg Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2025-05-21T18:02:51Z"
      },
      "sha": "ecaa4ece99e38ed2f799bd4af58cd88df1dfa7c5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDNlZmVhY2Y5OWI2ZjBmODUxODVjNjI0YWU2NmIxZTJjZGJjNTkyYzU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3efeacf99b6f0f85185c624ae66b1e2cdbc592c5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/3efeacf99b6f0f85185c624ae66b1e2cdbc592c5",
      "tree": {
        "sha": "66c54186edd00e9874efccbdeaeb94f8946140d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/66c54186edd00e9874efccbdeaeb94f8946140d2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ecaa4ece99e38ed2f799bd4af58cd88df1dfa7c5",
          "sha": "ecaa4ece99e38ed2f799bd4af58cd88df1dfa7c5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ecaa4ece99e38ed2f799bd4af58cd88df1dfa7c5"
        }
      ],
      "message": "txgraph: Add ability to trim oversized clusters (feature)\n\nDuring reorganisations, it is possible that dependencies get add which\nresult in clusters that violate limits (count, size), when linking the\nnew from-block transactions to the old from-mempool transactions.\n\nUnlike RBF scenarios, we cannot simply reject these policy violations\nwhen they are due to received blocks. To accomodate this, add a Trim()\nfunction to TxGraph, which removes transactions (including descendants)\nin order to make all resulting clusters satisfy the limits.\n\nIn the initial version of the function added here, the following approach\nis used:\n- Lazily compute a naive linearization for the to-be-merged cluster (using\n  an O(n log n) algorithm, optimized for far larger groups of transactions\n  than the normal linearization code).\n- Initialize a set of accepted transactions to {}\n- Iterate over the transactions in this cluster one by one:\n  - If adding the transaction to the set makes it exceed the max cluster size\n    or count limit, stop.\n  - Add the transaction to the set.\n- Remove all transactions from the cluster that were not included in the set\n  (note that this necessarily includes all descendants too, because they\n  appear later in the naive linearization).\n\nCo-authored-by: Greg Sanders <gsanders87@gmail.com>",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-06-17T19:16:57Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-16T22:57:57Z"
      },
      "sha": "3efeacf99b6f0f85185c624ae66b1e2cdbc592c5"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18198396131,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAQ8tXzj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18198396131",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "44f5b6db95d80021ca5a13be7ec615a6340b3bff",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/44f5b6db95d80021ca5a13be7ec615a6340b3bff",
      "created_at": "2025-06-17T21:04:59Z"
    },
    {
      "event": "commented",
      "id": 2981831824,
      "node_id": "IC_kwDOABII586xuySQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2981831824",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-17T21:05:50Z",
      "updated_at": "2025-06-17T21:05:50Z",
      "author_association": "MEMBER",
      "body": "@glozow Awesome, thanks. I've included your commit (with minor changes) in this PR, and added my own 64000-transactions-merged-together test to it.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2981831824",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "mentioned",
      "id": 18198406539,
      "node_id": "MEE_lADOABII586kMugSzwAAAAQ8taWL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18198406539",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-17T21:05:51Z"
    },
    {
      "event": "subscribed",
      "id": 18198406551,
      "node_id": "SE_lADOABII586kMugSzwAAAAQ8taWX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18198406551",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-17T21:05:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18210712015,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAQ9cWnP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18210712015",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "643fffafdc70da5fbaf1992c36965595b9e63f84",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/643fffafdc70da5fbaf1992c36965595b9e63f84",
      "created_at": "2025-06-18T13:29:00Z"
    },
    {
      "event": "commented",
      "id": 2984337660,
      "node_id": "IC_kwDOABII586x4WD8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2984337660",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-18T13:57:42Z",
      "updated_at": "2025-06-18T13:57:42Z",
      "author_association": "MEMBER",
      "body": "@sipa to be clear, was the issue \r\n```\r\n    -+            if (new_count > m_max_cluster_count || new_size > m_max_cluster_size) break;\r\n    ++            if (new_count > m_max_cluster_count || new_size > m_max_cluster_size) continue;\r\n```   \r\n\r\nIn that the optimization means we should keep on going in case we're going to create/add to undersized clusters, but this `break` broke the optimization. In other words, the base performance was still intact? \r\n",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2984337660",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "mentioned",
      "id": 18211338780,
      "node_id": "MEE_lADOABII586kMugSzwAAAAQ9evoc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18211338780",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-18T13:57:44Z"
    },
    {
      "event": "subscribed",
      "id": 18211338814,
      "node_id": "SE_lADOABII586kMugSzwAAAAQ9evo-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18211338814",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-18T13:57:44Z"
    },
    {
      "event": "commented",
      "id": 2984354175,
      "node_id": "IC_kwDOABII586x4aF_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2984354175",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-18T14:01:09Z",
      "updated_at": "2025-06-18T14:01:31Z",
      "author_association": "MEMBER",
      "body": "@instagibbs Yes, exactly.\r\n\r\nThe commit was still an improvement, as it would only stop once an aggregate-of-clusters-so-far would exceed the limit, rather than stopping when the sum of all-clusters-so-far would exceed the limit (the behavior in the initial Trim commit). But with the `continue;` instead of `break;`, it isn't stopping, it'll just skip the cluster being aggregated, and its descendants.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2984354175",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "mentioned",
      "id": 18211419658,
      "node_id": "MEE_lADOABII586kMugSzwAAAAQ9fDYK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18211419658",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-18T14:01:10Z"
    },
    {
      "event": "subscribed",
      "id": 18211419689,
      "node_id": "SE_lADOABII586kMugSzwAAAAQ9fDYp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18211419689",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-18T14:01:10Z"
    },
    {
      "event": "reviewed",
      "id": 2939425053,
      "node_id": "PRR_kwDOABII586vNBEd",
      "url": null,
      "actor": null,
      "commit_id": "643fffafdc70da5fbaf1992c36965595b9e63f84",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reACK 643fffafdc70da5fbaf1992c36965595b9e63f84\r\n\r\n> and the UF structure purely for included or rejected transactions\r\n\r\ni.e. rejected here means \"things with no unmet deps yet never included\"\r\n\r\nValidated in my mental model that bug fix and heap logic changes are correct. Reviewed new unit tests and makes sense that it would have caught the bug. It's a bit further non-black-box, but they're simple.\r\n\r\n`git range-diff master e1f501cab224608004e3a1eee7a48eec3cea25fc 643fffafdc70da5fbaf1992c36965595b9e63f84`",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2939425053",
      "submitted_at": "2025-06-18T14:18:33Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ0MWY0ODFmMTZkMGY2ZGYzYTYxMzJjNmVhMzY2M2U4YTEyNWY4MzA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/441f481f16d0f6df3a6132c6ea3663e8a125f830",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/441f481f16d0f6df3a6132c6ea3663e8a125f830",
      "tree": {
        "sha": "2034f506f0248ff252eea5bff6591e2ad3310b11",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2034f506f0248ff252eea5bff6591e2ad3310b11"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3efeacf99b6f0f85185c624ae66b1e2cdbc592c5",
          "sha": "3efeacf99b6f0f85185c624ae66b1e2cdbc592c5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/3efeacf99b6f0f85185c624ae66b1e2cdbc592c5"
        }
      ],
      "message": "txgraph: add unit test for TxGraph::Trim (tests)\n\nCo-Authored-By: Pieter Wuille <pieter@wuille.net>",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-06-18T14:59:17Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2025-06-17T17:40:06Z"
      },
      "sha": "441f481f16d0f6df3a6132c6ea3663e8a125f830"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDRiMTY0MzQ0OWIzOWRhYjAwNzNhNmI5NmFmMjMxMmZjYjM0YTJkOWM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4b1643449b39dab0073a6b96af2312fcb34a2d9c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4b1643449b39dab0073a6b96af2312fcb34a2d9c",
      "tree": {
        "sha": "4e7d6097b3143e34fa3cf0082f126c2b944a28c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4e7d6097b3143e34fa3cf0082f126c2b944a28c3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/441f481f16d0f6df3a6132c6ea3663e8a125f830",
          "sha": "441f481f16d0f6df3a6132c6ea3663e8a125f830",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/441f481f16d0f6df3a6132c6ea3663e8a125f830"
        }
      ],
      "message": "txgraph: add fuzz test scenario that avoids cycles inside Trim() (tests)\n\nTrim internally builds an approximate dependency graph of the merged cluster,\nreplacing all existing dependencies within existing clusters with a simple\nlinear chain of dependencies. This helps keep the complexity of the merging\noperation down, but may result in cycles to appear in the general case, even\nthough in real scenarios (where Trim is called for stitching re-added mempool\ntransactions after a reorg back to the existing mempool transactions) such\ncycles are not possible.\n\nAdd a test that specifically targets Trim() but in scenarios where it is\nguaranteed not to have any cycles. It is a special case, is much more a\nwhitebox test than a blackbox test, and relies on randomness rather than\nfuzz input. The upside is that somewhat stronger properties can be tested.\n\nCo-authored-by: Greg Sanders <gsanders87@gmail.com>",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-06-18T14:59:21Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-05-27T21:33:30Z"
      },
      "sha": "4b1643449b39dab0073a6b96af2312fcb34a2d9c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDJiMmRmOTg3NDdmZGI2MzgwNTg4OTkxMTY3Y2UyZThjYjkyZjNiZmI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "tree": {
        "sha": "789d2dd20a32c51e0a2a6d3c97dbe0bc4d30db48",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/789d2dd20a32c51e0a2a6d3c97dbe0bc4d30db48"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4b1643449b39dab0073a6b96af2312fcb34a2d9c",
          "sha": "4b1643449b39dab0073a6b96af2312fcb34a2d9c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4b1643449b39dab0073a6b96af2312fcb34a2d9c"
        }
      ],
      "message": "txgraph: Track multiple potential would-be clusters in Trim (improvement)\n\nIn the existing Trim function, as soon as the set of accepted transactions\nwould exceed the max cluster size or count limit, the acceptance loop is\nstopped, removing all later transactions. However, it is possible that by\nexcluding some of those transactions the would-be cluster splits apart into\nmultiple would-clusters. And those clusters may well permit far more\ntransactions before their limits are reached.\n\nTake this into account by using a union-find structure inside TrimTxData to\nkeep track of the count/size of all would-be clusters that would be formed\nat any point, and only reject transactions which would cause these resulting\npartitions to exceed their limits.\n\nThis is not an optimization in terms of CPU usage or memory; it just\nimproves the quality of the transactions removed by Trim().",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-06-18T15:06:27Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-20T04:06:07Z"
      },
      "sha": "2b2df98747fdb6380588991167ce2e8cb92f3bfb"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18212961947,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAQ9k76b",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18212961947",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "created_at": "2025-06-18T15:15:28Z"
    },
    {
      "event": "commented",
      "id": 2984656423,
      "node_id": "IC_kwDOABII586x5j4n",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2984656423",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-18T15:18:13Z",
      "updated_at": "2025-06-18T15:18:13Z",
      "author_association": "MEMBER",
      "body": "@instagibbs Done. Also expanded comments slightly, made unit test constant names a bit more consistent, and sprinkled some `graph->SanityCheck();` calls over the tests.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2984656423",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "mentioned",
      "id": 18213014544,
      "node_id": "MEE_lADOABII586kMugSzwAAAAQ9lIwQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18213014544",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-18T15:18:15Z"
    },
    {
      "event": "subscribed",
      "id": 18213014561,
      "node_id": "SE_lADOABII586kMugSzwAAAAQ9lIwh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18213014561",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-18T15:18:15Z"
    },
    {
      "event": "commented",
      "id": 2984802550,
      "node_id": "IC_kwDOABII586x6Hj2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2984802550",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-18T15:54:01Z",
      "updated_at": "2025-06-18T15:54:01Z",
      "author_association": "MEMBER",
      "body": "reACK 2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2984802550",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "commented",
      "id": 3019243840,
      "node_id": "IC_kwDOABII586z9gFA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3019243840",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-30T13:49:46Z",
      "updated_at": "2025-06-30T13:49:46Z",
      "author_association": "MEMBER",
      "body": "Would there be interest in adding a benchmark for the Trim() operation here, or rather in a follow-up?",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-3019243840",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "commented",
      "id": 3019618093,
      "node_id": "IC_kwDOABII586z-7ct",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3019618093",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-30T15:27:08Z",
      "updated_at": "2025-06-30T15:27:08Z",
      "author_association": "MEMBER",
      "body": "@sipa linked here, added to follow-up potentially?",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-3019618093",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "mentioned",
      "id": 18389456710,
      "node_id": "MEE_lADOABII586kMugSzwAAAARIGNdG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18389456710",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-30T15:27:09Z"
    },
    {
      "event": "subscribed",
      "id": 18389456735,
      "node_id": "SE_lADOABII586kMugSzwAAAARIGNdf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18389456735",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-30T15:27:09Z"
    },
    {
      "event": "commented",
      "id": 3024909015,
      "node_id": "IC_kwDOABII5860THLX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3024909015",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-01T17:20:44Z",
      "updated_at": "2025-07-01T17:24:16Z",
      "author_association": "MEMBER",
      "body": "@instagibbs @ismaelsadeeq See https://github.com/sipa/bitcoin/commit/0a8e1d6e39bd1ba6d3df149945b8dfd78e1fb7e6\r\n\r\nIt's the same scenario as the `txgraph_trim_huge` unit test (1000 chains of 64 reorged transactions each, merged together by 11 mempool transactions into one giant would-be cluster, then `Trim()`ed down to something acceptable). Takes around 15 ms for me.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-3024909015",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "mentioned",
      "id": 18415877471,
      "node_id": "MEE_lADOABII586kMugSzwAAAARJq_1f",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18415877471",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-01T17:20:45Z"
    },
    {
      "event": "subscribed",
      "id": 18415877489,
      "node_id": "SE_lADOABII586kMugSzwAAAARJq_1x",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18415877489",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-01T17:20:45Z"
    },
    {
      "event": "mentioned",
      "id": 18415877505,
      "node_id": "MEE_lADOABII586kMugSzwAAAARJq_2B",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18415877505",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-01T17:20:45Z"
    },
    {
      "event": "subscribed",
      "id": 18415877521,
      "node_id": "SE_lADOABII586kMugSzwAAAARJq_2R",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18415877521",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-01T17:20:45Z"
    },
    {
      "event": "commented",
      "id": 3024981580,
      "node_id": "IC_kwDOABII5860TY5M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3024981580",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-01T17:46:27Z",
      "updated_at": "2025-07-01T17:46:27Z",
      "author_association": "MEMBER",
      "body": "@sipa one order of magnitude more for me on my wimpy laptop but well within acceptable bounds I suspect for a reorg. IIUC this is one of the more pessimistic mempool topologies for this since you're going to have to go through the ~entire mempool before finishing",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-3024981580",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "mentioned",
      "id": 18416265510,
      "node_id": "MEE_lADOABII586kMugSzwAAAARJsekm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18416265510",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-01T17:46:28Z"
    },
    {
      "event": "subscribed",
      "id": 18416265547,
      "node_id": "SE_lADOABII586kMugSzwAAAARJselL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18416265547",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-01T17:46:28Z"
    },
    {
      "event": "commented",
      "id": 3025430544,
      "node_id": "IC_kwDOABII5860VGgQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3025430544",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-01T20:39:03Z",
      "updated_at": "2025-07-01T20:39:03Z",
      "author_association": "MEMBER",
      "body": "> Would there be interest in adding a benchmark for the Trim() operation here, or rather in a follow-up?\r\n\r\nThat will be nice, I don't mind adding it here. I plan to do another round of review of the added tests and diff after my last review so if added will review it as well.\r\n\r\nI try running the bench on the linked commit. `MakeTxGraph` seems to takes two parameters, but the bench call provided three arguments.\r\nI removed `NUM_ACCEPTABLE_ITERS` arg this is the result.\r\n\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|       12,750,500.00 |               78.43 |    0.0% |      0.01 | `TxGraphTrim`\r\n```",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-3025430544",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909286865",
      "pull_request_review_id": 2540686525,
      "id": 1909286865,
      "node_id": "PRRC_kwDOABII585xzWfR",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 953,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm not sure how this is intended to be used, but storing a stack address seems like a problem? RVO may help but that seems brittle. I imagine the caller should be passing in their own `Ref` instead?",
      "created_at": "2025-01-09T18:43:50Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909286865",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909286865"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1710,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909293407",
      "pull_request_review_id": 2540686525,
      "id": 1909293407,
      "node_id": "PRRC_kwDOABII585xzYFf",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeeFrac Cluster::GetIndividualFeerate(ClusterIndex idx) noexcept\n+{\n+    return m_depgraph.FeeRate(idx);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeeFrac TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeeFrac{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeeFrac TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified ClusterIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (m_quality != QualityLevel::NEEDS_SPLIT) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(Ref& ref, int64_t fee) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    auto& locator = entry.m_locator;\n+    if (locator.IsPresent()) {\n+        locator.cluster->SetFee(*this, locator.index, fee);\n+    }\n+}\n+\n+} // namespace\n+\n+TxGraph::Ref::~Ref()\n+{\n+    if (m_graph) {\n+        // Inform the TxGraph about the Ref being destroyed.\n+        m_graph->UnlinkRef(m_index);\n+        m_graph = nullptr;\n+    }\n+}\n+\n+TxGraph::Ref& TxGraph::Ref::operator=(Ref&& other) noexcept\n+{\n+    // Inform both TxGraphs about the Refs being swapped.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1172,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why is this doing an effective swap? I would expect this to call `UnlinkRef` on the moved-from value and reset its `m_graph` and `m_index`. Otherwise it wouldn't be unlinked until the moved-from variable goes out of scope, no?",
      "created_at": "2025-01-09T18:48:55Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909293407",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909293407"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909295799",
      "pull_request_review_id": 2540686525,
      "id": 1909295799,
      "node_id": "PRRC_kwDOABII585xzYq3",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 188,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`m_ref{nullptr};`",
      "created_at": "2025-01-09T18:51:18Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909295799",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909295799"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909307659",
      "pull_request_review_id": 2540686525,
      "id": 1909307659,
      "node_id": "PRRC_kwDOABII585xzbkL",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 297,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Trying to convince myself this is guaranteed to terminate...\r\n\r\n`do{} while (!chunk.transactions.None())` rather than the `break` for readability? Or just `while()` if we need to guard against an empty linearization (presumably not?)",
      "created_at": "2025-01-09T19:02:47Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909307659",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909307659"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909321579",
      "pull_request_review_id": 2540686525,
      "id": 1909321579,
      "node_id": "PRRC_kwDOABII585xze9r",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 311,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Assume `!to_remove.empty()` or early return if it's allowed?",
      "created_at": "2025-01-09T19:17:27Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909321579",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909321579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 838,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909348870",
      "pull_request_review_id": 2540686525,
      "id": 1909348870,
      "node_id": "PRRC_kwDOABII585xzloG",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1007,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Looks like these 3 functions could `reserve()` for their `ret` vectors.",
      "created_at": "2025-01-09T19:42:45Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909348870",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909348870"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1662,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909385059",
      "pull_request_review_id": 2540851568,
      "id": 1909385059,
      "node_id": "PRRC_kwDOABII585xzudj",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 953,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909286865,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I believe it is safe, both with NRVO and without.\r\n\r\nWith NRVO, `ret` is constructed directly in the caller's target destination, so this isn't a pointer to local stack space.\r\n\r\nWithout NRVO, the `Ref(Ref&&)` move constructor is invoked by `return ret;`, which will update the pointer to the caller's destination.",
      "created_at": "2025-01-09T20:19:28Z",
      "updated_at": "2025-01-09T21:17:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909385059",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909385059"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1710,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909403690",
      "pull_request_review_id": 2540882536,
      "id": 1909403690,
      "node_id": "PRRC_kwDOABII585xzzAq",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeeFrac Cluster::GetIndividualFeerate(ClusterIndex idx) noexcept\n+{\n+    return m_depgraph.FeeRate(idx);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeeFrac TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeeFrac{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeeFrac TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified ClusterIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (m_quality != QualityLevel::NEEDS_SPLIT) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(Ref& ref, int64_t fee) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    auto& locator = entry.m_locator;\n+    if (locator.IsPresent()) {\n+        locator.cluster->SetFee(*this, locator.index, fee);\n+    }\n+}\n+\n+} // namespace\n+\n+TxGraph::Ref::~Ref()\n+{\n+    if (m_graph) {\n+        // Inform the TxGraph about the Ref being destroyed.\n+        m_graph->UnlinkRef(m_index);\n+        m_graph = nullptr;\n+    }\n+}\n+\n+TxGraph::Ref& TxGraph::Ref::operator=(Ref&& other) noexcept\n+{\n+    // Inform both TxGraphs about the Refs being swapped.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1172,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909293407,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Why is this doing an effective swap? \r\n\r\nI think this is quite common, that move-construction is effectively performing a swap.\r\n\r\n> I would expect this to call `UnlinkRef` on the moved-from value and reset its `m_graph` and `m_index`\r\n\r\nThat's possible too, and slightly more efficient I guess.\r\n\r\n> Otherwise it wouldn't be unlinked until the moved-from variable goes out of scope, no?\r\n\r\nIndeed. I don't think that's a problem.\r\n\r\n",
      "created_at": "2025-01-09T20:38:36Z",
      "updated_at": "2025-01-09T20:38:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909403690",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909403690"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909458303",
      "pull_request_review_id": 2540971508,
      "id": 1909458303,
      "node_id": "PRRC_kwDOABII585x0AV_",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeeFrac Cluster::GetIndividualFeerate(ClusterIndex idx) noexcept\n+{\n+    return m_depgraph.FeeRate(idx);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeeFrac TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeeFrac{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeeFrac TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified ClusterIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (m_quality != QualityLevel::NEEDS_SPLIT) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(Ref& ref, int64_t fee) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    auto& locator = entry.m_locator;\n+    if (locator.IsPresent()) {\n+        locator.cluster->SetFee(*this, locator.index, fee);\n+    }\n+}\n+\n+} // namespace\n+\n+TxGraph::Ref::~Ref()\n+{\n+    if (m_graph) {\n+        // Inform the TxGraph about the Ref being destroyed.\n+        m_graph->UnlinkRef(m_index);\n+        m_graph = nullptr;\n+    }\n+}\n+\n+TxGraph::Ref& TxGraph::Ref::operator=(Ref&& other) noexcept\n+{\n+    // Inform both TxGraphs about the Refs being swapped.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1172,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909293407,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Anyway, done!",
      "created_at": "2025-01-09T21:34:51Z",
      "updated_at": "2025-01-09T21:34:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909458303",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909458303"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909458391",
      "pull_request_review_id": 2540971629,
      "id": 1909458391,
      "node_id": "PRRC_kwDOABII585x0AXX",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 188,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909295799,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-01-09T21:34:56Z",
      "updated_at": "2025-01-09T21:34:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909458391",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909458391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909462275",
      "pull_request_review_id": 2540977582,
      "id": 1909462275,
      "node_id": "PRRC_kwDOABII585x0BUD",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 297,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909307659,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It terminates because:\r\n* Every chunk contains at least one element (added an Assume for that)\r\n* In the inner loop, one element from that chunk is Reset() (added an Assume that it indeed resets a bit that was previously set).\r\n\r\nI've changed it to a `do {} while(chunk.transactions.Any());` loop in the first commits, though it reverts back to a `while (true) { ... }` loop later, when the loop becomes a bit more complex.",
      "created_at": "2025-01-09T21:39:12Z",
      "updated_at": "2025-01-09T21:39:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909462275",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909462275"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909463152",
      "pull_request_review_id": 2540978925,
      "id": 1909463152,
      "node_id": "PRRC_kwDOABII585x0Bhw",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 311,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909321579,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done. I've also added a comment to the `Cluster::ApplyRemovals()` function definition stating that at least one element from the front of `to_remove` must belong to `this` Cluster (which is really why that requirement exists).",
      "created_at": "2025-01-09T21:40:05Z",
      "updated_at": "2025-01-09T21:40:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909463152",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909463152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 838,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909463444",
      "pull_request_review_id": 2540979340,
      "id": 1909463444,
      "node_id": "PRRC_kwDOABII585x0BmU",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1007,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909348870,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done. The third one disappears in a later commit, though.",
      "created_at": "2025-01-09T21:40:22Z",
      "updated_at": "2025-01-09T21:40:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909463444",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909463444"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1662,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909477090",
      "pull_request_review_id": 2541000748,
      "id": 1909477090,
      "node_id": "PRRC_kwDOABII585x0E7i",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeeFrac Cluster::GetIndividualFeerate(ClusterIndex idx) noexcept\n+{\n+    return m_depgraph.FeeRate(idx);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeeFrac TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeeFrac{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeeFrac TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified ClusterIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (m_quality != QualityLevel::NEEDS_SPLIT) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(Ref& ref, int64_t fee) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    auto& locator = entry.m_locator;\n+    if (locator.IsPresent()) {\n+        locator.cluster->SetFee(*this, locator.index, fee);\n+    }\n+}\n+\n+} // namespace\n+\n+TxGraph::Ref::~Ref()\n+{\n+    if (m_graph) {\n+        // Inform the TxGraph about the Ref being destroyed.\n+        m_graph->UnlinkRef(m_index);\n+        m_graph = nullptr;\n+    }\n+}\n+\n+TxGraph::Ref& TxGraph::Ref::operator=(Ref&& other) noexcept\n+{\n+    // Inform both TxGraphs about the Refs being swapped.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1172,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909293407,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> > Why is this doing an effective swap?\r\n> \r\n> I think this is quite common, that move-construction is effectively performing a swap.\r\n> \r\n> > I would expect this to call `UnlinkRef` on the moved-from value and reset its `m_graph` and `m_index`\r\n> \r\n> That's possible too, and slightly more efficient I guess.\r\n> \r\n> > Otherwise it wouldn't be unlinked until the moved-from variable goes out of scope, no?\r\n> \r\n> Indeed. I don't think that's a problem.\r\n\r\nAfaik the move/swap idiom is only safe if the swapped-to value's dtor doesn't have any interesting ordering requirements or side-effects.\r\n\r\nAs a contrived example, a user may do something like:\r\n```c++\r\nstd::vector<TxGraph::Ref> vec;\r\n\r\nvec.push_back(txgraph->AddTransaction(fee));\r\nauto ref = txgraph->AddTransaction(fee2);\r\n...\r\nref = std::move(vec.back());\r\n```\r\nThe vector now holds the old ref and `UnlinkRef` will not be called until that element is removed. I realize it's allowed to be a \"valid but unspecified state\", but I wouldn't expect a ref to be hanging around.",
      "created_at": "2025-01-09T21:56:14Z",
      "updated_at": "2025-01-09T21:56:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909477090",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909477090"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909492867",
      "pull_request_review_id": 2541025670,
      "id": 1909492867,
      "node_id": "PRRC_kwDOABII585x0IyD",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 953,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909286865,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, right, I missed that the move ctor would handle the update. Thanks for explaining.",
      "created_at": "2025-01-09T22:15:14Z",
      "updated_at": "2025-01-09T22:15:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909492867",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909492867"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1710,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1928741430",
      "pull_request_review_id": 2572752495,
      "id": 1928741430,
      "node_id": "PRRC_kwDOABII585y9kI2",
      "diff_hunk": "@@ -1449,6 +1465,7 @@ Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_in\n TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n {\n     Assume(m_chunkindex_observers == 0 || m_clustersets.size() > 1);\n+    Assume(feerate.size > 0 && uint64_t(feerate.size) <= m_max_cluster_size);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "6cb99b067cf9028777a2036a8a3240c2511a3caf",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "FYI -- in my rebase of #28676, I'm seeing `tx_pool` fuzz test failures due to this line. Not clear to me whether we should require the caller to enforce the policy requirement that a single tx be below the cluster size limit, or just let the caller discover a changeset is oversized and then reject?",
      "created_at": "2025-01-24T14:10:51Z",
      "updated_at": "2025-01-24T14:10:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1928741430",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1928741430"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1928775309",
      "pull_request_review_id": 2572810863,
      "id": 1928775309,
      "node_id": "PRRC_kwDOABII585y9saN",
      "diff_hunk": "@@ -1449,6 +1465,7 @@ Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_in\n TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n {\n     Assume(m_chunkindex_observers == 0 || m_clustersets.size() > 1);\n+    Assume(feerate.size > 0 && uint64_t(feerate.size) <= m_max_cluster_size);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "6cb99b067cf9028777a2036a8a3240c2511a3caf",
      "in_reply_to_id": 1928741430,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Right. That rule exists because the alternative requires existing clusters to be oversized as AddTransaction constructs a singleton cluster instantly. All other forms of oversizedness happen as a result of applying dependencies, which are done lazily.\r\n\r\nI'll think about relaxing this.",
      "created_at": "2025-01-24T14:34:05Z",
      "updated_at": "2025-01-24T14:34:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1928775309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1928775309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1929869292",
      "pull_request_review_id": 2574392651,
      "id": 1929869292,
      "node_id": "PRRC_kwDOABII585zB3fs",
      "diff_hunk": "@@ -1449,6 +1465,7 @@ Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_in\n TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n {\n     Assume(m_chunkindex_observers == 0 || m_clustersets.size() > 1);\n+    Assume(feerate.size > 0 && uint64_t(feerate.size) <= m_max_cluster_size);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "6cb99b067cf9028777a2036a8a3240c2511a3caf",
      "in_reply_to_id": 1928741430,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, it is now allowed to have individually oversized transactions.",
      "created_at": "2025-01-26T20:45:43Z",
      "updated_at": "2025-01-26T20:45:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1929869292",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1929869292"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1968497012",
      "pull_request_review_id": 2638575710,
      "id": 1968497012,
      "node_id": "PRRC_kwDOABII5851VOF0",
      "diff_hunk": "@@ -1336,6 +1347,38 @@ std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph,\n     return ret;\n }\n \n+/** Make linearization topological, retaining its ordering where possible. */\n+template<typename SetType>\n+void FixLinearization(const DepGraph<SetType>& depgraph, Span<DepGraphIndex> linearization) noexcept\n+{\n+    // This algorithm can be summarized as moving every element in the linearization backwards\n+    // until it is placed after all its ancestors.\n+    SetType done;\n+    const auto len = linearization.size();\n+    // Iterate over the elements of linearization from back to front (i is distance from back).\n+    for (DepGraphIndex i = 0; i < len; ++i) {\n+        /** The element at that position. */\n+        DepGraphIndex elem = linearization[len - 1 - i];\n+        /** j represents how far from the back of the linearization elem should be placed. */\n+        DepGraphIndex j = i;\n+        // Figure out which elements need to be moved before elem.\n+        SetType place_before = done & depgraph.Ancestors(elem);\n+        // Find which position to place elem in (updating j), continuously moving the elements\n+        // in between forward.\n+        while (place_before.Any()) {\n+            // j cannot be 0 here; if it was, then there was necessarily nothing earlier which",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 469,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "e43f6ca3b80cff2e05f88223ee9de3e2fe014243",
      "in_reply_to_id": null,
      "user": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n            // j cannot be 0 or less; if it was, then there was necessarily nothing earlier which\r\n```",
      "created_at": "2025-02-24T22:20:13Z",
      "updated_at": "2025-02-24T22:20:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1968497012",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1968497012"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1381,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1968500577",
      "pull_request_review_id": 2638581738,
      "id": 1968500577,
      "node_id": "PRRC_kwDOABII5851VO9h",
      "diff_hunk": "@@ -1336,6 +1347,38 @@ std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph,\n     return ret;\n }\n \n+/** Make linearization topological, retaining its ordering where possible. */\n+template<typename SetType>\n+void FixLinearization(const DepGraph<SetType>& depgraph, Span<DepGraphIndex> linearization) noexcept\n+{\n+    // This algorithm can be summarized as moving every element in the linearization backwards\n+    // until it is placed after all its ancestors.\n+    SetType done;\n+    const auto len = linearization.size();\n+    // Iterate over the elements of linearization from back to front (i is distance from back).\n+    for (DepGraphIndex i = 0; i < len; ++i) {\n+        /** The element at that position. */\n+        DepGraphIndex elem = linearization[len - 1 - i];\n+        /** j represents how far from the back of the linearization elem should be placed. */\n+        DepGraphIndex j = i;\n+        // Figure out which elements need to be moved before elem.\n+        SetType place_before = done & depgraph.Ancestors(elem);\n+        // Find which position to place elem in (updating j), continuously moving the elements\n+        // in between forward.\n+        while (place_before.Any()) {\n+            // j cannot be 0 here; if it was, then there was necessarily nothing earlier which",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 469,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "e43f6ca3b80cff2e05f88223ee9de3e2fe014243",
      "in_reply_to_id": 1968497012,
      "user": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```\r\nif it was, then there was necessarily nothing earlier which elem needs to be place before anymore, and place_before would be empty.\r\n```\r\nThis comment seems jumbled and hard to understand.  Is it possible to word this better?",
      "created_at": "2025-02-24T22:23:55Z",
      "updated_at": "2025-02-24T22:23:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1968500577",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1968500577"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1381,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1968529011",
      "pull_request_review_id": 2638627438,
      "id": 1968529011,
      "node_id": "PRRC_kwDOABII5851VV5z",
      "diff_hunk": "@@ -0,0 +1,2801 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+#include <util/vector.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This is a singleton cluster consisting of a transaction that individually exceeds the\n+     *  cluster size limit. It cannot be merged with anything. */\n+    OVERSIZED,\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster may have multiple disconnected components, which are all OPTIMAL. */\n+    NEEDS_SPLIT_OPTIMAL,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** Information about a transaction inside TxGraphImpl::Trim. */\n+struct TrimTxData\n+{\n+    /** Chunk feerate for this transaction. */\n+    FeePerWeight m_chunk_feerate;\n+    /** GraphIndex of the transaction. */\n+    TxGraph::GraphIndex m_index;\n+    /** Number of unmet dependencies this transaction has. -1 if the transaction is included. */\n+    uint32_t m_deps_left;\n+    /** Number of dependencies that apply to this transaction as child. */\n+    uint32_t m_parent_count;\n+    /** Where in deps_by_child those dependencies begin. */\n+    uint32_t m_parent_offset;\n+    /** Number of dependencies that apply to this transaction as parent. */\n+    uint32_t m_children_count;\n+    /** Where in deps_by_parent those dependencies begin. */\n+    uint32_t m_children_offset;\n+    /** Size of the transaction. */\n+    uint32_t m_tx_size;\n+\n+    // As transactions get processed, they get organized into trees which form partitions\n+    // representing the would-be clusters up to that point. The root of each tree is a\n+    // representative for that partition.\n+    // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+\n+    /** Pointer to another TrimTxData, towards the root of the tree. If this is a root, m_uf_parent\n+     *  is equal to this itself. */\n+    TrimTxData* m_uf_parent;\n+    /** If this is a root, the total number of transactions in the parition. */\n+    uint32_t m_uf_count;\n+    /** If this is a root, the total size of transactions in the partition. */\n+    uint64_t m_uf_size;\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable(bool after_split = false) const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL ||\n+               (after_split && (m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE ||\n+                                m_quality == QualityLevel::NEEDS_SPLIT_OPTIMAL));\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal(bool after_split = false) const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL ||\n+               (after_split && m_quality == QualityLevel::NEEDS_SPLIT_OPTIMAL);\n+    }\n+    /** Whether this cluster is oversized (just due to the size of its transaction(s), not due to\n+     *  dependencies that are yet to be added. */\n+    bool IsOversized() const noexcept { return m_quality == QualityLevel::OVERSIZED; }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT ||\n+               m_quality == QualityLevel::NEEDS_SPLIT_OPTIMAL ||\n+               m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Get the total size of the transactions in this Cluster. */\n+    uint64_t GetTxSize() const noexcept;\n+    /** Given a DepGraphIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(DepGraphIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at the level below this Cluster). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions from a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from level to level-1. */\n+    void LevelDown(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+    /** For every chunk in the cluster, append its FeeFrac to ret. */\n+    void AppendChunkFeerates(std::vector<FeeFrac>& ret) const noexcept;\n+    /** Add a TrimTxData entry for every transaction in the Cluster to ret. Implicit dependencies\n+     *  between consecutive transactions in the linearization are added to deps. Return the\n+     *  Cluster's combined transaction size. */\n+    uint64_t AppendTrimData(std::vector<TrimTxData>& ret, std::vector<std::pair<GraphIndex, GraphIndex>>& deps) const noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their ancestors to output. */\n+    void GetAncestorRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their descendants to output. */\n+    void GetDescendantRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. Returns\n+     *  the range ends at the end of the cluster. */\n+    bool GetClusterRefs(TxGraphImpl& graph, std::span<TxGraph::Ref*> range, LinearizationIndex start_pos) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+\n+    // Debugging functions.\n+\n+    void SanityCheck(const TxGraphImpl& graph, int level) const;\n+};\n+\n+/** The transaction graph, including staged changes.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl::ClusterSet).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * The Clusters are kept in one or two ClusterSet objects, one for the \"main\" graph, and one for\n+ * the proposed changes (\"staging\"). If a transaction occurs in both, they share the same Entry,\n+ * but there will be a separate Cluster per graph.\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+    friend class BlockBuilderImpl;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** This TxGraphImpl's maximum cluster count limit. */\n+    const DepGraphIndex m_max_cluster_count;\n+    /** This TxGraphImpl's maximum cluster size limit. */\n+    const uint64_t m_max_cluster_size;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** Information about all groups of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** The groups of Clusters to be merged. */\n+        std::vector<GroupEntry> m_groups;\n+        /** Which clusters are to be merged. GroupEntry::m_cluster_offset indexes into this. */\n+        std::vector<Cluster*> m_group_clusters;\n+        /** Whether at least one of the groups cannot be applied because it would result in a\n+         *  Cluster that violates the cluster count limit. */\n+        bool m_group_oversized;\n+    };\n+\n+    /** The collection of all Clusters in main or staged. */\n+    struct ClusterSet\n+    {\n+        /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+        std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+        /** Which removals have yet to be applied. */\n+        std::vector<GraphIndex> m_to_remove;\n+        /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+         *  into this. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+        /** Information about the merges to be performed, if known. */\n+        std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n+        /** Total number of transactions in this graph (sum of all transaction counts in all\n+         *  Clusters, and for staging also those inherited from the main ClusterSet). */\n+        GraphIndex m_txcount{0};\n+        /** Total number of individually oversized transactions in the graph. */\n+        GraphIndex m_txcount_oversized{0};\n+        /** Whether this graph is oversized (if known). This roughly matches\n+         *  m_group_data->m_group_oversized || (m_txcount_oversized > 0), but may be known even if\n+         *  m_group_data is not. */\n+        std::optional<bool> m_oversized{false};\n+    };\n+\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;\n+\n+    /** Information about a chunk in the main graph. */\n+    struct ChunkData\n+    {\n+        /** The Entry which is the last transaction of the chunk. */\n+        mutable GraphIndex m_graph_index;\n+        /** How many transactions the chunk contains (-1 = singleton tail of cluster). */\n+        LinearizationIndex m_chunk_count;\n+\n+        ChunkData(GraphIndex graph_index, LinearizationIndex chunk_count) noexcept :\n+            m_graph_index{graph_index}, m_chunk_count{chunk_count} {}\n+    };\n+\n+    /** Comparator for ChunkData objects in mining order. */\n+    class ChunkOrder\n+    {\n+        const TxGraphImpl* const m_graph;\n+    public:\n+        explicit ChunkOrder(const TxGraphImpl* graph) : m_graph(graph) {}\n+\n+        bool operator()(const ChunkData& a, const ChunkData& b) const noexcept\n+        {\n+            const auto& a_entry = m_graph->m_entries[a.m_graph_index];\n+            const auto& b_entry = m_graph->m_entries[b.m_graph_index];\n+            // First sort from high feerate to low feerate.\n+            auto cmp_feerate = FeeRateCompare(a_entry.m_main_chunk_feerate, b_entry.m_main_chunk_feerate);\n+            if (cmp_feerate != 0) return cmp_feerate > 0;\n+            // Then sort by increasing Cluster pointer.\n+            Assume(a_entry.m_locator[0].IsPresent());\n+            Assume(b_entry.m_locator[0].IsPresent());\n+            if (a_entry.m_locator[0].cluster != b_entry.m_locator[0].cluster) {\n+                return std::less{}(a_entry.m_locator[0].cluster, b_entry.m_locator[0].cluster);\n+            }\n+            // Finally sort by position within the Cluster.\n+            return a_entry.m_main_lin_index < b_entry.m_main_lin_index;\n+        }\n+    };\n+\n+    /** Definition for the mining index type. */\n+    using ChunkIndex = std::set<ChunkData, ChunkOrder>;\n+\n+    /** Index of ChunkData objects. */\n+    ChunkIndex m_chunkindex;\n+    /** Number of index-observing objects in existence (BlockBuilderImpl). */\n+    size_t m_chunkindex_observers{0};\n+    /** Cache of discarded ChunkIndex node handles. */\n+    std::vector<ChunkIndex::node_type> m_chunkindex_discarded;\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears.\n+     *  Every Entry has MAX_LEVELS locators, as it may appear in one Cluster per level.\n+     *\n+     *  Each level of a Locator is in one of three states:\n+     *\n+     *  - (P)resent: actually occurs in a Cluster at that level.\n+     *\n+     *  - (M)issing:\n+     *    - In the main graph:    the transaction does not exist in main.\n+     *    - In the staging graph: the transaction's existence is the same as in main. If it doesn't\n+     *                            exist in main, (M) in staging means it does not exist there\n+     *                            either. If it does exist in main, (M) in staging means the\n+     *                            cluster it is in has not been modified in staging, and thus the\n+     *                            transaction implicitly exists in staging too (without explicit\n+     *                            Cluster object; see PullIn() to create it in staging too).\n+     *\n+     *  - (R)emoved: only possible in staging; it means the transaction exists in main, but is\n+     *               removed in staging.\n+     *\n+     * The following combinations are possible:\n+     * - (M,M): the transaction doesn't exist in either graph.\n+     * - (P,M): the transaction exists in both, but only exists explicitly in a Cluster object in\n+     *          main. Its existence in staging is inherited from main.\n+     * - (P,P): the transaction exists in both, and is materialized in both. Thus, the clusters\n+     *          and/or their linearizations may be different in main and staging.\n+     * - (M,P): the transaction is added in staging, and does not exist in main.\n+     * - (P,R): the transaction exists in main, but is removed in staging.\n+     *\n+     * When staging does not exist, only (M,M) and (P,M) are possible.\n+     */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (if cluster == nullptr: 0 = missing, -1 = removed). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing (= same as lower level, or non-existing if level 0). */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as removed (not allowed in level 0). */\n+        void SetRemoved() noexcept { cluster = nullptr; index = DepGraphIndex(-1); }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is missing. */\n+        bool IsMissing() const noexcept { return cluster == nullptr && index == 0; }\n+        /** Check if this Locator is removed. */\n+        bool IsRemoved() const noexcept { return cluster == nullptr && index == DepGraphIndex(-1); }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object if any, or nullptr if unlinked. */\n+        Ref* m_ref{nullptr};\n+        /** Iterator to the corresponding ChunkData, if any. */\n+        ChunkIndex::iterator m_chunkindex_iterator;\n+        /** Which Cluster and position therein this Entry appears in. ([0] = main, [1] = staged). */\n+        Locator m_locator[MAX_LEVELS];\n+        /** The chunk feerate of this transaction in main (if present in m_locator[0]). */\n+        FeePerWeight m_main_chunk_feerate;\n+        /** The position this transaction has in the main linearization (if present). */\n+        LinearizationIndex m_main_lin_index;\n+    };\n+\n+    /** The set of all transactions (in all levels combined). GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl with the specified limits. */\n+    explicit TxGraphImpl(DepGraphIndex max_cluster_count, uint64_t max_cluster_size) noexcept :\n+        m_max_cluster_count(max_cluster_count),\n+        m_max_cluster_size(max_cluster_size),\n+        m_chunkindex(ChunkOrder(this))\n+    {\n+        Assume(max_cluster_count >= 1);\n+        Assume(max_cluster_count <= MAX_CLUSTER_COUNT_LIMIT);\n+        m_clustersets.reserve(MAX_LEVELS);\n+        m_clustersets.emplace_back();\n+    }\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** If idx exists in the specified level ClusterSet (explicitly, or in the level below and not\n+    *   removed), return the Cluster it is in. Otherwise, return nullptr. */\n+    Cluster* FindCluster(GraphIndex idx, int level) const noexcept;\n+    /** Extract a Cluster from its ClusterSet. */\n+    std::unique_ptr<Cluster> ExtractCluster(int level, QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster into its ClusterSet. */\n+    ClusterSetIndex InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+    /** Make a transaction not exist at a specified level. It must currently exist there. */\n+    void ClearLocator(int level, GraphIndex index, bool oversized_tx) noexcept;\n+    /** Find which Clusters conflict with the top level. */\n+    std::vector<Cluster*> GetConflicts() const noexcept;\n+    /** Clear an Entry's ChunkData. */\n+    void ClearChunkData(Entry& entry) noexcept;\n+    /** Give an Entry a ChunkData object. */\n+    void CreateChunkData(GraphIndex idx, LinearizationIndex chunk_count) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        Assume(m_chunkindex_observers == 0 || !entry.m_locator[0].IsPresent());\n+        entry.m_ref = nullptr;\n+        // Mark the transaction as to be removed in all levels where it explicitly or implicitly\n+        // exists.\n+        bool exists_anywhere{false};\n+        bool exists{false};\n+        for (size_t level = 0; level < m_clustersets.size(); ++level) {\n+            if (entry.m_locator[level].IsPresent()) {\n+                exists_anywhere = true;\n+                exists = true;\n+            } else if (entry.m_locator[level].IsRemoved()) {\n+                exists = false;\n+            }\n+            if (exists) {\n+                m_clustersets[level].m_to_remove.push_back(idx);\n+                // Force recomputation of grouping data.\n+                m_clustersets[level].m_group_data = std::nullopt;\n+                // Do not wipe the oversized state of a lower level graph (main) if a higher level\n+                // one (staging) exists. The reason for this is that the alternative would mean that\n+                // cluster merges may need to be applied to a formerly-oversized main graph while\n+                // staging exists (to satisfy chunk feerate queries into main, for example), and such\n+                // merges could conflict with pulls of some of their constituents into staging.\n+                if (level == m_clustersets.size() - 1 && m_clustersets[level].m_oversized == true) {\n+                    m_clustersets[level].m_oversized = std::nullopt;\n+                }\n+            }\n+        }\n+        m_unlinked.push_back(idx);\n+        if (!exists_anywhere) Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  or staged removals referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** If cluster is not in to_level, copy it there, and return a pointer to it. This has no\n+    *   effect if to_level is 0 (main), but for to_level=1 (staging) this modifies the locators of\n+    *   its transactions from inherited (P,M) to explicit (P,P). */\n+    Cluster* PullIn(Cluster* cluster, int to_level) noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel) up to the specified level. */\n+    void ApplyRemovals(int up_to_level) noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting up to the specified level. */\n+    void SplitAll(int up_to_level) noexcept;\n+    /** Populate m_group_data based on m_deps_to_add in the specified level. */\n+    void GroupClusters(int level) noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters in the specified level. */\n+    void ApplyDependencies(int level) noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+    /** Make all Clusters at the specified level have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAllAcceptable(int level) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    void DoWork() noexcept final;\n+\n+    void StartStaging() noexcept final;\n+    void CommitStaging() noexcept final;\n+    void AbortStaging() noexcept final;\n+    bool HaveStaging() const noexcept final { return m_clustersets.size() > 1; }\n+\n+    bool Exists(const Ref& arg, bool main_only = false) noexcept final;\n+    FeePerWeight GetMainChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetAncestorsUnion(std::span<const Ref* const> args, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetDescendantsUnion(std::span<const Ref* const> args, bool main_only = false) noexcept final;\n+    GraphIndex GetTransactionCount(bool main_only = false) noexcept final;\n+    bool IsOversized(bool main_only = false) noexcept final;\n+    std::strong_ordering CompareMainOrder(const Ref& a, const Ref& b) noexcept final;\n+    GraphIndex CountDistinctClusters(std::span<const Ref* const> refs, bool main_only = false) noexcept final;\n+    std::pair<std::vector<FeeFrac>, std::vector<FeeFrac>> GetMainStagingDiagrams() noexcept final;\n+    std::vector<Ref*> Trim() noexcept final;\n+\n+    std::unique_ptr<BlockBuilder> GetBlockBuilder() noexcept final;\n+    std::pair<std::vector<Ref*>, FeePerWeight> GetWorstMainChunk() noexcept final;\n+\n+    void SanityCheck() const final;\n+};\n+\n+/** Implementation of the TxGraph::BlockBuilder interface. */\n+class BlockBuilderImpl final : public TxGraph::BlockBuilder\n+{\n+    /** Which TxGraphImpl this object is doing block building for. It will have its\n+     *  m_chunkindex_observers incremented as long as this BlockBuilderImpl exists. */\n+    TxGraphImpl* const m_graph;\n+    /** Vector for actual storage pointed to by TxGraph::BlockBuilder::m_current_chunk. */\n+    std::vector<TxGraph::Ref*> m_chunkdata;\n+    /** Which cluster the current chunk belongs to, so we can exclude further transaction from it\n+     *  when that chunk is skipped, or std::nullopt if we're at the end of the current cluster. */\n+    std::optional<Cluster*> m_remaining_cluster{nullptr};\n+    /** Clusters which we're not including further transactions from. */\n+    std::set<Cluster*> m_excluded_clusters;\n+    /** Iterator to the next chunk (after the current one) in the chunk index. end() if nothing\n+     *  further remains. */\n+    TxGraphImpl::ChunkIndex::const_iterator m_next_iter;\n+\n+    /** Fill in information about the current chunk in m_current_chunk, m_chunkdata,\n+     *  m_remaining_cluster, and update m_next_iter. */\n+    void Next() noexcept;\n+\n+public:\n+    /** Construct a new BlockBuilderImpl to build blocks for the provided graph. */\n+    BlockBuilderImpl(TxGraphImpl& graph) noexcept;\n+\n+    // Implement the public interface.\n+    ~BlockBuilderImpl() final;\n+    void Include() noexcept final;\n+    void Skip() noexcept final;\n+};\n+\n+void TxGraphImpl::ClearChunkData(Entry& entry) noexcept\n+{\n+    if (entry.m_chunkindex_iterator != m_chunkindex.end()) {\n+        Assume(m_chunkindex_observers == 0);\n+        // If the Entry has a non-empty m_chunkindex_iterator, extract it, and move the handle\n+        // to the cache of discarded chunkindex entries.\n+        m_chunkindex_discarded.emplace_back(m_chunkindex.extract(entry.m_chunkindex_iterator));\n+        entry.m_chunkindex_iterator = m_chunkindex.end();\n+    }\n+}\n+\n+void TxGraphImpl::CreateChunkData(GraphIndex idx, LinearizationIndex chunk_count) noexcept\n+{\n+    auto& entry = m_entries[idx];\n+    if (!m_chunkindex_discarded.empty()) {\n+        // Reuse an discarded node handle.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 620,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "e43f6ca3b80cff2e05f88223ee9de3e2fe014243",
      "in_reply_to_id": null,
      "user": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n        // Reuse a discarded node handle.\r\n```",
      "created_at": "2025-02-24T22:48:56Z",
      "updated_at": "2025-02-24T22:48:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1968529011",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1968529011"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 680,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089137415",
      "pull_request_review_id": 2840518650,
      "id": 2089137415,
      "node_id": "PRRC_kwDOABII5858hbUH",
      "diff_hunk": "@@ -262,12 +268,16 @@ FUZZ_TARGET(txgraph)\n \n     // Decide the maximum number of transactions per cluster we will use in this simulation.\n     auto max_count = provider.ConsumeIntegralInRange<DepGraphIndex>(1, MAX_CLUSTER_COUNT_LIMIT);\n+    // And the maximum combined size of transactions per cluster.\n+    auto max_size = provider.ConsumeIntegralInRange<uint64_t>(1, 0x3fffff * MAX_CLUSTER_COUNT_LIMIT);",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 29,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "462429bc159b1b5ddb5443c484c9bdeae985ad26",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "462429bc159b1b5ddb5443c484c9bdeae985ad26\r\n\r\nnitty: max_agg_size",
      "created_at": "2025-05-14T14:50:09Z",
      "updated_at": "2025-05-19T20:26:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2089137415",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089137415"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 272,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089151874",
      "pull_request_review_id": 2840518650,
      "id": 2089151874,
      "node_id": "PRRC_kwDOABII5858he2C",
      "diff_hunk": "@@ -391,12 +401,12 @@ FUZZ_TARGET(txgraph)\n                 if (alt) {\n                     // If alt is true, pick fee and size from the entire range.\n                     fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n-                    size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+                    size = provider.ConsumeIntegralInRange<int32_t>(1, max_tx_size);\n                 } else {\n                     // Otherwise, use smaller range which consume fewer fuzz input bytes, as just\n                     // these are likely sufficient to trigger all interesting code paths already.\n                     fee = provider.ConsumeIntegral<uint8_t>();\n-                    size = provider.ConsumeIntegral<uint8_t>() + 1;\n+                    size = provider.ConsumeIntegralInRange<uint32_t>(1, std::min<uint32_t>(0xff, max_tx_size));",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 54,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "462429bc159b1b5ddb5443c484c9bdeae985ad26",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "462429bc159b1b5ddb5443c484c9bdeae985ad26\r\n\r\nmisinterpreted the commit message that the _aggregate_ size should not be hit when adding transaction, rather than each individual txn shouldn't exceed this limit. Maybe make this crystal clear.",
      "created_at": "2025-05-14T14:56:32Z",
      "updated_at": "2025-05-19T20:26:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2089151874",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089151874"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 409,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089165076",
      "pull_request_review_id": 2840518650,
      "id": 2089165076,
      "node_id": "PRRC_kwDOABII5858hiEU",
      "diff_hunk": "@@ -109,6 +109,8 @@ class Cluster\n     }\n     /** Get the number of transactions in this Cluster. */\n     LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Get the total size of the transactions in this Cluster. */\n+    uint64_t GetTxSize() const noexcept;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "462429bc159b1b5ddb5443c484c9bdeae985ad26",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "462429bc159b1b5ddb5443c484c9bdeae985ad26\r\n\r\nnitty: GetTotalTxSize? GetAggTxSize? GetTxsSize?",
      "created_at": "2025-05-14T15:02:59Z",
      "updated_at": "2025-05-19T20:26:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2089165076",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089165076"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 113,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089169224",
      "pull_request_review_id": 2840518650,
      "id": 2089169224,
      "node_id": "PRRC_kwDOABII5858hjFI",
      "diff_hunk": "@@ -1453,7 +1469,7 @@ void TxGraphImpl::GroupClusters(int level) noexcept\n             ++new_entry.m_deps_count;\n         }\n         // Detect oversizedness.\n-        if (total_count > m_max_cluster_count) {\n+        if (total_count > m_max_cluster_count || total_size > m_max_cluster_size) {\n             clusterset.m_group_data->m_group_oversized = true;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 66,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "462429bc159b1b5ddb5443c484c9bdeae985ad26",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "462429bc159b1b5ddb5443c484c9bdeae985ad26\r\n\r\nnit: docstring for `m_group_oversized` should be updated",
      "created_at": "2025-05-14T15:04:56Z",
      "updated_at": "2025-05-19T20:26:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2089169224",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089169224"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1473,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089177610",
      "pull_request_review_id": 2840518650,
      "id": 2089177610,
      "node_id": "PRRC_kwDOABII5858hlIK",
      "diff_hunk": "@@ -63,10 +63,10 @@ class TxGraph\n     /** Virtual destructor, so inheriting is safe. */\n     virtual ~TxGraph() = default;\n     /** Construct a new transaction with the specified feerate, and return a Ref to it.\n-     *  If a staging graph exists, the new transaction is only created there. In all\n-     *  further calls, only Refs created by AddTransaction() are allowed to be passed to this\n-     *  TxGraph object (or empty Ref objects). Ref objects may outlive the TxGraph they were\n-     *  created for. */\n+     *  If a staging graph exists, the new transaction is only created there. feerate.size cannot\n+     *  exceed the graph's max cluster size. In all further calls, only Refs created by",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 9,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "462429bc159b1b5ddb5443c484c9bdeae985ad26",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "and can't also be 0? Didn't double check this was already the case, but an assertion is added in 462429bc159b1b5ddb5443c484c9bdeae985ad26",
      "created_at": "2025-05-14T15:09:21Z",
      "updated_at": "2025-05-19T20:26:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2089177610",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089177610"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089187012",
      "pull_request_review_id": 2840518650,
      "id": 2089187012,
      "node_id": "PRRC_kwDOABII5858hnbE",
      "diff_hunk": "@@ -2124,6 +2141,8 @@ void Cluster::SanityCheck(const TxGraphImpl& graph, int level) const\n     assert(m_linearization.size() <= graph.m_max_cluster_count);\n     // The level must match the level the Cluster occurs in.\n     assert(m_level == level);\n+    // The sum of their sizes cannot exceed m_max_cluster_size.\n+    assert(GetTxSize() <= graph.m_max_cluster_size);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 82,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "462429bc159b1b5ddb5443c484c9bdeae985ad26",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "462429bc159b1b5ddb5443c484c9bdeae985ad26\r\n\r\nWas a bit confusing at first, but this must be true because clusters are never merged (via dependency application) when to-be-merged-clusters would be oversized.",
      "created_at": "2025-05-14T15:14:02Z",
      "updated_at": "2025-05-19T20:26:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2089187012",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089187012"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089208525",
      "pull_request_review_id": 2840518650,
      "id": 2089208525,
      "node_id": "PRRC_kwDOABII5858hsrN",
      "diff_hunk": "@@ -134,6 +134,8 @@ struct SimTxGraph\n         simmap[simpos] = std::make_shared<TxGraph::Ref>();\n         auto ptr = simmap[simpos].get();\n         simrevmap[ptr] = simpos;\n+        // This may invalidate our cached oversized value.",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 57,
      "original_position": 4,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "439ccf713b8f9de1dff1d02678bb68d0f29ea175\r\n\r\ncommit message maybe could get beefed up a bit with motivation since at first blush it seems odd to add singletons we wouldn't have relayed in the first place",
      "created_at": "2025-05-14T15:24:35Z",
      "updated_at": "2025-05-19T20:26:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2089208525",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089208525"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089210412",
      "pull_request_review_id": 2840518650,
      "id": 2089210412,
      "node_id": "PRRC_kwDOABII5858htIs",
      "diff_hunk": "@@ -35,6 +35,9 @@ using ClusterSetIndex = uint32_t;\n /** Quality levels for cached cluster linearizations. */\n enum class QualityLevel\n {\n+    /** This is a singleton cluster consisting of a transaction that individually exceeds the\n+     *  cluster size limit. It cannot be merged with anything. */\n+    OVERSIZED,",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 6,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "439ccf713b8f9de1dff1d02678bb68d0f29ea175\r\n\r\nnit: `SINGLETON_OVERSIZED` to reduce later mental gymnastics",
      "created_at": "2025-05-14T15:25:34Z",
      "updated_at": "2025-05-19T20:26:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2089210412",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089210412"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089215165",
      "pull_request_review_id": 2840518650,
      "id": 2089215165,
      "node_id": "PRRC_kwDOABII5858huS9",
      "diff_hunk": "@@ -447,7 +456,7 @@ class TxGraphImpl final : public TxGraph\n     ClusterSet& GetClusterSet(int level) noexcept;\n     const ClusterSet& GetClusterSet(int level) const noexcept;\n     /** Make a transaction not exist at a specified level. It must currently exist there. */\n-    void ClearLocator(int level, GraphIndex index) noexcept;\n+    void ClearLocator(int level, GraphIndex index, bool oversized_tx) noexcept;",
      "path": "src/txgraph.cpp",
      "position": 142,
      "original_position": 38,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "439ccf713b8f9de1dff1d02678bb68d0f29ea175\r\n\r\nplease add documentation on what `oversized_tx` should be",
      "created_at": "2025-05-14T15:27:56Z",
      "updated_at": "2025-05-19T20:26:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2089215165",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089215165"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 502,
      "original_line": 502,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089244722",
      "pull_request_review_id": 2840518650,
      "id": 2089244722,
      "node_id": "PRRC_kwDOABII5858h1gy",
      "diff_hunk": "@@ -815,9 +827,14 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n         todo.Reset(m_linearization.back());\n         m_linearization.pop_back();\n     }\n-    if (todo.None()) {\n+    if (m_linearization.empty()) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 81,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "439ccf713b8f9de1dff1d02678bb68d0f29ea175\r\n\r\nis this a future optimization? these types of clusters were already being marked as `NEED_SPLIT_*`",
      "created_at": "2025-05-14T15:43:29Z",
      "updated_at": "2025-05-19T20:26:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2089244722",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089244722"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 830,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089255284",
      "pull_request_review_id": 2840518650,
      "id": 2089255284,
      "node_id": "PRRC_kwDOABII5858h4F0",
      "diff_hunk": "@@ -838,7 +855,10 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n void Cluster::Clear(TxGraphImpl& graph) noexcept\n {\n     for (auto i : m_linearization) {\n-        graph.ClearLocator(m_level, m_mapping[i]);\n+        // We do not care about setting oversized_tx accurately here, because this function is only\n+        // applied to main-graph Clusters in CommitStaging, which will overwrite main's\n+        // m_txcount_oversized anyway with the staging graph's value.\n+        graph.ClearLocator(m_level, m_mapping[i], /*oversized_tx=*/false);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 100,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n        Assume(m_level == 0);\r\n        graph.ClearLocator(m_level, m_mapping[i], /*oversized_tx=*/false);\r\n```",
      "created_at": "2025-05-14T15:48:25Z",
      "updated_at": "2025-05-19T20:26:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2089255284",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089255284"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 861,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089767602",
      "pull_request_review_id": 2840518650,
      "id": 2089767602,
      "node_id": "PRRC_kwDOABII5858j1Ky",
      "diff_hunk": "@@ -2646,6 +2668,38 @@ std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n         return a->m_chunk_feerate < b->m_chunk_feerate;\n     };\n \n+    /** Given a TrimTxData entry, find the representative of the partition it is in. */\n+    static constexpr auto find_fn = [](TrimTxData* arg) noexcept {\n+        while (arg != arg->m_uf_parent) {\n+            // Replace pointer to parent with pointer to grandparent (path splitting).\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+            auto par = arg->m_uf_parent;\n+            arg->m_uf_parent = par->m_uf_parent;\n+            arg = par;\n+        }\n+        return arg;\n+    };\n+\n+    /** Given two TrimTxData entries, union the partitions they are in, and return the\n+     *  representative. */\n+    static constexpr auto union_fn = [](TrimTxData* arg1, TrimTxData* arg2) noexcept {\n+        // Replace arg1 and arg2 by their representatives.\n+        auto rep1 = find_fn(arg1);\n+        auto rep2 = find_fn(arg2);\n+        // Bail out if both representatives are the same, because that means arg1 and arg2 are in\n+        // the same partition already.\n+        if (rep1 == rep2) return rep1;",
      "path": "src/txgraph.cpp",
      "position": 532,
      "original_position": 87,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "acb2b6a90a47567773268a024bcf2f1ddfcc60df",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "acb2b6a90a47567773268a024bcf2f1ddfcc60df\r\n\r\nFYI this condition doesn't appear to be hit in the fuzz harness",
      "created_at": "2025-05-14T21:15:52Z",
      "updated_at": "2025-05-19T20:26:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2089767602",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089767602"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2684,
      "original_line": 2684,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2095835261",
      "pull_request_review_id": 2840518650,
      "id": 2095835261,
      "node_id": "PRRC_kwDOABII58586-h9",
      "diff_hunk": "@@ -838,7 +855,10 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n void Cluster::Clear(TxGraphImpl& graph) noexcept\n {\n     for (auto i : m_linearization) {\n-        graph.ClearLocator(m_level, m_mapping[i]);\n+        // We do not care about setting oversized_tx accurately here, because this function is only",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 97,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "439ccf713b8f9de1dff1d02678bb68d0f29ea175\r\n\r\nShould this function have clearer naming/documentation to avoid future regressions in use? Seems brittle to me.",
      "created_at": "2025-05-19T14:23:22Z",
      "updated_at": "2025-05-19T20:26:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2095835261",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2095835261"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 858,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2095873167",
      "pull_request_review_id": 2840518650,
      "id": 2095873167,
      "node_id": "PRRC_kwDOABII58587HyP",
      "diff_hunk": "@@ -248,8 +254,11 @@ class TxGraphImpl final : public TxGraph\n         /** Total number of transactions in this graph (sum of all transaction counts in all\n          *  Clusters, and for staging also those inherited from the main ClusterSet). */\n         GraphIndex m_txcount{0};\n+        /** Total number of individually oversized transactions in the graph. */\n+        GraphIndex m_txcount_oversized{0};\n         /** Whether this graph is oversized (if known). This roughly matches\n-         *  m_group_data->m_group_oversized, but may be known even if m_group_data is not. */\n+         *  m_group_data->m_group_oversized || (m_txcount_oversized > 0), but may be known even if",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 28,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "439ccf713b8f9de1dff1d02678bb68d0f29ea175\r\n\r\nDo we need `m_group_oversized`? Seems like a variable we have to keep in sync for no reason:\r\n\r\n```\r\ndiff --git a/src/txgraph.cpp b/src/txgraph.cpp\r\nindex 01076b763b..853f8530a0 100644\r\n--- a/src/txgraph.cpp\r\n+++ b/src/txgraph.cpp\r\n@@ -231,7 +231,4 @@ private:\r\n         /** Which clusters are to be merged. GroupEntry::m_cluster_offset indexes into this. */\r\n         std::vector<Cluster*> m_group_clusters;\r\n-        /** Whether at least one of the groups cannot be applied because it would result in a\r\n-         *  Cluster that violates the cluster count limit. */\r\n-        bool m_group_oversized;\r\n     };\r\n \r\n@@ -257,7 +254,5 @@ private:\r\n         /** Total number of individually oversized transactions in the graph. */\r\n         GraphIndex m_txcount_oversized{0};\r\n-        /** Whether this graph is oversized (if known). This roughly matches\r\n-         *  m_group_data->m_group_oversized || (m_txcount_oversized > 0), but may be known even if\r\n-         *  m_group_data is not. */\r\n+        /** Whether this graph is oversized (if known). */\r\n         std::optional<bool> m_oversized{false};\r\n \r\n@@ -1470,7 +1465,7 @@ void TxGraphImpl::GroupClusters(int level) noexcept\r\n     clusterset.m_group_data = GroupData{};\r\n     clusterset.m_group_data->m_group_clusters.reserve(an_clusters.size());\r\n-    clusterset.m_group_data->m_group_oversized = false;\r\n     clusterset.m_deps_to_add.clear();\r\n     clusterset.m_deps_to_add.reserve(an_deps.size());\r\n+    clusterset.m_oversized = false;\r\n     auto an_deps_it = an_deps.begin();\r\n     auto an_clusters_it = an_clusters.begin();\r\n@@ -1502,10 +1497,9 @@ void TxGraphImpl::GroupClusters(int level) noexcept\r\n         // Detect oversizedness.\r\n         if (total_count > m_max_cluster_count || total_size > m_max_cluster_size) {\r\n-            clusterset.m_group_data->m_group_oversized = true;\r\n+            clusterset.m_oversized = true;\r\n         }\r\n     }\r\n     Assume(an_deps_it == an_deps.end());\r\n     Assume(an_clusters_it == an_clusters.end());\r\n-    clusterset.m_oversized = clusterset.m_group_data->m_group_oversized;\r\n     Compact();\r\n }\r\n@@ -2371,11 +2365,4 @@ void TxGraphImpl::SanityCheck() const\r\n         if (!clusterset.m_removed.empty()) compact_possible = false;\r\n \r\n-        // If m_group_data exists, and no outstanding removals remain, m_group_oversized must match\r\n-        // m_group_oversized || (m_txcount_oversized > 0).\r\n-        if (clusterset.m_group_data.has_value() && clusterset.m_to_remove.empty()) {\r\n-            assert(clusterset.m_oversized ==\r\n-                   (clusterset.m_group_data->m_group_oversized || (clusterset.m_txcount_oversized > 0)));\r\n-        }\r\n-\r\n         // For non-top levels, m_oversized must be known (as it cannot change until the level\r\n         // on top is gone).\r\n```",
      "created_at": "2025-05-19T14:40:51Z",
      "updated_at": "2025-05-19T20:26:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2095873167",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2095873167"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2095933998",
      "pull_request_review_id": 2840518650,
      "id": 2095933998,
      "node_id": "PRRC_kwDOABII58587Wou",
      "diff_hunk": "@@ -62,12 +62,29 @@ struct TrimTxData\n     TxGraph::GraphIndex m_index;\n     /** Number of unmet dependencies this transaction has. -1 if the transaction is included. */\n     uint32_t m_deps_left;\n+    /** Number of dependencies that apply to this transaction as child. */",
      "path": "src/txgraph.cpp",
      "position": 29,
      "original_position": 4,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "acb2b6a90a47567773268a024bcf2f1ddfcc60df",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "acb2b6a90a47567773268a024bcf2f1ddfcc60df\r\n\r\nSome of this commit message should probably go in ce825731e8bea294e71b339015eccdb087e760c7 ? First paragraph at least.",
      "created_at": "2025-05-19T15:09:29Z",
      "updated_at": "2025-05-19T20:26:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2095933998",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2095933998"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 71,
      "original_line": 71,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2096430670",
      "pull_request_review_id": 2840518650,
      "id": 2096430670,
      "node_id": "PRRC_kwDOABII58589P5O",
      "diff_hunk": "@@ -788,6 +788,27 @@ FUZZ_TARGET(txgraph)\n                     assert(sum == worst_chunk_feerate);\n                 }\n                 break;\n+            } else if ((block_builders.empty() || sims.size() > 1) && command-- == 0) {",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 169,
      "original_position": 4,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Here are a couple suggestions to tighten up the checks on what we're trimming. Attempted to state that:\r\n1) non-oversized clusters remain untouched\r\n2) transactions with no ancestors that are undersized should never be trimmed (this seems natural but the interface doesn't guarantee it)\r\n\r\nMostly trying to avoid degenerate behavior like entire mempool being wiped, or any oversized cluster being completely wiped needlessly.\r\n```\r\ndiff --git a/src/test/fuzz/txgraph.cpp b/src/test/fuzz/txgraph.cpp\r\nindex 47ad5792bf..bdf759f485 100644\r\n--- a/src/test/fuzz/txgraph.cpp\r\n+++ b/src/test/fuzz/txgraph.cpp\r\n@@ -91,4 +91,28 @@ struct SimTxGraph\r\n     }\r\n \r\n+    /** Returns true if all positions in the given set are in oversized clusters, false otherwise. */\r\n+    bool AllInOversizedClusters(SetType set)\r\n+    {\r\n+        if (set.Any() && !IsOversized()) return false;\r\n+\r\n+        auto todo = graph.Positions();\r\n+        if (!set.IsSubsetOf(todo)) return false;\r\n+\r\n+        // Walk all clusters, and make sure all of `set` doesn't come from non-oversized clusters\r\n+        while (todo.Any()) {\r\n+            auto component = graph.FindConnectedComponent(todo);\r\n+            bool is_oversized{component.Count() > max_cluster_count};\r\n+            uint64_t component_size{0};\r\n+            for (auto i : component) component_size += graph.FeeRate(i).size;\r\n+            is_oversized |= component_size > max_cluster_size;\r\n+            // Some element existed in a non-oversized cluster\r\n+            if (!is_oversized && set.Overlaps(component)) {\r\n+                return false;\r\n+            }\r\n+            todo -= component;\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n     void MakeModified(DepGraphIndex index)\r\n     {\r\n@@ -798,8 +822,16 @@ FUZZ_TARGET(txgraph)\r\n                 }\r\n                 auto removed_set = top_sim.MakeSet(removed);\r\n-                // The removed set must contain all its own descendants.\r\n                 for (auto simpos : removed_set) {\r\n+                    // The removed set must contain all its own descendants.\r\n                     assert(top_sim.graph.Descendants(simpos).IsSubsetOf(removed_set));\r\n+\r\n+                    // Nothing removed should have no ancestors and be undersized itself\r\n+                    assert(!(top_sim.GetAncDesc(top_sim.GetRef(simpos), /*desc=*/false).Count() == 0 &&\r\n+                        (uint64_t) top_sim.graph.FeeRate(simpos).size <= top_sim.max_cluster_size));\r\n                 }\r\n+\r\n+                // Nothing from not-oversized-clusters should have been removed\r\n+                assert(top_sim.AllInOversizedClusters(removed_set));\r\n+\r\n                 // Apply all removals to the simulation, and verify the result is no longer\r\n                 // oversized. Don't query the real graph for oversizedness; it is compared\r\n```",
      "created_at": "2025-05-19T20:23:07Z",
      "updated_at": "2025-05-19T20:26:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2096430670",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2096430670"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 828,
      "original_line": 828,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098113781",
      "pull_request_review_id": 2854383890,
      "id": 2098113781,
      "node_id": "PRRC_kwDOABII5859Dqz1",
      "diff_hunk": "@@ -886,6 +908,37 @@ void Cluster::AppendChunkFeerates(std::vector<FeeFrac>& ret) const noexcept\n     ret.insert(ret.end(), chunk_feerates.begin(), chunk_feerates.end());\n }\n \n+uint64_t Cluster::AppendTrimData(std::vector<TrimTxData>& ret, std::vector<std::pair<GraphIndex, GraphIndex>>& deps) const noexcept\n+{\n+    LinearizationChunking linchunking(m_depgraph, m_linearization);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 49,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n    const LinearizationChunking linchunking(m_depgraph, m_linearization);\r\n```",
      "created_at": "2025-05-20T14:20:55Z",
      "updated_at": "2025-05-27T14:46:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2098113781",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098113781"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 919,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098190802",
      "pull_request_review_id": 2854383890,
      "id": 2098190802,
      "node_id": "PRRC_kwDOABII5859D9nS",
      "diff_hunk": "@@ -151,6 +168,10 @@ class Cluster\n     void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n     /** For every chunk in the cluster, append its FeeFrac to ret. */\n     void AppendChunkFeerates(std::vector<FeeFrac>& ret) const noexcept;\n+    /** Add a TrimTxData entry for every transaction in the Cluster to ret. Implicit dependencies",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 28,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: 3 out of the N fields are being set here, could we be specific which ones for clarity?",
      "created_at": "2025-05-20T14:51:48Z",
      "updated_at": "2025-05-27T14:46:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2098190802",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098190802"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098239806",
      "pull_request_review_id": 2854383890,
      "id": 2098239806,
      "node_id": "PRRC_kwDOABII5859EJk-",
      "diff_hunk": "@@ -2542,6 +2595,183 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    if (!clusterset.m_group_data->m_group_oversized) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. This\n+    // continues as long the number or size of all picked transactions together does not exceed the\n+    // graph's configured cluster limits. All remaining transactions are then marked as removed.\n+    //\n+    // A next invocation of GroupClusters (after applying the removals) will compute the new\n+    // resulting clusters, and none of them will violate the limits.\n+\n+    /** All dependencies (both to be added ones, and implicit ones between consecutive transactions\n+     *  in existing cluster linearizations). */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps;\n+    /** Information about all transactions involved in a Cluster group to be trimmed, sorted by\n+     *  GraphIndex. */\n+    std::vector<TrimTxData> trim_data;\n+    /** Iterators into trim_data, treated as a max heap according to cmp_fn below. */\n+    std::vector<std::vector<TrimTxData>::iterator> trim_heap;\n+\n+    /** Function to define the ordering of trim_heap. */\n+    static constexpr auto cmp_fn = [](auto a, auto b) noexcept {\n+        // Sort by increasing chunk feerate, and then by decreasing size.\n+        // We do not need to sort by cluster or within clusters, because due to the implicit\n+        // dependency between consecutive linearization elements, no two transactions from the\n+        // same Cluster will ever simultaneously be in the heap.\n+        return a->m_chunk_feerate < b->m_chunk_feerate;\n+    };\n+\n+    /** Get iterator to TrimTxData entry for a given index. */\n+    auto locate_fn = [&](GraphIndex index) noexcept {\n+        auto it = std::lower_bound(trim_data.begin(), trim_data.end(), index, [](TrimTxData& elem, GraphIndex idx) noexcept {\n+            return elem.m_index < idx;\n+        });\n+        Assume(it != trim_data.end() && it->m_index == index);\n+        return it;\n+    };\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        trim_data.clear();\n+        trim_heap.clear();\n+        deps.clear();\n+\n+        // Gather trim data from all involved Clusters.\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        uint64_t size{0};\n+        for (Cluster* cluster : cluster_span) {\n+            size += cluster->AppendTrimData(trim_data, deps);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 156,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: leave a comment that deps is also being added to here, briefly forgot",
      "created_at": "2025-05-20T15:12:25Z",
      "updated_at": "2025-05-27T14:46:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2098239806",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098239806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2669,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098240846",
      "pull_request_review_id": 2854383890,
      "id": 2098240846,
      "node_id": "PRRC_kwDOABII5859EJ1O",
      "diff_hunk": "@@ -2542,6 +2595,183 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    if (!clusterset.m_group_data->m_group_oversized) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. This\n+    // continues as long the number or size of all picked transactions together does not exceed the\n+    // graph's configured cluster limits. All remaining transactions are then marked as removed.\n+    //\n+    // A next invocation of GroupClusters (after applying the removals) will compute the new\n+    // resulting clusters, and none of them will violate the limits.\n+\n+    /** All dependencies (both to be added ones, and implicit ones between consecutive transactions\n+     *  in existing cluster linearizations). */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps;\n+    /** Information about all transactions involved in a Cluster group to be trimmed, sorted by\n+     *  GraphIndex. */\n+    std::vector<TrimTxData> trim_data;\n+    /** Iterators into trim_data, treated as a max heap according to cmp_fn below. */\n+    std::vector<std::vector<TrimTxData>::iterator> trim_heap;\n+\n+    /** Function to define the ordering of trim_heap. */\n+    static constexpr auto cmp_fn = [](auto a, auto b) noexcept {\n+        // Sort by increasing chunk feerate, and then by decreasing size.\n+        // We do not need to sort by cluster or within clusters, because due to the implicit\n+        // dependency between consecutive linearization elements, no two transactions from the\n+        // same Cluster will ever simultaneously be in the heap.\n+        return a->m_chunk_feerate < b->m_chunk_feerate;\n+    };\n+\n+    /** Get iterator to TrimTxData entry for a given index. */\n+    auto locate_fn = [&](GraphIndex index) noexcept {\n+        auto it = std::lower_bound(trim_data.begin(), trim_data.end(), index, [](TrimTxData& elem, GraphIndex idx) noexcept {\n+            return elem.m_index < idx;\n+        });\n+        Assume(it != trim_data.end() && it->m_index == index);\n+        return it;\n+    };\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        trim_data.clear();\n+        trim_heap.clear();\n+        deps.clear();\n+\n+        // Gather trim data from all involved Clusters.\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        uint64_t size{0};\n+        for (Cluster* cluster : cluster_span) {\n+            size += cluster->AppendTrimData(trim_data, deps);\n+        }\n+        // If this group of Clusters does not violate any limits, continue to the next group.\n+        if (trim_data.size() <= m_max_cluster_count && size <= m_max_cluster_size) continue;\n+        // Sort the trim data by GraphIndex. In what follows, we will treat this sorted vector as\n+        // a map from GraphIndex to TrimTxData, and its ordering will not change anymore.\n+        std::sort(trim_data.begin(), trim_data.end(), [](auto& a, auto& b) noexcept { return a.m_index < b.m_index; });\n+\n+        // Construct deps, and sort it by child.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 164,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n        // Append explicit deps, and sort it by child.\r\n```",
      "created_at": "2025-05-20T15:12:57Z",
      "updated_at": "2025-05-27T14:46:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2098240846",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098240846"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2677,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098251956",
      "pull_request_review_id": 2854383890,
      "id": 2098251956,
      "node_id": "PRRC_kwDOABII5859EMi0",
      "diff_hunk": "@@ -2542,6 +2595,183 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    if (!clusterset.m_group_data->m_group_oversized) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. This\n+    // continues as long the number or size of all picked transactions together does not exceed the\n+    // graph's configured cluster limits. All remaining transactions are then marked as removed.\n+    //\n+    // A next invocation of GroupClusters (after applying the removals) will compute the new\n+    // resulting clusters, and none of them will violate the limits.\n+\n+    /** All dependencies (both to be added ones, and implicit ones between consecutive transactions\n+     *  in existing cluster linearizations). */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps;\n+    /** Information about all transactions involved in a Cluster group to be trimmed, sorted by\n+     *  GraphIndex. */\n+    std::vector<TrimTxData> trim_data;\n+    /** Iterators into trim_data, treated as a max heap according to cmp_fn below. */\n+    std::vector<std::vector<TrimTxData>::iterator> trim_heap;\n+\n+    /** Function to define the ordering of trim_heap. */\n+    static constexpr auto cmp_fn = [](auto a, auto b) noexcept {\n+        // Sort by increasing chunk feerate, and then by decreasing size.\n+        // We do not need to sort by cluster or within clusters, because due to the implicit\n+        // dependency between consecutive linearization elements, no two transactions from the\n+        // same Cluster will ever simultaneously be in the heap.\n+        return a->m_chunk_feerate < b->m_chunk_feerate;\n+    };\n+\n+    /** Get iterator to TrimTxData entry for a given index. */\n+    auto locate_fn = [&](GraphIndex index) noexcept {\n+        auto it = std::lower_bound(trim_data.begin(), trim_data.end(), index, [](TrimTxData& elem, GraphIndex idx) noexcept {\n+            return elem.m_index < idx;\n+        });\n+        Assume(it != trim_data.end() && it->m_index == index);\n+        return it;\n+    };\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        trim_data.clear();\n+        trim_heap.clear();\n+        deps.clear();\n+\n+        // Gather trim data from all involved Clusters.\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        uint64_t size{0};\n+        for (Cluster* cluster : cluster_span) {\n+            size += cluster->AppendTrimData(trim_data, deps);\n+        }\n+        // If this group of Clusters does not violate any limits, continue to the next group.\n+        if (trim_data.size() <= m_max_cluster_count && size <= m_max_cluster_size) continue;\n+        // Sort the trim data by GraphIndex. In what follows, we will treat this sorted vector as\n+        // a map from GraphIndex to TrimTxData, and its ordering will not change anymore.\n+        std::sort(trim_data.begin(), trim_data.end(), [](auto& a, auto& b) noexcept { return a.m_index < b.m_index; });\n+\n+        // Construct deps, and sort it by child.\n+        deps.insert(deps.end(),\n+                    clusterset.m_deps_to_add.begin() + group_data.m_deps_offset,\n+                    clusterset.m_deps_to_add.begin() + group_data.m_deps_offset + group_data.m_deps_count);\n+        std::sort(deps.begin(), deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+        // Fill m_deps_left in trim_data. Because of the sort above, all",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 169,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n        // Fill m_deps_left in trim_data and initially populate trim_heap. Because of the sort above, all\r\n```",
      "created_at": "2025-05-20T15:17:59Z",
      "updated_at": "2025-05-27T14:46:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2098251956",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098251956"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2682,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098254652",
      "pull_request_review_id": 2854383890,
      "id": 2098254652,
      "node_id": "PRRC_kwDOABII5859ENM8",
      "diff_hunk": "@@ -2542,6 +2595,183 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    if (!clusterset.m_group_data->m_group_oversized) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. This\n+    // continues as long the number or size of all picked transactions together does not exceed the\n+    // graph's configured cluster limits. All remaining transactions are then marked as removed.\n+    //\n+    // A next invocation of GroupClusters (after applying the removals) will compute the new\n+    // resulting clusters, and none of them will violate the limits.\n+\n+    /** All dependencies (both to be added ones, and implicit ones between consecutive transactions\n+     *  in existing cluster linearizations). */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps;\n+    /** Information about all transactions involved in a Cluster group to be trimmed, sorted by\n+     *  GraphIndex. */\n+    std::vector<TrimTxData> trim_data;\n+    /** Iterators into trim_data, treated as a max heap according to cmp_fn below. */\n+    std::vector<std::vector<TrimTxData>::iterator> trim_heap;\n+\n+    /** Function to define the ordering of trim_heap. */\n+    static constexpr auto cmp_fn = [](auto a, auto b) noexcept {\n+        // Sort by increasing chunk feerate, and then by decreasing size.\n+        // We do not need to sort by cluster or within clusters, because due to the implicit\n+        // dependency between consecutive linearization elements, no two transactions from the\n+        // same Cluster will ever simultaneously be in the heap.\n+        return a->m_chunk_feerate < b->m_chunk_feerate;\n+    };\n+\n+    /** Get iterator to TrimTxData entry for a given index. */\n+    auto locate_fn = [&](GraphIndex index) noexcept {\n+        auto it = std::lower_bound(trim_data.begin(), trim_data.end(), index, [](TrimTxData& elem, GraphIndex idx) noexcept {\n+            return elem.m_index < idx;\n+        });\n+        Assume(it != trim_data.end() && it->m_index == index);\n+        return it;\n+    };\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        trim_data.clear();\n+        trim_heap.clear();\n+        deps.clear();\n+\n+        // Gather trim data from all involved Clusters.\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        uint64_t size{0};\n+        for (Cluster* cluster : cluster_span) {\n+            size += cluster->AppendTrimData(trim_data, deps);\n+        }\n+        // If this group of Clusters does not violate any limits, continue to the next group.\n+        if (trim_data.size() <= m_max_cluster_count && size <= m_max_cluster_size) continue;\n+        // Sort the trim data by GraphIndex. In what follows, we will treat this sorted vector as\n+        // a map from GraphIndex to TrimTxData, and its ordering will not change anymore.\n+        std::sort(trim_data.begin(), trim_data.end(), [](auto& a, auto& b) noexcept { return a.m_index < b.m_index; });\n+\n+        // Construct deps, and sort it by child.\n+        deps.insert(deps.end(),\n+                    clusterset.m_deps_to_add.begin() + group_data.m_deps_offset,\n+                    clusterset.m_deps_to_add.begin() + group_data.m_deps_offset + group_data.m_deps_count);\n+        std::sort(deps.begin(), deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+        // Fill m_deps_left in trim_data. Because of the sort above, all\n+        // dependencies involving the same child are grouped together, so a single linear scan\n+        // suffices.\n+        auto deps_it = deps.begin();\n+        for (auto trim_it = trim_data.begin(); trim_it != trim_data.end(); ++trim_it) {\n+            trim_it->m_deps_left = 0;\n+            while (deps_it != deps.end() && deps_it->second == trim_it->m_index) {\n+                ++trim_it->m_deps_left;\n+                ++deps_it;\n+            }\n+            // If this transaction has no unmet dependencies, and is not oversized, add it to the\n+            // heap (just append for now, the heapification happens below).\n+            if (trim_it->m_deps_left == 0 && trim_it->m_tx_size <= m_max_cluster_size) {\n+                trim_heap.push_back(trim_it);\n+            }\n+        }\n+        Assume(deps_it == deps.end());\n+\n+        // Sort deps by parent.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 187,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n        // Sort deps by parent by graph index. The order is unchanged from now on.\r\n```",
      "created_at": "2025-05-20T15:19:12Z",
      "updated_at": "2025-05-27T14:46:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2098254652",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098254652"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2700,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098265434",
      "pull_request_review_id": 2854383890,
      "id": 2098265434,
      "node_id": "PRRC_kwDOABII5859EP1a",
      "diff_hunk": "@@ -2542,6 +2595,183 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    if (!clusterset.m_group_data->m_group_oversized) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. This\n+    // continues as long the number or size of all picked transactions together does not exceed the\n+    // graph's configured cluster limits. All remaining transactions are then marked as removed.\n+    //\n+    // A next invocation of GroupClusters (after applying the removals) will compute the new\n+    // resulting clusters, and none of them will violate the limits.\n+\n+    /** All dependencies (both to be added ones, and implicit ones between consecutive transactions\n+     *  in existing cluster linearizations). */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps;\n+    /** Information about all transactions involved in a Cluster group to be trimmed, sorted by\n+     *  GraphIndex. */\n+    std::vector<TrimTxData> trim_data;\n+    /** Iterators into trim_data, treated as a max heap according to cmp_fn below. */\n+    std::vector<std::vector<TrimTxData>::iterator> trim_heap;\n+\n+    /** Function to define the ordering of trim_heap. */\n+    static constexpr auto cmp_fn = [](auto a, auto b) noexcept {\n+        // Sort by increasing chunk feerate, and then by decreasing size.\n+        // We do not need to sort by cluster or within clusters, because due to the implicit\n+        // dependency between consecutive linearization elements, no two transactions from the\n+        // same Cluster will ever simultaneously be in the heap.\n+        return a->m_chunk_feerate < b->m_chunk_feerate;\n+    };\n+\n+    /** Get iterator to TrimTxData entry for a given index. */\n+    auto locate_fn = [&](GraphIndex index) noexcept {\n+        auto it = std::lower_bound(trim_data.begin(), trim_data.end(), index, [](TrimTxData& elem, GraphIndex idx) noexcept {\n+            return elem.m_index < idx;\n+        });\n+        Assume(it != trim_data.end() && it->m_index == index);\n+        return it;\n+    };\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        trim_data.clear();\n+        trim_heap.clear();\n+        deps.clear();\n+\n+        // Gather trim data from all involved Clusters.\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        uint64_t size{0};\n+        for (Cluster* cluster : cluster_span) {\n+            size += cluster->AppendTrimData(trim_data, deps);\n+        }\n+        // If this group of Clusters does not violate any limits, continue to the next group.\n+        if (trim_data.size() <= m_max_cluster_count && size <= m_max_cluster_size) continue;\n+        // Sort the trim data by GraphIndex. In what follows, we will treat this sorted vector as\n+        // a map from GraphIndex to TrimTxData, and its ordering will not change anymore.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 161,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n        // a map from GraphIndex to TrimTxData via locate_fn, and its ordering will not change anymore.\r\n```",
      "created_at": "2025-05-20T15:23:59Z",
      "updated_at": "2025-05-27T14:46:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2098265434",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098265434"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2713,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098308679",
      "pull_request_review_id": 2854383890,
      "id": 2098308679,
      "node_id": "PRRC_kwDOABII5859EaZH",
      "diff_hunk": "@@ -2542,6 +2595,183 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    if (!clusterset.m_group_data->m_group_oversized) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. This\n+    // continues as long the number or size of all picked transactions together does not exceed the\n+    // graph's configured cluster limits. All remaining transactions are then marked as removed.\n+    //\n+    // A next invocation of GroupClusters (after applying the removals) will compute the new\n+    // resulting clusters, and none of them will violate the limits.\n+\n+    /** All dependencies (both to be added ones, and implicit ones between consecutive transactions\n+     *  in existing cluster linearizations). */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps;\n+    /** Information about all transactions involved in a Cluster group to be trimmed, sorted by\n+     *  GraphIndex. */\n+    std::vector<TrimTxData> trim_data;\n+    /** Iterators into trim_data, treated as a max heap according to cmp_fn below. */\n+    std::vector<std::vector<TrimTxData>::iterator> trim_heap;\n+\n+    /** Function to define the ordering of trim_heap. */\n+    static constexpr auto cmp_fn = [](auto a, auto b) noexcept {\n+        // Sort by increasing chunk feerate, and then by decreasing size.\n+        // We do not need to sort by cluster or within clusters, because due to the implicit\n+        // dependency between consecutive linearization elements, no two transactions from the\n+        // same Cluster will ever simultaneously be in the heap.\n+        return a->m_chunk_feerate < b->m_chunk_feerate;\n+    };\n+\n+    /** Get iterator to TrimTxData entry for a given index. */\n+    auto locate_fn = [&](GraphIndex index) noexcept {\n+        auto it = std::lower_bound(trim_data.begin(), trim_data.end(), index, [](TrimTxData& elem, GraphIndex idx) noexcept {\n+            return elem.m_index < idx;\n+        });\n+        Assume(it != trim_data.end() && it->m_index == index);\n+        return it;\n+    };\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        trim_data.clear();\n+        trim_heap.clear();\n+        deps.clear();\n+\n+        // Gather trim data from all involved Clusters.\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        uint64_t size{0};\n+        for (Cluster* cluster : cluster_span) {\n+            size += cluster->AppendTrimData(trim_data, deps);\n+        }\n+        // If this group of Clusters does not violate any limits, continue to the next group.\n+        if (trim_data.size() <= m_max_cluster_count && size <= m_max_cluster_size) continue;\n+        // Sort the trim data by GraphIndex. In what follows, we will treat this sorted vector as\n+        // a map from GraphIndex to TrimTxData, and its ordering will not change anymore.\n+        std::sort(trim_data.begin(), trim_data.end(), [](auto& a, auto& b) noexcept { return a.m_index < b.m_index; });\n+\n+        // Construct deps, and sort it by child.\n+        deps.insert(deps.end(),\n+                    clusterset.m_deps_to_add.begin() + group_data.m_deps_offset,\n+                    clusterset.m_deps_to_add.begin() + group_data.m_deps_offset + group_data.m_deps_count);\n+        std::sort(deps.begin(), deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+        // Fill m_deps_left in trim_data. Because of the sort above, all\n+        // dependencies involving the same child are grouped together, so a single linear scan\n+        // suffices.\n+        auto deps_it = deps.begin();\n+        for (auto trim_it = trim_data.begin(); trim_it != trim_data.end(); ++trim_it) {\n+            trim_it->m_deps_left = 0;\n+            while (deps_it != deps.end() && deps_it->second == trim_it->m_index) {\n+                ++trim_it->m_deps_left;\n+                ++deps_it;\n+            }\n+            // If this transaction has no unmet dependencies, and is not oversized, add it to the\n+            // heap (just append for now, the heapification happens below).\n+            if (trim_it->m_deps_left == 0 && trim_it->m_tx_size <= m_max_cluster_size) {\n+                trim_heap.push_back(trim_it);\n+            }\n+        }\n+        Assume(deps_it == deps.end());\n+\n+        // Sort deps by parent.\n+        std::sort(deps.begin(), deps.end(), [](auto& a, auto& b) noexcept { return a.first < b.first; });\n+        // Fill m_children_offset and m_children_count in trim_data. Because of the sort above, all\n+        // dependencies involving the same parent are grouped together, so a single linear scan\n+        // suffices.\n+        deps_it = deps.begin();\n+        for (auto& trim_entry : trim_data) {\n+            trim_entry.m_children_count = 0;\n+            trim_entry.m_children_offset = deps_it - deps.begin();\n+            while (deps_it != deps.end() && deps_it->first == trim_entry.m_index) {\n+                ++trim_entry.m_children_count;\n+                ++deps_it;\n+            }\n+        }\n+        Assume(deps_it == deps.end());\n+\n+        // Build a heap of all transactions with 0 unmet dependencies.\n+        std::make_heap(trim_heap.begin(), trim_heap.end(), cmp_fn);\n+\n+        // Iterate over to-be-included transactions. It is possible that the heap empties without\n+        // ever hitting either cluster limit, in case the implied graph (to be added dependencies\n+        // plus implicit dependency between each original transaction and its predecessor in the\n+        // linearization it came from) contains cycles. Such cycles will be removed entirely,\n+        // because each of the transactions in the cycle permanently have unmet dependencies.\n+        // However, this cannot occur in real scenarios where Trim() is called to deal with\n+        // reorganizations that would violate cluster limits, as all added dependencies are in the\n+        // same direction (from old mempool transactions to new from-block transactions); cycles\n+        // require dependencies in both directions to be added.\n+        uint32_t total_count{0};\n+        uint64_t total_size{0};\n+        while (!trim_heap.empty()) {\n+            // Move the best remaining transaction to the end of trim_heap.\n+            std::pop_heap(trim_heap.begin(), trim_heap.end(), cmp_fn);\n+            // Pop it, and find its TrimTxData.\n+            auto& entry = *trim_heap.back();\n+            trim_heap.pop_back();\n+\n+            // Compute resource counts.\n+            total_count += 1;\n+            total_size += entry.m_tx_size;\n+            // Stop if this would violate any limit.\n+            if (total_count > m_max_cluster_count || total_size > m_max_cluster_size) break;\n+\n+            // Mark the entry as included (so the loop below will not remove the transaction).\n+            entry.m_deps_left = uint32_t(-1);\n+            // Mark each to-be-added dependency involving this transaction as parent satisfied.\n+            for (auto& [par, chl] : std::span{deps}.subspan(entry.m_children_offset, entry.m_children_count)) {\n+                Assume(par == entry.m_index);\n+                auto chl_it = locate_fn(chl);\n+                // Reduce the number of unmet dependencies of chl_it, and if that brings the number\n+                // to zero, add it to the heap.\n+                Assume(chl_it->m_deps_left > 0);\n+                if (--chl_it->m_deps_left == 0) {\n+                    trim_heap.push_back(chl_it);\n+                    std::push_heap(trim_heap.begin(), trim_heap.end(), cmp_fn);\n+                }\n+            }\n+        }\n+\n+        // Remove all the transactions that were not processed above. Because nothing gets\n+        // processed until/unless all its dependencies are met, this automatically guarantees\n+        // that if a transaction is removed, all its descendants, or would-be descendants, are\n+        // removed as well.\n+        for (const auto& trim_entry : trim_data) {\n+            if (trim_entry.m_deps_left != uint32_t(-1)) {\n+                ret.push_back(m_entries[trim_entry.m_index].m_ref);\n+                clusterset.m_to_remove.push_back(trim_entry.m_index);\n+            }\n+        }\n+    }\n+    clusterset.m_group_data.reset();\n+    clusterset.m_oversized = false;\n+    return ret;",
      "path": "src/txgraph.cpp",
      "position": 699,
      "original_position": 259,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n    Assume(!ret.empty());\r\n    return ret;\r\n```",
      "created_at": "2025-05-20T15:43:24Z",
      "updated_at": "2025-05-27T14:46:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2098308679",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098308679"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2851,
      "original_line": 2851,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100993169",
      "pull_request_review_id": 2858860983,
      "id": 2100993169,
      "node_id": "PRRC_kwDOABII5859OpyR",
      "diff_hunk": "@@ -134,6 +134,8 @@ struct SimTxGraph\n         simmap[simpos] = std::make_shared<TxGraph::Ref>();\n         auto ptr = simmap[simpos].get();\n         simrevmap[ptr] = simpos;\n+        // This may invalidate our cached oversized value.",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 57,
      "original_position": 4,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": 2089208525,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I have expanded the commit message of both Trim commits.",
      "created_at": "2025-05-21T19:15:11Z",
      "updated_at": "2025-05-22T11:45:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2100993169",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100993169"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100993968",
      "pull_request_review_id": 2858860983,
      "id": 2100993968,
      "node_id": "PRRC_kwDOABII5859Op-w",
      "diff_hunk": "@@ -262,12 +268,16 @@ FUZZ_TARGET(txgraph)\n \n     // Decide the maximum number of transactions per cluster we will use in this simulation.\n     auto max_count = provider.ConsumeIntegralInRange<DepGraphIndex>(1, MAX_CLUSTER_COUNT_LIMIT);\n+    // And the maximum combined size of transactions per cluster.\n+    auto max_size = provider.ConsumeIntegralInRange<uint64_t>(1, 0x3fffff * MAX_CLUSTER_COUNT_LIMIT);",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 29,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "462429bc159b1b5ddb5443c484c9bdeae985ad26",
      "in_reply_to_id": 2089137415,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I have changed the variable names to `max_cluster_count` and `max_cluster_size` everywhere.",
      "created_at": "2025-05-21T19:15:45Z",
      "updated_at": "2025-05-21T19:24:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2100993968",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100993968"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 272,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100995144",
      "pull_request_review_id": 2858860983,
      "id": 2100995144,
      "node_id": "PRRC_kwDOABII5859OqRI",
      "diff_hunk": "@@ -391,12 +401,12 @@ FUZZ_TARGET(txgraph)\n                 if (alt) {\n                     // If alt is true, pick fee and size from the entire range.\n                     fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n-                    size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+                    size = provider.ConsumeIntegralInRange<int32_t>(1, max_tx_size);\n                 } else {\n                     // Otherwise, use smaller range which consume fewer fuzz input bytes, as just\n                     // these are likely sufficient to trigger all interesting code paths already.\n                     fee = provider.ConsumeIntegral<uint8_t>();\n-                    size = provider.ConsumeIntegral<uint8_t>() + 1;\n+                    size = provider.ConsumeIntegralInRange<uint32_t>(1, std::min<uint32_t>(0xff, max_tx_size));",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 54,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "462429bc159b1b5ddb5443c484c9bdeae985ad26",
      "in_reply_to_id": 2089151874,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Do you mean in the TxGraph::AddTransaction definition in txgraph.h? I have expanded the comments in the fuzz test around this a bit.",
      "created_at": "2025-05-21T19:16:31Z",
      "updated_at": "2025-05-21T19:24:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2100995144",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100995144"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 409,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100995536",
      "pull_request_review_id": 2858860983,
      "id": 2100995536,
      "node_id": "PRRC_kwDOABII5859OqXQ",
      "diff_hunk": "@@ -109,6 +109,8 @@ class Cluster\n     }\n     /** Get the number of transactions in this Cluster. */\n     LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Get the total size of the transactions in this Cluster. */\n+    uint64_t GetTxSize() const noexcept;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "462429bc159b1b5ddb5443c484c9bdeae985ad26",
      "in_reply_to_id": 2089165076,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`GetTotalTxSize` is a nice color.",
      "created_at": "2025-05-21T19:16:47Z",
      "updated_at": "2025-05-21T19:24:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2100995536",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100995536"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 113,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100996101",
      "pull_request_review_id": 2858860983,
      "id": 2100996101,
      "node_id": "PRRC_kwDOABII5859OqgF",
      "diff_hunk": "@@ -1453,7 +1469,7 @@ void TxGraphImpl::GroupClusters(int level) noexcept\n             ++new_entry.m_deps_count;\n         }\n         // Detect oversizedness.\n-        if (total_count > m_max_cluster_count) {\n+        if (total_count > m_max_cluster_count || total_size > m_max_cluster_size) {\n             clusterset.m_group_data->m_group_oversized = true;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 66,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "462429bc159b1b5ddb5443c484c9bdeae985ad26",
      "in_reply_to_id": 2089169224,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, but also removed in a later commit.",
      "created_at": "2025-05-21T19:17:13Z",
      "updated_at": "2025-05-21T19:24:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2100996101",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100996101"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1473,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101000637",
      "pull_request_review_id": 2858860983,
      "id": 2101000637,
      "node_id": "PRRC_kwDOABII5859Orm9",
      "diff_hunk": "@@ -63,10 +63,10 @@ class TxGraph\n     /** Virtual destructor, so inheriting is safe. */\n     virtual ~TxGraph() = default;\n     /** Construct a new transaction with the specified feerate, and return a Ref to it.\n-     *  If a staging graph exists, the new transaction is only created there. In all\n-     *  further calls, only Refs created by AddTransaction() are allowed to be passed to this\n-     *  TxGraph object (or empty Ref objects). Ref objects may outlive the TxGraph they were\n-     *  created for. */\n+     *  If a staging graph exists, the new transaction is only created there. feerate.size cannot\n+     *  exceed the graph's max cluster size. In all further calls, only Refs created by",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 9,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "462429bc159b1b5ddb5443c484c9bdeae985ad26",
      "in_reply_to_id": 2089177610,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added as comment.",
      "created_at": "2025-05-21T19:18:56Z",
      "updated_at": "2025-05-21T19:24:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2101000637",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101000637"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101001371",
      "pull_request_review_id": 2858860983,
      "id": 2101001371,
      "node_id": "PRRC_kwDOABII5859Oryb",
      "diff_hunk": "@@ -2124,6 +2141,8 @@ void Cluster::SanityCheck(const TxGraphImpl& graph, int level) const\n     assert(m_linearization.size() <= graph.m_max_cluster_count);\n     // The level must match the level the Cluster occurs in.\n     assert(m_level == level);\n+    // The sum of their sizes cannot exceed m_max_cluster_size.\n+    assert(GetTxSize() <= graph.m_max_cluster_size);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 82,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "462429bc159b1b5ddb5443c484c9bdeae985ad26",
      "in_reply_to_id": 2089187012,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've added a comment to highlight that.",
      "created_at": "2025-05-21T19:19:11Z",
      "updated_at": "2025-05-21T19:24:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2101001371",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101001371"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101002139",
      "pull_request_review_id": 2858860983,
      "id": 2101002139,
      "node_id": "PRRC_kwDOABII5859Or-b",
      "diff_hunk": "@@ -35,6 +35,9 @@ using ClusterSetIndex = uint32_t;\n /** Quality levels for cached cluster linearizations. */\n enum class QualityLevel\n {\n+    /** This is a singleton cluster consisting of a transaction that individually exceeds the\n+     *  cluster size limit. It cannot be merged with anything. */\n+    OVERSIZED,",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 6,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": 2089210412,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good idea, I went with `OVERSIZED_SINGLETON`.",
      "created_at": "2025-05-21T19:19:35Z",
      "updated_at": "2025-05-21T19:24:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2101002139",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101002139"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101002887",
      "pull_request_review_id": 2858860983,
      "id": 2101002887,
      "node_id": "PRRC_kwDOABII5859OsKH",
      "diff_hunk": "@@ -447,7 +456,7 @@ class TxGraphImpl final : public TxGraph\n     ClusterSet& GetClusterSet(int level) noexcept;\n     const ClusterSet& GetClusterSet(int level) const noexcept;\n     /** Make a transaction not exist at a specified level. It must currently exist there. */\n-    void ClearLocator(int level, GraphIndex index) noexcept;\n+    void ClearLocator(int level, GraphIndex index, bool oversized_tx) noexcept;",
      "path": "src/txgraph.cpp",
      "position": 142,
      "original_position": 38,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": 2089215165,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-05-21T19:19:46Z",
      "updated_at": "2025-05-21T19:24:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2101002887",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101002887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 502,
      "original_line": 502,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101004897",
      "pull_request_review_id": 2858860983,
      "id": 2101004897,
      "node_id": "PRRC_kwDOABII5859Osph",
      "diff_hunk": "@@ -815,9 +827,14 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n         todo.Reset(m_linearization.back());\n         m_linearization.pop_back();\n     }\n-    if (todo.None()) {\n+    if (m_linearization.empty()) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 81,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": 2089244722,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I have simplified this to just a `m_linearization.empty() ||` in the if conditional below.",
      "created_at": "2025-05-21T19:20:18Z",
      "updated_at": "2025-05-21T19:24:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2101004897",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101004897"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 830,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101006466",
      "pull_request_review_id": 2858860983,
      "id": 2101006466,
      "node_id": "PRRC_kwDOABII5859OtCC",
      "diff_hunk": "@@ -838,7 +855,10 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n void Cluster::Clear(TxGraphImpl& graph) noexcept\n {\n     for (auto i : m_linearization) {\n-        graph.ClearLocator(m_level, m_mapping[i]);\n+        // We do not care about setting oversized_tx accurately here, because this function is only\n+        // applied to main-graph Clusters in CommitStaging, which will overwrite main's\n+        // m_txcount_oversized anyway with the staging graph's value.\n+        graph.ClearLocator(m_level, m_mapping[i], /*oversized_tx=*/false);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 100,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": 2089255284,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Instead of this big unintuitive comment, I have replaced it with `/*oversized_tx=*/m_quality == QualityLevel::OVERSIZED_SINGLETON`. With that, I don't think the `Assume` is neccesary?",
      "created_at": "2025-05-21T19:21:11Z",
      "updated_at": "2025-05-21T19:24:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2101006466",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101006466"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 861,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101007195",
      "pull_request_review_id": 2858860983,
      "id": 2101007195,
      "node_id": "PRRC_kwDOABII5859OtNb",
      "diff_hunk": "@@ -2646,6 +2668,38 @@ std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n         return a->m_chunk_feerate < b->m_chunk_feerate;\n     };\n \n+    /** Given a TrimTxData entry, find the representative of the partition it is in. */\n+    static constexpr auto find_fn = [](TrimTxData* arg) noexcept {\n+        while (arg != arg->m_uf_parent) {\n+            // Replace pointer to parent with pointer to grandparent (path splitting).\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+            auto par = arg->m_uf_parent;\n+            arg->m_uf_parent = par->m_uf_parent;\n+            arg = par;\n+        }\n+        return arg;\n+    };\n+\n+    /** Given two TrimTxData entries, union the partitions they are in, and return the\n+     *  representative. */\n+    static constexpr auto union_fn = [](TrimTxData* arg1, TrimTxData* arg2) noexcept {\n+        // Replace arg1 and arg2 by their representatives.\n+        auto rep1 = find_fn(arg1);\n+        auto rep2 = find_fn(arg2);\n+        // Bail out if both representatives are the same, because that means arg1 and arg2 are in\n+        // the same partition already.\n+        if (rep1 == rep2) return rep1;",
      "path": "src/txgraph.cpp",
      "position": 532,
      "original_position": 87,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "acb2b6a90a47567773268a024bcf2f1ddfcc60df",
      "in_reply_to_id": 2089767602,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Both `assert(rep1 == rep2)` and `assert(rep1 != rep2)` instantly trigger failures when fuzzing for me.",
      "created_at": "2025-05-21T19:21:41Z",
      "updated_at": "2025-05-21T19:24:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2101007195",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101007195"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2684,
      "original_line": 2684,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101007955",
      "pull_request_review_id": 2858860983,
      "id": 2101007955,
      "node_id": "PRRC_kwDOABII5859OtZT",
      "diff_hunk": "@@ -838,7 +855,10 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n void Cluster::Clear(TxGraphImpl& graph) noexcept\n {\n     for (auto i : m_linearization) {\n-        graph.ClearLocator(m_level, m_mapping[i]);\n+        // We do not care about setting oversized_tx accurately here, because this function is only",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 97,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": 2095835261,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "See above, I have dropped the constraints on `ClearLocator` instead.",
      "created_at": "2025-05-21T19:22:12Z",
      "updated_at": "2025-05-21T19:24:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2101007955",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101007955"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 858,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101009187",
      "pull_request_review_id": 2858860983,
      "id": 2101009187,
      "node_id": "PRRC_kwDOABII5859Otsj",
      "diff_hunk": "@@ -248,8 +254,11 @@ class TxGraphImpl final : public TxGraph\n         /** Total number of transactions in this graph (sum of all transaction counts in all\n          *  Clusters, and for staging also those inherited from the main ClusterSet). */\n         GraphIndex m_txcount{0};\n+        /** Total number of individually oversized transactions in the graph. */\n+        GraphIndex m_txcount_oversized{0};\n         /** Whether this graph is oversized (if known). This roughly matches\n-         *  m_group_data->m_group_oversized, but may be known even if m_group_data is not. */\n+         *  m_group_data->m_group_oversized || (m_txcount_oversized > 0), but may be known even if",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 28,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": 2095873167,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nice catch, after the changes in \"Permit transactions that exceed cluster size limit\", `m_group_oversized` is never read anymore. Included this patch as a separate simplification commit.",
      "created_at": "2025-05-21T19:23:00Z",
      "updated_at": "2025-05-21T19:24:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2101009187",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101009187"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101010831",
      "pull_request_review_id": 2858860983,
      "id": 2101010831,
      "node_id": "PRRC_kwDOABII5859OuGP",
      "diff_hunk": "@@ -788,6 +788,27 @@ FUZZ_TARGET(txgraph)\n                     assert(sum == worst_chunk_feerate);\n                 }\n                 break;\n+            } else if ((block_builders.empty() || sims.size() > 1) && command-- == 0) {",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 169,
      "original_position": 4,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": 2096430670,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Taken, except for:\r\n\r\n```patch\r\n+                  assert(!(top_sim.GetAncDesc(top_sim.GetRef(simpos), /*desc=*/false).Count() == 0 &&\r\n+                        (uint64_t) top_sim.graph.FeeRate(simpos).size <= top_sim.max_cluster_size));\r\n```\r\n\r\nbecause `Count() == 0` will never be true (ancestors always includes the transaction itself), and the test fails when I change it to `Count() == 1`.",
      "created_at": "2025-05-21T19:24:03Z",
      "updated_at": "2025-05-21T19:24:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2101010831",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101010831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 828,
      "original_line": 828,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101012572",
      "pull_request_review_id": 2858888092,
      "id": 2101012572,
      "node_id": "PRRC_kwDOABII5859Ouhc",
      "diff_hunk": "@@ -62,12 +62,29 @@ struct TrimTxData\n     TxGraph::GraphIndex m_index;\n     /** Number of unmet dependencies this transaction has. -1 if the transaction is included. */\n     uint32_t m_deps_left;\n+    /** Number of dependencies that apply to this transaction as child. */",
      "path": "src/txgraph.cpp",
      "position": 29,
      "original_position": 4,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "acb2b6a90a47567773268a024bcf2f1ddfcc60df",
      "in_reply_to_id": 2095933998,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I have expanded the commit messages.",
      "created_at": "2025-05-21T19:25:09Z",
      "updated_at": "2025-05-21T19:25:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2101012572",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101012572"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 71,
      "original_line": 71,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101120274",
      "pull_request_review_id": 2854383890,
      "id": 2101120274,
      "node_id": "PRRC_kwDOABII5859PI0S",
      "diff_hunk": "@@ -788,6 +788,27 @@ FUZZ_TARGET(txgraph)\n                     assert(sum == worst_chunk_feerate);\n                 }\n                 break;\n+            } else if ((block_builders.empty() || sims.size() > 1) && command-- == 0) {",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 169,
      "original_position": 4,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": 2096430670,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, I see it now. Both variants of the Trim() algorithm can definitely remove these types of transactions.\r\n\r\nf.e. if cluster limit is 2 and you have: \r\nTxA <- TxB <- TxC\r\nTxA <- TxE\r\nTxD <- TxE\r\n\r\nYou may select TxA+TxB only (after stopping at TxC), evicting TxC+TxD+TxE, if TxD's cfr is low.\r\n\r\nIf TxD's cfr is higher than TxB or TxC, then you could retain A+B+D\r\n\r\nAfter a bunch of debugging, I was able to figure out a stronger check, *if* we constrain the scenario from a non-oversized to oversized transition with pending dependencies applied: https://github.com/instagibbs/bitcoin/tree/2025-05-applytrim",
      "created_at": "2025-05-21T20:34:34Z",
      "updated_at": "2025-05-27T14:46:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2101120274",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101120274"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 828,
      "original_line": 828,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101196912",
      "pull_request_review_id": 2859163884,
      "id": 2101196912,
      "node_id": "PRRC_kwDOABII5859Pbhw",
      "diff_hunk": "@@ -391,12 +401,12 @@ FUZZ_TARGET(txgraph)\n                 if (alt) {\n                     // If alt is true, pick fee and size from the entire range.\n                     fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n-                    size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+                    size = provider.ConsumeIntegralInRange<int32_t>(1, max_tx_size);\n                 } else {\n                     // Otherwise, use smaller range which consume fewer fuzz input bytes, as just\n                     // these are likely sufficient to trigger all interesting code paths already.\n                     fee = provider.ConsumeIntegral<uint8_t>();\n-                    size = provider.ConsumeIntegral<uint8_t>() + 1;\n+                    size = provider.ConsumeIntegralInRange<uint32_t>(1, std::min<uint32_t>(0xff, max_tx_size));",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 54,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "462429bc159b1b5ddb5443c484c9bdeae985ad26",
      "in_reply_to_id": 2089151874,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Does :+1: mean \"That is what I meant\" or \"It's fixed now\"?",
      "created_at": "2025-05-21T21:25:48Z",
      "updated_at": "2025-05-21T21:25:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2101196912",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101196912"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 409,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102062249",
      "pull_request_review_id": 2860445285,
      "id": 2102062249,
      "node_id": "PRRC_kwDOABII5859Suyp",
      "diff_hunk": "@@ -101,6 +104,9 @@ class Cluster\n     {\n         return m_quality == QualityLevel::OPTIMAL;\n     }\n+    /** Whether this cluster is oversized (just due to the size of its transaction(s), not due to\n+     *  dependencies that are yet to be added. */\n+    bool IsOversized() const noexcept { return m_quality == QualityLevel::OVERSIZED_SINGLETON; }",
      "path": "src/txgraph.cpp",
      "position": 65,
      "original_position": 16,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "bd95322455693649b4fb3a776e90e01ddd36dca1",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This method's name aligns with its functionality.\r\n\r\nHowever with the addition of this commit I think  there is ambiguity currently between  the size oversize, the  count oversize and both. This makes it a bit confusing to follow.\r\n\r\nmaybe separate the two.\r\n\r\noversize should be for size.\r\n\r\noverlimit or something like it for both",
      "created_at": "2025-05-22T09:18:18Z",
      "updated_at": "2025-05-22T14:30:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2102062249",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102062249"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102277142",
      "pull_request_review_id": 2860445285,
      "id": 2102277142,
      "node_id": "PRRC_kwDOABII5859TjQW",
      "diff_hunk": "@@ -818,7 +831,7 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n     if (todo.None()) {\n         // If no further removals remain, and thus all removals were at the end, we may be able\n         // to leave the cluster at a better quality level.\n-        if (IsAcceptable(/*after_split=*/true)) {\n+        if (m_linearization.empty() || IsAcceptable(/*after_split=*/true)) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 93,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "bd95322455693649b4fb3a776e90e01ddd36dca1",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "if there is nothing in the cluster? why should it be marked as needs_split_acceptable?\r\nAlso I see no crashes after removing the new or condition.",
      "created_at": "2025-05-22T11:00:29Z",
      "updated_at": "2025-05-22T14:30:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2102277142",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102277142"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 834,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102457782",
      "pull_request_review_id": 2860445285,
      "id": 2102457782,
      "node_id": "PRRC_kwDOABII5859UPW2",
      "diff_hunk": "@@ -789,6 +814,31 @@ FUZZ_TARGET(txgraph)\n                     assert(sum == worst_chunk_feerate);\n                 }\n                 break;\n+            } else if ((block_builders.empty() || sims.size() > 1) && command-- == 0) {\n+                // Trim.\n+                bool was_oversized = top_sim.IsOversized();\n+                auto removed = real->Trim();\n+                if (!was_oversized) {\n+                    assert(removed.empty());\n+                    break;\n+                }\n+                auto removed_set = top_sim.MakeSet(removed);",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 176,
      "original_position": 44,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "412a9e0e69ccf461554660b7c622b768cfb8ccb3",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "assert that we trim when oversized ?\r\n\r\n```suggestion\r\n                assert(!removed.empty());\r\n                auto removed_set = top_sim.MakeSet(removed);\r\n```\r\n",
      "created_at": "2025-05-22T12:38:29Z",
      "updated_at": "2025-05-22T14:30:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2102457782",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102457782"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 835,
      "original_line": 835,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102494391",
      "pull_request_review_id": 2860445285,
      "id": 2102494391,
      "node_id": "PRRC_kwDOABII5859UYS3",
      "diff_hunk": "@@ -247,6 +247,31 @@ struct SimTxGraph\n             }\n         }\n     }\n+\n+\n+    /** Returns true if all positions in the given set are in oversized clusters, false otherwise. */\n+    bool AllInOversizedClusters(const SetType& set)\n+    {\n+        if (set.Any() && !IsOversized()) return false;\n+\n+        auto todo = graph.Positions();\n+        if (!set.IsSubsetOf(todo)) return false;\n+\n+        // Walk all clusters, and make sure all of set doesn't come from non-oversized clusters\n+        while (todo.Any()) {\n+            auto component = graph.FindConnectedComponent(todo);\n+            bool is_oversized = component.Count() > max_cluster_count;\n+            uint64_t component_size{0};\n+            for (auto i : component) component_size += graph.FeeRate(i).size;\n+            is_oversized |= component_size > max_cluster_size;\n+            // Some element existed in a non-oversized cluster\n+            if (!is_oversized && set.Overlaps(component)) {\n+                return false;\n+            }",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 24,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "412a9e0e69ccf461554660b7c622b768cfb8ccb3",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "check both ways\r\n```suggestion\r\n            }\r\n            // No element exist in set and cluster is oversized \r\n            if (is_oversized && !set.Overlaps(component)){\r\n               return false;\r\n            }\r\n```",
      "created_at": "2025-05-22T12:56:05Z",
      "updated_at": "2025-05-22T14:30:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2102494391",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102494391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 270,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102571828",
      "pull_request_review_id": 2860445285,
      "id": 2102571828,
      "node_id": "PRRC_kwDOABII5859UrM0",
      "diff_hunk": "@@ -169,6 +169,11 @@ class TxGraph\n      *  that appear identically in both. Use FeeFrac rather than FeePerWeight so CompareChunks is\n      *  usable without type-conversion. */\n     virtual std::pair<std::vector<FeeFrac>, std::vector<FeeFrac>> GetMainStagingDiagrams() noexcept = 0;\n+    /** Remove transactions (including their own descendants) according to a fast but best-effort\n+     *  strategy such that the TxGraph's cluster and size limits are respected. Applies to staging\n+     *  if it exists, and to main otherwise. Returns the list of all removed transactions in\n+     *  unspecified order. This has no effect unless the relevant graph is oversized. */\n+    virtual std::vector<Ref*> Trim() noexcept = 0;",
      "path": "src/txgraph.h",
      "position": 23,
      "original_position": 8,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "412a9e0e69ccf461554660b7c622b768cfb8ccb3",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Indicate that it should not be called when their is an instance of block builder.",
      "created_at": "2025-05-22T13:30:57Z",
      "updated_at": "2025-05-22T14:30:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2102571828",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102571828"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 176,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103297850",
      "pull_request_review_id": 2862413711,
      "id": 2103297850,
      "node_id": "PRRC_kwDOABII5859Xcc6",
      "diff_hunk": "@@ -789,6 +814,31 @@ FUZZ_TARGET(txgraph)\n                     assert(sum == worst_chunk_feerate);\n                 }\n                 break;\n+            } else if ((block_builders.empty() || sims.size() > 1) && command-- == 0) {\n+                // Trim.\n+                bool was_oversized = top_sim.IsOversized();\n+                auto removed = real->Trim();\n+                if (!was_oversized) {\n+                    assert(removed.empty());\n+                    break;\n+                }\n+                auto removed_set = top_sim.MakeSet(removed);",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 176,
      "original_position": 44,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "412a9e0e69ccf461554660b7c622b768cfb8ccb3",
      "in_reply_to_id": 2102457782,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-05-22T19:51:45Z",
      "updated_at": "2025-05-22T20:02:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2103297850",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103297850"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 835,
      "original_line": 835,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103301238",
      "pull_request_review_id": 2862413711,
      "id": 2103301238,
      "node_id": "PRRC_kwDOABII5859XdR2",
      "diff_hunk": "@@ -101,6 +104,9 @@ class Cluster\n     {\n         return m_quality == QualityLevel::OPTIMAL;\n     }\n+    /** Whether this cluster is oversized (just due to the size of its transaction(s), not due to\n+     *  dependencies that are yet to be added. */\n+    bool IsOversized() const noexcept { return m_quality == QualityLevel::OVERSIZED_SINGLETON; }",
      "path": "src/txgraph.cpp",
      "position": 65,
      "original_position": 16,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "bd95322455693649b4fb3a776e90e01ddd36dca1",
      "in_reply_to_id": 2102062249,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "To be clear, `Cluster::IsOversized()` returns whether the Cluster is oversized in general. It's just the case that changes to clusters which bring it over the size/count limit are never applied, so the only way an actually materialized Cluster can be oversized is if it's a singleton transaction which is oversized on its own.",
      "created_at": "2025-05-22T19:54:12Z",
      "updated_at": "2025-05-22T20:02:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2103301238",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103301238"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103303619",
      "pull_request_review_id": 2862413711,
      "id": 2103303619,
      "node_id": "PRRC_kwDOABII5859Xd3D",
      "diff_hunk": "@@ -169,6 +169,11 @@ class TxGraph\n      *  that appear identically in both. Use FeeFrac rather than FeePerWeight so CompareChunks is\n      *  usable without type-conversion. */\n     virtual std::pair<std::vector<FeeFrac>, std::vector<FeeFrac>> GetMainStagingDiagrams() noexcept = 0;\n+    /** Remove transactions (including their own descendants) according to a fast but best-effort\n+     *  strategy such that the TxGraph's cluster and size limits are respected. Applies to staging\n+     *  if it exists, and to main otherwise. Returns the list of all removed transactions in\n+     *  unspecified order. This has no effect unless the relevant graph is oversized. */\n+    virtual std::vector<Ref*> Trim() noexcept = 0;",
      "path": "src/txgraph.h",
      "position": 23,
      "original_position": 8,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "412a9e0e69ccf461554660b7c622b768cfb8ccb3",
      "in_reply_to_id": 2102571828,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The `GetBlockBuilder` function already states \"While the returned object exists, no mutators on the main graph are allowed.\". I'm open to putting a comment to that effect on each of the mutators where it matters (incl. `Trim`), but I feel like it should be done consistently.",
      "created_at": "2025-05-22T19:55:52Z",
      "updated_at": "2025-05-22T20:02:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2103303619",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103303619"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 176,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103305067",
      "pull_request_review_id": 2862413711,
      "id": 2103305067,
      "node_id": "PRRC_kwDOABII5859XeNr",
      "diff_hunk": "@@ -247,6 +247,31 @@ struct SimTxGraph\n             }\n         }\n     }\n+\n+\n+    /** Returns true if all positions in the given set are in oversized clusters, false otherwise. */\n+    bool AllInOversizedClusters(const SetType& set)\n+    {\n+        if (set.Any() && !IsOversized()) return false;\n+\n+        auto todo = graph.Positions();\n+        if (!set.IsSubsetOf(todo)) return false;\n+\n+        // Walk all clusters, and make sure all of set doesn't come from non-oversized clusters\n+        while (todo.Any()) {\n+            auto component = graph.FindConnectedComponent(todo);\n+            bool is_oversized = component.Count() > max_cluster_count;\n+            uint64_t component_size{0};\n+            for (auto i : component) component_size += graph.FeeRate(i).size;\n+            is_oversized |= component_size > max_cluster_size;\n+            // Some element existed in a non-oversized cluster\n+            if (!is_oversized && set.Overlaps(component)) {\n+                return false;\n+            }",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 24,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "412a9e0e69ccf461554660b7c622b768cfb8ccb3",
      "in_reply_to_id": 2102494391,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Interesting, done! I have renamed the function to `MatchesOversizedClusters` and added a comment to clarify what it does.\r\n\r\nI've also simplified it to just `if (is_oversized != set.Overlaps(component)) return false;`.",
      "created_at": "2025-05-22T19:56:53Z",
      "updated_at": "2025-05-22T20:02:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2103305067",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103305067"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 270,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103305596",
      "pull_request_review_id": 2862413711,
      "id": 2103305596,
      "node_id": "PRRC_kwDOABII5859XeV8",
      "diff_hunk": "@@ -818,7 +831,7 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n     if (todo.None()) {\n         // If no further removals remain, and thus all removals were at the end, we may be able\n         // to leave the cluster at a better quality level.\n-        if (IsAcceptable(/*after_split=*/true)) {\n+        if (m_linearization.empty() || IsAcceptable(/*after_split=*/true)) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 93,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "bd95322455693649b4fb3a776e90e01ddd36dca1",
      "in_reply_to_id": 2102277142,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "You're right, this doesn't matter at all. The Cluster will just be deleted by `Split` anyway. Removed it.",
      "created_at": "2025-05-22T19:57:17Z",
      "updated_at": "2025-05-22T20:02:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2103305596",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103305596"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 834,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103368896",
      "pull_request_review_id": 2862525266,
      "id": 2103368896,
      "node_id": "PRRC_kwDOABII5859XtzA",
      "diff_hunk": "@@ -101,6 +104,9 @@ class Cluster\n     {\n         return m_quality == QualityLevel::OPTIMAL;\n     }\n+    /** Whether this cluster is oversized (just due to the size of its transaction(s), not due to\n+     *  dependencies that are yet to be added. */\n+    bool IsOversized() const noexcept { return m_quality == QualityLevel::OVERSIZED_SINGLETON; }",
      "path": "src/txgraph.cpp",
      "position": 65,
      "original_position": 16,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "bd95322455693649b4fb3a776e90e01ddd36dca1",
      "in_reply_to_id": 2102062249,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> To be clear, Cluster::IsOversized() returns whether the Cluster is oversized in general. \r\n\r\nhuh, I missed thanks for the clarity.\r\nI think you can add this comment as well  or anything that would make this explicit and clearer will be appreciated.\r\n",
      "created_at": "2025-05-22T20:42:31Z",
      "updated_at": "2025-05-22T20:42:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2103368896",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103368896"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103574633",
      "pull_request_review_id": 2862840277,
      "id": 2103574633,
      "node_id": "PRRC_kwDOABII5859YgBp",
      "diff_hunk": "@@ -101,6 +104,9 @@ class Cluster\n     {\n         return m_quality == QualityLevel::OPTIMAL;\n     }\n+    /** Whether this cluster is oversized (just due to the size of its transaction(s), not due to\n+     *  dependencies that are yet to be added. */\n+    bool IsOversized() const noexcept { return m_quality == QualityLevel::OVERSIZED_SINGLETON; }",
      "path": "src/txgraph.cpp",
      "position": 65,
      "original_position": 16,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "bd95322455693649b4fb3a776e90e01ddd36dca1",
      "in_reply_to_id": 2102062249,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Expanded the comment to say that.",
      "created_at": "2025-05-22T23:50:00Z",
      "updated_at": "2025-05-22T23:50:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2103574633",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103574633"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105046798",
      "pull_request_review_id": 2854383890,
      "id": 2105046798,
      "node_id": "PRRC_kwDOABII5859eHcO",
      "diff_hunk": "@@ -391,12 +401,12 @@ FUZZ_TARGET(txgraph)\n                 if (alt) {\n                     // If alt is true, pick fee and size from the entire range.\n                     fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n-                    size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+                    size = provider.ConsumeIntegralInRange<int32_t>(1, max_tx_size);\n                 } else {\n                     // Otherwise, use smaller range which consume fewer fuzz input bytes, as just\n                     // these are likely sufficient to trigger all interesting code paths already.\n                     fee = provider.ConsumeIntegral<uint8_t>();\n-                    size = provider.ConsumeIntegral<uint8_t>() + 1;\n+                    size = provider.ConsumeIntegralInRange<uint32_t>(1, std::min<uint32_t>(0xff, max_tx_size));",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 54,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "462429bc159b1b5ddb5443c484c9bdeae985ad26",
      "in_reply_to_id": 2089151874,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "comments appear clear enough now",
      "created_at": "2025-05-23T16:59:55Z",
      "updated_at": "2025-05-27T14:46:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2105046798",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105046798"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 409,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105047787",
      "pull_request_review_id": 2854383890,
      "id": 2105047787,
      "node_id": "PRRC_kwDOABII5859eHrr",
      "diff_hunk": "@@ -2646,6 +2668,38 @@ std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n         return a->m_chunk_feerate < b->m_chunk_feerate;\n     };\n \n+    /** Given a TrimTxData entry, find the representative of the partition it is in. */\n+    static constexpr auto find_fn = [](TrimTxData* arg) noexcept {\n+        while (arg != arg->m_uf_parent) {\n+            // Replace pointer to parent with pointer to grandparent (path splitting).\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+            auto par = arg->m_uf_parent;\n+            arg->m_uf_parent = par->m_uf_parent;\n+            arg = par;\n+        }\n+        return arg;\n+    };\n+\n+    /** Given two TrimTxData entries, union the partitions they are in, and return the\n+     *  representative. */\n+    static constexpr auto union_fn = [](TrimTxData* arg1, TrimTxData* arg2) noexcept {\n+        // Replace arg1 and arg2 by their representatives.\n+        auto rep1 = find_fn(arg1);\n+        auto rep2 = find_fn(arg2);\n+        // Bail out if both representatives are the same, because that means arg1 and arg2 are in\n+        // the same partition already.\n+        if (rep1 == rep2) return rep1;",
      "path": "src/txgraph.cpp",
      "position": 532,
      "original_position": 87,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "acb2b6a90a47567773268a024bcf2f1ddfcc60df",
      "in_reply_to_id": 2089767602,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "curious. Coverage report may be off.",
      "created_at": "2025-05-23T17:00:20Z",
      "updated_at": "2025-05-27T14:46:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2105047787",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105047787"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2684,
      "original_line": 2684,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105065998",
      "pull_request_review_id": 2854383890,
      "id": 2105065998,
      "node_id": "PRRC_kwDOABII5859eMIO",
      "diff_hunk": "@@ -240,8 +240,9 @@ class TxGraph\n     };\n };\n \n-/** Construct a new TxGraph with the specified limit on transactions within a cluster. That\n- *  number cannot exceed MAX_CLUSTER_COUNT_LIMIT. */\n-std::unique_ptr<TxGraph> MakeTxGraph(unsigned max_cluster_count) noexcept;\n+/** Construct a new TxGraph with the specified limit on the number of transactions within a cluster,\n+ *  and on the sum of transaction sizes within a cluster. max_cluster_count cannot exceed\n+ *  MAX_CLUSTER_COUNT_LIMIT. */",
      "path": "src/txgraph.h",
      "position": 36,
      "original_position": 24,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0e59c73288883c7993b542ac8c6c5832dfe760bd",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nano-nit while we're driving by: max_cluster_count should be > 0",
      "created_at": "2025-05-23T17:07:07Z",
      "updated_at": "2025-05-27T14:46:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2105065998",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105065998"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 250,
      "original_line": 250,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2109371814",
      "pull_request_review_id": 2854383890,
      "id": 2109371814,
      "node_id": "PRRC_kwDOABII5859unWm",
      "diff_hunk": "@@ -838,7 +855,10 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n void Cluster::Clear(TxGraphImpl& graph) noexcept\n {\n     for (auto i : m_linearization) {\n-        graph.ClearLocator(m_level, m_mapping[i]);\n+        // We do not care about setting oversized_tx accurately here, because this function is only\n+        // applied to main-graph Clusters in CommitStaging, which will overwrite main's\n+        // m_txcount_oversized anyway with the staging graph's value.\n+        graph.ClearLocator(m_level, m_mapping[i], /*oversized_tx=*/false);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 100,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": 2089255284,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "much better thanks",
      "created_at": "2025-05-27T14:33:32Z",
      "updated_at": "2025-05-27T14:46:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2109371814",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2109371814"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 861,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2109372231",
      "pull_request_review_id": 2854383890,
      "id": 2109372231,
      "node_id": "PRRC_kwDOABII5859undH",
      "diff_hunk": "@@ -838,7 +855,10 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n void Cluster::Clear(TxGraphImpl& graph) noexcept\n {\n     for (auto i : m_linearization) {\n-        graph.ClearLocator(m_level, m_mapping[i]);\n+        // We do not care about setting oversized_tx accurately here, because this function is only",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 97,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "439ccf713b8f9de1dff1d02678bb68d0f29ea175",
      "in_reply_to_id": 2095835261,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "better thanks",
      "created_at": "2025-05-27T14:33:42Z",
      "updated_at": "2025-05-27T14:46:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2109372231",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2109372231"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 858,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2109385109",
      "pull_request_review_id": 2854383890,
      "id": 2109385109,
      "node_id": "PRRC_kwDOABII5859uqmV",
      "diff_hunk": "@@ -2466,6 +2595,249 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    Assume(clusterset.m_oversized.has_value());\n+    if (clusterset.m_oversized == false) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. Along the\n+    // way, the counts and sizes of the would-be clusters up to that point are tracked (by\n+    // partitioning the involved transactions using a union-find structure). Any transaction whose\n+    // addition would cause a violation is removed, along with all their descendants.\n+    //\n+    // A next invocation of GroupClusters (after applying the removals) will compute the new\n+    // resulting clusters, and none of them will violate the limits.\n+\n+    /** All dependencies (both to be added ones, and implicit ones between consecutive transactions\n+     *  in existing cluster linearizations), sorted by parent. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps_by_parent;\n+    /** Same, but sorted by child. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps_by_child;\n+    /** Information about all transactions involved in a Cluster group to be trimmed, sorted by\n+     *  GraphIndex. */\n+    std::vector<TrimTxData> trim_data;\n+    /** Iterators into trim_data, treated as a max heap according to cmp_fn below. */\n+    std::vector<std::vector<TrimTxData>::iterator> trim_heap;\n+    /** The list of representatives of the partitions a given transaction depends on. */\n+    std::vector<TrimTxData*> current_deps;\n+\n+    /** Function to define the ordering of trim_heap. */\n+    static constexpr auto cmp_fn = [](auto a, auto b) noexcept {\n+        // Sort by increasing chunk feerate, and then by decreasing size.\n+        // We do not need to sort by cluster or within clusters, because due to the implicit\n+        // dependency between consecutive linearization elements, no two transactions from the\n+        // same Cluster will ever simultaneously be in the heap.\n+        return a->m_chunk_feerate < b->m_chunk_feerate;\n+    };\n+\n+    /** Given a TrimTxData entry, find the representative of the partition it is in. */\n+    static constexpr auto find_fn = [](TrimTxData* arg) noexcept {\n+        while (arg != arg->m_uf_parent) {\n+            // Replace pointer to parent with pointer to grandparent (path splitting).\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+            auto par = arg->m_uf_parent;\n+            arg->m_uf_parent = par->m_uf_parent;\n+            arg = par;\n+        }\n+        return arg;\n+    };\n+\n+    /** Given two TrimTxData entries, union the partitions they are in, and return the\n+     *  representative. */\n+    static constexpr auto union_fn = [](TrimTxData* arg1, TrimTxData* arg2) noexcept {\n+        // Replace arg1 and arg2 by their representatives.\n+        auto rep1 = find_fn(arg1);\n+        auto rep2 = find_fn(arg2);\n+        // Bail out if both representatives are the same, because that means arg1 and arg2 are in\n+        // the same partition already.\n+        if (rep1 == rep2) return rep1;\n+        // Pick the lower-count root to become a child of the higher-count one.\n+        // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_size.\n+        if (rep1->m_uf_count < rep2->m_uf_count) std::swap(rep1, rep2);\n+        rep2->m_uf_parent = rep1;\n+        // Add the statistics of arg2 (which is no longer a representative) to those of arg1 (which\n+        // is now the representative for both).\n+        rep1->m_uf_size += rep2->m_uf_size;\n+        rep1->m_uf_count += rep2->m_uf_count;\n+        return rep1;\n+    };\n+\n+    /** Get iterator to TrimTxData entry for a given index. */\n+    auto locate_fn = [&](GraphIndex index) noexcept {\n+        auto it = std::lower_bound(trim_data.begin(), trim_data.end(), index, [](TrimTxData& elem, GraphIndex idx) noexcept {\n+            return elem.m_index < idx;\n+        });\n+        Assume(it != trim_data.end() && it->m_index == index);\n+        return it;\n+    };\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        trim_data.clear();\n+        trim_heap.clear();\n+        deps_by_child.clear();\n+        deps_by_parent.clear();\n+\n+        // Gather trim data from all involved Clusters.\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        uint64_t size{0};\n+        for (Cluster* cluster : cluster_span) {\n+            size += cluster->AppendTrimData(trim_data, deps_by_child);\n+        }\n+        // If this group of Clusters does not violate any limits, continue to the next group.\n+        if (trim_data.size() <= m_max_cluster_count && size <= m_max_cluster_size) continue;\n+        // Sort the trim data by GraphIndex. In what follows, we will treat this sorted vector as\n+        // a map from GraphIndex to TrimTxData, and its ordering will not change anymore.\n+        std::sort(trim_data.begin(), trim_data.end(), [](auto& a, auto& b) noexcept { return a.m_index < b.m_index; });\n+\n+        // Construct deps_by_child.\n+        deps_by_child.insert(deps_by_child.end(),\n+                             clusterset.m_deps_to_add.begin() + group_data.m_deps_offset,\n+                             clusterset.m_deps_to_add.begin() + group_data.m_deps_offset + group_data.m_deps_count);\n+        std::sort(deps_by_child.begin(), deps_by_child.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+        // Fill m_parents_count and m_parents_offset in trim_data. Because of the sort above, all\n+        // dependencies involving the same child are grouped together, so a single linear scan\n+        // suffices.\n+        auto deps_it = deps_by_child.begin();\n+        for (auto trim_it = trim_data.begin(); trim_it != trim_data.end(); ++trim_it) {\n+            trim_it->m_parent_offset = deps_it - deps_by_child.begin();\n+            trim_it->m_deps_left = 0;\n+            while (deps_it != deps_by_child.end() && deps_it->second == trim_it->m_index) {\n+                ++trim_it->m_deps_left;\n+                ++deps_it;\n+            }\n+            trim_it->m_parent_count = trim_it->m_deps_left;\n+            // If this transaction has no unmet dependencies, and is not oversized, add it to the\n+            // heap (just append for now, the heapification happens below).\n+            if (trim_it->m_deps_left == 0 && trim_it->m_tx_size <= m_max_cluster_size) {\n+                // Initialize it as a singleton partition.\n+                trim_it->m_uf_parent = &*trim_it;\n+                trim_it->m_uf_count = 1;\n+                trim_it->m_uf_size = trim_it->m_tx_size;\n+                // Add to heap.\n+                trim_heap.push_back(trim_it);\n+            }\n+        }\n+        Assume(deps_it == deps_by_child.end());\n+\n+        // Construct deps_by_parent.\n+        deps_by_parent = deps_by_child;\n+        std::sort(deps_by_parent.begin(), deps_by_parent.end(), [](auto& a, auto& b) noexcept { return a.first < b.first; });\n+        // Fill m_children_offset and m_children_count in trim_data. Because of the sort above, all\n+        // dependencies involving the same parent are grouped together, so a single linear scan\n+        // suffices.\n+        deps_it = deps_by_parent.begin();\n+        for (auto& trim_entry : trim_data) {\n+            trim_entry.m_children_count = 0;\n+            trim_entry.m_children_offset = deps_it - deps_by_parent.begin();\n+            while (deps_it != deps_by_parent.end() && deps_it->first == trim_entry.m_index) {\n+                ++trim_entry.m_children_count;\n+                ++deps_it;\n+            }\n+        }\n+        Assume(deps_it == deps_by_parent.end());\n+\n+        // Build a heap of all transactions with 0 unmet dependencies.\n+        std::make_heap(trim_heap.begin(), trim_heap.end(), cmp_fn);\n+\n+        // Iterate over to-be-included transactions. It is possible that the heap empties without",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 614,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "538e9ff804f8dfba6f6a808e83572fdeab145ab8",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/instagibbs/bitcoin/tree/2025-05-applytrim\r\n\r\nWorked on a test attempts to cover the claim here. It ended up being more complicated than that (claim a bit wrong?) due to the lazy application of dependencies. For this property to hold, I believe you have to touch the TxGraph in any way that applies dependencies when undersized, *then* transition to oversized graph for the circular dependencies to not occur in the implied graph.\r\n\r\nWithout the dependencies applied, the linearization order can be \"nonsensical\", which then creates a contradictory dependency, iow cycle. This cycle ends up dropping sometimes the entire cluster ala\r\n\r\n`EhBGLQYGhDOENwYAr6+vr682AAYAAHoAAAAAAEr/EIQGBi0GBoQ0BjYQLUYGBoQzAEAzhAYGhDcG\r\nADIABgAAMwAAMQCEBgY=`\r\n\r\nThis can be tested by commenting out the `CountDistinctClusters` invocation in the new test. \r\n\r\nThe good news is this usage pattern is \"natural\", so in practice each new transaction (package) will have a TxGraph with all dependencies applied except for the new package. It's just weird and I'm unsure how to do better. Perhaps Trim could pre-emptively apply dependencies + FixLinearization for each grouped cluster.\r\n\r\nIn this graph, T2 is the implied parent of T1 thanks to to-be-applied dependencies not being applied yet, causing the trim heap to never get an entry:\r\n![image](https://github.com/user-attachments/assets/cbcbcba2-0791-4f8d-b21b-dc2b3d941be2)\r\n",
      "created_at": "2025-05-27T14:39:03Z",
      "updated_at": "2025-05-27T14:50:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2109385109",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2109385109"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2776,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110817020",
      "pull_request_review_id": 2873447422,
      "id": 2110817020,
      "node_id": "PRRC_kwDOABII58590IL8",
      "diff_hunk": "@@ -886,6 +908,37 @@ void Cluster::AppendChunkFeerates(std::vector<FeeFrac>& ret) const noexcept\n     ret.insert(ret.end(), chunk_feerates.begin(), chunk_feerates.end());\n }\n \n+uint64_t Cluster::AppendTrimData(std::vector<TrimTxData>& ret, std::vector<std::pair<GraphIndex, GraphIndex>>& deps) const noexcept\n+{\n+    LinearizationChunking linchunking(m_depgraph, m_linearization);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 49,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": 2098113781,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-05-28T03:33:02Z",
      "updated_at": "2025-05-28T03:33:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2110817020",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110817020"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 919,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110819198",
      "pull_request_review_id": 2873451151,
      "id": 2110819198,
      "node_id": "PRRC_kwDOABII58590It-",
      "diff_hunk": "@@ -2542,6 +2595,183 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    if (!clusterset.m_group_data->m_group_oversized) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. This\n+    // continues as long the number or size of all picked transactions together does not exceed the\n+    // graph's configured cluster limits. All remaining transactions are then marked as removed.\n+    //\n+    // A next invocation of GroupClusters (after applying the removals) will compute the new\n+    // resulting clusters, and none of them will violate the limits.\n+\n+    /** All dependencies (both to be added ones, and implicit ones between consecutive transactions\n+     *  in existing cluster linearizations). */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps;\n+    /** Information about all transactions involved in a Cluster group to be trimmed, sorted by\n+     *  GraphIndex. */\n+    std::vector<TrimTxData> trim_data;\n+    /** Iterators into trim_data, treated as a max heap according to cmp_fn below. */\n+    std::vector<std::vector<TrimTxData>::iterator> trim_heap;\n+\n+    /** Function to define the ordering of trim_heap. */\n+    static constexpr auto cmp_fn = [](auto a, auto b) noexcept {\n+        // Sort by increasing chunk feerate, and then by decreasing size.\n+        // We do not need to sort by cluster or within clusters, because due to the implicit\n+        // dependency between consecutive linearization elements, no two transactions from the\n+        // same Cluster will ever simultaneously be in the heap.\n+        return a->m_chunk_feerate < b->m_chunk_feerate;\n+    };\n+\n+    /** Get iterator to TrimTxData entry for a given index. */\n+    auto locate_fn = [&](GraphIndex index) noexcept {\n+        auto it = std::lower_bound(trim_data.begin(), trim_data.end(), index, [](TrimTxData& elem, GraphIndex idx) noexcept {\n+            return elem.m_index < idx;\n+        });\n+        Assume(it != trim_data.end() && it->m_index == index);\n+        return it;\n+    };\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        trim_data.clear();\n+        trim_heap.clear();\n+        deps.clear();\n+\n+        // Gather trim data from all involved Clusters.\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        uint64_t size{0};\n+        for (Cluster* cluster : cluster_span) {\n+            size += cluster->AppendTrimData(trim_data, deps);\n+        }\n+        // If this group of Clusters does not violate any limits, continue to the next group.\n+        if (trim_data.size() <= m_max_cluster_count && size <= m_max_cluster_size) continue;\n+        // Sort the trim data by GraphIndex. In what follows, we will treat this sorted vector as\n+        // a map from GraphIndex to TrimTxData, and its ordering will not change anymore.\n+        std::sort(trim_data.begin(), trim_data.end(), [](auto& a, auto& b) noexcept { return a.m_index < b.m_index; });\n+\n+        // Construct deps, and sort it by child.\n+        deps.insert(deps.end(),\n+                    clusterset.m_deps_to_add.begin() + group_data.m_deps_offset,\n+                    clusterset.m_deps_to_add.begin() + group_data.m_deps_offset + group_data.m_deps_count);\n+        std::sort(deps.begin(), deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+        // Fill m_deps_left in trim_data. Because of the sort above, all\n+        // dependencies involving the same child are grouped together, so a single linear scan\n+        // suffices.\n+        auto deps_it = deps.begin();\n+        for (auto trim_it = trim_data.begin(); trim_it != trim_data.end(); ++trim_it) {\n+            trim_it->m_deps_left = 0;\n+            while (deps_it != deps.end() && deps_it->second == trim_it->m_index) {\n+                ++trim_it->m_deps_left;\n+                ++deps_it;\n+            }\n+            // If this transaction has no unmet dependencies, and is not oversized, add it to the\n+            // heap (just append for now, the heapification happens below).\n+            if (trim_it->m_deps_left == 0 && trim_it->m_tx_size <= m_max_cluster_size) {\n+                trim_heap.push_back(trim_it);\n+            }\n+        }\n+        Assume(deps_it == deps.end());\n+\n+        // Sort deps by parent.\n+        std::sort(deps.begin(), deps.end(), [](auto& a, auto& b) noexcept { return a.first < b.first; });\n+        // Fill m_children_offset and m_children_count in trim_data. Because of the sort above, all\n+        // dependencies involving the same parent are grouped together, so a single linear scan\n+        // suffices.\n+        deps_it = deps.begin();\n+        for (auto& trim_entry : trim_data) {\n+            trim_entry.m_children_count = 0;\n+            trim_entry.m_children_offset = deps_it - deps.begin();\n+            while (deps_it != deps.end() && deps_it->first == trim_entry.m_index) {\n+                ++trim_entry.m_children_count;\n+                ++deps_it;\n+            }\n+        }\n+        Assume(deps_it == deps.end());\n+\n+        // Build a heap of all transactions with 0 unmet dependencies.\n+        std::make_heap(trim_heap.begin(), trim_heap.end(), cmp_fn);\n+\n+        // Iterate over to-be-included transactions. It is possible that the heap empties without\n+        // ever hitting either cluster limit, in case the implied graph (to be added dependencies\n+        // plus implicit dependency between each original transaction and its predecessor in the\n+        // linearization it came from) contains cycles. Such cycles will be removed entirely,\n+        // because each of the transactions in the cycle permanently have unmet dependencies.\n+        // However, this cannot occur in real scenarios where Trim() is called to deal with\n+        // reorganizations that would violate cluster limits, as all added dependencies are in the\n+        // same direction (from old mempool transactions to new from-block transactions); cycles\n+        // require dependencies in both directions to be added.\n+        uint32_t total_count{0};\n+        uint64_t total_size{0};\n+        while (!trim_heap.empty()) {\n+            // Move the best remaining transaction to the end of trim_heap.\n+            std::pop_heap(trim_heap.begin(), trim_heap.end(), cmp_fn);\n+            // Pop it, and find its TrimTxData.\n+            auto& entry = *trim_heap.back();\n+            trim_heap.pop_back();\n+\n+            // Compute resource counts.\n+            total_count += 1;\n+            total_size += entry.m_tx_size;\n+            // Stop if this would violate any limit.\n+            if (total_count > m_max_cluster_count || total_size > m_max_cluster_size) break;\n+\n+            // Mark the entry as included (so the loop below will not remove the transaction).\n+            entry.m_deps_left = uint32_t(-1);\n+            // Mark each to-be-added dependency involving this transaction as parent satisfied.\n+            for (auto& [par, chl] : std::span{deps}.subspan(entry.m_children_offset, entry.m_children_count)) {\n+                Assume(par == entry.m_index);\n+                auto chl_it = locate_fn(chl);\n+                // Reduce the number of unmet dependencies of chl_it, and if that brings the number\n+                // to zero, add it to the heap.\n+                Assume(chl_it->m_deps_left > 0);\n+                if (--chl_it->m_deps_left == 0) {\n+                    trim_heap.push_back(chl_it);\n+                    std::push_heap(trim_heap.begin(), trim_heap.end(), cmp_fn);\n+                }\n+            }\n+        }\n+\n+        // Remove all the transactions that were not processed above. Because nothing gets\n+        // processed until/unless all its dependencies are met, this automatically guarantees\n+        // that if a transaction is removed, all its descendants, or would-be descendants, are\n+        // removed as well.\n+        for (const auto& trim_entry : trim_data) {\n+            if (trim_entry.m_deps_left != uint32_t(-1)) {\n+                ret.push_back(m_entries[trim_entry.m_index].m_ref);\n+                clusterset.m_to_remove.push_back(trim_entry.m_index);\n+            }\n+        }\n+    }\n+    clusterset.m_group_data.reset();\n+    clusterset.m_oversized = false;\n+    return ret;",
      "path": "src/txgraph.cpp",
      "position": 699,
      "original_position": 259,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": 2098308679,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-05-28T03:35:00Z",
      "updated_at": "2025-05-28T03:39:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2110819198",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110819198"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2851,
      "original_line": 2851,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110820382",
      "pull_request_review_id": 2873451151,
      "id": 2110820382,
      "node_id": "PRRC_kwDOABII58590JAe",
      "diff_hunk": "@@ -2466,6 +2595,249 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    Assume(clusterset.m_oversized.has_value());\n+    if (clusterset.m_oversized == false) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. Along the\n+    // way, the counts and sizes of the would-be clusters up to that point are tracked (by\n+    // partitioning the involved transactions using a union-find structure). Any transaction whose\n+    // addition would cause a violation is removed, along with all their descendants.\n+    //\n+    // A next invocation of GroupClusters (after applying the removals) will compute the new\n+    // resulting clusters, and none of them will violate the limits.\n+\n+    /** All dependencies (both to be added ones, and implicit ones between consecutive transactions\n+     *  in existing cluster linearizations), sorted by parent. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps_by_parent;\n+    /** Same, but sorted by child. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps_by_child;\n+    /** Information about all transactions involved in a Cluster group to be trimmed, sorted by\n+     *  GraphIndex. */\n+    std::vector<TrimTxData> trim_data;\n+    /** Iterators into trim_data, treated as a max heap according to cmp_fn below. */\n+    std::vector<std::vector<TrimTxData>::iterator> trim_heap;\n+    /** The list of representatives of the partitions a given transaction depends on. */\n+    std::vector<TrimTxData*> current_deps;\n+\n+    /** Function to define the ordering of trim_heap. */\n+    static constexpr auto cmp_fn = [](auto a, auto b) noexcept {\n+        // Sort by increasing chunk feerate, and then by decreasing size.\n+        // We do not need to sort by cluster or within clusters, because due to the implicit\n+        // dependency between consecutive linearization elements, no two transactions from the\n+        // same Cluster will ever simultaneously be in the heap.\n+        return a->m_chunk_feerate < b->m_chunk_feerate;\n+    };\n+\n+    /** Given a TrimTxData entry, find the representative of the partition it is in. */\n+    static constexpr auto find_fn = [](TrimTxData* arg) noexcept {\n+        while (arg != arg->m_uf_parent) {\n+            // Replace pointer to parent with pointer to grandparent (path splitting).\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+            auto par = arg->m_uf_parent;\n+            arg->m_uf_parent = par->m_uf_parent;\n+            arg = par;\n+        }\n+        return arg;\n+    };\n+\n+    /** Given two TrimTxData entries, union the partitions they are in, and return the\n+     *  representative. */\n+    static constexpr auto union_fn = [](TrimTxData* arg1, TrimTxData* arg2) noexcept {\n+        // Replace arg1 and arg2 by their representatives.\n+        auto rep1 = find_fn(arg1);\n+        auto rep2 = find_fn(arg2);\n+        // Bail out if both representatives are the same, because that means arg1 and arg2 are in\n+        // the same partition already.\n+        if (rep1 == rep2) return rep1;\n+        // Pick the lower-count root to become a child of the higher-count one.\n+        // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_size.\n+        if (rep1->m_uf_count < rep2->m_uf_count) std::swap(rep1, rep2);\n+        rep2->m_uf_parent = rep1;\n+        // Add the statistics of arg2 (which is no longer a representative) to those of arg1 (which\n+        // is now the representative for both).\n+        rep1->m_uf_size += rep2->m_uf_size;\n+        rep1->m_uf_count += rep2->m_uf_count;\n+        return rep1;\n+    };\n+\n+    /** Get iterator to TrimTxData entry for a given index. */\n+    auto locate_fn = [&](GraphIndex index) noexcept {\n+        auto it = std::lower_bound(trim_data.begin(), trim_data.end(), index, [](TrimTxData& elem, GraphIndex idx) noexcept {\n+            return elem.m_index < idx;\n+        });\n+        Assume(it != trim_data.end() && it->m_index == index);\n+        return it;\n+    };\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        trim_data.clear();\n+        trim_heap.clear();\n+        deps_by_child.clear();\n+        deps_by_parent.clear();\n+\n+        // Gather trim data from all involved Clusters.\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        uint64_t size{0};\n+        for (Cluster* cluster : cluster_span) {\n+            size += cluster->AppendTrimData(trim_data, deps_by_child);\n+        }\n+        // If this group of Clusters does not violate any limits, continue to the next group.\n+        if (trim_data.size() <= m_max_cluster_count && size <= m_max_cluster_size) continue;\n+        // Sort the trim data by GraphIndex. In what follows, we will treat this sorted vector as\n+        // a map from GraphIndex to TrimTxData, and its ordering will not change anymore.\n+        std::sort(trim_data.begin(), trim_data.end(), [](auto& a, auto& b) noexcept { return a.m_index < b.m_index; });\n+\n+        // Construct deps_by_child.\n+        deps_by_child.insert(deps_by_child.end(),\n+                             clusterset.m_deps_to_add.begin() + group_data.m_deps_offset,\n+                             clusterset.m_deps_to_add.begin() + group_data.m_deps_offset + group_data.m_deps_count);\n+        std::sort(deps_by_child.begin(), deps_by_child.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+        // Fill m_parents_count and m_parents_offset in trim_data. Because of the sort above, all\n+        // dependencies involving the same child are grouped together, so a single linear scan\n+        // suffices.\n+        auto deps_it = deps_by_child.begin();\n+        for (auto trim_it = trim_data.begin(); trim_it != trim_data.end(); ++trim_it) {\n+            trim_it->m_parent_offset = deps_it - deps_by_child.begin();\n+            trim_it->m_deps_left = 0;\n+            while (deps_it != deps_by_child.end() && deps_it->second == trim_it->m_index) {\n+                ++trim_it->m_deps_left;\n+                ++deps_it;\n+            }\n+            trim_it->m_parent_count = trim_it->m_deps_left;\n+            // If this transaction has no unmet dependencies, and is not oversized, add it to the\n+            // heap (just append for now, the heapification happens below).\n+            if (trim_it->m_deps_left == 0 && trim_it->m_tx_size <= m_max_cluster_size) {\n+                // Initialize it as a singleton partition.\n+                trim_it->m_uf_parent = &*trim_it;\n+                trim_it->m_uf_count = 1;\n+                trim_it->m_uf_size = trim_it->m_tx_size;\n+                // Add to heap.\n+                trim_heap.push_back(trim_it);\n+            }\n+        }\n+        Assume(deps_it == deps_by_child.end());\n+\n+        // Construct deps_by_parent.\n+        deps_by_parent = deps_by_child;\n+        std::sort(deps_by_parent.begin(), deps_by_parent.end(), [](auto& a, auto& b) noexcept { return a.first < b.first; });\n+        // Fill m_children_offset and m_children_count in trim_data. Because of the sort above, all\n+        // dependencies involving the same parent are grouped together, so a single linear scan\n+        // suffices.\n+        deps_it = deps_by_parent.begin();\n+        for (auto& trim_entry : trim_data) {\n+            trim_entry.m_children_count = 0;\n+            trim_entry.m_children_offset = deps_it - deps_by_parent.begin();\n+            while (deps_it != deps_by_parent.end() && deps_it->first == trim_entry.m_index) {\n+                ++trim_entry.m_children_count;\n+                ++deps_it;\n+            }\n+        }\n+        Assume(deps_it == deps_by_parent.end());\n+\n+        // Build a heap of all transactions with 0 unmet dependencies.\n+        std::make_heap(trim_heap.begin(), trim_heap.end(), cmp_fn);\n+\n+        // Iterate over to-be-included transactions. It is possible that the heap empties without",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 614,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "538e9ff804f8dfba6f6a808e83572fdeab145ab8",
      "in_reply_to_id": 2109385109,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've written a test based on this, which randomly adds dependencies but in a \"directed\" sense that never introduces cycles (rather than just has 2 specific scenarios).",
      "created_at": "2025-05-28T03:36:28Z",
      "updated_at": "2025-05-28T03:39:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2110820382",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110820382"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2776,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110820614",
      "pull_request_review_id": 2873451151,
      "id": 2110820614,
      "node_id": "PRRC_kwDOABII58590JEG",
      "diff_hunk": "@@ -240,8 +240,9 @@ class TxGraph\n     };\n };\n \n-/** Construct a new TxGraph with the specified limit on transactions within a cluster. That\n- *  number cannot exceed MAX_CLUSTER_COUNT_LIMIT. */\n-std::unique_ptr<TxGraph> MakeTxGraph(unsigned max_cluster_count) noexcept;\n+/** Construct a new TxGraph with the specified limit on the number of transactions within a cluster,\n+ *  and on the sum of transaction sizes within a cluster. max_cluster_count cannot exceed\n+ *  MAX_CLUSTER_COUNT_LIMIT. */",
      "path": "src/txgraph.h",
      "position": 36,
      "original_position": 24,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "0e59c73288883c7993b542ac8c6c5832dfe760bd",
      "in_reply_to_id": 2105065998,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Forgot to take this. Will leave open for now.",
      "created_at": "2025-05-28T03:36:46Z",
      "updated_at": "2025-05-28T03:39:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2110820614",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110820614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 250,
      "original_line": 250,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110820744",
      "pull_request_review_id": 2873451151,
      "id": 2110820744,
      "node_id": "PRRC_kwDOABII58590JGI",
      "diff_hunk": "@@ -2542,6 +2595,183 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    if (!clusterset.m_group_data->m_group_oversized) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. This\n+    // continues as long the number or size of all picked transactions together does not exceed the\n+    // graph's configured cluster limits. All remaining transactions are then marked as removed.\n+    //\n+    // A next invocation of GroupClusters (after applying the removals) will compute the new\n+    // resulting clusters, and none of them will violate the limits.\n+\n+    /** All dependencies (both to be added ones, and implicit ones between consecutive transactions\n+     *  in existing cluster linearizations). */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps;\n+    /** Information about all transactions involved in a Cluster group to be trimmed, sorted by\n+     *  GraphIndex. */\n+    std::vector<TrimTxData> trim_data;\n+    /** Iterators into trim_data, treated as a max heap according to cmp_fn below. */\n+    std::vector<std::vector<TrimTxData>::iterator> trim_heap;\n+\n+    /** Function to define the ordering of trim_heap. */\n+    static constexpr auto cmp_fn = [](auto a, auto b) noexcept {\n+        // Sort by increasing chunk feerate, and then by decreasing size.\n+        // We do not need to sort by cluster or within clusters, because due to the implicit\n+        // dependency between consecutive linearization elements, no two transactions from the\n+        // same Cluster will ever simultaneously be in the heap.\n+        return a->m_chunk_feerate < b->m_chunk_feerate;\n+    };\n+\n+    /** Get iterator to TrimTxData entry for a given index. */\n+    auto locate_fn = [&](GraphIndex index) noexcept {\n+        auto it = std::lower_bound(trim_data.begin(), trim_data.end(), index, [](TrimTxData& elem, GraphIndex idx) noexcept {\n+            return elem.m_index < idx;\n+        });\n+        Assume(it != trim_data.end() && it->m_index == index);\n+        return it;\n+    };\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        trim_data.clear();\n+        trim_heap.clear();\n+        deps.clear();\n+\n+        // Gather trim data from all involved Clusters.\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        uint64_t size{0};\n+        for (Cluster* cluster : cluster_span) {\n+            size += cluster->AppendTrimData(trim_data, deps);\n+        }\n+        // If this group of Clusters does not violate any limits, continue to the next group.\n+        if (trim_data.size() <= m_max_cluster_count && size <= m_max_cluster_size) continue;\n+        // Sort the trim data by GraphIndex. In what follows, we will treat this sorted vector as\n+        // a map from GraphIndex to TrimTxData, and its ordering will not change anymore.\n+        std::sort(trim_data.begin(), trim_data.end(), [](auto& a, auto& b) noexcept { return a.m_index < b.m_index; });\n+\n+        // Construct deps, and sort it by child.\n+        deps.insert(deps.end(),\n+                    clusterset.m_deps_to_add.begin() + group_data.m_deps_offset,\n+                    clusterset.m_deps_to_add.begin() + group_data.m_deps_offset + group_data.m_deps_count);\n+        std::sort(deps.begin(), deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+        // Fill m_deps_left in trim_data. Because of the sort above, all\n+        // dependencies involving the same child are grouped together, so a single linear scan\n+        // suffices.\n+        auto deps_it = deps.begin();\n+        for (auto trim_it = trim_data.begin(); trim_it != trim_data.end(); ++trim_it) {\n+            trim_it->m_deps_left = 0;\n+            while (deps_it != deps.end() && deps_it->second == trim_it->m_index) {\n+                ++trim_it->m_deps_left;\n+                ++deps_it;\n+            }\n+            // If this transaction has no unmet dependencies, and is not oversized, add it to the\n+            // heap (just append for now, the heapification happens below).\n+            if (trim_it->m_deps_left == 0 && trim_it->m_tx_size <= m_max_cluster_size) {\n+                trim_heap.push_back(trim_it);\n+            }\n+        }\n+        Assume(deps_it == deps.end());\n+\n+        // Sort deps by parent.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 187,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": 2098254652,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-05-28T03:36:56Z",
      "updated_at": "2025-05-28T03:39:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2110820744",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110820744"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2700,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110820827",
      "pull_request_review_id": 2873451151,
      "id": 2110820827,
      "node_id": "PRRC_kwDOABII58590JHb",
      "diff_hunk": "@@ -2542,6 +2595,183 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    if (!clusterset.m_group_data->m_group_oversized) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. This\n+    // continues as long the number or size of all picked transactions together does not exceed the\n+    // graph's configured cluster limits. All remaining transactions are then marked as removed.\n+    //\n+    // A next invocation of GroupClusters (after applying the removals) will compute the new\n+    // resulting clusters, and none of them will violate the limits.\n+\n+    /** All dependencies (both to be added ones, and implicit ones between consecutive transactions\n+     *  in existing cluster linearizations). */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps;\n+    /** Information about all transactions involved in a Cluster group to be trimmed, sorted by\n+     *  GraphIndex. */\n+    std::vector<TrimTxData> trim_data;\n+    /** Iterators into trim_data, treated as a max heap according to cmp_fn below. */\n+    std::vector<std::vector<TrimTxData>::iterator> trim_heap;\n+\n+    /** Function to define the ordering of trim_heap. */\n+    static constexpr auto cmp_fn = [](auto a, auto b) noexcept {\n+        // Sort by increasing chunk feerate, and then by decreasing size.\n+        // We do not need to sort by cluster or within clusters, because due to the implicit\n+        // dependency between consecutive linearization elements, no two transactions from the\n+        // same Cluster will ever simultaneously be in the heap.\n+        return a->m_chunk_feerate < b->m_chunk_feerate;\n+    };\n+\n+    /** Get iterator to TrimTxData entry for a given index. */\n+    auto locate_fn = [&](GraphIndex index) noexcept {\n+        auto it = std::lower_bound(trim_data.begin(), trim_data.end(), index, [](TrimTxData& elem, GraphIndex idx) noexcept {\n+            return elem.m_index < idx;\n+        });\n+        Assume(it != trim_data.end() && it->m_index == index);\n+        return it;\n+    };\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        trim_data.clear();\n+        trim_heap.clear();\n+        deps.clear();\n+\n+        // Gather trim data from all involved Clusters.\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        uint64_t size{0};\n+        for (Cluster* cluster : cluster_span) {\n+            size += cluster->AppendTrimData(trim_data, deps);\n+        }\n+        // If this group of Clusters does not violate any limits, continue to the next group.\n+        if (trim_data.size() <= m_max_cluster_count && size <= m_max_cluster_size) continue;\n+        // Sort the trim data by GraphIndex. In what follows, we will treat this sorted vector as\n+        // a map from GraphIndex to TrimTxData, and its ordering will not change anymore.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 161,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": 2098265434,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-05-28T03:37:02Z",
      "updated_at": "2025-05-28T03:39:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2110820827",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110820827"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2713,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110820886",
      "pull_request_review_id": 2873451151,
      "id": 2110820886,
      "node_id": "PRRC_kwDOABII58590JIW",
      "diff_hunk": "@@ -2542,6 +2595,183 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    if (!clusterset.m_group_data->m_group_oversized) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. This\n+    // continues as long the number or size of all picked transactions together does not exceed the\n+    // graph's configured cluster limits. All remaining transactions are then marked as removed.\n+    //\n+    // A next invocation of GroupClusters (after applying the removals) will compute the new\n+    // resulting clusters, and none of them will violate the limits.\n+\n+    /** All dependencies (both to be added ones, and implicit ones between consecutive transactions\n+     *  in existing cluster linearizations). */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps;\n+    /** Information about all transactions involved in a Cluster group to be trimmed, sorted by\n+     *  GraphIndex. */\n+    std::vector<TrimTxData> trim_data;\n+    /** Iterators into trim_data, treated as a max heap according to cmp_fn below. */\n+    std::vector<std::vector<TrimTxData>::iterator> trim_heap;\n+\n+    /** Function to define the ordering of trim_heap. */\n+    static constexpr auto cmp_fn = [](auto a, auto b) noexcept {\n+        // Sort by increasing chunk feerate, and then by decreasing size.\n+        // We do not need to sort by cluster or within clusters, because due to the implicit\n+        // dependency between consecutive linearization elements, no two transactions from the\n+        // same Cluster will ever simultaneously be in the heap.\n+        return a->m_chunk_feerate < b->m_chunk_feerate;\n+    };\n+\n+    /** Get iterator to TrimTxData entry for a given index. */\n+    auto locate_fn = [&](GraphIndex index) noexcept {\n+        auto it = std::lower_bound(trim_data.begin(), trim_data.end(), index, [](TrimTxData& elem, GraphIndex idx) noexcept {\n+            return elem.m_index < idx;\n+        });\n+        Assume(it != trim_data.end() && it->m_index == index);\n+        return it;\n+    };\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        trim_data.clear();\n+        trim_heap.clear();\n+        deps.clear();\n+\n+        // Gather trim data from all involved Clusters.\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        uint64_t size{0};\n+        for (Cluster* cluster : cluster_span) {\n+            size += cluster->AppendTrimData(trim_data, deps);\n+        }\n+        // If this group of Clusters does not violate any limits, continue to the next group.\n+        if (trim_data.size() <= m_max_cluster_count && size <= m_max_cluster_size) continue;\n+        // Sort the trim data by GraphIndex. In what follows, we will treat this sorted vector as\n+        // a map from GraphIndex to TrimTxData, and its ordering will not change anymore.\n+        std::sort(trim_data.begin(), trim_data.end(), [](auto& a, auto& b) noexcept { return a.m_index < b.m_index; });\n+\n+        // Construct deps, and sort it by child.\n+        deps.insert(deps.end(),\n+                    clusterset.m_deps_to_add.begin() + group_data.m_deps_offset,\n+                    clusterset.m_deps_to_add.begin() + group_data.m_deps_offset + group_data.m_deps_count);\n+        std::sort(deps.begin(), deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+        // Fill m_deps_left in trim_data. Because of the sort above, all",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 169,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": 2098251956,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-05-28T03:37:09Z",
      "updated_at": "2025-05-28T03:39:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2110820886",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110820886"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2682,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110821027",
      "pull_request_review_id": 2873451151,
      "id": 2110821027,
      "node_id": "PRRC_kwDOABII58590JKj",
      "diff_hunk": "@@ -2542,6 +2595,183 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    if (!clusterset.m_group_data->m_group_oversized) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. This\n+    // continues as long the number or size of all picked transactions together does not exceed the\n+    // graph's configured cluster limits. All remaining transactions are then marked as removed.\n+    //\n+    // A next invocation of GroupClusters (after applying the removals) will compute the new\n+    // resulting clusters, and none of them will violate the limits.\n+\n+    /** All dependencies (both to be added ones, and implicit ones between consecutive transactions\n+     *  in existing cluster linearizations). */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps;\n+    /** Information about all transactions involved in a Cluster group to be trimmed, sorted by\n+     *  GraphIndex. */\n+    std::vector<TrimTxData> trim_data;\n+    /** Iterators into trim_data, treated as a max heap according to cmp_fn below. */\n+    std::vector<std::vector<TrimTxData>::iterator> trim_heap;\n+\n+    /** Function to define the ordering of trim_heap. */\n+    static constexpr auto cmp_fn = [](auto a, auto b) noexcept {\n+        // Sort by increasing chunk feerate, and then by decreasing size.\n+        // We do not need to sort by cluster or within clusters, because due to the implicit\n+        // dependency between consecutive linearization elements, no two transactions from the\n+        // same Cluster will ever simultaneously be in the heap.\n+        return a->m_chunk_feerate < b->m_chunk_feerate;\n+    };\n+\n+    /** Get iterator to TrimTxData entry for a given index. */\n+    auto locate_fn = [&](GraphIndex index) noexcept {\n+        auto it = std::lower_bound(trim_data.begin(), trim_data.end(), index, [](TrimTxData& elem, GraphIndex idx) noexcept {\n+            return elem.m_index < idx;\n+        });\n+        Assume(it != trim_data.end() && it->m_index == index);\n+        return it;\n+    };\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        trim_data.clear();\n+        trim_heap.clear();\n+        deps.clear();\n+\n+        // Gather trim data from all involved Clusters.\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        uint64_t size{0};\n+        for (Cluster* cluster : cluster_span) {\n+            size += cluster->AppendTrimData(trim_data, deps);\n+        }\n+        // If this group of Clusters does not violate any limits, continue to the next group.\n+        if (trim_data.size() <= m_max_cluster_count && size <= m_max_cluster_size) continue;\n+        // Sort the trim data by GraphIndex. In what follows, we will treat this sorted vector as\n+        // a map from GraphIndex to TrimTxData, and its ordering will not change anymore.\n+        std::sort(trim_data.begin(), trim_data.end(), [](auto& a, auto& b) noexcept { return a.m_index < b.m_index; });\n+\n+        // Construct deps, and sort it by child.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 164,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": 2098240846,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-05-28T03:37:18Z",
      "updated_at": "2025-05-28T03:39:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2110821027",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110821027"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2677,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110821096",
      "pull_request_review_id": 2873451151,
      "id": 2110821096,
      "node_id": "PRRC_kwDOABII58590JLo",
      "diff_hunk": "@@ -2542,6 +2595,183 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    if (!clusterset.m_group_data->m_group_oversized) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. This\n+    // continues as long the number or size of all picked transactions together does not exceed the\n+    // graph's configured cluster limits. All remaining transactions are then marked as removed.\n+    //\n+    // A next invocation of GroupClusters (after applying the removals) will compute the new\n+    // resulting clusters, and none of them will violate the limits.\n+\n+    /** All dependencies (both to be added ones, and implicit ones between consecutive transactions\n+     *  in existing cluster linearizations). */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> deps;\n+    /** Information about all transactions involved in a Cluster group to be trimmed, sorted by\n+     *  GraphIndex. */\n+    std::vector<TrimTxData> trim_data;\n+    /** Iterators into trim_data, treated as a max heap according to cmp_fn below. */\n+    std::vector<std::vector<TrimTxData>::iterator> trim_heap;\n+\n+    /** Function to define the ordering of trim_heap. */\n+    static constexpr auto cmp_fn = [](auto a, auto b) noexcept {\n+        // Sort by increasing chunk feerate, and then by decreasing size.\n+        // We do not need to sort by cluster or within clusters, because due to the implicit\n+        // dependency between consecutive linearization elements, no two transactions from the\n+        // same Cluster will ever simultaneously be in the heap.\n+        return a->m_chunk_feerate < b->m_chunk_feerate;\n+    };\n+\n+    /** Get iterator to TrimTxData entry for a given index. */\n+    auto locate_fn = [&](GraphIndex index) noexcept {\n+        auto it = std::lower_bound(trim_data.begin(), trim_data.end(), index, [](TrimTxData& elem, GraphIndex idx) noexcept {\n+            return elem.m_index < idx;\n+        });\n+        Assume(it != trim_data.end() && it->m_index == index);\n+        return it;\n+    };\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        trim_data.clear();\n+        trim_heap.clear();\n+        deps.clear();\n+\n+        // Gather trim data from all involved Clusters.\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        uint64_t size{0};\n+        for (Cluster* cluster : cluster_span) {\n+            size += cluster->AppendTrimData(trim_data, deps);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 156,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": 2098239806,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-05-28T03:37:24Z",
      "updated_at": "2025-05-28T03:39:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2110821096",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110821096"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2669,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110821680",
      "pull_request_review_id": 2873451151,
      "id": 2110821680,
      "node_id": "PRRC_kwDOABII58590JUw",
      "diff_hunk": "@@ -151,6 +168,10 @@ class Cluster\n     void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n     /** For every chunk in the cluster, append its FeeFrac to ret. */\n     void AppendChunkFeerates(std::vector<FeeFrac>& ret) const noexcept;\n+    /** Add a TrimTxData entry for every transaction in the Cluster to ret. Implicit dependencies",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 28,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": 2098190802,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done. Also organized the fields of `struct TrimTxData` a bit more logically, into \"Populated by Cluster::AppendTxData\" and \"Only used internally in TxGraphImpl::Trim\" sections.",
      "created_at": "2025-05-28T03:38:20Z",
      "updated_at": "2025-05-28T03:39:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2110821680",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110821680"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110822058",
      "pull_request_review_id": 2873451151,
      "id": 2110822058,
      "node_id": "PRRC_kwDOABII58590Jaq",
      "diff_hunk": "@@ -788,6 +788,27 @@ FUZZ_TARGET(txgraph)\n                     assert(sum == worst_chunk_feerate);\n                 }\n                 break;\n+            } else if ((block_builders.empty() || sims.size() > 1) && command-- == 0) {",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 169,
      "original_position": 4,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "ce825731e8bea294e71b339015eccdb087e760c7",
      "in_reply_to_id": 2096430670,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a commit with a test like this, with some changes. LMK what you think.",
      "created_at": "2025-05-28T03:38:59Z",
      "updated_at": "2025-05-28T03:39:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2110822058",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2110822058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 828,
      "original_line": 828,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2146164467",
      "pull_request_review_id": 2926551924,
      "id": 2146164467,
      "node_id": "PRRC_kwDOABII585_697z",
      "diff_hunk": "@@ -2525,6 +2581,189 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    Assume(clusterset.m_oversized.has_value());\n+    if (clusterset.m_oversized == false) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. This\n+    // continues as long the number or size of all picked transactions together does not exceed the",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 116,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "1664ec567f7ecd305b8489ca55a6d630fb12d497",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n    // continues as long as the number or size of all picked transactions together does not exceed the\r\n```",
      "created_at": "2025-06-13T21:48:12Z",
      "updated_at": "2025-06-17T17:14:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2146164467",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2146164467"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2612,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2150731987",
      "pull_request_review_id": 2926551924,
      "id": 2150731987,
      "node_id": "PRRC_kwDOABII586AMZDT",
      "diff_hunk": "@@ -240,8 +240,9 @@ class TxGraph\n     };\n };\n \n-/** Construct a new TxGraph with the specified limit on transactions within a cluster. That\n- *  number cannot exceed MAX_CLUSTER_COUNT_LIMIT. */\n-std::unique_ptr<TxGraph> MakeTxGraph(unsigned max_cluster_count) noexcept;\n+/** Construct a new TxGraph with the specified limit on the number of transactions within a cluster,",
      "path": "src/txgraph.h",
      "position": 34,
      "original_position": 22,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "416a8d16d0fd7025c12a577319353da06faddb90",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Perhaps worth noting (for future visitors) that these two limits have pretty different purposes even though they both contribute to the oversizedness property. Max cluster count helps bound linearization complexity, but max cluster size's purpose is largely external to `TxGraph`. It is only a parameter so that `TxGraph` can help enforce it.",
      "created_at": "2025-06-16T19:41:19Z",
      "updated_at": "2025-06-17T17:14:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2150731987",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2150731987"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 248,
      "original_line": 248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152557817",
      "pull_request_review_id": 2926551924,
      "id": 2152557817,
      "node_id": "PRRC_kwDOABII586ATWz5",
      "diff_hunk": "@@ -64,9 +64,9 @@ class TxGraph\n     virtual ~TxGraph() = default;\n     /** Construct a new transaction with the specified feerate, and return a Ref to it.\n      *  If a staging graph exists, the new transaction is only created there. feerate.size must be\n-     *  strictly positive, and cannot exceed the graph's max cluster size. In all further calls,\n-     *  only Refs created by AddTransaction() are allowed to be passed to this TxGraph object (or\n-     *  empty Ref objects). Ref objects may outlive the TxGraph they were created for. */\n+     *  strictly positive. In all further calls, only Refs created by AddTransaction() are allowed\n+     *  to be passed to this TxGraph object (or empty Ref objects). Ref objects may outlive the\n+     *  TxGraph they were created for. */",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 9,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "221de30171acc1a20549079309b545612f727efb",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in 221de30171acc1a20549079309b545612f727efb, do I understand correctly that we also don't ever expect `OVERSIZED_SINGLETON` to occur in the wild (i.e. we wouldn't accept any transactions above standard size in reorgs and max standard size > max cluster size), but `TxGraph` must handle this case as part of handling oversizedness in general?",
      "created_at": "2025-06-17T15:22:46Z",
      "updated_at": "2025-06-17T17:14:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2152557817",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152557817"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": 67,
      "start_side": "LEFT",
      "line": null,
      "original_line": 69,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152804408",
      "pull_request_review_id": 2936518483,
      "id": 2152804408,
      "node_id": "PRRC_kwDOABII586AUTA4",
      "diff_hunk": "@@ -240,8 +240,9 @@ class TxGraph\n     };\n };\n \n-/** Construct a new TxGraph with the specified limit on transactions within a cluster. That\n- *  number cannot exceed MAX_CLUSTER_COUNT_LIMIT. */\n-std::unique_ptr<TxGraph> MakeTxGraph(unsigned max_cluster_count) noexcept;\n+/** Construct a new TxGraph with the specified limit on the number of transactions within a cluster,",
      "path": "src/txgraph.h",
      "position": 34,
      "original_position": 22,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "416a8d16d0fd7025c12a577319353da06faddb90",
      "in_reply_to_id": 2150731987,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes and no.\r\n\r\nI've come to think of them as both being a feature that TxGraph offers to the mempool/net_processing code to help enforce its policy limits. So in this regard, they are equivalent.\r\n\r\nThe reason for the *existence* of the policy limits differs however: weight is there to bound how good/predictable transaction quality can be through linearization (avoiding binpacking), while count is there to keep the TxGraphImpl implementation efficient. But it isn't the case that this directly determines the count limit, otherwise e.g. more performant machines should have a higher limit for example.",
      "created_at": "2025-06-17T17:29:58Z",
      "updated_at": "2025-06-17T17:33:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2152804408",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152804408"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 248,
      "original_line": 248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152804802",
      "pull_request_review_id": 2936518483,
      "id": 2152804802,
      "node_id": "PRRC_kwDOABII586AUTHC",
      "diff_hunk": "@@ -2525,6 +2581,189 @@ std::pair<std::vector<TxGraph::Ref*>, FeePerWeight> TxGraphImpl::GetWorstMainChu\n     return ret;\n }\n \n+std::vector<TxGraph::Ref*> TxGraphImpl::Trim() noexcept\n+{\n+    int level = GetTopLevel();\n+    Assume(m_main_chunkindex_observers == 0 || level != 0);\n+    std::vector<TxGraph::Ref*> ret;\n+\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    auto& clusterset = GetClusterSet(level);\n+    if (clusterset.m_oversized == false) return ret;\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if not oversized.\n+    Assume(clusterset.m_oversized.has_value());\n+    if (clusterset.m_oversized == false) return ret;\n+\n+    // In this function, would-be clusters (as precomputed in m_group_data by GroupClusters) are\n+    // trimmed by removing transactions in them such that the resulting clusters satisfy the size\n+    // and count limits.\n+    //\n+    // It works by defining for each would-be cluster a rudimentary linearization: at every point\n+    // the highest-chunk-feerate remaining transaction is picked among those with no unmet\n+    // dependencies. \"Dependency\" here means either a to-be-added dependency (m_deps_to_add), or\n+    // an implicit dependency added between any two consecutive transaction in their current\n+    // cluster linearization. So it can be seen as a \"merge sort\" of the chunks of the clusters,\n+    // but respecting the dependencies being added.\n+    //\n+    // This rudimentary linearization is computed lazily, by putting all eligible (no unmet\n+    // dependencies) transactions in a heap, and popping the highest-feerate one from it. This\n+    // continues as long the number or size of all picked transactions together does not exceed the",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 116,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "1664ec567f7ecd305b8489ca55a6d630fb12d497",
      "in_reply_to_id": 2146164467,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-06-17T17:30:11Z",
      "updated_at": "2025-06-17T17:33:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2152804802",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152804802"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2612,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152805562",
      "pull_request_review_id": 2936518483,
      "id": 2152805562,
      "node_id": "PRRC_kwDOABII586AUTS6",
      "diff_hunk": "@@ -64,9 +64,9 @@ class TxGraph\n     virtual ~TxGraph() = default;\n     /** Construct a new transaction with the specified feerate, and return a Ref to it.\n      *  If a staging graph exists, the new transaction is only created there. feerate.size must be\n-     *  strictly positive, and cannot exceed the graph's max cluster size. In all further calls,\n-     *  only Refs created by AddTransaction() are allowed to be passed to this TxGraph object (or\n-     *  empty Ref objects). Ref objects may outlive the TxGraph they were created for. */\n+     *  strictly positive. In all further calls, only Refs created by AddTransaction() are allowed\n+     *  to be passed to this TxGraph object (or empty Ref objects). Ref objects may outlive the\n+     *  TxGraph they were created for. */",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 9,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "221de30171acc1a20549079309b545612f727efb",
      "in_reply_to_id": 2152557817,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I believe that's correct. @sdaftuar ?\r\n\r\nFrom the commit message:\r\n\r\n> With this change, the responsibility for enforcing cluster size limits can be localized purely in TxGraph, without callers (and in particular, tests) needing to duplicate the enforcement for individual transactions.\r\n",
      "created_at": "2025-06-17T17:30:39Z",
      "updated_at": "2025-06-17T18:46:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2152805562",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152805562"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": 67,
      "start_side": "LEFT",
      "line": null,
      "original_line": 69,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152987296",
      "pull_request_review_id": 2936795175,
      "id": 2152987296,
      "node_id": "PRRC_kwDOABII586AU_qg",
      "diff_hunk": "@@ -240,8 +240,9 @@ class TxGraph\n     };\n };\n \n-/** Construct a new TxGraph with the specified limit on transactions within a cluster. That\n- *  number cannot exceed MAX_CLUSTER_COUNT_LIMIT. */\n-std::unique_ptr<TxGraph> MakeTxGraph(unsigned max_cluster_count) noexcept;\n+/** Construct a new TxGraph with the specified limit on the number of transactions within a cluster,",
      "path": "src/txgraph.h",
      "position": 34,
      "original_position": 22,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "416a8d16d0fd7025c12a577319353da06faddb90",
      "in_reply_to_id": 2150731987,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fair enough, I suppose they are both external policy limits!",
      "created_at": "2025-06-17T19:07:19Z",
      "updated_at": "2025-06-17T19:07:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2152987296",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152987296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 248,
      "original_line": 248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154727582",
      "pull_request_review_id": 2939425053,
      "id": 2154727582,
      "node_id": "PRRC_kwDOABII586Aboie",
      "diff_hunk": "@@ -0,0 +1,241 @@\n+// Copyright (c) 2023-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <txgraph.h>\n+\n+#include <random.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <memory>\n+#include <vector>\n+\n+BOOST_AUTO_TEST_SUITE(txgraph_tests)\n+\n+BOOST_AUTO_TEST_CASE(txgraph_trim_zigzag)\n+{\n+    // T     T     T     T     T     T     T     T     T     T     T     T     T     T (50 T's)\n+    //  \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   /\n+    //   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /\n+    //    B     B     B     B     B     B     B     B     B     B     B     B     B    (49 B's)\n+    //\n+    /** The maximum cluster count used in this test. */\n+    static constexpr int MAX_CLUSTER_COUNT = 50;\n+    /** The number of \"bottom\" transactions, which are in the mempool already. */\n+    static constexpr int NUM_BOTTOM_TX = 49;\n+    /** The number of \"top\" transactions, which come from disconnected blocks. These are re-added\n+     *  to the mempool and, while connecting them to the already-in-mempool transactions, we\n+     *   discover the resulting cluster is oversized. */\n+    static constexpr int NUM_TOP_TX = 50;\n+    /** The total number of transactions in the test. */\n+    static constexpr int TOTAL_NUM_TX = NUM_BOTTOM_TX + NUM_TOP_TX;\n+    static_assert(TOTAL_NUM_TX > MAX_CLUSTER_COUNT);\n+    /** Set a very large cluster size limit so that only the count limit is triggered. */\n+    static constexpr int32_t MAX_CLUSTER_SIZE = 100'000 * 100;\n+\n+    // Create a new graph for the test.\n+    auto graph = MakeTxGraph(MAX_CLUSTER_COUNT, MAX_CLUSTER_SIZE);\n+\n+    // Add all transactions and store their Refs.\n+    std::vector<TxGraph::Ref> refs;\n+    refs.reserve(TOTAL_NUM_TX);\n+    // First all bottom transactions: the i'th bottom transaction is at position i.\n+    for (unsigned int i = 0; i < NUM_BOTTOM_TX; ++i) {\n+        refs.push_back(graph->AddTransaction(FeePerWeight{200 - i, 100}));\n+    }\n+    // Then all top transactions: the i'th top transaction is at position NUM_BOTTOM_TX + i.\n+    for (unsigned int i = 0; i < NUM_TOP_TX; ++i) {\n+        refs.push_back(graph->AddTransaction(FeePerWeight{100 - i, 100}));\n+    }\n+\n+    // Create the zigzag dependency structure.\n+    // Each transaction in the bottom row depends on two adjacent transactions from the top row.\n+    for (unsigned int i = 0; i < NUM_BOTTOM_TX; ++i) {\n+        graph->AddDependency(/*parent=*/refs[NUM_BOTTOM_TX + i], /*child=*/refs[i]);\n+        graph->AddDependency(/*parent=*/refs[NUM_BOTTOM_TX + i + 1], /*child=*/refs[i]);\n+    }\n+\n+    // Check that the graph is now oversized. This also forces the graph to\n+    // group clusters and compute the oversized status.\n+    BOOST_CHECK_EQUAL(graph->GetTransactionCount(), TOTAL_NUM_TX);\n+    BOOST_CHECK(graph->IsOversized(false));",
      "path": "src/test/txgraph_tests.cpp",
      "position": null,
      "original_position": 62,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "4ead162a4601edd25964240f943d0524b71fabe7",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "micro-nit: main_only could be annotated and true to make it clear we're not looking at staging (even though it doesn't exist)",
      "created_at": "2025-06-18T14:15:07Z",
      "updated_at": "2025-06-18T14:18:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2154727582",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154727582"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154733042",
      "pull_request_review_id": 2939425053,
      "id": 2154733042,
      "node_id": "PRRC_kwDOABII586Abp3y",
      "diff_hunk": "@@ -0,0 +1,241 @@\n+// Copyright (c) 2023-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <txgraph.h>\n+\n+#include <random.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <memory>\n+#include <vector>\n+\n+BOOST_AUTO_TEST_SUITE(txgraph_tests)\n+\n+BOOST_AUTO_TEST_CASE(txgraph_trim_zigzag)\n+{\n+    // T     T     T     T     T     T     T     T     T     T     T     T     T     T (50 T's)\n+    //  \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   /\n+    //   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /\n+    //    B     B     B     B     B     B     B     B     B     B     B     B     B    (49 B's)\n+    //\n+    /** The maximum cluster count used in this test. */\n+    static constexpr int MAX_CLUSTER_COUNT = 50;\n+    /** The number of \"bottom\" transactions, which are in the mempool already. */\n+    static constexpr int NUM_BOTTOM_TX = 49;\n+    /** The number of \"top\" transactions, which come from disconnected blocks. These are re-added\n+     *  to the mempool and, while connecting them to the already-in-mempool transactions, we\n+     *   discover the resulting cluster is oversized. */\n+    static constexpr int NUM_TOP_TX = 50;\n+    /** The total number of transactions in the test. */\n+    static constexpr int TOTAL_NUM_TX = NUM_BOTTOM_TX + NUM_TOP_TX;\n+    static_assert(TOTAL_NUM_TX > MAX_CLUSTER_COUNT);\n+    /** Set a very large cluster size limit so that only the count limit is triggered. */\n+    static constexpr int32_t MAX_CLUSTER_SIZE = 100'000 * 100;\n+\n+    // Create a new graph for the test.\n+    auto graph = MakeTxGraph(MAX_CLUSTER_COUNT, MAX_CLUSTER_SIZE);\n+\n+    // Add all transactions and store their Refs.\n+    std::vector<TxGraph::Ref> refs;\n+    refs.reserve(TOTAL_NUM_TX);\n+    // First all bottom transactions: the i'th bottom transaction is at position i.\n+    for (unsigned int i = 0; i < NUM_BOTTOM_TX; ++i) {\n+        refs.push_back(graph->AddTransaction(FeePerWeight{200 - i, 100}));\n+    }\n+    // Then all top transactions: the i'th top transaction is at position NUM_BOTTOM_TX + i.\n+    for (unsigned int i = 0; i < NUM_TOP_TX; ++i) {\n+        refs.push_back(graph->AddTransaction(FeePerWeight{100 - i, 100}));\n+    }\n+\n+    // Create the zigzag dependency structure.\n+    // Each transaction in the bottom row depends on two adjacent transactions from the top row.\n+    for (unsigned int i = 0; i < NUM_BOTTOM_TX; ++i) {\n+        graph->AddDependency(/*parent=*/refs[NUM_BOTTOM_TX + i], /*child=*/refs[i]);\n+        graph->AddDependency(/*parent=*/refs[NUM_BOTTOM_TX + i + 1], /*child=*/refs[i]);\n+    }\n+\n+    // Check that the graph is now oversized. This also forces the graph to\n+    // group clusters and compute the oversized status.\n+    BOOST_CHECK_EQUAL(graph->GetTransactionCount(), TOTAL_NUM_TX);\n+    BOOST_CHECK(graph->IsOversized(false));\n+\n+    // Call Trim() to remove transactions and bring the cluster back within limits.\n+    auto removed_refs = graph->Trim();\n+    BOOST_CHECK(!graph->IsOversized(false));\n+\n+    BOOST_CHECK_EQUAL(removed_refs.size(), TOTAL_NUM_TX - MAX_CLUSTER_COUNT);\n+    BOOST_CHECK_EQUAL(graph->GetTransactionCount(), MAX_CLUSTER_COUNT);\n+\n+    // Only prefix of size max_cluster_count is left. That's the first half of the top and first half of the bottom.\n+    for (unsigned int i = 0; i < refs.size(); ++i) {\n+        const bool first_half = (i < (NUM_BOTTOM_TX / 2)) ||\n+                                (i >= NUM_BOTTOM_TX && i < NUM_BOTTOM_TX + NUM_TOP_TX / 2 + 1);\n+        BOOST_CHECK_EQUAL(graph->Exists(refs[i]), first_half);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(txgraph_trim_flower)\n+{\n+    // We will build an oversized flower-shaped graph: all transactions are spent by 1 descendant.\n+    //\n+    //   T   T   T   T   T   T   T   T (100 T's)\n+    //   |   |   |   |   |   |   |   |\n+    //   |   |   |   |   |   |   |   |\n+    //   \\---+---+---+-+-+---+---+---/\n+    //                 |\n+    //                 B (1 B)\n+    //\n+    /** The maximum cluster count used in this test. */\n+    static constexpr int MAX_CLUSTER_COUNT = 50;\n+    /** The number of \"top\" transactions, which come from disconnected blocks. These are re-added\n+     *  to the mempool and, connecting them to the already-in-mempool transactions, we discover the\n+     *  resulting cluster is oversized. */\n+    static constexpr int NUM_TOP_TX = MAX_CLUSTER_COUNT * 2;\n+    /** The total number of transactions in this test. */\n+    static constexpr int TOTAL_NUM_TX = NUM_TOP_TX + 1;\n+    /** Set a very large cluster size limit so that only the count limit is triggered. */\n+    static constexpr int32_t MAX_CLUSTER_SIZE = 100'000 * 100;\n+\n+    auto graph = MakeTxGraph(MAX_CLUSTER_COUNT, MAX_CLUSTER_SIZE);\n+\n+    // Add all transactions and store their Refs.\n+    std::vector<TxGraph::Ref> refs;\n+    refs.reserve(TOTAL_NUM_TX);\n+\n+    // Add all transactions. They are in individual clusters.\n+    refs.push_back(graph->AddTransaction({1, 100}));\n+    for (unsigned int i = 0; i < NUM_TOP_TX; ++i) {\n+        refs.push_back(graph->AddTransaction(FeePerWeight{500 + i, 100}));\n+    }\n+\n+    // The 0th transaction spends all the top transactions.\n+    for (unsigned int i = 1; i < TOTAL_NUM_TX; ++i) {\n+        graph->AddDependency(/*parent=*/refs[i], /*child=*/refs[0]);\n+    }\n+\n+    // Check that the graph is now oversized. This also forces the graph to\n+    // group clusters and compute the oversized status.\n+    BOOST_CHECK(graph->IsOversized(false));\n+\n+    // Call Trim() to remove transactions and bring the cluster back within limits.\n+    auto removed_refs = graph->Trim();\n+    BOOST_CHECK(!graph->IsOversized(false));\n+\n+    BOOST_CHECK_EQUAL(removed_refs.size(), TOTAL_NUM_TX - MAX_CLUSTER_COUNT);\n+    BOOST_CHECK_EQUAL(graph->GetTransactionCount(), MAX_CLUSTER_COUNT);\n+\n+    // Only prefix of size max_cluster_count (last max_cluster_count top transactions) is left.\n+    for (unsigned int i = 0; i < refs.size(); ++i) {\n+        const bool top_highest_feerate = i > (TOTAL_NUM_TX - MAX_CLUSTER_COUNT - 1);\n+        BOOST_CHECK_EQUAL(graph->Exists(refs[i]), top_highest_feerate);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(txgraph_trim_huge)\n+{\n+    // The from-block transactions consist of 1000 fully linear clusters, each with 64\n+    // transactions. The mempool contains 11 transactions that together merge all of these into\n+    // a single cluster.\n+    //\n+    // (1000 chains of 64 transactions, 64000 T's total)\n+    //\n+    //      T          T          T          T          T          T          T          T\n+    //      |          |          |          |          |          |          |          |\n+    //      T          T          T          T          T          T          T          T\n+    //      |          |          |          |          |          |          |          |\n+    //      T          T          T          T          T          T          T          T\n+    //      |          |          |          |          |          |          |          |\n+    //      T          T          T          T          T          T          T          T\n+    //  (64 long)  (64 long)  (64 long)  (64 long)  (64 long)  (64 long)  (64 long)  (64 long)\n+    //      |          |          |          |          |          |          |          |\n+    //      |          |         / \\         |         / \\         |          |         /\n+    //      \\----------+--------/   \\--------+--------/   \\--------+-----+----+--------/\n+    //                 |                     |                           |\n+    //                 B                     B                           B\n+    //\n+    //  (11 B's, each attaching to up to 100 chains of 64 T's)\n+    //\n+    /** The maximum cluster count used in this test. */\n+    static constexpr int MAX_CLUSTER_COUNT = 64;\n+    /** The number of \"top\" (from-block) chains of transactions. */\n+    static constexpr int NUM_TOP_CHAINS = 1000;\n+    /** The number of transactions per top chain. */\n+    static constexpr int NUM_TX_PER_TOP_CHAIN = MAX_CLUSTER_COUNT;\n+    /** The (maximum) number of dependencies per bottom transaction. */\n+    static constexpr int NUM_DEPS_PER_BOTTOM_TX = 100;\n+    /** Set a very large cluster size limit so that only the count limit is triggered. */\n+    static constexpr int32_t MAX_CLUSTER_SIZE = 100'000 * 100;\n+\n+    /** Refs to all top transactions. */\n+    std::vector<TxGraph::Ref> top_refs;\n+    /** Refs to all bottom transactions. */\n+    std::vector<TxGraph::Ref> bottom_refs;\n+    /** Indexes into top_refs for some transaction of each component, in arbitrary order.\n+     *  Initially these are the last transactions in each chains, but as bottom transactions are\n+     *  added, entries will be removed when they get merged, and randomized. */\n+    std::vector<size_t> top_components;\n+\n+    FastRandomContext rng;\n+    auto graph = MakeTxGraph(MAX_CLUSTER_COUNT, MAX_CLUSTER_SIZE);\n+\n+    // Construct the top chains.\n+    for (int chain = 0; chain < NUM_TOP_CHAINS; ++chain) {\n+        for (int chaintx = 0; chaintx < NUM_TX_PER_TOP_CHAIN; ++chaintx) {\n+            // Use random fees, size 1.\n+            int64_t fee = rng.randbits<27>() + 100;\n+            FeePerWeight feerate{fee, 1};\n+            top_refs.push_back(graph->AddTransaction(feerate));\n+            // Add internal dependencies linked the chain transactions together.\n+            if (chaintx > 0) {\n+                 graph->AddDependency(*(top_refs.rbegin()), *(top_refs.rbegin() + 1));\n+            }\n+        }\n+        // Remember the last transaction in each chain, to attach the bottom transactions to.\n+        top_components.push_back(top_refs.size() - 1);\n+    }\n+\n+    // Not oversized so far (just 1000 clusters of 64).\n+    BOOST_CHECK(!graph->IsOversized());\n+\n+    // Construct the bottom transactions, and dependencies to the top chains.\n+    while (top_components.size() > 1) {\n+        // Construct the transaction.\n+        int64_t fee = rng.randbits<27>() + 100;\n+        FeePerWeight feerate{fee, 1};\n+        auto bottom_tx = graph->AddTransaction(feerate);\n+        // Determine the number of dependencies this transaction will have.\n+        int deps = std::min<int>(NUM_DEPS_PER_BOTTOM_TX, top_components.size());\n+        for (int dep = 0; dep < deps; ++dep) {\n+            // Pick an transaction in top_components to attach to.\n+            auto idx = rng.randrange(top_components.size());\n+            // Add dependency.\n+            graph->AddDependency(/*parent=*/top_refs[top_components[idx]], /*child=*/bottom_tx);\n+            // Unless this is the last dependency being added, remove from top_components, as\n+            // the component will be merged with that one.\n+            if (dep < deps - 1) {\n+                // Move entry top the back.\n+                if (idx != top_components.size() - 1) std::swap(top_components.back(), top_components[idx]);\n+                // And pop it.\n+                top_components.pop_back();\n+            }\n+        }\n+        bottom_refs.push_back(std::move(bottom_tx));\n+    }\n+\n+    // Now we are oversized (one cluster of 64011).",
      "path": "src/test/txgraph_tests.cpp",
      "position": 235,
      "original_position": 227,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "4ead162a4601edd25964240f943d0524b71fabe7",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: can just assert this number rather than put in comment",
      "created_at": "2025-06-18T14:17:26Z",
      "updated_at": "2025-06-18T14:18:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2154733042",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154733042"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 235,
      "original_line": 235,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154888947",
      "pull_request_review_id": 2939687157,
      "id": 2154888947,
      "node_id": "PRRC_kwDOABII586AcP7z",
      "diff_hunk": "@@ -0,0 +1,241 @@\n+// Copyright (c) 2023-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <txgraph.h>\n+\n+#include <random.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <memory>\n+#include <vector>\n+\n+BOOST_AUTO_TEST_SUITE(txgraph_tests)\n+\n+BOOST_AUTO_TEST_CASE(txgraph_trim_zigzag)\n+{\n+    // T     T     T     T     T     T     T     T     T     T     T     T     T     T (50 T's)\n+    //  \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   /\n+    //   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /\n+    //    B     B     B     B     B     B     B     B     B     B     B     B     B    (49 B's)\n+    //\n+    /** The maximum cluster count used in this test. */\n+    static constexpr int MAX_CLUSTER_COUNT = 50;\n+    /** The number of \"bottom\" transactions, which are in the mempool already. */\n+    static constexpr int NUM_BOTTOM_TX = 49;\n+    /** The number of \"top\" transactions, which come from disconnected blocks. These are re-added\n+     *  to the mempool and, while connecting them to the already-in-mempool transactions, we\n+     *   discover the resulting cluster is oversized. */\n+    static constexpr int NUM_TOP_TX = 50;\n+    /** The total number of transactions in the test. */\n+    static constexpr int TOTAL_NUM_TX = NUM_BOTTOM_TX + NUM_TOP_TX;\n+    static_assert(TOTAL_NUM_TX > MAX_CLUSTER_COUNT);\n+    /** Set a very large cluster size limit so that only the count limit is triggered. */\n+    static constexpr int32_t MAX_CLUSTER_SIZE = 100'000 * 100;\n+\n+    // Create a new graph for the test.\n+    auto graph = MakeTxGraph(MAX_CLUSTER_COUNT, MAX_CLUSTER_SIZE);\n+\n+    // Add all transactions and store their Refs.\n+    std::vector<TxGraph::Ref> refs;\n+    refs.reserve(TOTAL_NUM_TX);\n+    // First all bottom transactions: the i'th bottom transaction is at position i.\n+    for (unsigned int i = 0; i < NUM_BOTTOM_TX; ++i) {\n+        refs.push_back(graph->AddTransaction(FeePerWeight{200 - i, 100}));\n+    }\n+    // Then all top transactions: the i'th top transaction is at position NUM_BOTTOM_TX + i.\n+    for (unsigned int i = 0; i < NUM_TOP_TX; ++i) {\n+        refs.push_back(graph->AddTransaction(FeePerWeight{100 - i, 100}));\n+    }\n+\n+    // Create the zigzag dependency structure.\n+    // Each transaction in the bottom row depends on two adjacent transactions from the top row.\n+    for (unsigned int i = 0; i < NUM_BOTTOM_TX; ++i) {\n+        graph->AddDependency(/*parent=*/refs[NUM_BOTTOM_TX + i], /*child=*/refs[i]);\n+        graph->AddDependency(/*parent=*/refs[NUM_BOTTOM_TX + i + 1], /*child=*/refs[i]);\n+    }\n+\n+    // Check that the graph is now oversized. This also forces the graph to\n+    // group clusters and compute the oversized status.\n+    BOOST_CHECK_EQUAL(graph->GetTransactionCount(), TOTAL_NUM_TX);\n+    BOOST_CHECK(graph->IsOversized(false));",
      "path": "src/test/txgraph_tests.cpp",
      "position": null,
      "original_position": 62,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "4ead162a4601edd25964240f943d0524b71fabe7",
      "in_reply_to_id": 2154727582,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-06-18T15:17:21Z",
      "updated_at": "2025-06-18T15:17:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2154888947",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154888947"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154889407",
      "pull_request_review_id": 2939687853,
      "id": 2154889407,
      "node_id": "PRRC_kwDOABII586AcQC_",
      "diff_hunk": "@@ -0,0 +1,241 @@\n+// Copyright (c) 2023-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <txgraph.h>\n+\n+#include <random.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <memory>\n+#include <vector>\n+\n+BOOST_AUTO_TEST_SUITE(txgraph_tests)\n+\n+BOOST_AUTO_TEST_CASE(txgraph_trim_zigzag)\n+{\n+    // T     T     T     T     T     T     T     T     T     T     T     T     T     T (50 T's)\n+    //  \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   / \\   /\n+    //   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /   \\ /\n+    //    B     B     B     B     B     B     B     B     B     B     B     B     B    (49 B's)\n+    //\n+    /** The maximum cluster count used in this test. */\n+    static constexpr int MAX_CLUSTER_COUNT = 50;\n+    /** The number of \"bottom\" transactions, which are in the mempool already. */\n+    static constexpr int NUM_BOTTOM_TX = 49;\n+    /** The number of \"top\" transactions, which come from disconnected blocks. These are re-added\n+     *  to the mempool and, while connecting them to the already-in-mempool transactions, we\n+     *   discover the resulting cluster is oversized. */\n+    static constexpr int NUM_TOP_TX = 50;\n+    /** The total number of transactions in the test. */\n+    static constexpr int TOTAL_NUM_TX = NUM_BOTTOM_TX + NUM_TOP_TX;\n+    static_assert(TOTAL_NUM_TX > MAX_CLUSTER_COUNT);\n+    /** Set a very large cluster size limit so that only the count limit is triggered. */\n+    static constexpr int32_t MAX_CLUSTER_SIZE = 100'000 * 100;\n+\n+    // Create a new graph for the test.\n+    auto graph = MakeTxGraph(MAX_CLUSTER_COUNT, MAX_CLUSTER_SIZE);\n+\n+    // Add all transactions and store their Refs.\n+    std::vector<TxGraph::Ref> refs;\n+    refs.reserve(TOTAL_NUM_TX);\n+    // First all bottom transactions: the i'th bottom transaction is at position i.\n+    for (unsigned int i = 0; i < NUM_BOTTOM_TX; ++i) {\n+        refs.push_back(graph->AddTransaction(FeePerWeight{200 - i, 100}));\n+    }\n+    // Then all top transactions: the i'th top transaction is at position NUM_BOTTOM_TX + i.\n+    for (unsigned int i = 0; i < NUM_TOP_TX; ++i) {\n+        refs.push_back(graph->AddTransaction(FeePerWeight{100 - i, 100}));\n+    }\n+\n+    // Create the zigzag dependency structure.\n+    // Each transaction in the bottom row depends on two adjacent transactions from the top row.\n+    for (unsigned int i = 0; i < NUM_BOTTOM_TX; ++i) {\n+        graph->AddDependency(/*parent=*/refs[NUM_BOTTOM_TX + i], /*child=*/refs[i]);\n+        graph->AddDependency(/*parent=*/refs[NUM_BOTTOM_TX + i + 1], /*child=*/refs[i]);\n+    }\n+\n+    // Check that the graph is now oversized. This also forces the graph to\n+    // group clusters and compute the oversized status.\n+    BOOST_CHECK_EQUAL(graph->GetTransactionCount(), TOTAL_NUM_TX);\n+    BOOST_CHECK(graph->IsOversized(false));\n+\n+    // Call Trim() to remove transactions and bring the cluster back within limits.\n+    auto removed_refs = graph->Trim();\n+    BOOST_CHECK(!graph->IsOversized(false));\n+\n+    BOOST_CHECK_EQUAL(removed_refs.size(), TOTAL_NUM_TX - MAX_CLUSTER_COUNT);\n+    BOOST_CHECK_EQUAL(graph->GetTransactionCount(), MAX_CLUSTER_COUNT);\n+\n+    // Only prefix of size max_cluster_count is left. That's the first half of the top and first half of the bottom.\n+    for (unsigned int i = 0; i < refs.size(); ++i) {\n+        const bool first_half = (i < (NUM_BOTTOM_TX / 2)) ||\n+                                (i >= NUM_BOTTOM_TX && i < NUM_BOTTOM_TX + NUM_TOP_TX / 2 + 1);\n+        BOOST_CHECK_EQUAL(graph->Exists(refs[i]), first_half);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(txgraph_trim_flower)\n+{\n+    // We will build an oversized flower-shaped graph: all transactions are spent by 1 descendant.\n+    //\n+    //   T   T   T   T   T   T   T   T (100 T's)\n+    //   |   |   |   |   |   |   |   |\n+    //   |   |   |   |   |   |   |   |\n+    //   \\---+---+---+-+-+---+---+---/\n+    //                 |\n+    //                 B (1 B)\n+    //\n+    /** The maximum cluster count used in this test. */\n+    static constexpr int MAX_CLUSTER_COUNT = 50;\n+    /** The number of \"top\" transactions, which come from disconnected blocks. These are re-added\n+     *  to the mempool and, connecting them to the already-in-mempool transactions, we discover the\n+     *  resulting cluster is oversized. */\n+    static constexpr int NUM_TOP_TX = MAX_CLUSTER_COUNT * 2;\n+    /** The total number of transactions in this test. */\n+    static constexpr int TOTAL_NUM_TX = NUM_TOP_TX + 1;\n+    /** Set a very large cluster size limit so that only the count limit is triggered. */\n+    static constexpr int32_t MAX_CLUSTER_SIZE = 100'000 * 100;\n+\n+    auto graph = MakeTxGraph(MAX_CLUSTER_COUNT, MAX_CLUSTER_SIZE);\n+\n+    // Add all transactions and store their Refs.\n+    std::vector<TxGraph::Ref> refs;\n+    refs.reserve(TOTAL_NUM_TX);\n+\n+    // Add all transactions. They are in individual clusters.\n+    refs.push_back(graph->AddTransaction({1, 100}));\n+    for (unsigned int i = 0; i < NUM_TOP_TX; ++i) {\n+        refs.push_back(graph->AddTransaction(FeePerWeight{500 + i, 100}));\n+    }\n+\n+    // The 0th transaction spends all the top transactions.\n+    for (unsigned int i = 1; i < TOTAL_NUM_TX; ++i) {\n+        graph->AddDependency(/*parent=*/refs[i], /*child=*/refs[0]);\n+    }\n+\n+    // Check that the graph is now oversized. This also forces the graph to\n+    // group clusters and compute the oversized status.\n+    BOOST_CHECK(graph->IsOversized(false));\n+\n+    // Call Trim() to remove transactions and bring the cluster back within limits.\n+    auto removed_refs = graph->Trim();\n+    BOOST_CHECK(!graph->IsOversized(false));\n+\n+    BOOST_CHECK_EQUAL(removed_refs.size(), TOTAL_NUM_TX - MAX_CLUSTER_COUNT);\n+    BOOST_CHECK_EQUAL(graph->GetTransactionCount(), MAX_CLUSTER_COUNT);\n+\n+    // Only prefix of size max_cluster_count (last max_cluster_count top transactions) is left.\n+    for (unsigned int i = 0; i < refs.size(); ++i) {\n+        const bool top_highest_feerate = i > (TOTAL_NUM_TX - MAX_CLUSTER_COUNT - 1);\n+        BOOST_CHECK_EQUAL(graph->Exists(refs[i]), top_highest_feerate);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(txgraph_trim_huge)\n+{\n+    // The from-block transactions consist of 1000 fully linear clusters, each with 64\n+    // transactions. The mempool contains 11 transactions that together merge all of these into\n+    // a single cluster.\n+    //\n+    // (1000 chains of 64 transactions, 64000 T's total)\n+    //\n+    //      T          T          T          T          T          T          T          T\n+    //      |          |          |          |          |          |          |          |\n+    //      T          T          T          T          T          T          T          T\n+    //      |          |          |          |          |          |          |          |\n+    //      T          T          T          T          T          T          T          T\n+    //      |          |          |          |          |          |          |          |\n+    //      T          T          T          T          T          T          T          T\n+    //  (64 long)  (64 long)  (64 long)  (64 long)  (64 long)  (64 long)  (64 long)  (64 long)\n+    //      |          |          |          |          |          |          |          |\n+    //      |          |         / \\         |         / \\         |          |         /\n+    //      \\----------+--------/   \\--------+--------/   \\--------+-----+----+--------/\n+    //                 |                     |                           |\n+    //                 B                     B                           B\n+    //\n+    //  (11 B's, each attaching to up to 100 chains of 64 T's)\n+    //\n+    /** The maximum cluster count used in this test. */\n+    static constexpr int MAX_CLUSTER_COUNT = 64;\n+    /** The number of \"top\" (from-block) chains of transactions. */\n+    static constexpr int NUM_TOP_CHAINS = 1000;\n+    /** The number of transactions per top chain. */\n+    static constexpr int NUM_TX_PER_TOP_CHAIN = MAX_CLUSTER_COUNT;\n+    /** The (maximum) number of dependencies per bottom transaction. */\n+    static constexpr int NUM_DEPS_PER_BOTTOM_TX = 100;\n+    /** Set a very large cluster size limit so that only the count limit is triggered. */\n+    static constexpr int32_t MAX_CLUSTER_SIZE = 100'000 * 100;\n+\n+    /** Refs to all top transactions. */\n+    std::vector<TxGraph::Ref> top_refs;\n+    /** Refs to all bottom transactions. */\n+    std::vector<TxGraph::Ref> bottom_refs;\n+    /** Indexes into top_refs for some transaction of each component, in arbitrary order.\n+     *  Initially these are the last transactions in each chains, but as bottom transactions are\n+     *  added, entries will be removed when they get merged, and randomized. */\n+    std::vector<size_t> top_components;\n+\n+    FastRandomContext rng;\n+    auto graph = MakeTxGraph(MAX_CLUSTER_COUNT, MAX_CLUSTER_SIZE);\n+\n+    // Construct the top chains.\n+    for (int chain = 0; chain < NUM_TOP_CHAINS; ++chain) {\n+        for (int chaintx = 0; chaintx < NUM_TX_PER_TOP_CHAIN; ++chaintx) {\n+            // Use random fees, size 1.\n+            int64_t fee = rng.randbits<27>() + 100;\n+            FeePerWeight feerate{fee, 1};\n+            top_refs.push_back(graph->AddTransaction(feerate));\n+            // Add internal dependencies linked the chain transactions together.\n+            if (chaintx > 0) {\n+                 graph->AddDependency(*(top_refs.rbegin()), *(top_refs.rbegin() + 1));\n+            }\n+        }\n+        // Remember the last transaction in each chain, to attach the bottom transactions to.\n+        top_components.push_back(top_refs.size() - 1);\n+    }\n+\n+    // Not oversized so far (just 1000 clusters of 64).\n+    BOOST_CHECK(!graph->IsOversized());\n+\n+    // Construct the bottom transactions, and dependencies to the top chains.\n+    while (top_components.size() > 1) {\n+        // Construct the transaction.\n+        int64_t fee = rng.randbits<27>() + 100;\n+        FeePerWeight feerate{fee, 1};\n+        auto bottom_tx = graph->AddTransaction(feerate);\n+        // Determine the number of dependencies this transaction will have.\n+        int deps = std::min<int>(NUM_DEPS_PER_BOTTOM_TX, top_components.size());\n+        for (int dep = 0; dep < deps; ++dep) {\n+            // Pick an transaction in top_components to attach to.\n+            auto idx = rng.randrange(top_components.size());\n+            // Add dependency.\n+            graph->AddDependency(/*parent=*/top_refs[top_components[idx]], /*child=*/bottom_tx);\n+            // Unless this is the last dependency being added, remove from top_components, as\n+            // the component will be merged with that one.\n+            if (dep < deps - 1) {\n+                // Move entry top the back.\n+                if (idx != top_components.size() - 1) std::swap(top_components.back(), top_components[idx]);\n+                // And pop it.\n+                top_components.pop_back();\n+            }\n+        }\n+        bottom_refs.push_back(std::move(bottom_tx));\n+    }\n+\n+    // Now we are oversized (one cluster of 64011).",
      "path": "src/test/txgraph_tests.cpp",
      "position": 235,
      "original_position": 227,
      "commit_id": "2b2df98747fdb6380588991167ce2e8cb92f3bfb",
      "original_commit_id": "4ead162a4601edd25964240f943d0524b71fabe7",
      "in_reply_to_id": 2154733042,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've added a computation for it, and assertion.",
      "created_at": "2025-06-18T15:17:33Z",
      "updated_at": "2025-06-18T15:17:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r2154889407",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154889407"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 235,
      "original_line": 235,
      "side": "RIGHT"
    }
  ]
}