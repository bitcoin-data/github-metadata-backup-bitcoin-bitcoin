{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553",
    "id": 2248495552,
    "node_id": "PR_kwDOABII586GBVHA",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/31553",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/31553.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/31553.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/c7624ac16934bdf1dc106f87ce66da328ceeed3d",
    "number": 31553,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "cluster mempool: add TxGraph reorg functionality",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Part of cluster mempool (#30289). Builds on top of #31444.\r\n\r\nDuring reorganisations, it is possible that dependencies get added which would result in clusters that violate policy limits (cluster count, cluster weight), when linking the new from-block transactions to the old from-mempool transactions. Unlike RBF scenarios, we cannot simply reject the changes when they are due to received blocks. To accommodate this, add a `TxGraph::Trim()`, which removes some subset of transactions (including descendants) in order to make all resulting clusters satisfy the limits.\r\n\r\nConceptually, the way this is done is by defining a rudimentary linearization for the entire would-be too-large cluster, iterating it from beginning to end, and reasoning about the counts and weights of the clusters that would be reached using transactions up to that point. If a transaction is encountered whose addition would violate the limit, it is removed, together with all its descendants.\r\n\r\nThis rudimentary linearization is like a merge sort of the chunks of the clusters being combined, but respecting topology. More specifically, it is continuously picking the highest-chunk-feerate remaining transaction among those which have no unmet dependencies left. For efficiency, this rudimentary linearization is computed lazily, by putting all viable transactions in a heap, sorted by chunk feerate, and adding new transactions to it as they become viable.\r\n\r\nThe `Trim()` function is rather unusual compared to the `TxGraph` functionality added in previous PRs, in that `Trim()` makes it own decisions about what the resulting graph contents will be, without good specification of how it makes that decision - it is just a best-effort attempt (which is improved in the last commit). All other `TxGraph` mutators are simply to inform the graph about changes the calling mempool code decided on; this one lets the decision be made by txgraph.\r\n\r\nAs part of this, the \"oversized\" property is expanded to also encompass a configurable cluster weight limit (in addition to cluster count limit). \r\n",
    "labels": [
      {
        "id": 164208572,
        "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
        "name": "Mempool",
        "color": "fef2c0",
        "default": false
      }
    ],
    "created_at": "2024-12-22T19:06:05Z",
    "updated_at": "2025-02-12T22:29:24Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "6e76e1b7f50385cb7e591c10617985d38952e45b",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sipa:202412_txgraph_trim",
      "ref": "202412_txgraph_trim",
      "sha": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 20,
        "stargazers_count": 91,
        "watchers_count": 91,
        "size": 254930,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-02-12T22:30:57Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2025-01-09T14:12:33Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "048ef98626b9ed62355923f089ad5cc5b6a898a3",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36715,
        "stargazers_count": 81964,
        "watchers_count": 81964,
        "size": 275462,
        "default_branch": "master",
        "open_issues_count": 694,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-02-12T17:51:01Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-02-12T20:58:06Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 4273,
    "deletions": 151,
    "changed_files": 12,
    "commits": 35,
    "review_comments": 19,
    "comments": 7
  },
  "events": [
    {
      "event": "commented",
      "id": 2558561140,
      "node_id": "IC_kwDOABII586YgIt0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2558561140",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-22T19:06:08Z",
      "updated_at": "2025-02-11T16:13:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/31553.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#31519](https://github.com/bitcoin/bitcoin/pull/31519) (refactor: Use std::span over Span by maflcko)\n* [#30605](https://github.com/bitcoin/bitcoin/pull/30605) (Cluster linearization: separate tests from tests-of-tests by sipa)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2558561140",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "labeled",
      "id": 15798589053,
      "node_id": "LE_lADOABII586kMugSzwAAAAOtq1Z9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15798589053",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-02T13:05:14Z",
      "label": {
        "name": "Mempool",
        "color": "fef2c0"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15861077490,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOxZNXy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15861077490",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3e809fa9e6c0fc025ad180fe2d47e03cb9e6da4b",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/3e809fa9e6c0fc025ad180fe2d47e03cb9e6da4b",
      "created_at": "2025-01-08T23:27:48Z"
    },
    {
      "event": "labeled",
      "id": 15861624638,
      "node_id": "LE_lADOABII586kMugSzwAAAAOxbS8-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15861624638",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T00:52:10Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2578976969,
      "node_id": "IC_kwDOABII586ZuBDJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2578976969",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T00:52:11Z",
      "updated_at": "2025-01-09T00:52:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/35343429418</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2578976969",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15861756974,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOxbzQu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15861756974",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "75c675702ae91a234eca58a8733f69ebcf21eef4",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/75c675702ae91a234eca58a8733f69ebcf21eef4",
      "created_at": "2025-01-09T01:12:51Z"
    },
    {
      "event": "unlabeled",
      "id": 15862045073,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAOxc5mR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15862045073",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T02:34:45Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15868145094,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOx0K3G",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15868145094",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5a6550f8cafae8317eccf7bfc797669189176924",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/5a6550f8cafae8317eccf7bfc797669189176924",
      "created_at": "2025-01-09T13:41:37Z"
    },
    {
      "event": "reviewed",
      "id": 2540686525,
      "node_id": "PRR_kwDOABII586Xb8y9",
      "url": null,
      "actor": null,
      "commit_id": "5a6550f8cafae8317eccf7bfc797669189176924",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Very quick and shallow pass through the initial impl commit. This PR is a lot to get through :)",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2540686525",
      "submitted_at": "2025-01-09T20:03:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15873846189,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOyJ6ut",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15873846189",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fa14d0679f9362024cf5513e498b969cd74819a2",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/fa14d0679f9362024cf5513e498b969cd74819a2",
      "created_at": "2025-01-09T21:34:39Z"
    },
    {
      "event": "labeled",
      "id": 15874780470,
      "node_id": "LE_lADOABII586kMugSzwAAAAOyNe02",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15874780470",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T23:22:13Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2581434615,
      "node_id": "IC_kwDOABII586Z3ZD3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2581434615",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T23:22:14Z",
      "updated_at": "2025-01-09T23:22:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/35398283653</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2581434615",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15875391286,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOyPz82",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15875391286",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ab08987564dee21f805f8bc789b717e71eece9b7",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/ab08987564dee21f805f8bc789b717e71eece9b7",
      "created_at": "2025-01-10T01:19:28Z"
    },
    {
      "event": "unlabeled",
      "id": 15875791692,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAOyRVtM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15875791692",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-10T02:22:43Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15876195420,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOyS4Rc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15876195420",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fbd6568f6590726a3f786577628df1e6bcf971cc",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/fbd6568f6590726a3f786577628df1e6bcf971cc",
      "created_at": "2025-01-10T03:34:07Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15967733445,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAO3wEbF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15967733445",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9046cbf9ed4426ff8d2b9bec06f2ca72378f644c",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/9046cbf9ed4426ff8d2b9bec06f2ca72378f644c",
      "created_at": "2025-01-16T21:13:01Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16034249752,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAO7tzwY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16034249752",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e4a2fd900cdf417b231dc6cca33d0532adf1e9d4",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/e4a2fd900cdf417b231dc6cca33d0532adf1e9d4",
      "created_at": "2025-01-22T20:02:02Z"
    },
    {
      "event": "reviewed",
      "id": 2572752495,
      "node_id": "PRR_kwDOABII586ZWRZv",
      "url": null,
      "actor": null,
      "commit_id": "6cb99b067cf9028777a2036a8a3240c2511a3caf",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2572752495",
      "submitted_at": "2025-01-24T14:10:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16064776329,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAO9iQiJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16064776329",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a312648704640dc946939dfe42f21ebfcd62ae92",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/a312648704640dc946939dfe42f21ebfcd62ae92",
      "created_at": "2025-01-24T22:11:35Z"
    },
    {
      "event": "commented",
      "id": 2613488644,
      "node_id": "IC_kwDOABII586bxqwE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2613488644",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-24T22:14:46Z",
      "updated_at": "2025-01-24T22:14:46Z",
      "author_association": "MEMBER",
      "body": "Some changes:\r\n* As a result of dropping `Cleanup` in the base PR, `Trim` now reports which transactions it removed, as it becomes the caller's responsibility of destroying Refs.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2613488644",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "labeled",
      "id": 16065345293,
      "node_id": "LE_lADOABII586kMugSzwAAAAO9kbcN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16065345293",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-24T23:23:36Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2613584141,
      "node_id": "IC_kwDOABII586byCEN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2613584141",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-24T23:23:37Z",
      "updated_at": "2025-01-24T23:23:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/36148923463</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2613584141",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16068867983,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAO9x3eP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16068867983",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "52c4105a1c341a7a82dab3e792a2f8f5b9ca51b4",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/52c4105a1c341a7a82dab3e792a2f8f5b9ca51b4",
      "created_at": "2025-01-26T04:37:22Z"
    },
    {
      "event": "commented",
      "id": 2614209321,
      "node_id": "IC_kwDOABII586b0asp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2614209321",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-26T04:42:19Z",
      "updated_at": "2025-01-26T04:42:19Z",
      "author_association": "MEMBER",
      "body": "* Add support for calling `AddTransaction` with a feerate whose size already violates the cluster size limit.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2614209321",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "unlabeled",
      "id": 16070110443,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAO92mzr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16070110443",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-26T13:42:29Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16070941633,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAO95xvB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16070941633",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "df7185517f2d9ecae9a7c0114bf4a33ca73638a0",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/df7185517f2d9ecae9a7c0114bf4a33ca73638a0",
      "created_at": "2025-01-26T19:57:25Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16131781541,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPBh3Ol",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16131781541",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "265ad9efa9401c4cbe4395b88370c778fc5e6ae3",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/265ad9efa9401c4cbe4395b88370c778fc5e6ae3",
      "created_at": "2025-01-30T23:46:30Z"
    },
    {
      "event": "commented",
      "id": 2626051202,
      "node_id": "IC_kwDOABII586chlyC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2626051202",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T01:01:46Z",
      "updated_at": "2025-01-31T01:01:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/36451226624</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2626051202",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "labeled",
      "id": 16132409137,
      "node_id": "LE_lADOABII586kMugSzwAAAAPBkQcx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16132409137",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T01:01:46Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16134011538,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPBqXqS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16134011538",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e9b4cb1e9bd6309717372c4cc9d0dea3bb4010fa",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/e9b4cb1e9bd6309717372c4cc9d0dea3bb4010fa",
      "created_at": "2025-01-31T05:00:00Z"
    },
    {
      "event": "unlabeled",
      "id": 16134472638,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAPBsIO-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16134472638",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T06:09:40Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16146246231,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPCZCpX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16146246231",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2cac7317b6d799e276ccb3536c30d7b84fb2a765",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/2cac7317b6d799e276ccb3536c30d7b84fb2a765",
      "created_at": "2025-01-31T22:01:28Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16148263464,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPCgvIo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16148263464",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "42d725960c70c22c2ad7d94cb02dc12c407ae111",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/42d725960c70c22c2ad7d94cb02dc12c407ae111",
      "created_at": "2025-02-01T03:43:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16181709103,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPEgUkv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16181709103",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c4f31251b0e85079f6abfe776a23fecb2c832317",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/c4f31251b0e85079f6abfe776a23fecb2c832317",
      "created_at": "2025-02-04T16:18:01Z"
    },
    {
      "event": "labeled",
      "id": 16184169710,
      "node_id": "LE_lADOABII586kMugSzwAAAAPEptTu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16184169710",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-04T19:32:57Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 16186256526,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAPExqyO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16186256526",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-04T23:03:25Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16204090793,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPF1s2p",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16204090793",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9618a33eb754443a6bd7d1504d60896013d3a102",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/9618a33eb754443a6bd7d1504d60896013d3a102",
      "created_at": "2025-02-06T04:28:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16271005473,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPJ09ch",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16271005473",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9da91b512cc1c0ff1df657473b601ff6d1a4786c",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/9da91b512cc1c0ff1df657473b601ff6d1a4786c",
      "created_at": "2025-02-11T20:33:09Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGI5NjcwZmU5ZTljNDg5NDFlNTA3NmM3NmU2MGI0YTgzMjY1OGYwZTM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b9670fe9e9c48941e5076c76e60b4a832658f0e3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b9670fe9e9c48941e5076c76e60b4a832658f0e3",
      "tree": {
        "sha": "ed6b40a34b62ad336c9e4f72a28c07d4230726cd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ed6b40a34b62ad336c9e4f72a28c07d4230726cd"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/713bf66b1f7703473a7de3a5aab6171e7adebfd4",
          "sha": "713bf66b1f7703473a7de3a5aab6171e7adebfd4",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/713bf66b1f7703473a7de3a5aab6171e7adebfd4"
        }
      ],
      "message": "clusterlin: add FixLinearization function + fuzz test\n\nThis function takes an existing ordering for transactions in a DepGraph, and\nmakes it a valid linearization for it (i.e., topological). Any topological\nprefix of the input remains untouched.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T18:38:08Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-10-25T18:11:50Z"
      },
      "sha": "b9670fe9e9c48941e5076c76e60b4a832658f0e3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDIzYThiZjA3NTRkNTc3YjlmMzM2OWFjMzJlZDU2ODYwYTM2ZTBlNzU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/23a8bf0754d577b9f3369ac32ed56860a36e0e75",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/23a8bf0754d577b9f3369ac32ed56860a36e0e75",
      "tree": {
        "sha": "3bd2e5caf27c18d9758d79bdc732a4cd8d12cb74",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3bd2e5caf27c18d9758d79bdc732a4cd8d12cb74"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b9670fe9e9c48941e5076c76e60b4a832658f0e3",
          "sha": "b9670fe9e9c48941e5076c76e60b4a832658f0e3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b9670fe9e9c48941e5076c76e60b4a832658f0e3"
        }
      ],
      "message": "clusterlin: make IsAcyclic() a DepGraph member function\n\n... instead of being a separate test-only function.\n\nAlso add a fuzz test for it returning false.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T18:55:09Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-12T20:13:58Z"
      },
      "sha": "23a8bf0754d577b9f3369ac32ed56860a36e0e75"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDExZjMzZjdmY2I2NWZjNzZjYmZkZjU2MDE1ZTZjYTJmOGM1ODFiNjY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/11f33f7fcb65fc76cbfdf56015e6ca2f8c581b66",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/11f33f7fcb65fc76cbfdf56015e6ca2f8c581b66",
      "tree": {
        "sha": "ef79a9b3ab1a7b5fc14a87a3ce93b9d8364f334a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ef79a9b3ab1a7b5fc14a87a3ce93b9d8364f334a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/23a8bf0754d577b9f3369ac32ed56860a36e0e75",
          "sha": "23a8bf0754d577b9f3369ac32ed56860a36e0e75",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/23a8bf0754d577b9f3369ac32ed56860a36e0e75"
        }
      ],
      "message": "clusterlin: (refactor) ClusterIndex -> DepGraphIndex\n\nSince cluster_linearize.h does not actually have a Cluster type anymore, it is more\nappropriate to rename the index type to DepGraphIndex.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T18:57:35Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-31T21:26:06Z"
      },
      "sha": "11f33f7fcb65fc76cbfdf56015e6ca2f8c581b66"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGYzMjc5ZDVhMDYwY2Q5YjUzZDQ1ZDllZWYwYTAyN2I3OWNmOWEyOGY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f3279d5a060cd9b53d45d9eef0a027b79cf9a28f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f3279d5a060cd9b53d45d9eef0a027b79cf9a28f",
      "tree": {
        "sha": "f3137598699e67eec8e05bf05cce56171ad00ae4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f3137598699e67eec8e05bf05cce56171ad00ae4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/11f33f7fcb65fc76cbfdf56015e6ca2f8c581b66",
          "sha": "11f33f7fcb65fc76cbfdf56015e6ca2f8c581b66",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/11f33f7fcb65fc76cbfdf56015e6ca2f8c581b66"
        }
      ],
      "message": "feefrac: introduce tagged wrappers to distinguish vsize/WU rates",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T18:57:39Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-30T22:14:52Z"
      },
      "sha": "f3279d5a060cd9b53d45d9eef0a027b79cf9a28f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDFlMzFlZGVmZmQwYTMzZmFmNThlMzY1ZjM1NzkxMDE1YTY3ZmZhNTM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1e31edeffd0a33faf58e365f35791015a67ffa53",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/1e31edeffd0a33faf58e365f35791015a67ffa53",
      "tree": {
        "sha": "b5335f5a98df3a6987670728a10de6377ae3bb2b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b5335f5a98df3a6987670728a10de6377ae3bb2b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f3279d5a060cd9b53d45d9eef0a027b79cf9a28f",
          "sha": "f3279d5a060cd9b53d45d9eef0a027b79cf9a28f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f3279d5a060cd9b53d45d9eef0a027b79cf9a28f"
        }
      ],
      "message": "txgraph: (feature) add initial version\n\nThis adds an initial version of the txgraph module, with the TxGraph class.\nIt encapsulates knowledge about the fees, sizes, and dependencies between all\nmempool transactions, but nothing else.\n\nIn particular, it lacks knowledge about txids, inputs, outputs, CTransactions,\n... and so on. Instead, it exposes a generic TxGraph::Ref type to reference\nnodes in the TxGraph, which can be passed around and stored by layers on top.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:34Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-08-21T18:37:00Z"
      },
      "sha": "1e31edeffd0a33faf58e365f35791015a67ffa53"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGVlNzNhMDEyMTA5YTRiNTdhNmJkNmVlN2ZiMzRjZDY0ODk4MzRhMTg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ee73a012109a4b57a6bd6ee7fb34cd6489834a18",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ee73a012109a4b57a6bd6ee7fb34cd6489834a18",
      "tree": {
        "sha": "36a800dcf5e0fece40cd29aa8e92c33557e18760",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/36a800dcf5e0fece40cd29aa8e92c33557e18760"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1e31edeffd0a33faf58e365f35791015a67ffa53",
          "sha": "1e31edeffd0a33faf58e365f35791015a67ffa53",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/1e31edeffd0a33faf58e365f35791015a67ffa53"
        }
      ],
      "message": "txgraph: (tests) add simulation fuzz test\n\nThis adds a simulation fuzz test for txgraph, by comparing with a naive\nreimplementation that models the entire graph as a single DepGraph, and\nclusters in TxGraph as connected components within that DepGraph.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-15T19:15:12Z"
      },
      "sha": "ee73a012109a4b57a6bd6ee7fb34cd6489834a18"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGE5NGY2ZGQ4NzA4ZWE2MDBhNWVmZTZlMzhkMTY1NTBmMmIwMzdhODM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a94f6dd8708ea600a5efe6e38d16550f2b037a83",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a94f6dd8708ea600a5efe6e38d16550f2b037a83",
      "tree": {
        "sha": "cd6da4f490c8dc004f4000c69d57005b734f3442",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cd6da4f490c8dc004f4000c69d57005b734f3442"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ee73a012109a4b57a6bd6ee7fb34cd6489834a18",
          "sha": "ee73a012109a4b57a6bd6ee7fb34cd6489834a18",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ee73a012109a4b57a6bd6ee7fb34cd6489834a18"
        }
      ],
      "message": "txgraph: (tests) add internal sanity check function\n\nTo make testing more powerful, expose a function to perform an internal sanity\ncheck on the state of a TxGraph. This is especially important as TxGraphImpl\ncontains many redundantly represented pieces of information:\n\n* graph contains clusters, which refer to entries, but the entries refer back\n* graph maintains pointers to Ref objects, which point back to the graph.\n\nThis lets us make sure they are always in sync.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-15T03:45:46Z"
      },
      "sha": "a94f6dd8708ea600a5efe6e38d16550f2b037a83"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDdkZWM5NTYyMDY4ZTAxOGExMzVlZTRhNDQwNWNiYzA1ZjRhNmUxYjA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7dec9562068e018a135ee4a4405cbc05f4a6e1b0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/7dec9562068e018a135ee4a4405cbc05f4a6e1b0",
      "tree": {
        "sha": "16b47afa83105ae397104ccd0e71b25efac22194",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/16b47afa83105ae397104ccd0e71b25efac22194"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a94f6dd8708ea600a5efe6e38d16550f2b037a83",
          "sha": "a94f6dd8708ea600a5efe6e38d16550f2b037a83",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a94f6dd8708ea600a5efe6e38d16550f2b037a83"
        }
      ],
      "message": "txgraph: (optimization) avoid per-group vectors for clusters & dependencies\n\nInstead construct a single vector with the list of all clusters in all groups,\nand then store per-group offset/range in that list.\n\nFor dependencies, reuse m_deps_to_add, and store offset/range into that.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-26T04:23:28Z"
      },
      "sha": "7dec9562068e018a135ee4a4405cbc05f4a6e1b0"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDcyYWI1NGI3MGZiMDc5MTU0ODU4YTM3MTdmN2Y2MzlmZmFhMThhYTg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/72ab54b70fb079154858a3717f7f639ffaa18aa8",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/72ab54b70fb079154858a3717f7f639ffaa18aa8",
      "tree": {
        "sha": "31fc2cc4ed8be050bcf820546f7adf62629aeeb6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/31fc2cc4ed8be050bcf820546f7adf62629aeeb6"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7dec9562068e018a135ee4a4405cbc05f4a6e1b0",
          "sha": "7dec9562068e018a135ee4a4405cbc05f4a6e1b0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/7dec9562068e018a135ee4a4405cbc05f4a6e1b0"
        }
      ],
      "message": "txgraph: (feature) make max cluster count configurable and \"oversize\" state\n\nInstead of leaving the responsibility on higher layers to guarantee that\nno connected component within TxGraph (a barely exposed concept, except through\nGetCluster()) exceeds the cluster count limit, move this responsibility to\nTxGraph itself:\n* TxGraph retains a cluster count limit, but it becomes configurable at construction\n  time (this primarily helps with testing that it is properly enforced).\n* It is always allowed to perform mutators on TxGraph, even if they would cause the\n  cluster count limit to be exceeded. Instead, TxGraph exposes an IsOversized()\n  function, which queries whether it is in a special \"oversize\" state.\n* During oversize state, many inspectors are unavailable, but mutators remain valid,\n  so the higher layer can \"fix\" the oversize state before continuing.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-24T13:53:50Z"
      },
      "sha": "72ab54b70fb079154858a3717f7f639ffaa18aa8"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ3ZDQ0NmNhZTkzY2YxNDIyM2MxZTQ4YjMyNWI3ZTYxYmM3Mzg3NGU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/47d446cae93cf14223c1e48b325b7e61bc73874e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/47d446cae93cf14223c1e48b325b7e61bc73874e",
      "tree": {
        "sha": "029bc15126984cddacb5139e0a5204aa3d104db1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/029bc15126984cddacb5139e0a5204aa3d104db1"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/72ab54b70fb079154858a3717f7f639ffaa18aa8",
          "sha": "72ab54b70fb079154858a3717f7f639ffaa18aa8",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/72ab54b70fb079154858a3717f7f639ffaa18aa8"
        }
      ],
      "message": "txgraph: (optimization) avoid representative lookup for each dependency\n\nThe m_deps_to_add vector is sorted by child Cluster*, which matches the\norder of an_clusters. This means we can walk through m_deps_to_add while\ndoing the representative lookups for an_clusters, and reuse them.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-22T19:53:32Z"
      },
      "sha": "47d446cae93cf14223c1e48b325b7e61bc73874e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ4ZDMxNDVjZTYxNTljODg0OWMwNTY5OGYwYmZlZjE2N2ZkNjM5YTc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/48d3145ce6159c8849c05698f0bfef167fd639a7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/48d3145ce6159c8849c05698f0bfef167fd639a7",
      "tree": {
        "sha": "85153d0339e94f1a0b2d23fc63319da40d2d7fbb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/85153d0339e94f1a0b2d23fc63319da40d2d7fbb"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/47d446cae93cf14223c1e48b325b7e61bc73874e",
          "sha": "47d446cae93cf14223c1e48b325b7e61bc73874e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/47d446cae93cf14223c1e48b325b7e61bc73874e"
        }
      ],
      "message": "txgraph: (optimization) avoid looking up the same child cluster repeatedly\n\nSince m_deps_to_add has been sorted by child Cluster* already, all dependencies\nwith the same child will be processed consecutively. Take advantage of this by\nremember the last partition merged with, and reusing that if applicable.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-22T19:36:00Z"
      },
      "sha": "48d3145ce6159c8849c05698f0bfef167fd639a7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ0MzQ2MGRiNmJmNmY1MzU3OWRkMTVjZTFjZmNkZmM3YTQyMjdhMTA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/443460db6bf6f53579dd15ce1cfcdfc7a4227a10",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/443460db6bf6f53579dd15ce1cfcdfc7a4227a10",
      "tree": {
        "sha": "28f32492d679ca985ca92f85c0b17eddf2c21db9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/28f32492d679ca985ca92f85c0b17eddf2c21db9"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/48d3145ce6159c8849c05698f0bfef167fd639a7",
          "sha": "48d3145ce6159c8849c05698f0bfef167fd639a7",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/48d3145ce6159c8849c05698f0bfef167fd639a7"
        }
      ],
      "message": "txgraph: (optimization) delay chunking while sub-acceptable\n\nChunk-based information (primarily, chunk feerates) are never accessed without\nfirst bringing the relevant Clusters to an \"acceptable\" quality level. Thus,\nwhile operations are ongoing and Clusters are not acceptable, we can omit\ncomputing the chunkings and chunk feerates for Clusters.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-15T18:31:23Z"
      },
      "sha": "443460db6bf6f53579dd15ce1cfcdfc7a4227a10"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQzZjY1NzMxMzM0NTkyY2E5YTU0MDNlY2EzZDM0NjQ1N2QwODI0MmM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/43f65731334592ca9a5403eca3d346457d08242c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/43f65731334592ca9a5403eca3d346457d08242c",
      "tree": {
        "sha": "3e85045cf5c04390fc24ea8ccff4e11cddf44adb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3e85045cf5c04390fc24ea8ccff4e11cddf44adb"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/443460db6bf6f53579dd15ce1cfcdfc7a4227a10",
          "sha": "443460db6bf6f53579dd15ce1cfcdfc7a4227a10",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/443460db6bf6f53579dd15ce1cfcdfc7a4227a10"
        }
      ],
      "message": "txgraph: (optimization) special-case removal of tail of cluster\n\nWhen transactions are removed from the tail of a cluster, we know the existing\nlinearization remains acceptable/optimal (if it already was), but may just need\nsplitting, so special case these into separate quality levels.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-14T23:10:24Z"
      },
      "sha": "43f65731334592ca9a5403eca3d346457d08242c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDAyNTkwMGZhNzYxZmU3MzU3ZjlhM2Q4YjI1ZTFlNmQ3MTIzMTAxZTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/025900fa761fe7357f9a3d8b25e1e6d7123101e6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/025900fa761fe7357f9a3d8b25e1e6d7123101e6",
      "tree": {
        "sha": "cbe5064f659fa02441e886260f6215431070d582",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cbe5064f659fa02441e886260f6215431070d582"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/43f65731334592ca9a5403eca3d346457d08242c",
          "sha": "43f65731334592ca9a5403eca3d346457d08242c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/43f65731334592ca9a5403eca3d346457d08242c"
        }
      ],
      "message": "txgraph: (refactor) group per-graph data in ClusterSet\n\nThis is a preparation for a next commit where a TxGraph will start representing\npotentially two distinct graphs (a main one, and a staging one with proposed\nchanges).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-24T13:37:53Z"
      },
      "sha": "025900fa761fe7357f9a3d8b25e1e6d7123101e6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZkMTFkMGNkMzk0YmM1ZjY0YmIwNjMwNmJmNzFmMjk3MjUwODExMmQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6d11d0cd394bc5f64bb06306bf71f2972508112d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6d11d0cd394bc5f64bb06306bf71f2972508112d",
      "tree": {
        "sha": "88d0bada1a6ee1652ff6de30bb3075dc2016c9f6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/88d0bada1a6ee1652ff6de30bb3075dc2016c9f6"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/025900fa761fe7357f9a3d8b25e1e6d7123101e6",
          "sha": "025900fa761fe7357f9a3d8b25e1e6d7123101e6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/025900fa761fe7357f9a3d8b25e1e6d7123101e6"
        }
      ],
      "message": "txgraph: (refactor) abstract out ClearLocator\n\nMove a number of related modifications to TxGraphImpl into a separate\nfunction for removal of transactions. This is preparation for a later\ncommit where this will be useful in more than one place.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-24T15:00:59Z"
      },
      "sha": "6d11d0cd394bc5f64bb06306bf71f2972508112d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGVkNGJkMGM4NjNkMmQxMmVlNzc5ZmEzNDE1NWEwZWU0Y2ZmNGVlZjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ed4bd0c863d2d12ee779fa34155a0ee4cff4eef1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ed4bd0c863d2d12ee779fa34155a0ee4cff4eef1",
      "tree": {
        "sha": "0a787e87725c08f7088571846de9efafdb4a7e14",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0a787e87725c08f7088571846de9efafdb4a7e14"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6d11d0cd394bc5f64bb06306bf71f2972508112d",
          "sha": "6d11d0cd394bc5f64bb06306bf71f2972508112d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6d11d0cd394bc5f64bb06306bf71f2972508112d"
        }
      ],
      "message": "txgraph: (feature) add staging support\n\nIn order to make it easy to evaluate proposed changes to a TxGraph, introduce a\n\"staging\" mode, where mutators (AddTransaction, AddDependency, RemoveTransaction)\ndo not modify the actual graph, but just a staging version of it. That staging\ngraph can then be commited (replacing the main one with it), or aborted (discarding\nthe staging).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-04T14:40:53Z"
      },
      "sha": "ed4bd0c863d2d12ee779fa34155a0ee4cff4eef1"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDBlMzk0ODYwZjlkZjQ2ZWE4ZWRiNjhjYTNiYTU1NjVmMWNjYzE4ZTA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e394860f9df46ea8edb68ca3ba5565f1ccc18e0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0e394860f9df46ea8edb68ca3ba5565f1ccc18e0",
      "tree": {
        "sha": "75280ddeb73f9d959e97615ee4e9a3b9d1d359ab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/75280ddeb73f9d959e97615ee4e9a3b9d1d359ab"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ed4bd0c863d2d12ee779fa34155a0ee4cff4eef1",
          "sha": "ed4bd0c863d2d12ee779fa34155a0ee4cff4eef1",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ed4bd0c863d2d12ee779fa34155a0ee4cff4eef1"
        }
      ],
      "message": "txgraph: (optimization) cache oversizedness of graphs",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-25T05:27:52Z"
      },
      "sha": "0e394860f9df46ea8edb68ca3ba5565f1ccc18e0"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDg0NzRjMGNmZjkyYzE2YjFmM2FmOGE1MDBjMDZkMTFkNzU2YTY3ZDk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8474c0cff92c16b1f3af8a500c06d11d756a67d9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8474c0cff92c16b1f3af8a500c06d11d756a67d9",
      "tree": {
        "sha": "df49f944eaabbce15f9cb641e034cc9a6bca83a8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/df49f944eaabbce15f9cb641e034cc9a6bca83a8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e394860f9df46ea8edb68ca3ba5565f1ccc18e0",
          "sha": "0e394860f9df46ea8edb68ca3ba5565f1ccc18e0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0e394860f9df46ea8edb68ca3ba5565f1ccc18e0"
        }
      ],
      "message": "txgraph: (feature) destroying Ref means removing transaction\n\nBefore this commit, if a TxGraph::Ref object is destroyed, it becomes impossible\nto refer to, but the actual corresponding transaction node in the TxGraph remains,\nand remains indefinitely as there is no way to remove it.\n\nFix this by making the destruction of TxGraph::Ref trigger immediate removal of\nthe corresponding transaction in TxGraph, both in main and staging if it exists.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-03T16:25:49Z"
      },
      "sha": "8474c0cff92c16b1f3af8a500c06d11d756a67d9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDJlZWQ1MjcyZTAyNzBmOTgwN2E2MDg2MTYwNGVkMjg5ODAxYjMzYWQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2eed5272e0270f9807a60861604ed289801b33ad",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/2eed5272e0270f9807a60861604ed289801b33ad",
      "tree": {
        "sha": "ae9a5f7b2062bf18eca1687eece48493e9857d5b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ae9a5f7b2062bf18eca1687eece48493e9857d5b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8474c0cff92c16b1f3af8a500c06d11d756a67d9",
          "sha": "8474c0cff92c16b1f3af8a500c06d11d756a67d9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8474c0cff92c16b1f3af8a500c06d11d756a67d9"
        }
      ],
      "message": "txgraph: (feature) expose ability to compare transactions\n\nIn order to make it possible for higher layers to compare transaction quality\n(ordering within the implicit total ordering on the mempool), expose a comparison\nfunction and test it.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-14T21:16:59Z"
      },
      "sha": "2eed5272e0270f9807a60861604ed289801b33ad"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDVmNGZlMTQ5M2U0ZDQ4ZTlmOTE5NGY4ZjQ2NmQxYmVjODA1MjUyZjg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5f4fe1493e4d48e9f9194f8f466d1bec805252f8",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5f4fe1493e4d48e9f9194f8f466d1bec805252f8",
      "tree": {
        "sha": "dd0d3eca48905dda58c1d89c9e2998592321c360",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dd0d3eca48905dda58c1d89c9e2998592321c360"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2eed5272e0270f9807a60861604ed289801b33ad",
          "sha": "2eed5272e0270f9807a60861604ed289801b33ad",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/2eed5272e0270f9807a60861604ed289801b33ad"
        }
      ],
      "message": "txgraph: (feature) Add DoWork function\n\nThis can be called when the caller has time to spend now, and wants future operations\nto be fast.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-09T19:22:24Z"
      },
      "sha": "5f4fe1493e4d48e9f9194f8f466d1bec805252f8"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDRlNzE5NjY3OGYyNGJhZGJjNWFjMDBkMzFjYTNiNGI3MjU0Y2E5M2Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4e7196678f24badbc5ac00d31ca3b4b7254ca93f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4e7196678f24badbc5ac00d31ca3b4b7254ca93f",
      "tree": {
        "sha": "062d24d17b983ed030b5463e9c639a0c9b4e6fdc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/062d24d17b983ed030b5463e9c639a0c9b4e6fdc"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5f4fe1493e4d48e9f9194f8f466d1bec805252f8",
          "sha": "5f4fe1493e4d48e9f9194f8f466d1bec805252f8",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5f4fe1493e4d48e9f9194f8f466d1bec805252f8"
        }
      ],
      "message": "txgraph: (feature) Add CountDistinctClusters function",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-16T21:00:10Z"
      },
      "sha": "4e7196678f24badbc5ac00d31ca3b4b7254ca93f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGFiN2I5NzlmYmJlNTVkNzIzNDY3NGNjMDE0NWQ4NDNiMmE5OTM3NDE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ab7b979fbbe55d7234674cc0145d843b2a993741",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ab7b979fbbe55d7234674cc0145d843b2a993741",
      "tree": {
        "sha": "4e72abb29afbeb623040f6b802c00b4d5dd228e0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4e72abb29afbeb623040f6b802c00b4d5dd228e0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4e7196678f24badbc5ac00d31ca3b4b7254ca93f",
          "sha": "4e7196678f24badbc5ac00d31ca3b4b7254ca93f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4e7196678f24badbc5ac00d31ca3b4b7254ca93f"
        }
      ],
      "message": "txgraph: (preparation) multiple inputs to Get{Ancestors,Descendant}Refs\n\nThis is a preparation for the next commit, which adds a feature to request\nthe Refs to multiple ancestors/descendants at once.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-06T03:53:45Z"
      },
      "sha": "ab7b979fbbe55d7234674cc0145d843b2a993741"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDFhMmVhOTE1Mzk5MjY4ZGExOTZhZjFjZmZiYzYxMzk3NzhiZDkxZTI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1a2ea915399268da196af1cffbc6139778bd91e2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/1a2ea915399268da196af1cffbc6139778bd91e2",
      "tree": {
        "sha": "69e998a0852647d124e3d66b84b200dc748afe7a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/69e998a0852647d124e3d66b84b200dc748afe7a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ab7b979fbbe55d7234674cc0145d843b2a993741",
          "sha": "ab7b979fbbe55d7234674cc0145d843b2a993741",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ab7b979fbbe55d7234674cc0145d843b2a993741"
        }
      ],
      "message": "txgraph: (feature) Get{Ancestors,Descendants}Union",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-06T03:52:58Z"
      },
      "sha": "1a2ea915399268da196af1cffbc6139778bd91e2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGExZGUwZTVkYTNlMzM4ZmU3NDE0N2Y4YTFjY2UxY2RjNTUyZDM4NmM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a1de0e5da3e338fe74147f8a1cce1cdc552d386c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a1de0e5da3e338fe74147f8a1cce1cdc552d386c",
      "tree": {
        "sha": "c46cfb2476448e1f576bffdd9625b8e38105a75a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c46cfb2476448e1f576bffdd9625b8e38105a75a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1a2ea915399268da196af1cffbc6139778bd91e2",
          "sha": "1a2ea915399268da196af1cffbc6139778bd91e2",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/1a2ea915399268da196af1cffbc6139778bd91e2"
        }
      ],
      "message": "txgraph: (feature) Add GetMainStagingDiagrams function\n\nThis allows determining whether the changes in a staging diagram unambiguously improve\nthe graph, through CompareChunks().",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-28T15:40:42Z"
      },
      "sha": "a1de0e5da3e338fe74147f8a1cce1cdc552d386c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDNiNmRlZGQzYjM4MTQ3NzgzY2NhMzAyOTE5Y2I3ZGM3ODQ2OGVmZDM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3b6dedd3b38147783cca302919cb7dc78468efd3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/3b6dedd3b38147783cca302919cb7dc78468efd3",
      "tree": {
        "sha": "af3f352a4a699745be9d92117285bec54a9ceb7b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/af3f352a4a699745be9d92117285bec54a9ceb7b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a1de0e5da3e338fe74147f8a1cce1cdc552d386c",
          "sha": "a1de0e5da3e338fe74147f8a1cce1cdc552d386c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a1de0e5da3e338fe74147f8a1cce1cdc552d386c"
        }
      ],
      "message": "txgraph: (preparation) maintain chunk index\n\nThis is preparation for exposing mining and eviction functionality in\nTxGraph.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-14T20:54:03Z"
      },
      "sha": "3b6dedd3b38147783cca302919cb7dc78468efd3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDc3NmMzYmNkZDQ5OTBhZTUxN2QwMDgzNGM2NTJmMzg4MjFhMmFmZDI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/776c3bcdd4990ae517d00834c652f38821a2afd2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/776c3bcdd4990ae517d00834c652f38821a2afd2",
      "tree": {
        "sha": "5bb2d99385aa532f9aa6c5512c023a5bfaa21b5a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5bb2d99385aa532f9aa6c5512c023a5bfaa21b5a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3b6dedd3b38147783cca302919cb7dc78468efd3",
          "sha": "3b6dedd3b38147783cca302919cb7dc78468efd3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/3b6dedd3b38147783cca302919cb7dc78468efd3"
        }
      ],
      "message": "txgraph: (feature) introduce BlockBuilder interface\n\nThis interface lets one iterate efficiently over the chunks of the main\ngraph in a TxGraph, in the same order as CompareMainOrder. Each chunk\ncan be marked as \"included\" or \"skipped\" (and in the latter case,\ndependent chunks will be skipped).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-25T16:31:02Z"
      },
      "sha": "776c3bcdd4990ae517d00834c652f38821a2afd2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA1ZjI5M2E4NWI4ZjE5M2MzMTVjZDBkYzE2Y2U5ZWYxOTRiM2UzZjA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/05f293a85b8f193c315cd0dc16ce9ef194b3e3f0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/05f293a85b8f193c315cd0dc16ce9ef194b3e3f0",
      "tree": {
        "sha": "724639091501a0f64f5698cabfc76515190d7aa9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/724639091501a0f64f5698cabfc76515190d7aa9"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/776c3bcdd4990ae517d00834c652f38821a2afd2",
          "sha": "776c3bcdd4990ae517d00834c652f38821a2afd2",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/776c3bcdd4990ae517d00834c652f38821a2afd2"
        }
      ],
      "message": "txgraph: (feature) introduce TxGraph::GetWorstMainChunk\n\nIt returns the last chunk that would be suggested for mining by BlockBuilder\nobjects. This is intended for eviction.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-08T22:18:12Z"
      },
      "sha": "05f293a85b8f193c315cd0dc16ce9ef194b3e3f0"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGFlMWUxYjZiMTliM2IzNmJjNjk3MjI2ZTJmNjRlYzA2NGZkNGE0MDg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ae1e1b6b19b3b36bc697226e2f64ec064fd4a408",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ae1e1b6b19b3b36bc697226e2f64ec064fd4a408",
      "tree": {
        "sha": "762894171fd2988415db7a3502d7e95e8e8860aa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/762894171fd2988415db7a3502d7e95e8e8860aa"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/05f293a85b8f193c315cd0dc16ce9ef194b3e3f0",
          "sha": "05f293a85b8f193c315cd0dc16ce9ef194b3e3f0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/05f293a85b8f193c315cd0dc16ce9ef194b3e3f0"
        }
      ],
      "message": "txgraph: (optimization) reuse discarded chunkindex entries",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-02T18:33:41Z"
      },
      "sha": "ae1e1b6b19b3b36bc697226e2f64ec064fd4a408"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDViMGYzMWQ5NWM2MDhlMDQ3YTE0ZTY5YjczYmVlNGM3NWU0NjFkNGQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5b0f31d95c608e047a14e69b73bee4c75e461d4d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5b0f31d95c608e047a14e69b73bee4c75e461d4d",
      "tree": {
        "sha": "0c932c885abed3f40d35e1cbc6f96c15c6743273",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0c932c885abed3f40d35e1cbc6f96c15c6743273"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ae1e1b6b19b3b36bc697226e2f64ec064fd4a408",
          "sha": "ae1e1b6b19b3b36bc697226e2f64ec064fd4a408",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ae1e1b6b19b3b36bc697226e2f64ec064fd4a408"
        }
      ],
      "message": "txgraph: (optimization) skipping end of cluster has no impact",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-27T21:12:10Z"
      },
      "sha": "5b0f31d95c608e047a14e69b73bee4c75e461d4d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGRmNzc1NTBlNWU1NDYyNWZhYTBjOGNlMzNiNGYyOGJiNTI0ODBlYTA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/df77550e5e54625faa0c8ce33b4f28bb52480ea0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/df77550e5e54625faa0c8ce33b4f28bb52480ea0",
      "tree": {
        "sha": "348be45ecaf7c7e76c448850508b06874713fab8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/348be45ecaf7c7e76c448850508b06874713fab8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5b0f31d95c608e047a14e69b73bee4c75e461d4d",
          "sha": "5b0f31d95c608e047a14e69b73bee4c75e461d4d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5b0f31d95c608e047a14e69b73bee4c75e461d4d"
        }
      ],
      "message": "txgraph: (optimization) special-case singletons in chunk index",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-27T20:29:40Z"
      },
      "sha": "df77550e5e54625faa0c8ce33b4f28bb52480ea0"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGNmZmEwZmU0NWVmMWMzNzQzYTkyNWQ4Y2NjNDM2NDQ0YTA2MDU0NGY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cffa0fe45ef1c3743a925d8ccc436444a060544f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/cffa0fe45ef1c3743a925d8ccc436444a060544f",
      "tree": {
        "sha": "ee7f9b64b1971e97350d4415a5249c02939b57ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ee7f9b64b1971e97350d4415a5249c02939b57ae"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/df77550e5e54625faa0c8ce33b4f28bb52480ea0",
          "sha": "df77550e5e54625faa0c8ce33b4f28bb52480ea0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/df77550e5e54625faa0c8ce33b4f28bb52480ea0"
        }
      ],
      "message": "txgraph: (feature) Add ability to configure maximum cluster size (weight)\n\nThis is integrated with the oversized property: the graph is oversized when\nany connected component within it contains more than the cluster count limit\nmany transactions, or when their combined size/weight exceeds the cluster size\nlimit.\n\nIt becomes disallowed to call AddTransaction with a size larger than this limit.\nIn addition, SetTransactionFeeRate becomes SetTransactionFee, so that we do not\nneed to deal with the case that a call to this function might affect the\noversizedness.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-17T13:13:25Z"
      },
      "sha": "cffa0fe45ef1c3743a925d8ccc436444a060544f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ3NDJhMzAxOTc4ODQ0MmMzZmJkZDUzYzY2MDEwNjc3YmE0YWUzNjc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4742a3019788442c3fbdd53c66010677ba4ae367",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4742a3019788442c3fbdd53c66010677ba4ae367",
      "tree": {
        "sha": "7da61bfac190b98680d106063eef03740de1ab31",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7da61bfac190b98680d106063eef03740de1ab31"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cffa0fe45ef1c3743a925d8ccc436444a060544f",
          "sha": "cffa0fe45ef1c3743a925d8ccc436444a060544f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/cffa0fe45ef1c3743a925d8ccc436444a060544f"
        }
      ],
      "message": "txgraph: (feature) permit transactions that exceed cluster size limit",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-25T19:24:41Z"
      },
      "sha": "4742a3019788442c3fbdd53c66010677ba4ae367"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDgwMWM3NTcwYTU4MTk5Y2E0MTJiYmJlYzY5MDIyMjZjYWI0NGRmZGU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/801c7570a58199ca412bbbec6902226cab44dfde",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/801c7570a58199ca412bbbec6902226cab44dfde",
      "tree": {
        "sha": "a8af532e457bc59af8a62243d5f7583c5eef5a32",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a8af532e457bc59af8a62243d5f7583c5eef5a32"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4742a3019788442c3fbdd53c66010677ba4ae367",
          "sha": "4742a3019788442c3fbdd53c66010677ba4ae367",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4742a3019788442c3fbdd53c66010677ba4ae367"
        }
      ],
      "message": "txgraph: (preparation) include oversized clusters in groups",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-25T22:23:22Z"
      },
      "sha": "801c7570a58199ca412bbbec6902226cab44dfde"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQzOGI2NzIzZGY5MDdhOGQ3NmJkZTQxYzNmOWZlZDRmODA1M2JmNTI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d38b6723df907a8d76bde41c3f9fed4f8053bf52",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d38b6723df907a8d76bde41c3f9fed4f8053bf52",
      "tree": {
        "sha": "7ba6c8016faf481f751e451fd6f2525951217386",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7ba6c8016faf481f751e451fd6f2525951217386"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/801c7570a58199ca412bbbec6902226cab44dfde",
          "sha": "801c7570a58199ca412bbbec6902226cab44dfde",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/801c7570a58199ca412bbbec6902226cab44dfde"
        }
      ],
      "message": "txgraph: (feature) Add ability to trim oversized clusters\n\nDuring reorganisations, it is possible that dependencies get add which\nresult in clusters that violate limits (count, size), when linking the\nnew from-block transactions to the old from-mempool transactions.\n\nUnlike RBF scenarios, we cannot simply reject these policy violations\nwhen they are due to received blocks. To accomodate this, add a Trim()\nfunction to TxGraph, which removes transactions (including descendants)\nin order to make all resulting clusters satisfy the limits.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-16T22:57:57Z"
      },
      "sha": "d38b6723df907a8d76bde41c3f9fed4f8053bf52"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGM3NjI0YWMxNjkzNGJkZjFkYzEwNmY4N2NlNjZkYTMyOGNlZWVkM2Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "tree": {
        "sha": "e7b43734f3fb14eca11c5ebf56faa61f5ce2b91c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e7b43734f3fb14eca11c5ebf56faa61f5ce2b91c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d38b6723df907a8d76bde41c3f9fed4f8053bf52",
          "sha": "d38b6723df907a8d76bde41c3f9fed4f8053bf52",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d38b6723df907a8d76bde41c3f9fed4f8053bf52"
        }
      ],
      "message": "txgraph: (improvement) track multiple potential would-be clusters in Trim\n\nIn a Trim function, for any given would-be group of clusters, a (rudimentary)\nlinearization for the would-be cluster is constructed on the fly by adding\neligible transactions to a heap. This continues until the total count or\nsize of the transaction exists a configured limit. Any transactions which\nappear later in this linearization are discarded.\n\nHowever, given that transactions at the end are discarded, it is possible that\nthe would-be cluster splits apart into multiple clusters. And those clusters\nmay well permit far more transactions before their limits are reached.\n\nTake this into account by using a union-find structure inside TrimTxData to\nkeep track of the count/size of all would-be clusters that would be formed\nat any point.\n\nThis is not an optimization in terms of CPU usage or memory; it just\nimproves the quality of the transactions removed by Trim().",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-12T22:28:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-20T04:06:07Z"
      },
      "sha": "c7624ac16934bdf1dc106f87ce66da328ceeed3d"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16287907888,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPK1cAw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16287907888",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "created_at": "2025-02-12T22:29:24Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909286865",
      "pull_request_review_id": 2540686525,
      "id": 1909286865,
      "node_id": "PRRC_kwDOABII585xzWfR",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;",
      "path": "src/txgraph.cpp",
      "position": 1630,
      "original_position": 953,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm not sure how this is intended to be used, but storing a stack address seems like a problem? RVO may help but that seems brittle. I imagine the caller should be passing in their own `Ref` instead?",
      "created_at": "2025-01-09T18:43:50Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909286865",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909286865"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1630,
      "original_line": 1630,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909293407",
      "pull_request_review_id": 2540686525,
      "id": 1909293407,
      "node_id": "PRRC_kwDOABII585xzYFf",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeeFrac Cluster::GetIndividualFeerate(ClusterIndex idx) noexcept\n+{\n+    return m_depgraph.FeeRate(idx);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeeFrac TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeeFrac{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeeFrac TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified ClusterIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (m_quality != QualityLevel::NEEDS_SPLIT) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(Ref& ref, int64_t fee) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    auto& locator = entry.m_locator;\n+    if (locator.IsPresent()) {\n+        locator.cluster->SetFee(*this, locator.index, fee);\n+    }\n+}\n+\n+} // namespace\n+\n+TxGraph::Ref::~Ref()\n+{\n+    if (m_graph) {\n+        // Inform the TxGraph about the Ref being destroyed.\n+        m_graph->UnlinkRef(m_index);\n+        m_graph = nullptr;\n+    }\n+}\n+\n+TxGraph::Ref& TxGraph::Ref::operator=(Ref&& other) noexcept\n+{\n+    // Inform both TxGraphs about the Refs being swapped.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1172,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why is this doing an effective swap? I would expect this to call `UnlinkRef` on the moved-from value and reset its `m_graph` and `m_index`. Otherwise it wouldn't be unlinked until the moved-from variable goes out of scope, no?",
      "created_at": "2025-01-09T18:48:55Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909293407",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909293407"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909295799",
      "pull_request_review_id": 2540686525,
      "id": 1909295799,
      "node_id": "PRRC_kwDOABII585xzYq3",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 188,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`m_ref{nullptr};`",
      "created_at": "2025-01-09T18:51:18Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909295799",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909295799"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909307659",
      "pull_request_review_id": 2540686525,
      "id": 1909307659,
      "node_id": "PRRC_kwDOABII585xzbkL",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 297,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Trying to convince myself this is guaranteed to terminate...\r\n\r\n`do{} while (!chunk.transactions.None())` rather than the `break` for readability? Or just `while()` if we need to guard against an empty linearization (presumably not?)",
      "created_at": "2025-01-09T19:02:47Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909307659",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909307659"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909321579",
      "pull_request_review_id": 2540686525,
      "id": 1909321579,
      "node_id": "PRRC_kwDOABII585xze9r",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;",
      "path": "src/txgraph.cpp",
      "position": 751,
      "original_position": 311,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Assume `!to_remove.empty()` or early return if it's allowed?",
      "created_at": "2025-01-09T19:17:27Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909321579",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909321579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 751,
      "original_line": 751,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909348870",
      "pull_request_review_id": 2540686525,
      "id": 1909348870,
      "node_id": "PRRC_kwDOABII585xzloG",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1007,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Looks like these 3 functions could `reserve()` for their `ret` vectors.",
      "created_at": "2025-01-09T19:42:45Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909348870",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909348870"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1662,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909385059",
      "pull_request_review_id": 2540851568,
      "id": 1909385059,
      "node_id": "PRRC_kwDOABII585xzudj",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;",
      "path": "src/txgraph.cpp",
      "position": 1630,
      "original_position": 953,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909286865,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I believe it is safe, both with NRVO and without.\r\n\r\nWith NRVO, `ret` is constructed directly in the caller's target destination, so this isn't a pointer to local stack space.\r\n\r\nWithout NRVO, the `Ref(Ref&&)` move constructor is invoked by `return ret;`, which will update the pointer to the caller's destination.",
      "created_at": "2025-01-09T20:19:28Z",
      "updated_at": "2025-01-09T21:17:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909385059",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909385059"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1630,
      "original_line": 1630,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909403690",
      "pull_request_review_id": 2540882536,
      "id": 1909403690,
      "node_id": "PRRC_kwDOABII585xzzAq",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeeFrac Cluster::GetIndividualFeerate(ClusterIndex idx) noexcept\n+{\n+    return m_depgraph.FeeRate(idx);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeeFrac TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeeFrac{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeeFrac TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified ClusterIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (m_quality != QualityLevel::NEEDS_SPLIT) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(Ref& ref, int64_t fee) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    auto& locator = entry.m_locator;\n+    if (locator.IsPresent()) {\n+        locator.cluster->SetFee(*this, locator.index, fee);\n+    }\n+}\n+\n+} // namespace\n+\n+TxGraph::Ref::~Ref()\n+{\n+    if (m_graph) {\n+        // Inform the TxGraph about the Ref being destroyed.\n+        m_graph->UnlinkRef(m_index);\n+        m_graph = nullptr;\n+    }\n+}\n+\n+TxGraph::Ref& TxGraph::Ref::operator=(Ref&& other) noexcept\n+{\n+    // Inform both TxGraphs about the Refs being swapped.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1172,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909293407,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Why is this doing an effective swap? \r\n\r\nI think this is quite common, that move-construction is effectively performing a swap.\r\n\r\n> I would expect this to call `UnlinkRef` on the moved-from value and reset its `m_graph` and `m_index`\r\n\r\nThat's possible too, and slightly more efficient I guess.\r\n\r\n> Otherwise it wouldn't be unlinked until the moved-from variable goes out of scope, no?\r\n\r\nIndeed. I don't think that's a problem.\r\n\r\n",
      "created_at": "2025-01-09T20:38:36Z",
      "updated_at": "2025-01-09T20:38:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909403690",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909403690"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909458303",
      "pull_request_review_id": 2540971508,
      "id": 1909458303,
      "node_id": "PRRC_kwDOABII585x0AV_",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeeFrac Cluster::GetIndividualFeerate(ClusterIndex idx) noexcept\n+{\n+    return m_depgraph.FeeRate(idx);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeeFrac TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeeFrac{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeeFrac TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified ClusterIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (m_quality != QualityLevel::NEEDS_SPLIT) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(Ref& ref, int64_t fee) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    auto& locator = entry.m_locator;\n+    if (locator.IsPresent()) {\n+        locator.cluster->SetFee(*this, locator.index, fee);\n+    }\n+}\n+\n+} // namespace\n+\n+TxGraph::Ref::~Ref()\n+{\n+    if (m_graph) {\n+        // Inform the TxGraph about the Ref being destroyed.\n+        m_graph->UnlinkRef(m_index);\n+        m_graph = nullptr;\n+    }\n+}\n+\n+TxGraph::Ref& TxGraph::Ref::operator=(Ref&& other) noexcept\n+{\n+    // Inform both TxGraphs about the Refs being swapped.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1172,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909293407,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Anyway, done!",
      "created_at": "2025-01-09T21:34:51Z",
      "updated_at": "2025-01-09T21:34:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909458303",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909458303"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909458391",
      "pull_request_review_id": 2540971629,
      "id": 1909458391,
      "node_id": "PRRC_kwDOABII585x0AXX",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 188,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909295799,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-01-09T21:34:56Z",
      "updated_at": "2025-01-09T21:34:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909458391",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909458391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909462275",
      "pull_request_review_id": 2540977582,
      "id": 1909462275,
      "node_id": "PRRC_kwDOABII585x0BUD",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 297,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909307659,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It terminates because:\r\n* Every chunk contains at least one element (added an Assume for that)\r\n* In the inner loop, one element from that chunk is Reset() (added an Assume that it indeed resets a bit that was previously set).\r\n\r\nI've changed it to a `do {} while(chunk.transactions.Any());` loop in the first commits, though it reverts back to a `while (true) { ... }` loop later, when the loop becomes a bit more complex.",
      "created_at": "2025-01-09T21:39:12Z",
      "updated_at": "2025-01-09T21:39:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909462275",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909462275"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909463152",
      "pull_request_review_id": 2540978925,
      "id": 1909463152,
      "node_id": "PRRC_kwDOABII585x0Bhw",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;",
      "path": "src/txgraph.cpp",
      "position": 751,
      "original_position": 311,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909321579,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done. I've also added a comment to the `Cluster::ApplyRemovals()` function definition stating that at least one element from the front of `to_remove` must belong to `this` Cluster (which is really why that requirement exists).",
      "created_at": "2025-01-09T21:40:05Z",
      "updated_at": "2025-01-09T21:40:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909463152",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909463152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 751,
      "original_line": 751,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909463444",
      "pull_request_review_id": 2540979340,
      "id": 1909463444,
      "node_id": "PRRC_kwDOABII585x0BmU",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1007,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909348870,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done. The third one disappears in a later commit, though.",
      "created_at": "2025-01-09T21:40:22Z",
      "updated_at": "2025-01-09T21:40:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909463444",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909463444"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1662,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909477090",
      "pull_request_review_id": 2541000748,
      "id": 1909477090,
      "node_id": "PRRC_kwDOABII585x0E7i",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeeFrac Cluster::GetIndividualFeerate(ClusterIndex idx) noexcept\n+{\n+    return m_depgraph.FeeRate(idx);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeeFrac TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeeFrac{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeeFrac TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified ClusterIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (m_quality != QualityLevel::NEEDS_SPLIT) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(Ref& ref, int64_t fee) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    auto& locator = entry.m_locator;\n+    if (locator.IsPresent()) {\n+        locator.cluster->SetFee(*this, locator.index, fee);\n+    }\n+}\n+\n+} // namespace\n+\n+TxGraph::Ref::~Ref()\n+{\n+    if (m_graph) {\n+        // Inform the TxGraph about the Ref being destroyed.\n+        m_graph->UnlinkRef(m_index);\n+        m_graph = nullptr;\n+    }\n+}\n+\n+TxGraph::Ref& TxGraph::Ref::operator=(Ref&& other) noexcept\n+{\n+    // Inform both TxGraphs about the Refs being swapped.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1172,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909293407,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> > Why is this doing an effective swap?\r\n> \r\n> I think this is quite common, that move-construction is effectively performing a swap.\r\n> \r\n> > I would expect this to call `UnlinkRef` on the moved-from value and reset its `m_graph` and `m_index`\r\n> \r\n> That's possible too, and slightly more efficient I guess.\r\n> \r\n> > Otherwise it wouldn't be unlinked until the moved-from variable goes out of scope, no?\r\n> \r\n> Indeed. I don't think that's a problem.\r\n\r\nAfaik the move/swap idiom is only safe if the swapped-to value's dtor doesn't have any interesting ordering requirements or side-effects.\r\n\r\nAs a contrived example, a user may do something like:\r\n```c++\r\nstd::vector<TxGraph::Ref> vec;\r\n\r\nvec.push_back(txgraph->AddTransaction(fee));\r\nauto ref = txgraph->AddTransaction(fee2);\r\n...\r\nref = std::move(vec.back());\r\n```\r\nThe vector now holds the old ref and `UnlinkRef` will not be called until that element is removed. I realize it's allowed to be a \"valid but unspecified state\", but I wouldn't expect a ref to be hanging around.",
      "created_at": "2025-01-09T21:56:14Z",
      "updated_at": "2025-01-09T21:56:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909477090",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909477090"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909492867",
      "pull_request_review_id": 2541025670,
      "id": 1909492867,
      "node_id": "PRRC_kwDOABII585x0IyD",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;",
      "path": "src/txgraph.cpp",
      "position": 1630,
      "original_position": 953,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909286865,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, right, I missed that the move ctor would handle the update. Thanks for explaining.",
      "created_at": "2025-01-09T22:15:14Z",
      "updated_at": "2025-01-09T22:15:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909492867",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909492867"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1630,
      "original_line": 1630,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1928741430",
      "pull_request_review_id": 2572752495,
      "id": 1928741430,
      "node_id": "PRRC_kwDOABII585y9kI2",
      "diff_hunk": "@@ -1449,6 +1465,7 @@ Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_in\n TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n {\n     Assume(m_chunkindex_observers == 0 || m_clustersets.size() > 1);\n+    Assume(feerate.size > 0 && uint64_t(feerate.size) <= m_max_cluster_size);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "6cb99b067cf9028777a2036a8a3240c2511a3caf",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "FYI -- in my rebase of #28676, I'm seeing `tx_pool` fuzz test failures due to this line. Not clear to me whether we should require the caller to enforce the policy requirement that a single tx be below the cluster size limit, or just let the caller discover a changeset is oversized and then reject?",
      "created_at": "2025-01-24T14:10:51Z",
      "updated_at": "2025-01-24T14:10:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1928741430",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1928741430"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1928775309",
      "pull_request_review_id": 2572810863,
      "id": 1928775309,
      "node_id": "PRRC_kwDOABII585y9saN",
      "diff_hunk": "@@ -1449,6 +1465,7 @@ Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_in\n TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n {\n     Assume(m_chunkindex_observers == 0 || m_clustersets.size() > 1);\n+    Assume(feerate.size > 0 && uint64_t(feerate.size) <= m_max_cluster_size);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "6cb99b067cf9028777a2036a8a3240c2511a3caf",
      "in_reply_to_id": 1928741430,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Right. That rule exists because the alternative requires existing clusters to be oversized as AddTransaction constructs a singleton cluster instantly. All other forms of oversizedness happen as a result of applying dependencies, which are done lazily.\r\n\r\nI'll think about relaxing this.",
      "created_at": "2025-01-24T14:34:05Z",
      "updated_at": "2025-01-24T14:34:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1928775309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1928775309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1929869292",
      "pull_request_review_id": 2574392651,
      "id": 1929869292,
      "node_id": "PRRC_kwDOABII585zB3fs",
      "diff_hunk": "@@ -1449,6 +1465,7 @@ Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_in\n TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n {\n     Assume(m_chunkindex_observers == 0 || m_clustersets.size() > 1);\n+    Assume(feerate.size > 0 && uint64_t(feerate.size) <= m_max_cluster_size);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "original_commit_id": "6cb99b067cf9028777a2036a8a3240c2511a3caf",
      "in_reply_to_id": 1928741430,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, it is now allowed to have individually oversized transactions.",
      "created_at": "2025-01-26T20:45:43Z",
      "updated_at": "2025-01-26T20:45:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1929869292",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1929869292"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1548,
      "side": "RIGHT"
    }
  ]
}