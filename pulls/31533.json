{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533",
    "id": 2242801623,
    "node_id": "PR_kwDOABII586Frm_X",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/31533",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/31533.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/31533.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/db2d39f642979f929261e5f1cd67f0c2f2ca045f",
    "number": 31533,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "fuzz: Add fuzz target for block index tree and related validation events",
    "user": {
      "login": "mzumsande",
      "id": 48763452,
      "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
      "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mzumsande",
      "html_url": "https://github.com/mzumsande",
      "followers_url": "https://api.github.com/users/mzumsande/followers",
      "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
      "organizations_url": "https://api.github.com/users/mzumsande/orgs",
      "repos_url": "https://api.github.com/users/mzumsande/repos",
      "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/mzumsande/received_events",
      "type": "User",
      "site_admin": false,
      "name": null,
      "patch_url": null
    },
    "body": "This adds a fuzz target for the block index and various events in validation that interact with it.\r\n\r\nIt can create arbitrary tree-like structure of block indexes, simulating (so far) the following events:\r\n- Adding a header\r\n- Receiving the full block (may be valid or not)\r\n- `ActivateBestChain()` - Reorging the chain to a new chain tip (possibly encountering invalid blocks on the way)\r\n- Pruning a block in the best chain\r\n- Receiving a previously pruned block again (`getblockfrompeer`)\r\n\r\nIt might be interesting / possible to extend this to more events, such as dealing with more than one chainstate (assumeutxo).\r\n\r\nThe test skips all actual validation of header/ block / transaction data by just simulating the outcome, and also doesn't interact with the data directory.\r\nThe main goal is to ensure the integrity of the block index tree in all fuzzed constellations, by calling `CheckBlockIndex()` at the end of each iteration.\r\n\r\nCompared to #29158 this approach has a more limited scope (by skipping all actual validation), but it is fast - it doesn't do a full init sequence on each iteration, but \"cleans up\" after itself by resetting the global validation state after each iteration.",
    "labels": [
      {
        "id": 62963516,
        "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
        "name": "Tests",
        "color": "d4c5f9",
        "default": false
      },
      {
        "id": 9554944034,
        "node_id": "LA_kwDOABII588AAAACOYTgIg",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Fuzzing",
        "name": "Fuzzing",
        "description": "",
        "color": "0e8a16",
        "default": false
      }
    ],
    "created_at": "2024-12-18T17:53:26Z",
    "updated_at": "2026-01-11T17:10:37Z",
    "closed_at": "2025-12-18T15:26:47Z",
    "mergeable_state": "unknown",
    "merged": true,
    "merged_at": "2025-12-18T15:26:47Z",
    "merged_by": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false,
      "name": null,
      "patch_url": null
    },
    "merge_commit_sha": "516ae5ede44a8a6abc59e90f9d89913e254524f4",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "head": {
      "label": "mzumsande:202412_fuzz_checkblockindex_pr",
      "ref": "202412_fuzz_checkblockindex_pr",
      "sha": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 187673073,
        "node_id": "MDEwOlJlcG9zaXRvcnkxODc2NzMwNzM=",
        "name": "bitcoin",
        "full_name": "mzumsande/bitcoin",
        "owner": {
          "login": "mzumsande",
          "id": 48763452,
          "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
          "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/mzumsande",
          "html_url": "https://github.com/mzumsande",
          "followers_url": "https://api.github.com/users/mzumsande/followers",
          "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
          "organizations_url": "https://api.github.com/users/mzumsande/orgs",
          "repos_url": "https://api.github.com/users/mzumsande/repos",
          "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/mzumsande/received_events",
          "type": "User",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/mzumsande/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/mzumsande/bitcoin",
        "archive_url": "https://api.github.com/repos/mzumsande/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/mzumsande/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/mzumsande/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/mzumsande/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/mzumsande/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/mzumsande/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/mzumsande/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/mzumsande/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/mzumsande/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/mzumsande/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/mzumsande/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/mzumsande/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/mzumsande/bitcoin/events",
        "forks_url": "https://api.github.com/repos/mzumsande/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/mzumsande/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/mzumsande/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/mzumsande/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/mzumsande/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/mzumsande/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/mzumsande/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/mzumsande/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/mzumsande/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/mzumsande/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/mzumsande/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/mzumsande/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/mzumsande/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/mzumsande/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/mzumsande/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/mzumsande/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:mzumsande/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/mzumsande/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/mzumsande/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/mzumsande/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/mzumsande/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/mzumsande/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/mzumsande/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/mzumsande/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/mzumsande/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/mzumsande/bitcoin/hooks",
        "svn_url": "https://github.com/mzumsande/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 0,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 279596,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-01-11T16:47:03Z",
        "created_at": "2019-05-20T16:03:10Z",
        "updated_at": "2025-12-18T16:51:52Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "13891a8a685d255cb13dd5018e3d5ccc18b07c34",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 38800,
        "stargazers_count": 87616,
        "watchers_count": 87616,
        "size": 301415,
        "default_branch": "master",
        "open_issues_count": 752,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-01-09T22:24:23Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2026-01-11T17:13:38Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 302,
    "deletions": 8,
    "changed_files": 6,
    "commits": 3,
    "review_comments": 52,
    "comments": 16
  },
  "events": [
    {
      "event": "commented",
      "id": 2551941878,
      "node_id": "IC_kwDOABII586YG4r2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2551941878",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-18T17:53:29Z",
      "updated_at": "2025-12-18T15:19:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/31533.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [maflcko](https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-3587318193), [sedited](https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-3587573179), [Crypt-iQ](https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-3670814276) |\n| Concept ACK | [ismaelsadeeq](https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-2931888182), [dergoegge](https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-3433037258) |\n\nIf your review is incorrectly listed, please copy-paste <code>&lt;!--meta-tag:bot-skip--&gt;</code> into the comment that the bot should ignore.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#34075](https://github.com/bitcoin/bitcoin/pull/34075) (fees: Introduce Mempool Based Fee Estimation to reduce overestimation by ismaelsadeeq)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-2551941878",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "labeled",
      "id": 15707020361,
      "node_id": "LE_lADOABII586j0ZifzwAAAAOoNhxJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15707020361",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-18T17:53:32Z",
      "label": {
        "name": "Tests",
        "color": "d4c5f9"
      }
    },
    {
      "event": "convert_to_draft",
      "id": 15707124651,
      "node_id": "CTDE_lADOABII586j0ZifzwAAAAOoN7Or",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15707124651",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-18T18:03:27Z"
    },
    {
      "event": "labeled",
      "id": 16033083745,
      "node_id": "LE_lADOABII586j0ZifzwAAAAO7pXFh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16033083745",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-22T18:14:23Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16049115812,
      "node_id": "HRFPE_lADOABII586j0ZifzwAAAAO8mhKk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16049115812",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "98d68e00c25c68cdcb9863b75fc10af3e81ad239",
      "commit_url": "https://api.github.com/repos/mzumsande/bitcoin/commits/98d68e00c25c68cdcb9863b75fc10af3e81ad239",
      "created_at": "2025-01-23T19:51:44Z"
    },
    {
      "event": "unlabeled",
      "id": 16049880991,
      "node_id": "UNLE_lADOABII586j0ZifzwAAAAO8pb-f",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16049880991",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-23T21:07:25Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2594613872,
      "node_id": "PRR_kwDOABII586apqpw",
      "url": null,
      "actor": null,
      "commit_id": "98d68e00c25c68cdcb9863b75fc10af3e81ad239",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-02-05T06:09:47Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-2594613872",
      "submitted_at": "2025-02-05T06:09:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16200576655,
      "node_id": "HRFPE_lADOABII586j0ZifzwAAAAPFoS6P",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16200576655",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "907e1257de30e594f82bc64076920ed288af8971",
      "commit_url": "https://api.github.com/repos/mzumsande/bitcoin/commits/907e1257de30e594f82bc64076920ed288af8971",
      "created_at": "2025-02-05T20:44:50Z"
    },
    {
      "event": "labeled",
      "id": 16201663363,
      "node_id": "LE_lADOABII586j0ZifzwAAAAPFscOD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16201663363",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-05T22:44:53Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16212425117,
      "node_id": "HRFPE_lADOABII586j0ZifzwAAAAPGVfmd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16212425117",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "7dd613b26870d628d84787b2f8a1c745931f97a6",
      "commit_url": "https://api.github.com/repos/mzumsande/bitcoin/commits/7dd613b26870d628d84787b2f8a1c745931f97a6",
      "created_at": "2025-02-06T16:07:07Z"
    },
    {
      "event": "unlabeled",
      "id": 16213986216,
      "node_id": "UNLE_lADOABII586j0ZifzwAAAAPGbcuo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16213986216",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-06T17:57:52Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2655085738,
      "node_id": "PRR_kwDOABII586eQWSq",
      "url": null,
      "actor": null,
      "commit_id": "7dd613b26870d628d84787b2f8a1c745931f97a6",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-03-03T19:30:58Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-2655085738",
      "submitted_at": "2025-03-03T19:30:58Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17133430309,
      "node_id": "HRFPE_lADOABII586j0ZifzwAAAAP9O2Yl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17133430309",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "c5b723623ca94dfa531a590580a538a3ddfb1277",
      "commit_url": "https://api.github.com/repos/mzumsande/bitcoin/commits/c5b723623ca94dfa531a590580a538a3ddfb1277",
      "created_at": "2025-04-04T17:03:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17157668747,
      "node_id": "HRFPE_lADOABII586j0ZifzwAAAAP-rT-L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17157668747",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "9622aab3892c6241e5640c2179434b64899505ca",
      "commit_url": "https://api.github.com/repos/mzumsande/bitcoin/commits/9622aab3892c6241e5640c2179434b64899505ca",
      "created_at": "2025-04-07T17:22:54Z"
    },
    {
      "event": "labeled",
      "id": 17694237977,
      "node_id": "LE_lADOABII586j0ZifzwAAAAQeqKUZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17694237977",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-16T20:37:45Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 17700639873,
      "node_id": "UNLE_lADOABII586j0ZifzwAAAAQfClSB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17700639873",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-17T23:18:54Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 18157387174,
      "node_id": "LE_lADOABII586j0ZifzwAAAAQ6Q72m",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18157387174",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-15T15:55:18Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2974134453,
      "node_id": "IC_kwDOABII586xRbC1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2974134453",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-15T15:55:19Z",
      "updated_at": "2025-06-15T15:55:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n At least one of the CI tasks failed.\n<sub>Task `tidy`: https://github.com/bitcoin/bitcoin/runs/40120572487</sub>\n<sub>LLM reason ( experimental): Missing or undefined member 'm_failed_blocks' in 'ChainstateManager' caused compilation error, leading to CI failure.</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-2974134453",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "reviewed",
      "id": 2931888182,
      "node_id": "PRR_kwDOABII586uwRA2",
      "url": null,
      "actor": null,
      "commit_id": "9622aab3892c6241e5640c2179434b64899505ca",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-16T12:30:20Z",
      "author_association": "MEMBER",
      "body": "Concept ACK\r\n\r\nSimple implementation, comments below are just a suggestions for minor improvements",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-2931888182",
      "submitted_at": "2025-06-16T12:30:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18178616901,
      "node_id": "HRFPE_lADOABII586j0ZifzwAAAAQ7h65F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18178616901",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "3d53859074108551d86971a37677c33ec896d86b",
      "commit_url": "https://api.github.com/repos/mzumsande/bitcoin/commits/3d53859074108551d86971a37677c33ec896d86b",
      "created_at": "2025-06-16T21:20:16Z"
    },
    {
      "event": "commented",
      "id": 2978189755,
      "node_id": "IC_kwDOABII586xg5G7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2978189755",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-16T21:22:06Z",
      "updated_at": "2025-06-16T21:22:23Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased due to silent conflict with #31405 and to address feedback by @ismaelsadeeq (thanks!). I think I'll fuzz this for a few more days and take it out of draft then.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-2978189755",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "mentioned",
      "id": 18178647641,
      "node_id": "MEE_lADOABII586j0ZifzwAAAAQ7iCZZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18178647641",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-16T21:22:44Z"
    },
    {
      "event": "subscribed",
      "id": 18178647672,
      "node_id": "SE_lADOABII586j0ZifzwAAAAQ7iCZ4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18178647672",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-16T21:22:44Z"
    },
    {
      "event": "reviewed",
      "id": 2934465960,
      "node_id": "PRR_kwDOABII586u6GWo",
      "url": null,
      "actor": null,
      "commit_id": "3d53859074108551d86971a37677c33ec896d86b",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-17T07:29:40Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-2934465960",
      "submitted_at": "2025-06-17T07:29:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "reviewed",
      "id": 2936239326,
      "node_id": "PRR_kwDOABII586vA3Te",
      "url": null,
      "actor": null,
      "commit_id": "3d53859074108551d86971a37677c33ec896d86b",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-17T15:57:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK, will test out.\r\n\r\nI think both approaches (this PR and the i/o-based https://github.com/bitcoin/bitcoin/pull/29158) have their merits and could both be merged. I like that this PR focuses on the internal state we want to check. I also like that the other PR does round-trip reads/writes to disk since I think there should be asserts on i/o like this.",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-2936239326",
      "submitted_at": "2025-06-17T15:54:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "unlabeled",
      "id": 18194256829,
      "node_id": "UNLE_lADOABII586j0ZifzwAAAAQ8dlO9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18194256829",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-17T16:12:08Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2981318280,
      "node_id": "IC_kwDOABII586xs06I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2981318280",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-17T18:00:41Z",
      "updated_at": "2025-06-17T18:00:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "Have you seen the below crash before / is it the same root cause as reported in #31512?\r\n\r\n<details closed>\r\n\r\n```\r\nRunning: crash-3b11c210b246fa09b395166b5007c451399115b8\r\nAssertion failed: (c->setBlockIndexCandidates.contains(const_cast<CBlockIndex*>(pindex))), function CheckBlockIndex, file validation.cpp, line 5416.\r\n==90212== ERROR: libFuzzer: deadly signal\r\n    #0 0x10876cd70 in __sanitizer_print_stack_trace+0x28 (libclang_rt.asan_osx_dynamic.dylib:arm64+0x5cd70)\r\n    #1 0x105276794 in fuzzer::PrintStackTrace() FuzzerUtil.cpp:210\r\n    #2 0x10525c57c in fuzzer::Fuzzer::CrashCallback() FuzzerLoop.cpp:231\r\n    #3 0x19b787620 in _sigtramp+0x34 (libsystem_platform.dylib:arm64+0x3620)\r\n    #4 0x19b74d888 in pthread_kill+0x124 (libsystem_pthread.dylib:arm64+0x6888)\r\n    #5 0x19b656c5c in abort+0x78 (libsystem_c.dylib:arm64+0x78c5c)\r\n    #6 0x19b655ee8 in __assert_rtn+0x118 (libsystem_c.dylib:arm64+0x77ee8)\r\n    #7 0x10506d1e4 in ChainstateManager::CheckBlockIndex() const validation.cpp:5416\r\n    #8 0x102c40e84 in block_index_tree_fuzz_target(std::__1::span<unsigned char const, 18446744073709551615ul>) block_index_tree.cpp:173\r\n    #9 0x1035242fc in LLVMFuzzerTestOneInput fuzz.cpp:215\r\n    #10 0x10525d9a4 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) FuzzerLoop.cpp:614\r\n    #11 0x10524a6e8 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) FuzzerDriver.cpp:327\r\n    #12 0x10524f980 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) FuzzerDriver.cpp:862\r\n    #13 0x10527707c in main FuzzerMain.cpp:20\r\n    #14 0x19b3aeb48  (<unknown module>)\r\n\r\n```\r\n</details>",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-2981318280",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "commented",
      "id": 2981374367,
      "node_id": "IC_kwDOABII586xtCmf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2981374367",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-17T18:18:12Z",
      "updated_at": "2025-06-17T18:18:12Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Have you seen the below crash before / is it the same root cause as reported in #31512?\r\n\r\nno, I haven't seen it, and it shouldn't be the same root cause - could you provide me the seed?",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-2981374367",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18197589242,
      "node_id": "HRFPE_lADOABII586j0ZifzwAAAAQ8qSz6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18197589242",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "commit_url": "https://api.github.com/repos/mzumsande/bitcoin/commits/ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "created_at": "2025-06-17T20:06:53Z"
    },
    {
      "event": "commented",
      "id": 2981694904,
      "node_id": "IC_kwDOABII586xuQ24",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2981694904",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-17T20:09:25Z",
      "updated_at": "2025-06-17T20:25:44Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for providing me with the seed! It was a bug in the fuzz test: when we set `abort_run` (because  reorging over pruned blocks also makes real nodes crash), we shouldn't call `CheckBlockIndex` in the fuzz test.\r\n\r\nThere are no known crashes with the current version. The problem of https://github.com/bitcoin/bitcoin/issues/31512 is being avoided by only allowing to prune blocks inside the chain for now, instead of pruning arbitrary blocks.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-2981694904",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "reviewed",
      "id": 2945100186,
      "node_id": "PRR_kwDOABII586viqma",
      "url": null,
      "actor": null,
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-20T08:57:25Z",
      "author_association": "MEMBER",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-2945100186",
      "submitted_at": "2025-06-20T08:57:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "reviewed",
      "id": 2950384616,
      "node_id": "PRR_kwDOABII586v20vo",
      "url": null,
      "actor": null,
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-10T15:00:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "It would be nice if we could also test out `LoadBlockIndex` since it inserts into `m_blocks_unlinked` for pruned blocks, but I think that will require a bit more mocking and not necessary for this PR.\r\n\r\nThere is some non-determinism in the fuzz test that I'll investigate:\r\n<details /closed>\r\n\r\n```\r\ndiff --git a/Users/eugenesiegel/btc/bitcoin-review/build/fuzz_det_cov.show.t0.a.txt b/Users/eugenesiegel/btc/bitcoin-review/build/fuzz_det_cov.show.t0.b.txt\r\nindex 45c6f3edb4..592f5964eb 100644\r\n--- a/Users/eugenesiegel/btc/bitcoin-review/build/fuzz_det_cov.show.t0.a.txt\r\n+++ b/Users/eugenesiegel/btc/bitcoin-review/build/fuzz_det_cov.show.t0.b.txt\r\n@@ -298059,13 +298059,13 @@\r\n  5513|  19.6k|            } else if (pindexPar == best_hdr_chain[nHeight - 1]) {\r\n                                  ^15.6k^15.6k\r\n   ------------------\r\n-  |  Branch (5513:24): [True: 6.04k, False: 9.57k]\r\n+  |  Branch (5513:24): [True: 6.03k, False: 9.57k]\r\n   ------------------\r\n  5514|       |                // Move to pindex's sibling on the best-chain, if it has one.\r\n- 5515|  6.04k|                pindex = best_hdr_chain[nHeight];\r\n+ 5515|  6.03k|                pindex = best_hdr_chain[nHeight];\r\n  5516|       |                // There will not be a next block if (and only if) parent block is the best header.\r\n- 5517|  6.04k|                assert((pindex == nullptr) == (pindexPar == best_hdr_chain.Tip()));\r\n- 5518|  6.04k|                break;\r\n+ 5517|  6.03k|                assert((pindex == nullptr) == (pindexPar == best_hdr_chain.Tip()));\r\n+ 5518|  6.03k|                break;\r\n  5519|  9.57k|            } else {\r\n  5520|       |                // Move up further.\r\n  5521|  9.57k|                pindex = pindexPar;\r\n@@ -299753,10 +299753,10 @@\r\n                                                                          ^6.06k\r\n   ------------------\r\n   |  Branch (6425:13): [True: 6.06k, False: 5.70k]\r\n-  |  Branch (6425:60): [True: 647, False: 5.41k]\r\n+  |  Branch (6425:60): [True: 645, False: 5.42k]\r\n   ------------------\r\n- 6426|    647|            m_best_header = &entry.second;\r\n- 6427|    647|        }\r\n+ 6426|    645|            m_best_header = &entry.second;\r\n+ 6427|    645|        }\r\n  6428|  11.7k|    }\r\n  6429|  1.98k|}\r\n  6430|       |\r\n\r\n\r\nThe coverage was not deterministic between runs.\r\n```\r\n</details>",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-2950384616",
      "submitted_at": "2025-06-23T14:41:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "commented",
      "id": 3058062207,
      "node_id": "IC_kwDOABII5862RlN_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3058062207",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-10T16:04:07Z",
      "updated_at": "2025-07-10T16:04:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "Still looking into the above source of non-determinism, it points to `RecalculateBestHeader`.\r\n\r\nA separate source of non-determinism is because `m_cached_finished_ibd` is not reset (if set) at the end of the run.",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-3058062207",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "commented",
      "id": 3058096115,
      "node_id": "IC_kwDOABII5862Rtfz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3058096115",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-10T16:14:13Z",
      "updated_at": "2025-07-10T16:14:13Z",
      "author_association": "MEMBER",
      "body": "> A separate source of non-determinism is because `m_cached_finished_ibd` is not reset (if set) at the end of the run.\r\n\r\nThis could be fixed by calling `ResetIbd()`, if there is need to.",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-3058096115",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "reviewed",
      "id": 3017290197,
      "node_id": "PRR_kwDOABII586z2DHV",
      "url": null,
      "actor": null,
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-14T18:08:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "I tracked down the `m_best_header` non-determinism I [posted above](https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-2950384616) to `RecalculateBestHeader`. It seems that since `m_block_index` is a `std::unordered_map`, the iteration order in `RecalculateBestHeader` is not guaranteed.\r\n\r\nI narrowed down my corpus to two files that, when run in separate processes (the first step of the `deterministic-fuzz-coverage` script), are deterministic. When they are run in the same process (the second step of the script), it is non-deterministic. I found this pretty confusing because `m_block_index` is cleared between runs (besides genesis). It seems that depending on the execution order, `m_block_index` may have changed internal map state (bucketing?) that is not reset by the calls to `erase` in this fuzz test. When I change the map to be a `std::map`, the non-determinism goes away. I am not sure if this can be fixed in this PR?",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-3017290197",
      "submitted_at": "2025-07-14T18:08:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "commented",
      "id": 3071149725,
      "node_id": "IC_kwDOABII5863Dgad",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3071149725",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T21:52:01Z",
      "updated_at": "2025-07-14T21:52:01Z",
      "author_association": "CONTRIBUTOR",
      "body": "> It seems that since m_block_index is a std::unordered_map, the iteration order in RecalculateBestHeader is not guaranteed.\r\n\r\nOh yes, this bit me in an earlier iteration of this PR where I made the mistake to do `PickValue(fuzzed_data_provider, blockman.m_block_index)` directly to pick a random block index (so that no `blocks` vector was needed).\r\n\r\nIt's also related to the fact that we don't use `CBlockIndexWorkComparator` tiebreak rules for `m_best_header` (documented in #32843), so I think it's currently intrinsically non-deterministic (not just in the context of the fuzz test) which block is the best header in case of multiple candidates with the same work?!",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-3071149725",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "commented",
      "id": 3433037258,
      "node_id": "IC_kwDOABII587Mn_3K",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3433037258",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-22T15:34:04Z",
      "updated_at": "2025-10-22T15:34:04Z",
      "author_association": "MEMBER",
      "body": "Concept ACK",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-3433037258",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "labeled",
      "id": 20610083005,
      "node_id": "LE_lADOABII586j0ZifzwAAAATMdOi9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20610083005",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-30T13:56:37Z",
      "label": {
        "name": "Fuzzing",
        "color": "0e8a16"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20614798385,
      "node_id": "HRFPE_lADOABII586j0ZifzwAAAATMvNwx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20614798385",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "48d11516da6351358080493fa95ea6252ce08525",
      "commit_url": "https://api.github.com/repos/mzumsande/bitcoin/commits/48d11516da6351358080493fa95ea6252ce08525",
      "created_at": "2025-10-30T16:59:21Z"
    },
    {
      "event": "commented",
      "id": 3469069615,
      "node_id": "IC_kwDOABII587Oxc0v",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3469069615",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-30T17:04:31Z",
      "updated_at": "2025-10-30T17:14:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "[ab8bc7a](https://github.com/bitcoin/bitcoin/commit/ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076) to [6abbb6e](https://github.com/bitcoin/bitcoin/commit/6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49):\r\nRebased, addressed remaining feedback, including resetting `m_cached_finished_ibd` reset to cleanup. Moved out of draft.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-3469069615",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "ready_for_review",
      "id": 20614911909,
      "node_id": "RFRE_lADOABII586j0ZifzwAAAATMvpel",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20614911909",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-30T17:04:35Z"
    },
    {
      "event": "reviewed",
      "id": 3400717262,
      "node_id": "PRR_kwDOABII587KstPO",
      "url": null,
      "actor": null,
      "commit_id": "48d11516da6351358080493fa95ea6252ce08525",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-30T17:06:37Z",
      "author_association": "MEMBER",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-3400717262",
      "submitted_at": "2025-10-30T17:06:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20615149621,
      "node_id": "HRFPE_lADOABII586j0ZifzwAAAATMwjg1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20615149621",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "1187e485073700996ec50fe52104891d177c58c4",
      "commit_url": "https://api.github.com/repos/mzumsande/bitcoin/commits/1187e485073700996ec50fe52104891d177c58c4",
      "created_at": "2025-10-30T17:12:36Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20615174797,
      "node_id": "HRFPE_lADOABII586j0ZifzwAAAATMwpqN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20615174797",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "commit_url": "https://api.github.com/repos/mzumsande/bitcoin/commits/6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "created_at": "2025-10-30T17:13:53Z"
    },
    {
      "event": "reviewed",
      "id": 3519067485,
      "node_id": "PRR_kwDOABII587RwLVd",
      "url": null,
      "actor": null,
      "commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-11-28T13:45:36Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-3519067485",
      "submitted_at": "2025-11-28T13:45:36Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "reviewed",
      "id": 3519081005,
      "node_id": "PRR_kwDOABII587RwOot",
      "url": null,
      "actor": null,
      "commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-11-28T13:50:26Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK 6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "user": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-3519081005",
      "submitted_at": "2025-11-28T13:50:26Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "review_requested",
      "id": 21243118740,
      "node_id": "RRE_lADOABII586j0ZifzwAAAATyMESU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21243118740",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-28T13:50:30Z",
      "requested_reviewer": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 21243119026,
      "node_id": "RRE_lADOABII586j0ZifzwAAAATyMEWy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21243119026",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-28T13:50:31Z",
      "requested_reviewer": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 21243119252,
      "node_id": "RRE_lADOABII586j0ZifzwAAAATyMEaU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21243119252",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-28T13:50:32Z",
      "requested_reviewer": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 3536286958,
      "node_id": "PRR_kwDOABII587Sx3Tu",
      "url": null,
      "actor": null,
      "commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-04T20:59:45Z",
      "author_association": "CONTRIBUTOR",
      "body": "Looks good, left some comments.",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-3536286958",
      "submitted_at": "2025-12-04T17:11:02Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "review_requested",
      "id": 21365178026,
      "node_id": "RRE_lADOABII586j0ZifzwAAAAT5dr6q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21365178026",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-04T17:11:07Z",
      "requested_reviewer": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21393456247,
      "node_id": "HRFPE_lADOABII586j0ZifzwAAAAT7Jjx3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21393456247",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "a0792c5e4f6999fdd0a42041aae276a4b72837ff",
      "commit_url": "https://api.github.com/repos/mzumsande/bitcoin/commits/a0792c5e4f6999fdd0a42041aae276a4b72837ff",
      "created_at": "2025-12-05T21:26:30Z"
    },
    {
      "event": "commented",
      "id": 3618658872,
      "node_id": "IC_kwDOABII587XsFo4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3618658872",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-05T21:27:48Z",
      "updated_at": "2025-12-05T21:27:48Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the reviews - with the most recent push I addressed https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2571742382 - will address the comments by @Crypt-iQ a bit later.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-3618658872",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "mentioned",
      "id": 21393473994,
      "node_id": "MEE_lADOABII586j0ZifzwAAAAT7JoHK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21393473994",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-05T21:27:49Z"
    },
    {
      "event": "subscribed",
      "id": 21393474012,
      "node_id": "SE_lADOABII586j0ZifzwAAAAT7JoHc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21393474012",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-05T21:27:49Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21393506334,
      "node_id": "HRFPE_lADOABII586j0ZifzwAAAAT7JwAe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21393506334",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "7927473c97b688d0c7162e4de294d137b8779568",
      "commit_url": "https://api.github.com/repos/mzumsande/bitcoin/commits/7927473c97b688d0c7162e4de294d137b8779568",
      "created_at": "2025-12-05T21:30:17Z"
    },
    {
      "event": "labeled",
      "id": 21393512371,
      "node_id": "LE_lADOABII586j0ZifzwAAAAT7Jxez",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21393512371",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-05T21:30:47Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 21394478365,
      "node_id": "UNLE_lADOABII586j0ZifzwAAAAT7NdUd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21394478365",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-05T22:48:30Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21438973124,
      "node_id": "HRFPE_lADOABII586j0ZifzwAAAAT93MTE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21438973124",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "62edceaf6d331cf7c06e277338b37831c910b1f7",
      "commit_url": "https://api.github.com/repos/mzumsande/bitcoin/commits/62edceaf6d331cf7c06e277338b37831c910b1f7",
      "created_at": "2025-12-08T23:22:38Z"
    },
    {
      "event": "commented",
      "id": 3629461809,
      "node_id": "IC_kwDOABII587YVTEx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3629461809",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-08T23:25:28Z",
      "updated_at": "2025-12-08T23:25:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "[7927473](https://github.com/bitcoin/bitcoin/commit/7927473c97b688d0c7162e4de294d137b8779568) to [62edcea](https://github.com/bitcoin/bitcoin/commit/62edceaf6d331cf7c06e277338b37831c910b1f7):\r\nAddressed feedback (didn't include `getblockfrompeer` behavior of re-downloading prune blocks yet, see above).",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-3629461809",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21463481983,
      "node_id": "HRFPE_lADOABII586j0ZifzwAAAAT_Ur5_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21463481983",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "ac67ab76470441ed7539eb780efa3912f1281faa",
      "commit_url": "https://api.github.com/repos/mzumsande/bitcoin/commits/ac67ab76470441ed7539eb780efa3912f1281faa",
      "created_at": "2025-12-09T20:40:08Z"
    },
    {
      "event": "commented",
      "id": 3634216561,
      "node_id": "IC_kwDOABII587Ynb5x",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3634216561",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-09T20:47:53Z",
      "updated_at": "2025-12-09T20:47:53Z",
      "author_association": "CONTRIBUTOR",
      "body": "[62edcea](https://github.com/bitcoin/bitcoin/commit/62edceaf6d331cf7c06e277338b37831c910b1f7) to [ac67ab7](https://github.com/bitcoin/bitcoin/commit/ac67ab76470441ed7539eb780efa3912f1281faa):\r\nAdded commit by @Crypt-iQ to redownload already pruned blocks (`getblockfrompeer`).",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-3634216561",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "mentioned",
      "id": 21463620221,
      "node_id": "MEE_lADOABII586j0ZifzwAAAAT_VNp9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21463620221",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-09T20:47:54Z"
    },
    {
      "event": "subscribed",
      "id": 21463620249,
      "node_id": "SE_lADOABII586j0ZifzwAAAAT_VNqZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21463620249",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-09T20:47:54Z"
    },
    {
      "event": "reviewed",
      "id": 3559946935,
      "node_id": "PRR_kwDOABII587UMHq3",
      "url": null,
      "actor": null,
      "commit_id": "ac67ab76470441ed7539eb780efa3912f1281faa",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-09T22:08:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "re-ACK ac67ab76470441ed7539eb780efa3912f1281faa\r\n\r\nThe addition of the re-download case is nice.",
      "user": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-3559946935",
      "submitted_at": "2025-12-09T22:08:56Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "reviewed",
      "id": 3563976228,
      "node_id": "PRR_kwDOABII587UbfYk",
      "url": null,
      "actor": null,
      "commit_id": "ac67ab76470441ed7539eb780efa3912f1281faa",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-10T18:42:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "crACK ac67ab76470441ed7539eb780efa3912f1281faa\r\n\r\nWill continue to fuzz and see if anything pops up.",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-3563976228",
      "submitted_at": "2025-12-10T18:42:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "labeled",
      "id": 21596007847,
      "node_id": "LE_lADOABII586j0ZifzwAAAAUHOO2n",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21596007847",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-16T15:42:30Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGMwMTFlM2FhNTQyNjMxYTg4NTcwMzlkZjc5NmViZjEzYTY1M2U4YTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c011e3aa542631a8857039df796ebf13a653e8a6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c011e3aa542631a8857039df796ebf13a653e8a6",
      "tree": {
        "sha": "e342304eb33ad1cf0dc64b791f9890d57eed3c8b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e342304eb33ad1cf0dc64b791f9890d57eed3c8b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/13891a8a685d255cb13dd5018e3d5ccc18b07c34",
          "sha": "13891a8a685d255cb13dd5018e3d5ccc18b07c34",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/13891a8a685d255cb13dd5018e3d5ccc18b07c34"
        }
      ],
      "message": "test: Wrap validation functions with TestChainstateManager\n\nThis allows to access them in the fuzz test in the next commit\nwithout making them public.\n\nCo-authored-by: TheCharlatan <seb.kung@gmail.com>",
      "committer": {
        "name": "Martin Zumsande",
        "email": "mzumsande@gmail.com",
        "date": "2025-12-16T16:25:46Z"
      },
      "author": {
        "name": "Martin Zumsande",
        "email": "mzumsande@gmail.com",
        "date": "2025-12-05T16:42:30Z"
      },
      "sha": "c011e3aa542631a8857039df796ebf13a653e8a6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ1ZjViMmRhYzMzMDkwNjM2ODM1MmExYzU4NTE4M2YwZDc1ZDc3OWQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/45f5b2dac330906368352a1c585183f0d75d779d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/45f5b2dac330906368352a1c585183f0d75d779d",
      "tree": {
        "sha": "95cc352019f46f8b788c3c000f57e266138a1739",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/95cc352019f46f8b788c3c000f57e266138a1739"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c011e3aa542631a8857039df796ebf13a653e8a6",
          "sha": "c011e3aa542631a8857039df796ebf13a653e8a6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c011e3aa542631a8857039df796ebf13a653e8a6"
        }
      ],
      "message": "fuzz: Add fuzzer for block index\n\nThis fuzz target creates arbitrary tree-like structure of indices,\nsimulating the following events:\n- Adding a header to the block tree db\n- Receiving the full block (may be valid or not)\n- Reorging to a new chain tip (possibly encountering invalid blocks on\n  the way)\n- pruning\nThe test skips all actual validation of header/ block / transaction data\nby just simulating the outcome, and also doesn't interact with the data directory.\n\nThe main goal is to test the integrity of the block index tree in\nall fuzzed constellations, by calling CheckBlockIndex()\nat the end of each iteration.",
      "committer": {
        "name": "Martin Zumsande",
        "email": "mzumsande@gmail.com",
        "date": "2025-12-16T16:25:46Z"
      },
      "author": {
        "name": "Martin Zumsande",
        "email": "mzumsande@gmail.com",
        "date": "2024-10-30T18:59:37Z"
      },
      "sha": "45f5b2dac330906368352a1c585183f0d75d779d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGRiMmQzOWY2NDI5NzlmOTI5MjYxZTVmMWNkNjdmMGMyZjJjYTA0NWY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "tree": {
        "sha": "5ca4fd82b61a4bd069e938ce30c8261168a71a92",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5ca4fd82b61a4bd069e938ce30c8261168a71a92"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/45f5b2dac330906368352a1c585183f0d75d779d",
          "sha": "45f5b2dac330906368352a1c585183f0d75d779d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/45f5b2dac330906368352a1c585183f0d75d779d"
        }
      ],
      "message": "fuzz: add subtest for re-downloading a previously pruned block\n\nThis imitates the use of the getblockfrompeer rpc.\nNote that currently pruning is limited to blocks in the active chain.\n\nCo-authored-by: Martin Zumsande <mzumsande@gmail.com>",
      "committer": {
        "name": "Martin Zumsande",
        "email": "mzumsande@gmail.com",
        "date": "2025-12-16T16:25:46Z"
      },
      "author": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2025-12-08T23:27:04Z"
      },
      "sha": "db2d39f642979f929261e5f1cd67f0c2f2ca045f"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21597119868,
      "node_id": "HRFPE_lADOABII586j0ZifzwAAAAUHSeV8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21597119868",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "commit_url": "https://api.github.com/repos/mzumsande/bitcoin/commits/db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "created_at": "2025-12-16T16:29:53Z"
    },
    {
      "event": "commented",
      "id": 3661412617,
      "node_id": "IC_kwDOABII587aPLkJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3661412617",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-16T16:32:55Z",
      "updated_at": "2025-12-16T16:32:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "[ac67ab7](https://github.com/bitcoin/bitcoin/commit/ac67ab76470441ed7539eb780efa3912f1281faa) to [db2d39f](https://github.com/bitcoin/bitcoin/commit/db2d39f642979f929261e5f1cd67f0c2f2ca045f): rebased, fixed naming issue.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-3661412617",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "labeled",
      "id": 21598520119,
      "node_id": "LE_lADOABII586j0ZifzwAAAAUHX0M3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21598520119",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-16T17:41:10Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 21598711520,
      "node_id": "UNLE_lADOABII586j0ZifzwAAAAUHYi7g",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21598711520",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-16T17:51:49Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 21600270591,
      "node_id": "UNLE_lADOABII586j0ZifzwAAAAUHefj_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21600270591",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-16T19:15:34Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 3587318193,
      "node_id": "PRR_kwDOABII587V0iGx",
      "url": null,
      "actor": null,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-17T12:39:41Z",
      "author_association": "MEMBER",
      "body": "lgtm, but I haven't reviewed the ABC part and I wonder why it is needed.\n\nreview ACK db2d39f642979f929261e5f1cd67f0c2f2ca045f \n\n<details><summary>Show signature</summary>\n\nSignature:\n\n```\nuntrusted comment: signature from minisign secret key on empty file; verify via: minisign -Vm \"${path_to_any_empty_file}\" -P RWTRmVTMeKV5noAMqVlsMugDDCyyTSbA3Re5AkUrhvLVln0tSaFWglOw -x \"${path_to_this_whole_four_line_signature_blob}\"\nRUTRmVTMeKV5npGrKx1nqXCw5zeVHdtdYURB/KlyA/LMFgpNCs+SkW9a8N95d+U4AP1RJMi+krxU1A3Yux4bpwZNLvVBKy0wLgM=\ntrusted comment: review ACK db2d39f642979f929261e5f1cd67f0c2f2ca045f \nKY7sn/dZsxGI5nYXf4tSZsmdUGBzYaUOUVbr+K87FJ+Dcko8OdPvto/RQhmORes6D400eQgSy4bzub8iPcvGCg==\n```\n\n</details>\n",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-3587318193",
      "submitted_at": "2025-12-17T12:39:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "review_requested",
      "id": 21616461314,
      "node_id": "RRE_lADOABII586j0ZifzwAAAAUIcQYC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21616461314",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-17T12:39:46Z",
      "requested_reviewer": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 21616461789,
      "node_id": "RRE_lADOABII586j0ZifzwAAAAUIcQfd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21616461789",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-17T12:39:48Z",
      "requested_reviewer": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 3587573179,
      "node_id": "PRR_kwDOABII587V1gW7",
      "url": null,
      "actor": null,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-17T12:48:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "Re-ACK db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "user": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#pullrequestreview-3587573179",
      "submitted_at": "2025-12-17T12:48:41Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
    },
    {
      "event": "commented",
      "id": 3670814276,
      "node_id": "IC_kwDOABII587azC5E",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3670814276",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-18T15:19:00Z",
      "updated_at": "2025-12-18T15:24:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "reACK https://github.com/bitcoin/bitcoin/commit/db2d39f642979f929261e5f1cd67f0c2f2ca045f\r\n\r\nI think the improvements suggested by @maflcko are worthwhile so I'd be happy to re-review.",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#issuecomment-3670814276",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31533"
    },
    {
      "event": "mentioned",
      "id": 21646610721,
      "node_id": "MEE_lADOABII586j0ZifzwAAAAUKPREh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21646610721",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-18T15:25:16Z"
    },
    {
      "event": "subscribed",
      "id": 21646610744,
      "node_id": "SE_lADOABII586j0ZifzwAAAAUKPRE4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21646610744",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-18T15:25:16Z"
    },
    {
      "event": "merged",
      "id": 21646648794,
      "node_id": "ME_lADOABII586j0ZifzwAAAAUKPaXa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21646648794",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "516ae5ede44a8a6abc59e90f9d89913e254524f4",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/516ae5ede44a8a6abc59e90f9d89913e254524f4",
      "created_at": "2025-12-18T15:26:47Z"
    },
    {
      "event": "closed",
      "id": 21646648825,
      "node_id": "CE_lADOABII586j0ZifzwAAAAUKPaX5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21646648825",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-18T15:26:47Z"
    },
    {
      "event": "head_ref_deleted",
      "id": 21648540872,
      "node_id": "HRDE_lADOABII586j0ZifzwAAAAUKWoTI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21648540872",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-18T16:49:33Z"
    },
    {
      "event": "referenced",
      "id": 21767305068,
      "node_id": "REFE_lADOABII586j0ZifzwAAAAURbrds",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21767305068",
      "actor": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "f8db928648255a0951d793cff40d49a94ae22533",
      "commit_url": "https://api.github.com/repos/sedited/rust-bitcoinkernel/commits/f8db928648255a0951d793cff40d49a94ae22533",
      "created_at": "2025-12-27T22:20:15Z"
    },
    {
      "event": "referenced",
      "id": 21767431070,
      "node_id": "REFE_lADOABII586j0ZifzwAAAAURcKOe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21767431070",
      "actor": {
        "login": "joshdoman",
        "id": 22065307,
        "node_id": "MDQ6VXNlcjIyMDY1MzA3",
        "avatar_url": "https://avatars.githubusercontent.com/u/22065307?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joshdoman",
        "html_url": "https://github.com/joshdoman",
        "followers_url": "https://api.github.com/users/joshdoman/followers",
        "following_url": "https://api.github.com/users/joshdoman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joshdoman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joshdoman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joshdoman/subscriptions",
        "organizations_url": "https://api.github.com/users/joshdoman/orgs",
        "repos_url": "https://api.github.com/users/joshdoman/repos",
        "events_url": "https://api.github.com/users/joshdoman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joshdoman/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "57661ceac9268c3273e5af04f4c515a70265a2d5",
      "commit_url": "https://api.github.com/repos/joshdoman/rust-bitcoinkernel/commits/57661ceac9268c3273e5af04f4c515a70265a2d5",
      "created_at": "2025-12-27T23:09:09Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1942239943",
      "pull_request_review_id": 2594613872,
      "id": 1942239943,
      "node_id": "PRRC_kwDOABII585zxDrH",
      "diff_hunk": "@@ -0,0 +1,201 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits;\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 63,
      "original_position": 56,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "original_commit_id": "98d68e00c25c68cdcb9863b75fc10af3e81ad239",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "98d68e0: shouldn't we have a `blocks.push_back(index)` in this block of code?\r\n\r\nright now, only genesis block gets inserted into `std::vector<CBlockIndex*> blocks` and we don't enter into the interesting test cases.",
      "created_at": "2025-02-05T04:46:22Z",
      "updated_at": "2025-02-05T06:09:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r1942239943",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1942239943"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 63,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943642068",
      "pull_request_review_id": 2596939749,
      "id": 1943642068,
      "node_id": "PRRC_kwDOABII585z2Z_U",
      "diff_hunk": "@@ -0,0 +1,201 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits;\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 63,
      "original_position": 56,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "original_commit_id": "98d68e00c25c68cdcb9863b75fc10af3e81ad239",
      "in_reply_to_id": 1942239943,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Good point - fixed, and also cleared `blocks` in the end!\r\nWhile working /testing this branch I directly did picked a value from blockman.m_block_index and introduced `blocks` right before pushing because picking from a `std::unordered_map` mad runs non-deterministic.",
      "created_at": "2025-02-05T20:47:21Z",
      "updated_at": "2025-02-05T20:47:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r1943642068",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943642068"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 63,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1978075230",
      "pull_request_review_id": 2655085738,
      "id": 1978075230,
      "node_id": "PRRC_kwDOABII58515whe",
      "diff_hunk": "@@ -0,0 +1,204 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits;\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 102,
      "original_position": 95,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "original_commit_id": "7dd613b26870d628d84787b2f8a1c745931f97a6",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "~~looks like we always break here since `old_tip`, `best_tip` and `chain.Tip()` is the genesis block initially.~~\r\nEDIT: oops no problem here, please mark as resolved! `best_tip` can be block at any height n. I got confused when I saw logs with lots of prune height = 0.",
      "created_at": "2025-03-03T19:30:57Z",
      "updated_at": "2025-03-04T06:55:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r1978075230",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1978075230"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 102,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2149856128",
      "pull_request_review_id": 2931888182,
      "id": 2149856128,
      "node_id": "PRRC_kwDOABII586AJDOA",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits;",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 28,
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "original_commit_id": "9622aab3892c6241e5640c2179434b64899505ca",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Should also indicate why the nBits is static?",
      "created_at": "2025-06-16T12:11:02Z",
      "updated_at": "2025-06-16T12:30:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2149856128",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2149856128"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2149860140",
      "pull_request_review_id": 2931888182,
      "id": 2149860140,
      "node_id": "PRRC_kwDOABII586AJEMs",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits;\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing one. This assumes headers are valid, so PoW is not relevant here.",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 57,
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "original_commit_id": "9622aab3892c6241e5640c2179434b64899505ca",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\r\n                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\r\n```",
      "created_at": "2025-06-16T12:12:07Z",
      "updated_at": "2025-06-16T12:30:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2149860140",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2149860140"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 57,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2149870395",
      "pull_request_review_id": 2931888182,
      "id": 2149870395,
      "node_id": "PRRC_kwDOABII586AJGs7",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits;\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 67,
      "original_position": 63,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "original_commit_id": "9622aab3892c6241e5640c2179434b64899505ca",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Assert that we connect to the picked index?",
      "created_at": "2025-06-16T12:14:56Z",
      "updated_at": "2025-06-16T12:30:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2149870395",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2149870395"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 67,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2149889347",
      "pull_request_review_id": 2931888182,
      "id": 2149889347,
      "node_id": "PRRC_kwDOABII586AJLVD",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits;\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least much chain work as we had at the start.\n+                        if (block->nChainWork > old_tip->nChainWork && fuzzed_data_provider.ConsumeBool()) {\n+                            break;\n+                        }\n+                    }\n+                } while (node::CBlockIndexWorkComparator()(chain.Tip(), old_tip));\n+                assert(chain.Tip()->nChainWork >= old_tip->nChainWork);\n+            },\n+            [&] {\n+                // Prune chain - dealing with block files is beyond the scope of this test, so just prune random blocks, making no assumptions what must\n+                // be together in a block file.\n+                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem describted in",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 148,
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "original_commit_id": "9622aab3892c6241e5640c2179434b64899505ca",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Maybe lil too early, but a nit when updating.\r\n```suggestion\r\n                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem described in\r\n```",
      "created_at": "2025-06-16T12:25:33Z",
      "updated_at": "2025-06-16T12:30:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2149889347",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2149889347"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2150909117",
      "pull_request_review_id": 2933549492,
      "id": 2150909117,
      "node_id": "PRRC_kwDOABII586ANES9",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits;",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 28,
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "original_commit_id": "9622aab3892c6241e5640c2179434b64899505ca",
      "in_reply_to_id": 2149856128,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2025-06-16T21:20:23Z",
      "updated_at": "2025-06-16T21:20:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2150909117",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2150909117"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2150909378",
      "pull_request_review_id": 2933549831,
      "id": 2150909378,
      "node_id": "PRRC_kwDOABII586ANEXC",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits;\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing one. This assumes headers are valid, so PoW is not relevant here.",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 57,
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "original_commit_id": "9622aab3892c6241e5640c2179434b64899505ca",
      "in_reply_to_id": 2149860140,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "added",
      "created_at": "2025-06-16T21:20:34Z",
      "updated_at": "2025-06-16T21:20:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2150909378",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2150909378"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 57,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2150909728",
      "pull_request_review_id": 2933550346,
      "id": 2150909728,
      "node_id": "PRRC_kwDOABII586ANEcg",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits;\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 67,
      "original_position": 63,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "original_commit_id": "9622aab3892c6241e5640c2179434b64899505ca",
      "in_reply_to_id": 2149870395,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "good idea, added an assert",
      "created_at": "2025-06-16T21:20:50Z",
      "updated_at": "2025-06-16T21:20:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2150909728",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2150909728"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 67,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2150909995",
      "pull_request_review_id": 2933550666,
      "id": 2150909995,
      "node_id": "PRRC_kwDOABII586ANEgr",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits;\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least much chain work as we had at the start.\n+                        if (block->nChainWork > old_tip->nChainWork && fuzzed_data_provider.ConsumeBool()) {\n+                            break;\n+                        }\n+                    }\n+                } while (node::CBlockIndexWorkComparator()(chain.Tip(), old_tip));\n+                assert(chain.Tip()->nChainWork >= old_tip->nChainWork);\n+            },\n+            [&] {\n+                // Prune chain - dealing with block files is beyond the scope of this test, so just prune random blocks, making no assumptions what must\n+                // be together in a block file.\n+                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem describted in",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 148,
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "original_commit_id": "9622aab3892c6241e5640c2179434b64899505ca",
      "in_reply_to_id": 2149889347,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "fixed",
      "created_at": "2025-06-16T21:21:00Z",
      "updated_at": "2025-06-16T21:21:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2150909995",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2150909995"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2151533101",
      "pull_request_review_id": 2934465960,
      "id": 2151533101,
      "node_id": "PRRC_kwDOABII586APcot",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least much chain work as we had at the start.",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 138,
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "original_commit_id": "3d53859074108551d86971a37677c33ec896d86b",
      "in_reply_to_id": null,
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "\r\n    at least much chain work as we had at the start -> at least as much chain work as we had at the start [missing as after at least]\r\n",
      "created_at": "2025-06-17T07:29:40Z",
      "updated_at": "2025-06-17T07:29:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2151533101",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2151533101"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 138,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2158398801",
      "pull_request_review_id": 2945100186,
      "id": 2158398801,
      "node_id": "PRRC_kwDOABII586Apo1R",
      "diff_hunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "original_commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: wrong section?",
      "created_at": "2025-06-20T08:56:26Z",
      "updated_at": "2025-06-20T08:57:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2158398801",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2158398801"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 7,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2158399123",
      "pull_request_review_id": 2945100186,
      "id": 2158399123,
      "node_id": "PRRC_kwDOABII586Apo6T",
      "diff_hunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 16,
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "original_commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "same nit",
      "created_at": "2025-06-20T08:56:33Z",
      "updated_at": "2025-06-20T08:57:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2158399123",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2158399123"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161793378",
      "pull_request_review_id": 2950384616,
      "id": 2161793378,
      "node_id": "PRRC_kwDOABII586A2lli",
      "diff_hunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least as much chain work as we had at the start.\n+                        if (block->nChainWork > old_tip->nChainWork && fuzzed_data_provider.ConsumeBool()) {\n+                            break;\n+                        }\n+                    }\n+                } while (node::CBlockIndexWorkComparator()(chain.Tip(), old_tip));\n+                assert(chain.Tip()->nChainWork >= old_tip->nChainWork);\n+            },\n+            [&] {\n+                // Prune chain - dealing with block files is beyond the scope of this test, so just prune random blocks, making no assumptions what must\n+                // be together in a block file.\n+                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem described in",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 155,
      "original_position": 149,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "original_commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "in_reply_to_id": null,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Could there also be a lambda that downloads a previously valid, pruned block that is in the main chain?",
      "created_at": "2025-06-23T14:37:30Z",
      "updated_at": "2025-06-23T14:41:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2161793378",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161793378"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 155,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162134403",
      "pull_request_review_id": 2950909220,
      "id": 2162134403,
      "node_id": "PRRC_kwDOABII586A342D",
      "diff_hunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least as much chain work as we had at the start.\n+                        if (block->nChainWork > old_tip->nChainWork && fuzzed_data_provider.ConsumeBool()) {\n+                            break;\n+                        }\n+                    }\n+                } while (node::CBlockIndexWorkComparator()(chain.Tip(), old_tip));\n+                assert(chain.Tip()->nChainWork >= old_tip->nChainWork);\n+            },\n+            [&] {\n+                // Prune chain - dealing with block files is beyond the scope of this test, so just prune random blocks, making no assumptions what must\n+                // be together in a block file.\n+                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem described in",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 155,
      "original_position": 149,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "original_commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "in_reply_to_id": 2161793378,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "you mean to simulate `getblockfrompeer`?\r\nI think it would be good to try!\r\nI thought about it and was a bit concerned it would open a can of worms of issues in `CheckBlockIndex()`, and I'm doubtful if we want to accomodate CBI too much just for `getblockfrompeer` - it's a rather recent and artifical rpc after all which I view as kind of a hack - but maybe these concerns are unfounded because I didn't try it! ",
      "created_at": "2025-06-23T17:41:05Z",
      "updated_at": "2025-06-23T17:41:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2162134403",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162134403"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 155,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162309721",
      "pull_request_review_id": 2951183252,
      "id": 2162309721,
      "node_id": "PRRC_kwDOABII586A4jpZ",
      "diff_hunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least as much chain work as we had at the start.\n+                        if (block->nChainWork > old_tip->nChainWork && fuzzed_data_provider.ConsumeBool()) {\n+                            break;\n+                        }\n+                    }\n+                } while (node::CBlockIndexWorkComparator()(chain.Tip(), old_tip));\n+                assert(chain.Tip()->nChainWork >= old_tip->nChainWork);\n+            },\n+            [&] {\n+                // Prune chain - dealing with block files is beyond the scope of this test, so just prune random blocks, making no assumptions what must\n+                // be together in a block file.\n+                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem described in",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 155,
      "original_position": 149,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "original_commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "in_reply_to_id": 2161793378,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> you mean to simulate getblockfrompeer?\r\n\r\nYup just to see that it's tolerated properly. I completely agree that `getblockfrompeer` is kind of a hack.",
      "created_at": "2025-06-23T18:39:42Z",
      "updated_at": "2025-06-23T18:39:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2162309721",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162309721"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 155,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2205513966",
      "pull_request_review_id": 3017290197,
      "id": 2205513966,
      "node_id": "PRRC_kwDOABII586DdXju",
      "diff_hunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least as much chain work as we had at the start.\n+                        if (block->nChainWork > old_tip->nChainWork && fuzzed_data_provider.ConsumeBool()) {\n+                            break;\n+                        }\n+                    }\n+                } while (node::CBlockIndexWorkComparator()(chain.Tip(), old_tip));\n+                assert(chain.Tip()->nChainWork >= old_tip->nChainWork);\n+            },\n+            [&] {\n+                // Prune chain - dealing with block files is beyond the scope of this test, so just prune random blocks, making no assumptions what must\n+                // be together in a block file.\n+                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem described in\n+                // https://github.com/bitcoin/bitcoin/issues/31512\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                int prune_height = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, chain.Height());\n+                CBlockIndex* prune_block{chain[prune_height]};\n+                if (prune_block != chain.Tip()) {\n+                    blockman.m_have_pruned = true;\n+                    prune_block->nStatus &= ~BLOCK_HAVE_DATA;\n+                    prune_block->nStatus &= ~BLOCK_HAVE_UNDO;\n+                    prune_block->nFile = 0;\n+                    prune_block->nDataPos = 0;\n+                    prune_block->nUndoPos = 0;\n+                    auto range = blockman.m_blocks_unlinked.equal_range(prune_block->pprev);\n+                    while (range.first != range.second) {\n+                        std::multimap<CBlockIndex*, CBlockIndex*>::iterator _it = range.first;\n+                        range.first++;\n+                        if (_it->second == prune_block) {\n+                            blockman.m_blocks_unlinked.erase(_it);\n+                        }\n+                    }\n+                }\n+            });\n+    }\n+    if (!abort_run) {\n+        chainman.CheckBlockIndex();\n+    }\n+\n+    // clean up global state changed by last iteration and prepare for next iteration\n+    {\n+        LOCK(cs_main);\n+        blocks.clear();",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 180,
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "original_commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "in_reply_to_id": null,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "`blocks` is reset each iteration, so can this be removed?",
      "created_at": "2025-07-14T18:05:51Z",
      "updated_at": "2025-07-14T18:08:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2205513966",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2205513966"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 180,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478861359",
      "pull_request_review_id": 3400688311,
      "id": 2478861359,
      "node_id": "PRRC_kwDOABII586TwGwv",
      "diff_hunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "original_commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "in_reply_to_id": 2158398801,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "fixed",
      "created_at": "2025-10-30T16:59:46Z",
      "updated_at": "2025-10-30T16:59:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2478861359",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478861359"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 7,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478862391",
      "pull_request_review_id": 3400689598,
      "id": 2478862391,
      "node_id": "PRRC_kwDOABII586TwHA3",
      "diff_hunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least as much chain work as we had at the start.\n+                        if (block->nChainWork > old_tip->nChainWork && fuzzed_data_provider.ConsumeBool()) {\n+                            break;\n+                        }\n+                    }\n+                } while (node::CBlockIndexWorkComparator()(chain.Tip(), old_tip));\n+                assert(chain.Tip()->nChainWork >= old_tip->nChainWork);\n+            },\n+            [&] {\n+                // Prune chain - dealing with block files is beyond the scope of this test, so just prune random blocks, making no assumptions what must\n+                // be together in a block file.\n+                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem described in\n+                // https://github.com/bitcoin/bitcoin/issues/31512\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                int prune_height = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, chain.Height());\n+                CBlockIndex* prune_block{chain[prune_height]};\n+                if (prune_block != chain.Tip()) {\n+                    blockman.m_have_pruned = true;\n+                    prune_block->nStatus &= ~BLOCK_HAVE_DATA;\n+                    prune_block->nStatus &= ~BLOCK_HAVE_UNDO;\n+                    prune_block->nFile = 0;\n+                    prune_block->nDataPos = 0;\n+                    prune_block->nUndoPos = 0;\n+                    auto range = blockman.m_blocks_unlinked.equal_range(prune_block->pprev);\n+                    while (range.first != range.second) {\n+                        std::multimap<CBlockIndex*, CBlockIndex*>::iterator _it = range.first;\n+                        range.first++;\n+                        if (_it->second == prune_block) {\n+                            blockman.m_blocks_unlinked.erase(_it);\n+                        }\n+                    }\n+                }\n+            });\n+    }\n+    if (!abort_run) {\n+        chainman.CheckBlockIndex();\n+    }\n+\n+    // clean up global state changed by last iteration and prepare for next iteration\n+    {\n+        LOCK(cs_main);\n+        blocks.clear();",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 180,
      "commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "original_commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "in_reply_to_id": 2205513966,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "done, thanks",
      "created_at": "2025-10-30T17:00:08Z",
      "updated_at": "2025-10-30T17:00:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2478862391",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478862391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 180,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478881137",
      "pull_request_review_id": 3400717262,
      "id": 2478881137,
      "node_id": "PRRC_kwDOABII586TwLlx",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 81,
      "commit_id": "48d11516da6351358080493fa95ea6252ce08525",
      "original_commit_id": "48d11516da6351358080493fa95ea6252ce08525",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "from the llm:\r\n\r\n\r\n    ReceivedBlockTransaction -> ReceivedBlockTransactions [the comment refers to the ReceivedBlockTransactions function; singular \"ReceivedBlockTransaction\" is incorrect and may confuse readers]\r\n    making no assumptions what must -> making no assumptions about what must [missing preposition \"about\" makes the phrase ungrammatical and harder to parse]\r\n",
      "created_at": "2025-10-30T17:06:37Z",
      "updated_at": "2025-10-30T17:06:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2478881137",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478881137"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478901830",
      "pull_request_review_id": 3400747285,
      "id": 2478901830,
      "node_id": "PRRC_kwDOABII586TwQpG",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 81,
      "commit_id": "48d11516da6351358080493fa95ea6252ce08525",
      "original_commit_id": "48d11516da6351358080493fa95ea6252ce08525",
      "in_reply_to_id": 2478881137,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "fixed those.",
      "created_at": "2025-10-30T17:12:54Z",
      "updated_at": "2025-10-30T17:12:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2478901830",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478901830"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2571742382",
      "pull_request_review_id": 3519067485,
      "id": 2571742382,
      "node_id": "PRRC_kwDOABII586ZSayu",
      "diff_hunk": "@@ -807,8 +809,6 @@ class Chainstate\n         ConnectTrace& connectTrace,\n         DisconnectedBlockTransactions& disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_mempool->cs);\n \n-    void InvalidBlockFound(CBlockIndex* pindex, const BlockValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);",
      "path": "src/validation.h",
      "position": 1,
      "original_position": 14,
      "commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "original_commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "in_reply_to_id": null,
      "user": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It would be nice if these could stay where they are. How about the following:\r\n<details>\r\n<summary>Protected Method Wrapper</summary>\r\n\r\n```diff\r\ndiff --git a/src/test/fuzz/block_index_tree.cpp b/src/test/fuzz/block_index_tree.cpp\r\nindex 037d168e0e..04fbbc5473 100644\r\n--- a/src/test/fuzz/block_index_tree.cpp\r\n+++ b/src/test/fuzz/block_index_tree.cpp\r\n@@ -14,0 +15 @@\r\n+#include <test/util/validation.h>\r\n@@ -44 +45 @@ FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\r\n-    ChainstateManager& chainman = *g_setup->m_node.chainman;\r\n+    auto& chainman = static_cast<TestChainstateManager&>(*g_setup->m_node.chainman);\r\n@@ -78 +79 @@ FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\r\n-                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\r\n+                        chainman.InvalidBlockFound(index, state);\r\n@@ -97 +98 @@ FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\r\n-                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\r\n+                    CBlockIndex* best_tip = chainman.FindMostWorkChain();\r\n@@ -130 +131 @@ FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\r\n-                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\r\n+                                chainman.InvalidBlockFound(block, state);\r\ndiff --git a/src/test/util/validation.cpp b/src/test/util/validation.cpp\r\nindex ce558078a6..b419069b19 100644\r\n--- a/src/test/util/validation.cpp\r\n+++ b/src/test/util/validation.cpp\r\n@@ -33,0 +34,22 @@ void TestChainstateManager::JumpOutOfIbd()\r\n+void TestChainstateManager::InvalidBlockFound(CBlockIndex* pindex, const BlockValidationState& state)\r\n+{\r\n+    struct TestChainstate : public Chainstate {\r\n+        void CallInvalidBlockFound(CBlockIndex* pindex, const BlockValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\r\n+            InvalidBlockFound(pindex, state);\r\n+        }\r\n+    };\r\n+\r\n+    static_cast<TestChainstate*>(&ActiveChainstate())->CallInvalidBlockFound(pindex, state);\r\n+}\r\n+\r\n+CBlockIndex* TestChainstateManager::FindMostWorkChain()\r\n+{\r\n+    struct TestChainstate : public Chainstate {\r\n+        CBlockIndex* CallFindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\r\n+            return FindMostWorkChain();\r\n+        }\r\n+    };\r\n+\r\n+    return static_cast<TestChainstate*>(&ActiveChainstate())->CallFindMostWorkChain();\r\n+}\r\n+\r\ndiff --git a/src/test/util/validation.h b/src/test/util/validation.h\r\nindex f9c6a8ac02..ae2e13b826 100644\r\n--- a/src/test/util/validation.h\r\n+++ b/src/test/util/validation.h\r\n@@ -18,0 +19,4 @@ struct TestChainstateManager : public ChainstateManager {\r\n+\r\n+    void InvalidBlockFound(CBlockIndex* pindex, const BlockValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\r\n+\r\n+    CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\r\ndiff --git a/src/validation.h b/src/validation.h\r\nindex 7f284da272..9e58bc9aa7 100644\r\n--- a/src/validation.h\r\n+++ b/src/validation.h\r\n@@ -800,2 +799,0 @@ public:\r\n-    void InvalidBlockFound(CBlockIndex* pindex, const BlockValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\r\n-    CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\r\n@@ -811,0 +810,2 @@ protected:\r\n+    void InvalidBlockFound(CBlockIndex* pindex, const BlockValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\r\n+    CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\r\n```\r\n</details>\r\n\r\nWe could also add similar methods for wrapping the block manager and the best invalid entry.",
      "created_at": "2025-11-28T13:45:36Z",
      "updated_at": "2025-11-28T13:45:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2571742382",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2571742382"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 853,
      "original_line": 853,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2586114315",
      "pull_request_review_id": 3536286958,
      "id": 2586114315,
      "node_id": "PRRC_kwDOABII586aJPkL",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 106,
      "commit_id": "7927473c97b688d0c7162e4de294d137b8779568",
      "original_commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "in_reply_to_id": null,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: I think the `it->nHeight > 0` branch is unnecessary? If `nHeight` is 0 and we are here, then that means the fork point was before the genesis block which should be impossible?",
      "created_at": "2025-12-03T18:00:29Z",
      "updated_at": "2025-12-04T17:11:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2586114315",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2586114315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2586270472",
      "pull_request_review_id": 3536286958,
      "id": 2586270472,
      "node_id": "PRRC_kwDOABII586aJ1sI",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 130,
      "commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "original_commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "in_reply_to_id": null,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Would it be a good idea to also call `InvalidChainFound(to_connect.front())` similar to [here](https://github.com/bitcoin/bitcoin/blob/9a29b2d331eed5b4cbd6922f63e397b68ff12447/src/validation.cpp#L3289)?",
      "created_at": "2025-12-03T18:58:14Z",
      "updated_at": "2025-12-04T17:11:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2586270472",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2586270472"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2586279490",
      "pull_request_review_id": 3536286958,
      "id": 2586279490,
      "node_id": "PRRC_kwDOABII586aJ35C",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least as much chain work as we had at the start.",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 139,
      "commit_id": "7927473c97b688d0c7162e4de294d137b8779568",
      "original_commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "in_reply_to_id": null,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "(Just a clarifying question)\r\n\r\nIs this true of ABC? From my reading, this is true of ABCStep but not ABC since ABC will stop (besides failure or interrupt) only when our tip is the block with most work (see: [here](https://github.com/bitcoin/bitcoin/blob/9a29b2d331eed5b4cbd6922f63e397b68ff12447/src/validation.cpp#L3519)).",
      "created_at": "2025-12-03T19:01:24Z",
      "updated_at": "2025-12-04T17:11:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2586279490",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2586279490"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2586804372",
      "pull_request_review_id": 3536286958,
      "id": 2586804372,
      "node_id": "PRRC_kwDOABII586aL4CU",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least as much chain work as we had at the start.\n+                        if (block->nChainWork > old_tip->nChainWork && fuzzed_data_provider.ConsumeBool()) {\n+                            break;\n+                        }\n+                    }\n+                } while (node::CBlockIndexWorkComparator()(chain.Tip(), old_tip));\n+                assert(chain.Tip()->nChainWork >= old_tip->nChainWork);\n+            },\n+            [&] {\n+                // Prune chain - dealing with block files is beyond the scope of this test, so just prune random blocks, making no assumptions\n+                // about what blocks are pruned together because they are in the same block file.\n+                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem described in\n+                // https://github.com/bitcoin/bitcoin/issues/31512\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                int prune_height = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, chain.Height());\n+                CBlockIndex* prune_block{chain[prune_height]};\n+                if (prune_block != chain.Tip()) {\n+                    blockman.m_have_pruned = true;\n+                    prune_block->nStatus &= ~BLOCK_HAVE_DATA;\n+                    prune_block->nStatus &= ~BLOCK_HAVE_UNDO;\n+                    prune_block->nFile = 0;\n+                    prune_block->nDataPos = 0;\n+                    prune_block->nUndoPos = 0;\n+                    auto range = blockman.m_blocks_unlinked.equal_range(prune_block->pprev);\n+                    while (range.first != range.second) {\n+                        std::multimap<CBlockIndex*, CBlockIndex*>::iterator _it = range.first;\n+                        range.first++;\n+                        if (_it->second == prune_block) {\n+                            blockman.m_blocks_unlinked.erase(_it);\n+                        }\n+                    }\n+                }\n+            });\n+    }\n+    if (!abort_run) {\n+        chainman.CheckBlockIndex();\n+    }\n+\n+    // clean up global state changed by last iteration and prepare for next iteration\n+    {\n+        LOCK(cs_main);\n+        genesis->nStatus |= BLOCK_HAVE_DATA;\n+        genesis->nStatus |= BLOCK_HAVE_UNDO;\n+        chainman.m_best_header = genesis;\n+        chainman.m_best_invalid = nullptr;\n+        chainman.nBlockSequenceId = 1;",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 185,
      "commit_id": "7927473c97b688d0c7162e4de294d137b8779568",
      "original_commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "in_reply_to_id": null,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Should this be 2 instead? See [here](https://github.com/bitcoin/bitcoin/blob/9a29b2d331eed5b4cbd6922f63e397b68ff12447/src/validation.h#L1058).",
      "created_at": "2025-12-03T22:23:26Z",
      "updated_at": "2025-12-04T17:11:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2586804372",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2586804372"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 186,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2589659925",
      "pull_request_review_id": 3536286958,
      "id": 2589659925,
      "node_id": "PRRC_kwDOABII586aWxMV",
      "diff_hunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least as much chain work as we had at the start.\n+                        if (block->nChainWork > old_tip->nChainWork && fuzzed_data_provider.ConsumeBool()) {\n+                            break;\n+                        }\n+                    }\n+                } while (node::CBlockIndexWorkComparator()(chain.Tip(), old_tip));\n+                assert(chain.Tip()->nChainWork >= old_tip->nChainWork);\n+            },\n+            [&] {\n+                // Prune chain - dealing with block files is beyond the scope of this test, so just prune random blocks, making no assumptions what must\n+                // be together in a block file.\n+                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem described in",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 155,
      "original_position": 149,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "original_commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "in_reply_to_id": 2161793378,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I hacked together a patch that does this, it hasn't found anything. Feel free to use if you want:\r\n\r\n<details>\r\n<summary> diff </summary>\r\n\r\n```diff\r\n\r\ndiff --git a/src/test/fuzz/block_index_tree.cpp b/src/test/fuzz/block_index_tree.cpp\r\nindex 037d168e0e..a8c0dc98cf 100644\r\n--- a/src/test/fuzz/block_index_tree.cpp\r\n+++ b/src/test/fuzz/block_index_tree.cpp\r\n@@ -49,6 +49,8 @@ FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\r\n     blocks.push_back(genesis);\r\n     bool abort_run{false};\r\n \r\n+    std::vector<CBlockIndex*> pruned_blocks;\r\n+\r\n     LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\r\n     {\r\n         if (abort_run) break;\r\n@@ -168,7 +170,23 @@ FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\r\n                             blockman.m_blocks_unlinked.erase(_it);\r\n                         }\r\n                     }\r\n+                    pruned_blocks.push_back(prune_block);\r\n                 }\r\n+            },\r\n+            [&] {\r\n+                // Download a previously pruned block\r\n+                LOCK(cs_main);\r\n+                size_t num_pruned = pruned_blocks.size();\r\n+                if (num_pruned == 0) return;\r\n+                size_t i = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_pruned - 1);\r\n+                CBlockIndex* index = pruned_blocks[i];\r\n+                CBlock block;\r\n+                block.vtx = std::vector<CTransactionRef>(index->nTx); // Set the number of tx to the prior value.\r\n+                FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\r\n+                chainman.ReceivedBlockTransactions(block, index, pos);\r\n+                assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\r\n+                assert(index->nStatus & BLOCK_HAVE_DATA);\r\n+                pruned_blocks.erase(pruned_blocks.begin() + i);\r\n             });\r\n     }\r\n     if (!abort_run) {\r\n```\r\n\r\n</details>\r\n\r\nEDIT: This introduces non-determinism, not sure why.",
      "created_at": "2025-12-04T16:01:07Z",
      "updated_at": "2025-12-04T19:07:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2589659925",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2589659925"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 155,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2594031239",
      "pull_request_review_id": 3546496114,
      "id": 2594031239,
      "node_id": "PRRC_kwDOABII586ancaH",
      "diff_hunk": "@@ -807,8 +809,6 @@ class Chainstate\n         ConnectTrace& connectTrace,\n         DisconnectedBlockTransactions& disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_mempool->cs);\n \n-    void InvalidBlockFound(CBlockIndex* pindex, const BlockValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);",
      "path": "src/validation.h",
      "position": 1,
      "original_position": 14,
      "commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "original_commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "in_reply_to_id": 2571742382,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I like this. The only downside is that moving the functions from `Chainstate` to `TestChainstateManager` is less flexible if ever we wanted to have multiple chainstates.\r\n\r\nI chose a similar approach for blockmanager etc., so that now we only need to move a few things from `private` to `protected` in the production part of the code.",
      "created_at": "2025-12-05T21:27:20Z",
      "updated_at": "2025-12-05T21:41:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2594031239",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2594031239"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 853,
      "original_line": 853,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2600302551",
      "pull_request_review_id": 3554263148,
      "id": 2600302551,
      "node_id": "PRRC_kwDOABII586a_XfX",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 130,
      "commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "original_commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "in_reply_to_id": 2586270472,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I have been thinking about removing this call from `ABCStep` for a while, because it doesn't seem necessary:\r\nDuring `ConnectTip()`, we call `InvalidBlockFound()`, which calls `InvalidChainFound()` for the block that fails validation. The additional call to `InvalidChainFound()` with the highest connectable block from the chain (which could be a successor of the invalid block, or the same block again) can lead to additional unnecessary work and duplicate logging. The only part from `InvalidChainFound()` that would make sense to do again is to update `m_best_invalid` if the invalid block is not the highest connectable block, but then again `m_best_invalid` is only used for logging.\r\n\r\nLet me know if this makes sense, this change always seemed a bit scary so I never PRed this / included this in other PRs from that area.\r\n\r\nThat being said, for now it seems reasonable to imitate the behavior, so I will add the call with the next push.\r\n",
      "created_at": "2025-12-08T22:06:48Z",
      "updated_at": "2025-12-08T22:08:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2600302551",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2600302551"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2600468539",
      "pull_request_review_id": 3554499576,
      "id": 2600468539,
      "node_id": "PRRC_kwDOABII586bAAA7",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least as much chain work as we had at the start.",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 139,
      "commit_id": "7927473c97b688d0c7162e4de294d137b8779568",
      "original_commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "in_reply_to_id": 2586279490,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "True, changed to `ABCStep`. The point is that we want to sometimes stop here (and possibly call `CheckBlockIndex` etc.), because whenever we would release cs_main, the same would be possible from another thread.",
      "created_at": "2025-12-08T23:19:28Z",
      "updated_at": "2025-12-08T23:19:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2600468539",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2600468539"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2600470202",
      "pull_request_review_id": 3554501662,
      "id": 2600470202,
      "node_id": "PRRC_kwDOABII586bAAa6",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 106,
      "commit_id": "7927473c97b688d0c7162e4de294d137b8779568",
      "original_commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "in_reply_to_id": 2586114315,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "makes sense, removed the condition",
      "created_at": "2025-12-08T23:19:53Z",
      "updated_at": "2025-12-08T23:19:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2600470202",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2600470202"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2600474557",
      "pull_request_review_id": 3554506771,
      "id": 2600474557,
      "node_id": "PRRC_kwDOABII586bABe9",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least as much chain work as we had at the start.\n+                        if (block->nChainWork > old_tip->nChainWork && fuzzed_data_provider.ConsumeBool()) {\n+                            break;\n+                        }\n+                    }\n+                } while (node::CBlockIndexWorkComparator()(chain.Tip(), old_tip));\n+                assert(chain.Tip()->nChainWork >= old_tip->nChainWork);\n+            },\n+            [&] {\n+                // Prune chain - dealing with block files is beyond the scope of this test, so just prune random blocks, making no assumptions\n+                // about what blocks are pruned together because they are in the same block file.\n+                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem described in\n+                // https://github.com/bitcoin/bitcoin/issues/31512\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                int prune_height = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, chain.Height());\n+                CBlockIndex* prune_block{chain[prune_height]};\n+                if (prune_block != chain.Tip()) {\n+                    blockman.m_have_pruned = true;\n+                    prune_block->nStatus &= ~BLOCK_HAVE_DATA;\n+                    prune_block->nStatus &= ~BLOCK_HAVE_UNDO;\n+                    prune_block->nFile = 0;\n+                    prune_block->nDataPos = 0;\n+                    prune_block->nUndoPos = 0;\n+                    auto range = blockman.m_blocks_unlinked.equal_range(prune_block->pprev);\n+                    while (range.first != range.second) {\n+                        std::multimap<CBlockIndex*, CBlockIndex*>::iterator _it = range.first;\n+                        range.first++;\n+                        if (_it->second == prune_block) {\n+                            blockman.m_blocks_unlinked.erase(_it);\n+                        }\n+                    }\n+                }\n+            });\n+    }\n+    if (!abort_run) {\n+        chainman.CheckBlockIndex();\n+    }\n+\n+    // clean up global state changed by last iteration and prepare for next iteration\n+    {\n+        LOCK(cs_main);\n+        genesis->nStatus |= BLOCK_HAVE_DATA;\n+        genesis->nStatus |= BLOCK_HAVE_UNDO;\n+        chainman.m_best_header = genesis;\n+        chainman.m_best_invalid = nullptr;\n+        chainman.nBlockSequenceId = 1;",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 185,
      "commit_id": "7927473c97b688d0c7162e4de294d137b8779568",
      "original_commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "in_reply_to_id": 2586804372,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "right, that changed recently with #29640",
      "created_at": "2025-12-08T23:20:57Z",
      "updated_at": "2025-12-08T23:20:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2600474557",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2600474557"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 186,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2600486783",
      "pull_request_review_id": 3554522067,
      "id": 2600486783,
      "node_id": "PRRC_kwDOABII586bAEd_",
      "diff_hunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least as much chain work as we had at the start.\n+                        if (block->nChainWork > old_tip->nChainWork && fuzzed_data_provider.ConsumeBool()) {\n+                            break;\n+                        }\n+                    }\n+                } while (node::CBlockIndexWorkComparator()(chain.Tip(), old_tip));\n+                assert(chain.Tip()->nChainWork >= old_tip->nChainWork);\n+            },\n+            [&] {\n+                // Prune chain - dealing with block files is beyond the scope of this test, so just prune random blocks, making no assumptions what must\n+                // be together in a block file.\n+                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem described in",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 155,
      "original_position": 149,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "original_commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "in_reply_to_id": 2161793378,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "looks good, I'll do some fuzzing with it / try to understand the non-determinism before I include it.",
      "created_at": "2025-12-08T23:24:29Z",
      "updated_at": "2025-12-08T23:24:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2600486783",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2600486783"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 155,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2604303347",
      "pull_request_review_id": 3559640043,
      "id": 2604303347,
      "node_id": "PRRC_kwDOABII586bOoPz",
      "diff_hunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least as much chain work as we had at the start.\n+                        if (block->nChainWork > old_tip->nChainWork && fuzzed_data_provider.ConsumeBool()) {\n+                            break;\n+                        }\n+                    }\n+                } while (node::CBlockIndexWorkComparator()(chain.Tip(), old_tip));\n+                assert(chain.Tip()->nChainWork >= old_tip->nChainWork);\n+            },\n+            [&] {\n+                // Prune chain - dealing with block files is beyond the scope of this test, so just prune random blocks, making no assumptions what must\n+                // be together in a block file.\n+                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem described in",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 155,
      "original_position": 149,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "original_commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "in_reply_to_id": 2161793378,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I added it now with an additional assert that `!(index->nStatus & BLOCK_HAVE_DATA)` before we redownload - which initially could crash, because we could have duplicates in `pruned_blocks` by pruning twice.  So I also added a check to the previous commit that we don't attempt to prune an already pruned block - maybe that was also the reason for the non-determinism?",
      "created_at": "2025-12-09T20:46:49Z",
      "updated_at": "2025-12-09T20:46:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2604303347",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2604303347"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 155,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2604320838",
      "pull_request_review_id": 3559664261,
      "id": 2604320838,
      "node_id": "PRRC_kwDOABII586bOshG",
      "diff_hunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least as much chain work as we had at the start.\n+                        if (block->nChainWork > old_tip->nChainWork && fuzzed_data_provider.ConsumeBool()) {\n+                            break;\n+                        }\n+                    }\n+                } while (node::CBlockIndexWorkComparator()(chain.Tip(), old_tip));\n+                assert(chain.Tip()->nChainWork >= old_tip->nChainWork);\n+            },\n+            [&] {\n+                // Prune chain - dealing with block files is beyond the scope of this test, so just prune random blocks, making no assumptions what must\n+                // be together in a block file.\n+                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem described in",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 155,
      "original_position": 149,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "original_commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "in_reply_to_id": 2161793378,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Also, the issues I was worried about were for situations where we prune/redownload blocks outside of the chain - only if we fixed #31512 and relaxed the pruning behaviour in the fuzz test, I would expect other issues to pop up. ",
      "created_at": "2025-12-09T20:51:14Z",
      "updated_at": "2025-12-09T20:51:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2604320838",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2604320838"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 155,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2607189790",
      "pull_request_review_id": 3563219544,
      "id": 2607189790,
      "node_id": "PRRC_kwDOABII586bZo8e",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 130,
      "commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "original_commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "in_reply_to_id": 2586270472,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I was pretty confused about the second call to `InvalidChainFound` when reading the code, so I think it makes sense to PR and remove. It seems to have been introduced in https://github.com/bitcoin/bitcoin/pull/4148 and only affects the warnings in `CheckForkWarningConditions`.\r\n\r\nSince `vpindexToConnect.front()` must descend (or be equal to) from the `CBlockIndex*` passed to `InvalidBlockFound` and all descendants of this `CBlockIndex*` will have been marked as invalid in `SetBlockFailureFlags`, the extra call to `InvalidChainFound(vpindexToConnect.front())` can't affect `m_best_header` so it's safe to delete imo.",
      "created_at": "2025-12-10T15:44:33Z",
      "updated_at": "2025-12-10T15:44:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2607189790",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2607189790"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2607768660",
      "pull_request_review_id": 3563946987,
      "id": 2607768660,
      "node_id": "PRRC_kwDOABII586bb2RU",
      "diff_hunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <cstdint>\n+#include <flatfile.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+\n+#include <optional>\n+#include <ranges>\n+#include <validation.h>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransaction can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ABC may release cs_main / not connect all blocks in one go - but only if we have at least as much chain work as we had at the start.\n+                        if (block->nChainWork > old_tip->nChainWork && fuzzed_data_provider.ConsumeBool()) {\n+                            break;\n+                        }\n+                    }\n+                } while (node::CBlockIndexWorkComparator()(chain.Tip(), old_tip));\n+                assert(chain.Tip()->nChainWork >= old_tip->nChainWork);\n+            },\n+            [&] {\n+                // Prune chain - dealing with block files is beyond the scope of this test, so just prune random blocks, making no assumptions what must\n+                // be together in a block file.\n+                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem described in",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 155,
      "original_position": 149,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "original_commit_id": "ab8bc7a1f877ad9e80a112dae6a12ff6ddbce076",
      "in_reply_to_id": 2161793378,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> because we could have duplicates in pruned_blocks by pruning twice\r\n\r\nAh, nice catch.\r\n\r\n> So I also added a check to the previous commit that we don't attempt to prune an already pruned block - maybe that was also the reason for the non-determinism?\r\n\r\nThe non-determinism is gone now, it was either because I had a small local patch to change `m_block_index` to `std::map` that I forgot about or because of the lack of this new check.",
      "created_at": "2025-12-10T18:28:14Z",
      "updated_at": "2025-12-10T18:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2607768660",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2607768660"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 155,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2607792781",
      "pull_request_review_id": 3563976228,
      "id": 2607792781,
      "node_id": "PRRC_kwDOABII586bb8KN",
      "diff_hunk": "@@ -39,3 +47,43 @@ void ValidationInterfaceTest::BlockConnected(\n {\n     obj.BlockConnected(role, block, pindex);\n }\n+void TestChainstateManager::InvalidBlockFound(CBlockIndex* pindex, const BlockValidationState& state)\n+{\n+    struct TestChainstate : public Chainstate {\n+        void CallInvalidBlockFound(CBlockIndex* pindex, const BlockValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+        {\n+            InvalidBlockFound(pindex, state);\n+        }\n+    };\n+\n+    static_cast<TestChainstate*>(&ActiveChainstate())->CallInvalidBlockFound(pindex, state);\n+}\n+\n+void TestChainstateManager::InvalidChainFound(CBlockIndex* pindex)",
      "path": "src/test/util/validation.cpp",
      "position": 1,
      "original_position": 36,
      "commit_id": "ac67ab76470441ed7539eb780efa3912f1281faa",
      "original_commit_id": "9f9d0e059fd82213a3cebaa20839d16b4aaf3e5f",
      "in_reply_to_id": null,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: (if you push up again) this could be named `pindexNew` to match the header?",
      "created_at": "2025-12-10T18:36:50Z",
      "updated_at": "2025-12-10T18:42:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2607792781",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2607792781"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2615504333",
      "pull_request_review_id": 3573514639,
      "id": 2615504333,
      "node_id": "PRRC_kwDOABII586b5W3N",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 130,
      "commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "original_commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "in_reply_to_id": 2586270472,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Yes, that's also my understanding. I'm working on a PR that will resolve this.",
      "created_at": "2025-12-12T20:33:21Z",
      "updated_at": "2025-12-12T20:33:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2615504333",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2615504333"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2623969437",
      "pull_request_review_id": 3583977354,
      "id": 2623969437,
      "node_id": "PRRC_kwDOABII586cZpid",
      "diff_hunk": "@@ -39,3 +47,43 @@ void ValidationInterfaceTest::BlockConnected(\n {\n     obj.BlockConnected(role, block, pindex);\n }\n+void TestChainstateManager::InvalidBlockFound(CBlockIndex* pindex, const BlockValidationState& state)\n+{\n+    struct TestChainstate : public Chainstate {\n+        void CallInvalidBlockFound(CBlockIndex* pindex, const BlockValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+        {\n+            InvalidBlockFound(pindex, state);\n+        }\n+    };\n+\n+    static_cast<TestChainstate*>(&ActiveChainstate())->CallInvalidBlockFound(pindex, state);\n+}\n+\n+void TestChainstateManager::InvalidChainFound(CBlockIndex* pindex)",
      "path": "src/test/util/validation.cpp",
      "position": 1,
      "original_position": 36,
      "commit_id": "ac67ab76470441ed7539eb780efa3912f1281faa",
      "original_commit_id": "9f9d0e059fd82213a3cebaa20839d16b4aaf3e5f",
      "in_reply_to_id": 2607792781,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2025-12-16T16:31:35Z",
      "updated_at": "2025-12-16T16:31:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2623969437",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2623969437"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626711907",
      "pull_request_review_id": 3587318193,
      "id": 2626711907,
      "node_id": "PRRC_kwDOABII586ckHFj",
      "diff_hunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/validation.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++;              // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    auto& chainman = static_cast<TestChainstateManager&>(*g_setup->m_node.chainman);\n+    auto& blockman = static_cast<TestBlockManager&>(chainman.m_blockman);\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 65,
      "original_position": 65,
      "commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "original_commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: Could use `IsValid(BLOCK_VALID_TREE)` for a stricter check?",
      "created_at": "2025-12-17T11:35:35Z",
      "updated_at": "2025-12-17T12:39:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2626711907",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626711907"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626714452",
      "pull_request_review_id": 3587318193,
      "id": 2626714452,
      "node_id": "PRRC_kwDOABII586ckHtU",
      "diff_hunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/validation.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++;              // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    auto& chainman = static_cast<TestChainstateManager&>(*g_setup->m_node.chainman);\n+    auto& blockman = static_cast<TestBlockManager&>(chainman.m_blockman);\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 75,
      "original_position": 75,
      "commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "original_commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: Could use `IsValid(BLOCK_VALID_TREE)` for a stricter check? Also, to avoid a (silent) conflict with https://github.com/bitcoin/bitcoin/pull/32950 ?",
      "created_at": "2025-12-17T11:36:30Z",
      "updated_at": "2025-12-17T12:39:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2626714452",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626714452"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 75,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626748203",
      "pull_request_review_id": 3587318193,
      "id": 2626748203,
      "node_id": "PRRC_kwDOABII586ckP8r",
      "diff_hunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/validation.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++;              // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    auto& chainman = static_cast<TestChainstateManager&>(*g_setup->m_node.chainman);\n+    auto& blockman = static_cast<TestBlockManager&>(chainman.m_blockman);\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 86,
      "original_position": 86,
      "commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "original_commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: Could use `IsValid(BLOCK_VALID_TRANSACTIONS)` for a stricter check?",
      "created_at": "2025-12-17T11:47:43Z",
      "updated_at": "2025-12-17T12:39:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2626748203",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626748203"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626777661",
      "pull_request_review_id": 3587318193,
      "id": 2626777661,
      "node_id": "PRRC_kwDOABII586ckXI9",
      "diff_hunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/validation.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++;              // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    auto& chainman = static_cast<TestChainstateManager&>(*g_setup->m_node.chainman);\n+    auto& blockman = static_cast<TestBlockManager&>(chainman.m_blockman);\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 87,
      "original_position": 87,
      "commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "original_commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: Could use `!bm.IsBlockPruned(*index)` for a stricter check?",
      "created_at": "2025-12-17T11:57:27Z",
      "updated_at": "2025-12-17T12:39:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2626777661",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626777661"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 87,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626858638",
      "pull_request_review_id": 3587318193,
      "id": 2626858638,
      "node_id": "PRRC_kwDOABII586ckq6O",
      "diff_hunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/validation.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++;              // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    auto& chainman = static_cast<TestChainstateManager&>(*g_setup->m_node.chainman);\n+    auto& blockman = static_cast<TestBlockManager&>(chainman.m_blockman);\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 92,
      "original_position": 92,
      "commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "original_commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "q: Maybe I am missing something, but what is the benefit of re-implementing this. `ConnectTip` is already `protected`, so it may be possible to mock it to inject invalidity?",
      "created_at": "2025-12-17T12:24:13Z",
      "updated_at": "2025-12-17T12:39:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2626858638",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626858638"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 92,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626894721",
      "pull_request_review_id": 3587318193,
      "id": 2626894721,
      "node_id": "PRRC_kwDOABII586ckzuB",
      "diff_hunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/validation.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++;              // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    auto& chainman = static_cast<TestChainstateManager&>(*g_setup->m_node.chainman);\n+    auto& blockman = static_cast<TestBlockManager&>(chainman.m_blockman);\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO)) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.InvalidBlockFound(block, state);\n+                                // This results in duplicate calls to InvalidChainFound, but mirrors the behavior in validation\n+                                chainman.InvalidChainFound(to_connect.front());\n+                                break;\n+                            } else {\n+                                block->RaiseValidity(BLOCK_VALID_SCRIPTS);\n+                                block->nStatus |= BLOCK_HAVE_UNDO;\n+                            }\n+                        }\n+                        chain.SetTip(*block);\n+                        chainman.ActiveChainstate().PruneBlockIndexCandidates();\n+                        // ActivateBestChainStep may release cs_main / not connect all blocks in one go - but only if we have at least as much chain work as we had at the start.\n+                        if (block->nChainWork > old_tip->nChainWork && fuzzed_data_provider.ConsumeBool()) {\n+                            break;\n+                        }\n+                    }\n+                } while (node::CBlockIndexWorkComparator()(chain.Tip(), old_tip));\n+                assert(chain.Tip()->nChainWork >= old_tip->nChainWork);\n+            },\n+            [&] {\n+                // Prune chain - dealing with block files is beyond the scope of this test, so just prune random blocks, making no assumptions\n+                // about what blocks are pruned together because they are in the same block file.\n+                // Also don't prune blocks outside of the chain for now - this would make the fuzzer crash because of the problem described in\n+                // https://github.com/bitcoin/bitcoin/issues/31512\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                int prune_height = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, chain.Height());\n+                CBlockIndex* prune_block{chain[prune_height]};\n+                if (prune_block != chain.Tip() && (prune_block->nStatus & BLOCK_HAVE_DATA)) {",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 159,
      "original_position": 159,
      "commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "original_commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: Could use the stricter `!bm.IsBlockPruned(prune_block)` check?",
      "created_at": "2025-12-17T12:36:13Z",
      "updated_at": "2025-12-17T12:39:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2626894721",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626894721"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 159,
      "original_line": 159,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626902739",
      "pull_request_review_id": 3587318193,
      "id": 2626902739,
      "node_id": "PRRC_kwDOABII586ck1rT",
      "diff_hunk": "@@ -171,7 +173,24 @@ FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n                             blockman.m_blocks_unlinked.erase(_it);\n                         }\n                     }\n+                    pruned_blocks.push_back(prune_block);\n                 }\n+            },\n+            [&] {\n+                // Download a previously pruned block\n+                LOCK(cs_main);\n+                size_t num_pruned = pruned_blocks.size();\n+                if (num_pruned == 0) return;\n+                size_t i = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_pruned - 1);\n+                CBlockIndex* index = pruned_blocks[i];\n+                assert(!(index->nStatus & BLOCK_HAVE_DATA));\n+                CBlock block;\n+                block.vtx = std::vector<CTransactionRef>(index->nTx); // Set the number of tx to the prior value.\n+                FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                chainman.ReceivedBlockTransactions(block, index, pos);\n+                assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                assert(index->nStatus & BLOCK_HAVE_DATA);\n+                pruned_blocks.erase(pruned_blocks.begin() + i);",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 30,
      "original_position": 30,
      "commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "original_commit_id": "db2d39f642979f929261e5f1cd67f0c2f2ca045f",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "same nit here for the asserts in the third commit.",
      "created_at": "2025-12-17T12:38:30Z",
      "updated_at": "2025-12-17T12:39:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2626902739",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626902739"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": 186,
      "original_start_line": 186,
      "start_side": "RIGHT",
      "line": 193,
      "original_line": 193,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2631512181",
      "pull_request_review_id": 3593546649,
      "id": 2631512181,
      "node_id": "PRRC_kwDOABII586c2bB1",
      "diff_hunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/validation.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++;              // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    auto& chainman = static_cast<TestChainstateManager&>(*g_setup->m_node.chainman);\n+    auto& blockman = static_cast<TestBlockManager&>(chainman.m_blockman);\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 92,
      "original_position": 92,
      "commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "original_commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "in_reply_to_id": 2626858638,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I was assuming that directly calling `ActivateBestChain` wouldn't work in a fuzz test due to certain things not being mocked out, but I wonder if it's possible to instead call it and not have to re-implement it here?",
      "created_at": "2025-12-18T15:18:51Z",
      "updated_at": "2025-12-18T15:18:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2631512181",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2631512181"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 92,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2631659231",
      "pull_request_review_id": 3593722656,
      "id": 2631659231,
      "node_id": "PRRC_kwDOABII586c2-7f",
      "diff_hunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/validation.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++;              // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    auto& chainman = static_cast<TestChainstateManager&>(*g_setup->m_node.chainman);\n+    auto& blockman = static_cast<TestBlockManager&>(chainman.m_blockman);\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 92,
      "original_position": 92,
      "commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "original_commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "in_reply_to_id": 2626858638,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I agree that it would be nice, but it's not so simple in my opinion:\r\n`ConnectTip()` being protected or not seems to be the least of problems:\r\n1. It would need to become `virtual`, because it is called internally by `ABCStep`. `ConnectTip()` is a member of `Chainstate`, not `ChainstateManager`.\r\n2. even if `ConnectTip` was virtual, it won't help with the current way to cast to a derived type (`auto& chainman = static_cast<TestChainstateManager&>(*g_setup->m_node.chainman);`) - which seems to be somewhat shady and strictly UB anyway, even if it works?! In the end it's still a `ChainstateManager` with a `Chainstate`, not a `TestChainstate` - how can we mock it's methods then?\r\n3. we neither want to change anything in `setup_common.cpp` where ChainstateManager is constructed nor add fuzz-specific code (`FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION`), because the mocking needs to be restricted to only this test - other fuzz tests need the real `ConnectTip()`.\r\n\r\nSo I don't see a way this is easily possible, at least not without invasive changes to the test framework - but let me know if you have an idea.",
      "created_at": "2025-12-18T15:59:52Z",
      "updated_at": "2025-12-18T15:59:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2631659231",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2631659231"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 92,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2631690440",
      "pull_request_review_id": 3593762520,
      "id": 2631690440,
      "node_id": "PRRC_kwDOABII586c3GjI",
      "diff_hunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/validation.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++;              // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    auto& chainman = static_cast<TestChainstateManager&>(*g_setup->m_node.chainman);\n+    auto& blockman = static_cast<TestBlockManager&>(chainman.m_blockman);\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 92,
      "original_position": 92,
      "commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "original_commit_id": "45f5b2dac330906368352a1c585183f0d75d779d",
      "in_reply_to_id": 2626858638,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "No, I think you are right here. There probably isn't a way (even when using UB) to mock this without touching the validation module.",
      "created_at": "2025-12-18T16:08:50Z",
      "updated_at": "2025-12-18T16:08:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2631690440",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2631690440"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 92,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2679914389",
      "pull_request_review_id": 3648113430,
      "id": 2679914389,
      "node_id": "PRRC_kwDOABII586fvD-V",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2020-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <flatfile.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <ranges>\n+#include <vector>\n+\n+const TestingSetup* g_setup;\n+\n+CBlockHeader ConsumeBlockHeader(FuzzedDataProvider& provider, uint256 prev_hash, int& nonce_counter)\n+{\n+    CBlockHeader header;\n+    header.nVersion = provider.ConsumeIntegral<decltype(header.nVersion)>();\n+    header.hashPrevBlock = prev_hash;\n+    header.hashMerkleRoot = uint256{}; // never used\n+    header.nTime = provider.ConsumeIntegral<decltype(header.nTime)>();\n+    header.nBits = Params().GenesisBlock().nBits; // not fuzzed because not used (validation is mocked).\n+    header.nNonce = nonce_counter++; // prevent creating multiple block headers with the same hash\n+    return header;\n+}\n+\n+void initialize_block_index_tree()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+}\n+\n+FUZZ_TARGET(block_index_tree, .init = initialize_block_index_tree)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+    ChainstateManager& chainman = *g_setup->m_node.chainman;\n+    auto& blockman = chainman.m_blockman;\n+    CBlockIndex* genesis = chainman.ActiveChainstate().m_chain[0];\n+    int nonce_counter = 0;\n+    std::vector<CBlockIndex*> blocks;\n+    blocks.push_back(genesis);\n+    bool abort_run{false};\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        if (abort_run) break;\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                // Receive a header building on an existing valid one. This assumes headers are valid, so PoW is not relevant here.\n+                LOCK(cs_main);\n+                CBlockIndex* prev_block = PickValue(fuzzed_data_provider, blocks);\n+                if (!(prev_block->nStatus & BLOCK_FAILED_MASK)) {\n+                    CBlockHeader header = ConsumeBlockHeader(fuzzed_data_provider, prev_block->GetBlockHash(), nonce_counter);\n+                    CBlockIndex* index = blockman.AddToBlockIndex(header, chainman.m_best_header);\n+                    assert(index->nStatus & BLOCK_VALID_TREE);\n+                    assert(index->pprev == prev_block);\n+                    blocks.push_back(index);\n+                }\n+            },\n+            [&] {\n+                // Receive a full block (valid or invalid) for an existing header, but don't attempt to connect it yet\n+                LOCK(cs_main);\n+                CBlockIndex* index = PickValue(fuzzed_data_provider, blocks);\n+                // Must be new to us and not known to be invalid (e.g. because of an invalid ancestor).\n+                if (index->nTx == 0 && !(index->nStatus & BLOCK_FAILED_MASK)) {\n+                    if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                        BlockValidationState state;\n+                        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                        chainman.ActiveChainstate().InvalidBlockFound(index, state);\n+                    } else {\n+                        size_t nTx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 1000);\n+                        CBlock block; // Dummy block, so that ReceivedBlockTransactions can infer a nTx value.\n+                        block.vtx = std::vector<CTransactionRef>(nTx);\n+                        FlatFilePos pos(0, fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 1000));\n+                        chainman.ReceivedBlockTransactions(block, index, pos);\n+                        assert(index->nStatus & BLOCK_VALID_TRANSACTIONS);\n+                        assert(index->nStatus & BLOCK_HAVE_DATA);\n+                    }\n+                }\n+            },\n+            [&] {\n+                // Simplified ActivateBestChain(): Try to move to a chain with more work - with the possibility of finding blocks to be invalid on the way\n+                LOCK(cs_main);\n+                auto& chain = chainman.ActiveChain();\n+                CBlockIndex* old_tip = chain.Tip();\n+                assert(old_tip);\n+                do {\n+                    CBlockIndex* best_tip = chainman.ActiveChainstate().FindMostWorkChain();\n+                    assert(best_tip);                   // Should at least return current tip\n+                    if (best_tip == chain.Tip()) break; // Nothing to do\n+                    // Rewind chain to forking point\n+                    const CBlockIndex* fork = chain.FindFork(best_tip);\n+                    // If we can't go back to the fork point due to pruned data, abort this run. In reality, a pruned node would also currently just crash in this scenario.\n+                    // This is very unlikely to happen due to the minimum pruning threshold of 550MiB.\n+                    CBlockIndex* it = chain.Tip();\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        if (!(it->nStatus & BLOCK_HAVE_UNDO) && it->nHeight > 0) {\n+                            assert(blockman.m_have_pruned);\n+                            abort_run = true;\n+                            return;\n+                        }\n+                        it = it->pprev;\n+                    }\n+                    chain.SetTip(*chain[fork->nHeight]);\n+\n+                    // Prepare new blocks to connect\n+                    std::vector<CBlockIndex*> to_connect;\n+                    it = best_tip;\n+                    while (it && it->nHeight != fork->nHeight) {\n+                        to_connect.push_back(it);\n+                        it = it->pprev;\n+                    }\n+                    // Connect blocks, possibly fail\n+                    for (CBlockIndex* block : to_connect | std::views::reverse) {\n+                        assert(!(block->nStatus & BLOCK_FAILED_MASK));\n+                        assert(block->nStatus & BLOCK_HAVE_DATA);\n+                        if (!block->IsValid(BLOCK_VALID_SCRIPTS)) {\n+                            if (fuzzed_data_provider.ConsumeBool()) { // Invalid\n+                                BlockValidationState state;\n+                                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"consensus-invalid\");\n+                                chainman.ActiveChainstate().InvalidBlockFound(block, state);",
      "path": "src/test/fuzz/block_index_tree.cpp",
      "position": 1,
      "original_position": 130,
      "commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "original_commit_id": "6abbb6ed6cb29b20645a7ef78bcf2e51fc7bde49",
      "in_reply_to_id": 2586270472,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "see #34254",
      "created_at": "2026-01-11T17:10:36Z",
      "updated_at": "2026-01-11T17:10:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31533#discussion_r2679914389",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2679914389"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31533"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    }
  ]
}