{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497",
    "id": 100741246,
    "node_id": "MDExOlB1bGxSZXF1ZXN0MTAwNzQxMjQ2",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/9497",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/9497.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/9497.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9497",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9497/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/96c7f2c3458950061b057fcd3daaf47b57e6bac7",
    "number": 9497,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "CCheckQueue Unit Tests",
    "user": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This PR builds on https://github.com/bitcoin/bitcoin/pull/9495 to unit test the CCheckQueue for correctness.\r\n\r\nThe cases covered in these tests are:\r\n\r\n1. Standard usage\r\n2. Failing checks are caught\r\n3. Prior blocks failing don't interfere with future blocks\r\n4. No Memory leakage (all check destructors are called before new blocks allowed, memory is freed).\r\n5. Thread Safety",
    "labels": [
      {
        "id": 62963516,
        "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
        "name": "Tests",
        "color": "d4c5f9",
        "default": false
      }
    ],
    "active_lock_reason": "resolved",
    "created_at": "2017-01-09T19:04:40Z",
    "updated_at": "2021-09-08T11:09:41Z",
    "closed_at": "2017-03-14T11:24:05Z",
    "mergeable_state": "unknown",
    "merged_at": "2017-03-14T11:24:05Z",
    "merge_commit_sha": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "JeremyRubin:checkqueue-tests",
      "ref": "checkqueue-tests",
      "sha": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 53111803,
        "node_id": "MDEwOlJlcG9zaXRvcnk1MzExMTgwMw==",
        "name": "bitcoin",
        "full_name": "JeremyRubin/bitcoin",
        "owner": {
          "login": "JeremyRubin",
          "id": 886523,
          "node_id": "MDQ6VXNlcjg4NjUyMw==",
          "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/JeremyRubin",
          "html_url": "https://github.com/JeremyRubin",
          "followers_url": "https://api.github.com/users/JeremyRubin/followers",
          "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
          "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
          "repos_url": "https://api.github.com/users/JeremyRubin/repos",
          "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/JeremyRubin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/JeremyRubin/bitcoin",
        "archive_url": "https://api.github.com/repos/JeremyRubin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/JeremyRubin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/JeremyRubin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/JeremyRubin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/JeremyRubin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/JeremyRubin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/JeremyRubin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/JeremyRubin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/JeremyRubin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/JeremyRubin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/JeremyRubin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/JeremyRubin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/JeremyRubin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/JeremyRubin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/JeremyRubin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/JeremyRubin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/JeremyRubin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/JeremyRubin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/JeremyRubin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/JeremyRubin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/JeremyRubin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/JeremyRubin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/JeremyRubin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/JeremyRubin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/JeremyRubin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/JeremyRubin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/JeremyRubin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/JeremyRubin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/JeremyRubin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:JeremyRubin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/JeremyRubin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/JeremyRubin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/JeremyRubin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/JeremyRubin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/JeremyRubin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/JeremyRubin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/JeremyRubin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/JeremyRubin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/JeremyRubin/bitcoin/hooks",
        "svn_url": "https://github.com/JeremyRubin/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 7,
        "stargazers_count": 10,
        "watchers_count": 10,
        "size": 203232,
        "default_branch": "master",
        "open_issues_count": 2,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-01-04T19:39:36Z",
        "created_at": "2016-03-04T06:06:13Z",
        "updated_at": "2023-01-05T18:14:42Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "e43a58514dd38dacd930aa4c94afb998d4360183",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 34345,
        "stargazers_count": 69851,
        "watchers_count": 69851,
        "size": 234261,
        "default_branch": "master",
        "open_issues_count": 631,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-08T22:17:10Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-06-09T03:19:05Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 455,
    "deletions": 10,
    "changed_files": 3,
    "commits": 2,
    "review_comments": 21,
    "comments": 9
  },
  "events": [
    {
      "event": "reviewed",
      "id": 15772203,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3NzIyMDM=",
      "url": null,
      "actor": null,
      "commit_id": "7fd784a6345e929ac77c6ec7bd1796a77f1cf312",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#pullrequestreview-15772203",
      "submitted_at": "2017-01-09T19:09:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
    },
    {
      "event": "labeled",
      "id": 916678359,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDkxNjY3ODM1OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/916678359",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-01-09T22:23:49Z",
      "label": {
        "name": "Tests",
        "color": "d4c5f9"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 916692180,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50OTE2NjkyMTgw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/916692180",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-01-09T22:34:06Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 916709836,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50OTE2NzA5ODM2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/916709836",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-01-09T22:48:30Z"
    },
    {
      "event": "commented",
      "id": 271445743,
      "node_id": "MDEyOklzc3VlQ29tbWVudDI3MTQ0NTc0Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/271445743",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-01-09T23:55:45Z",
      "updated_at": "2017-01-09T23:55:45Z",
      "author_association": "CONTRIBUTOR",
      "body": "Sorry for the line noise; the earlier build error should be addressed now.",
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-271445743",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9497"
    },
    {
      "event": "reviewed",
      "id": 16244421,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNDQ0MjE=",
      "url": null,
      "actor": null,
      "commit_id": "f4f14263ad74cf612b9d948e304f0052254de6de",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Overall great and very clever tests (thread safety one was fun to figure out). Added a bunch of minor comments. The only two comments I would really urge you to consider are the ones on the Memory and FrozenCleanup tests. I think it would be good to check same conditions without allocating large chunks of memory or doing 1-second busy loops so these tests can be more efficient and more reliable.",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#pullrequestreview-16244421",
      "submitted_at": "2017-01-11T22:57:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 920957105,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50OTIwOTU3MTA1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/920957105",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-01-12T16:11:14Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 921035453,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50OTIxMDM1NDUz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/921035453",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-01-12T16:58:33Z"
    },
    {
      "event": "reviewed",
      "id": 16669547,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Njk1NDc=",
      "url": null,
      "actor": null,
      "commit_id": "27b8cbaea84e8d31b4499e11340ed798c501c737",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "utACK d44af13ddc3615686a3e76cf9a3412999db0d692. Left one minor comment, feel free to ignore.",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#pullrequestreview-16669547",
      "submitted_at": "2017-01-13T22:59:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
    },
    {
      "event": "commented",
      "id": 273807134,
      "node_id": "MDEyOklzc3VlQ29tbWVudDI3MzgwNzEzNA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/273807134",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-01-19T15:32:12Z",
      "updated_at": "2017-01-19T15:32:12Z",
      "author_association": "MEMBER",
      "body": "ACK, needs squashing",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-273807134",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9497"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 929449032,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50OTI5NDQ5MDMy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/929449032",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-01-19T17:06:02Z"
    },
    {
      "event": "commented",
      "id": 273835825,
      "node_id": "MDEyOklzc3VlQ29tbWVudDI3MzgzNTgyNQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/273835825",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-01-19T17:07:08Z",
      "updated_at": "2017-01-19T17:07:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "Squashed!",
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-273835825",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9497"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 931389371,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50OTMxMzg5Mzcx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/931389371",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-01-20T22:19:17Z"
    },
    {
      "event": "commented",
      "id": 274195370,
      "node_id": "MDEyOklzc3VlQ29tbWVudDI3NDE5NTM3MA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/274195370",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-01-20T22:19:59Z",
      "updated_at": "2017-01-20T22:19:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased to be on top of https://github.com/bitcoin/bitcoin/pull/9495.",
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-274195370",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9497"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMjA3MzQyNGZkNWExODU3ODE3NTAzNDdmYmZiYjBjMTA4ZWY2NmZk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e2073424fd5a185781750347fbfbb0c108ef66fd",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e2073424fd5a185781750347fbfbb0c108ef66fd",
      "tree": {
        "sha": "a5946f8ef62e3545b9e10edef17d3d56b2a0b4eb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a5946f8ef62e3545b9e10edef17d3d56b2a0b4eb"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/25720fc394e27a951bcad26095fb5a711bfacb8f",
          "sha": "25720fc394e27a951bcad26095fb5a711bfacb8f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/25720fc394e27a951bcad26095fb5a711bfacb8f"
        }
      ],
      "message": "Fix CCheckQueue IsIdle (potential) race condition and remove dangerous constructors.",
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-01-20T23:18:59Z"
      },
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-01-09T16:13:37Z"
      },
      "sha": "e2073424fd5a185781750347fbfbb0c108ef66fd"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 931449042,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50OTMxNDQ5MDQy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/931449042",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-01-20T23:19:17Z"
    },
    {
      "event": "reviewed",
      "id": 19030165,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwMzAxNjU=",
      "url": null,
      "actor": null,
      "commit_id": "0949835100e60901f51ce2b7cd95d912d13241a5",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#pullrequestreview-19030165",
      "submitted_at": "2017-01-30T08:05:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
    },
    {
      "event": "reviewed",
      "id": 19033484,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwMzM0ODQ=",
      "url": null,
      "actor": null,
      "commit_id": "0949835100e60901f51ce2b7cd95d912d13241a5",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#pullrequestreview-19033484",
      "submitted_at": "2017-01-30T08:38:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
    },
    {
      "event": "reviewed",
      "id": 19034083,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwMzQwODM=",
      "url": null,
      "actor": null,
      "commit_id": "0949835100e60901f51ce2b7cd95d912d13241a5",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#pullrequestreview-19034083",
      "submitted_at": "2017-01-30T08:43:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
    },
    {
      "event": "reviewed",
      "id": 19034549,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwMzQ1NDk=",
      "url": null,
      "actor": null,
      "commit_id": "0949835100e60901f51ce2b7cd95d912d13241a5",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#pullrequestreview-19034549",
      "submitted_at": "2017-01-30T08:46:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
    },
    {
      "event": "reviewed",
      "id": 19034660,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwMzQ2NjA=",
      "url": null,
      "actor": null,
      "commit_id": "0949835100e60901f51ce2b7cd95d912d13241a5",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#pullrequestreview-19034660",
      "submitted_at": "2017-01-30T08:47:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NmM3ZjJjMzQ1ODk1MDA2MWIwNTdmY2QzZGFhZjQ3YjU3ZTZiYWM3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "tree": {
        "sha": "750bdc0c450e7427c74ab6be39c9afd84d66d534",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/750bdc0c450e7427c74ab6be39c9afd84d66d534"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e2073424fd5a185781750347fbfbb0c108ef66fd",
          "sha": "e2073424fd5a185781750347fbfbb0c108ef66fd",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e2073424fd5a185781750347fbfbb0c108ef66fd"
        }
      ],
      "message": "Add CheckQueue Tests",
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-02-16T06:37:53Z"
      },
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-01-08T00:51:23Z"
      },
      "sha": "96c7f2c3458950061b057fcd3daaf47b57e6bac7"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 964441597,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50OTY0NDQxNTk3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/964441597",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-02-16T06:38:10Z"
    },
    {
      "event": "commented",
      "id": 280245368,
      "node_id": "MDEyOklzc3VlQ29tbWVudDI4MDI0NTM2OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/280245368",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-02-16T06:42:08Z",
      "updated_at": "2017-02-16T06:42:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "Fixed the issues that @kallewoof raised, and squashed.\r\n\r\nUnsquashed preserved here https://github.com/JeremyRubin/bitcoin/tree/checkqueue-tests-unsquashed.",
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-280245368",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9497"
    },
    {
      "event": "mentioned",
      "id": 964444912,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50OTY0NDQ0OTEy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/964444912",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-02-16T06:42:08Z"
    },
    {
      "event": "subscribed",
      "id": 964444913,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDk2NDQ0NDkxMw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/964444913",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-02-16T06:42:08Z"
    },
    {
      "event": "commented",
      "id": 282500634,
      "node_id": "MDEyOklzc3VlQ29tbWVudDI4MjUwMDYzNA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/282500634",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-02-25T17:58:22Z",
      "updated_at": "2017-02-25T17:58:43Z",
      "author_association": "MEMBER",
      "body": "utACK 96c7f2c\r\n\r\nI'm a bit concerned about non-deterministic behavior in tests as this tends to be a pain when you do run into a problem. Or is this fixed seed / PRNG so that the numbers are always the same each time? (for `GetRand()`)",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-282500634",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9497"
    },
    {
      "event": "commented",
      "id": 282506083,
      "node_id": "MDEyOklzc3VlQ29tbWVudDI4MjUwNjA4Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/282506083",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-02-25T19:22:04Z",
      "updated_at": "2017-02-25T19:22:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "I could make them deterministic if that's desirable, but realistically these tests are already non-deterministic by virtue of being multithreaded. None of the uses of GetRand are particularly dangerous here, although perhaps they area a little slower than could be.",
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-282506083",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9497"
    },
    {
      "event": "commented",
      "id": 282513878,
      "node_id": "MDEyOklzc3VlQ29tbWVudDI4MjUxMzg3OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/282513878",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-02-25T21:31:16Z",
      "updated_at": "2017-02-25T21:31:16Z",
      "author_association": "MEMBER",
      "body": "I think that would be desirable, even if the multithreading makes it not 100%.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-282513878",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9497"
    },
    {
      "event": "commented",
      "id": 282579755,
      "node_id": "MDEyOklzc3VlQ29tbWVudDI4MjU3OTc1NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/282579755",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-02-26T19:22:10Z",
      "updated_at": "2017-02-26T19:22:10Z",
      "author_association": "MEMBER",
      "body": "ACK 96c7f2c",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#issuecomment-282579755",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9497"
    },
    {
      "event": "merged",
      "id": 998860751,
      "node_id": "MDExOk1lcmdlZEV2ZW50OTk4ODYwNzUx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/998860751",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "created_at": "2017-03-14T11:24:05Z"
    },
    {
      "event": "closed",
      "id": 998860752,
      "node_id": "MDExOkNsb3NlZEV2ZW50OTk4ODYwNzUy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/998860752",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-03-14T11:24:05Z"
    },
    {
      "event": "referenced",
      "id": 998860971,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDk5ODg2MDk3MQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/998860971",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "2c781fb920269036080bce69743259b01bc0edde",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2c781fb920269036080bce69743259b01bc0edde",
      "created_at": "2017-03-14T11:24:15Z"
    },
    {
      "event": "referenced",
      "id": 1110529301,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDExMTA1MjkzMDE=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/1110529301",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "f1c348e8d29e94d405324fe455bd8e00c3857318",
      "commit_url": "https://api.github.com/repos/luke-jr/bitcoin/commits/f1c348e8d29e94d405324fe455bd8e00c3857318",
      "created_at": "2017-06-05T19:23:33Z"
    },
    {
      "event": "referenced",
      "id": 1110550696,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDExMTA1NTA2OTY=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/1110550696",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "b71b605c6d414e5f24b8539cb7e336865da15f7f",
      "commit_url": "https://api.github.com/repos/luke-jr/bitcoin/commits/b71b605c6d414e5f24b8539cb7e336865da15f7f",
      "created_at": "2017-06-05T19:35:37Z"
    },
    {
      "event": "referenced",
      "id": 1110844084,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDExMTA4NDQwODQ=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/1110844084",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "1b864c9820abc0ba05093b97b813f4719584759b",
      "commit_url": "https://api.github.com/repos/luke-jr/bitcoin/commits/1b864c9820abc0ba05093b97b813f4719584759b",
      "created_at": "2017-06-05T23:03:40Z"
    },
    {
      "event": "referenced",
      "id": 1443456848,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDE0NDM0NTY4NDg=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/1443456848",
      "actor": {
        "login": "codablock",
        "id": 1884269,
        "node_id": "MDQ6VXNlcjE4ODQyNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1884269?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/codablock",
        "html_url": "https://github.com/codablock",
        "followers_url": "https://api.github.com/users/codablock/followers",
        "following_url": "https://api.github.com/users/codablock/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/codablock/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/codablock/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/codablock/subscriptions",
        "organizations_url": "https://api.github.com/users/codablock/orgs",
        "repos_url": "https://api.github.com/users/codablock/repos",
        "events_url": "https://api.github.com/users/codablock/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/codablock/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "7b7924d4724f7c29c5159caa26ea31c171623954",
      "commit_url": "https://api.github.com/repos/codablock/dash/commits/7b7924d4724f7c29c5159caa26ea31c171623954",
      "created_at": "2018-01-26T12:00:04Z"
    },
    {
      "event": "referenced",
      "id": 1599025345,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDE1OTkwMjUzNDU=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/1599025345",
      "actor": {
        "login": "sickpig",
        "id": 1469203,
        "node_id": "MDQ6VXNlcjE0NjkyMDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1469203?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sickpig",
        "html_url": "https://github.com/sickpig",
        "followers_url": "https://api.github.com/users/sickpig/followers",
        "following_url": "https://api.github.com/users/sickpig/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sickpig/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sickpig/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sickpig/subscriptions",
        "organizations_url": "https://api.github.com/users/sickpig/orgs",
        "repos_url": "https://api.github.com/users/sickpig/repos",
        "events_url": "https://api.github.com/users/sickpig/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sickpig/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "e1e28f46660cfae2bdda8dd0b8e097f943eda556",
      "commit_url": "https://api.github.com/repos/sickpig/BitcoinUnlimited/commits/e1e28f46660cfae2bdda8dd0b8e097f943eda556",
      "created_at": "2018-04-27T15:23:24Z"
    },
    {
      "event": "referenced",
      "id": 2056018780,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDIwNTYwMTg3ODA=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2056018780",
      "actor": {
        "login": "michelvankessel",
        "id": 16052447,
        "node_id": "MDQ6VXNlcjE2MDUyNDQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/16052447?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michelvankessel",
        "html_url": "https://github.com/michelvankessel",
        "followers_url": "https://api.github.com/users/michelvankessel/followers",
        "following_url": "https://api.github.com/users/michelvankessel/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michelvankessel/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michelvankessel/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michelvankessel/subscriptions",
        "organizations_url": "https://api.github.com/users/michelvankessel/orgs",
        "repos_url": "https://api.github.com/users/michelvankessel/repos",
        "events_url": "https://api.github.com/users/michelvankessel/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michelvankessel/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "587bed7faff9137fb12c45d846d64c9cd9cfb5c5",
      "commit_url": "https://api.github.com/repos/michelvankessel/blackcoin-more/commits/587bed7faff9137fb12c45d846d64c9cd9cfb5c5",
      "created_at": "2019-01-05T19:59:52Z"
    },
    {
      "event": "referenced",
      "id": 2056235536,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDIwNTYyMzU1MzY=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2056235536",
      "actor": {
        "login": "andvgal",
        "id": 6080632,
        "node_id": "MDQ6VXNlcjYwODA2MzI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6080632?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andvgal",
        "html_url": "https://github.com/andvgal",
        "followers_url": "https://api.github.com/users/andvgal/followers",
        "following_url": "https://api.github.com/users/andvgal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andvgal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andvgal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andvgal/subscriptions",
        "organizations_url": "https://api.github.com/users/andvgal/orgs",
        "repos_url": "https://api.github.com/users/andvgal/repos",
        "events_url": "https://api.github.com/users/andvgal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andvgal/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "abcda0e622060209f0523277b27f5c5bf0d136b4",
      "commit_url": "https://api.github.com/repos/energicryptocurrency/gen2-energi/commits/abcda0e622060209f0523277b27f5c5bf0d136b4",
      "created_at": "2019-01-06T10:40:22Z"
    },
    {
      "event": "referenced",
      "id": 2169128945,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDIxNjkxMjg5NDU=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2169128945",
      "actor": {
        "login": "CryptoCentric",
        "id": 38781794,
        "node_id": "MDQ6VXNlcjM4NzgxNzk0",
        "avatar_url": "https://avatars.githubusercontent.com/u/38781794?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/CryptoCentric",
        "html_url": "https://github.com/CryptoCentric",
        "followers_url": "https://api.github.com/users/CryptoCentric/followers",
        "following_url": "https://api.github.com/users/CryptoCentric/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/CryptoCentric/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/CryptoCentric/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/CryptoCentric/subscriptions",
        "organizations_url": "https://api.github.com/users/CryptoCentric/orgs",
        "repos_url": "https://api.github.com/users/CryptoCentric/repos",
        "events_url": "https://api.github.com/users/CryptoCentric/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/CryptoCentric/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "557d289d0f3f43083f4a4bc119e6a42d57c7866e",
      "commit_url": "https://api.github.com/repos/absolute-community/absolute/commits/557d289d0f3f43083f4a4bc119e6a42d57c7866e",
      "created_at": "2019-02-27T20:18:56Z"
    },
    {
      "event": "referenced",
      "id": 3545454980,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDM1NDU0NTQ5ODA=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/3545454980",
      "actor": {
        "login": "DeckerSU",
        "id": 22120003,
        "node_id": "MDQ6VXNlcjIyMTIwMDAz",
        "avatar_url": "https://avatars.githubusercontent.com/u/22120003?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DeckerSU",
        "html_url": "https://github.com/DeckerSU",
        "followers_url": "https://api.github.com/users/DeckerSU/followers",
        "following_url": "https://api.github.com/users/DeckerSU/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DeckerSU/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DeckerSU/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DeckerSU/subscriptions",
        "organizations_url": "https://api.github.com/users/DeckerSU/orgs",
        "repos_url": "https://api.github.com/users/DeckerSU/repos",
        "events_url": "https://api.github.com/users/DeckerSU/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DeckerSU/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "17a6f14968eedcc3d328a3ecbc9de97bee40c752",
      "commit_url": "https://api.github.com/repos/DeckerSU/komodo/commits/17a6f14968eedcc3d328a3ecbc9de97bee40c752",
      "created_at": "2020-07-14T18:46:08Z"
    },
    {
      "event": "referenced",
      "id": 4378199433,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQzNzgxOTk0MzM=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4378199433",
      "actor": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "234077678907dd7d3ecb781a96731c416d6d2ace",
      "commit_url": "https://api.github.com/repos/LarryRuane/zcash/commits/234077678907dd7d3ecb781a96731c416d6d2ace",
      "created_at": "2021-02-25T18:53:50Z"
    },
    {
      "event": "referenced",
      "id": 4378199435,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQzNzgxOTk0MzU=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4378199435",
      "actor": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "f8d9531a61140693f2f7a3ee847433a41ba8bc55",
      "commit_url": "https://api.github.com/repos/LarryRuane/zcash/commits/f8d9531a61140693f2f7a3ee847433a41ba8bc55",
      "created_at": "2021-02-25T18:53:50Z"
    },
    {
      "event": "referenced",
      "id": 4546631460,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1NDY2MzE0NjA=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4546631460",
      "actor": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "8e67b36e865e2ed5e0dce44817636fe6bcb4222c",
      "commit_url": "https://api.github.com/repos/LarryRuane/zcash/commits/8e67b36e865e2ed5e0dce44817636fe6bcb4222c",
      "created_at": "2021-04-02T18:30:28Z"
    },
    {
      "event": "referenced",
      "id": 4546631466,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1NDY2MzE0NjY=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4546631466",
      "actor": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "a314cdba56bf77cb0cb8545c26edf27fbebab3c9",
      "commit_url": "https://api.github.com/repos/LarryRuane/zcash/commits/a314cdba56bf77cb0cb8545c26edf27fbebab3c9",
      "created_at": "2021-04-02T18:30:28Z"
    },
    {
      "event": "referenced",
      "id": 4547361260,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1NDczNjEyNjA=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4547361260",
      "actor": {
        "login": "zkbot",
        "id": 17032253,
        "node_id": "MDQ6VXNlcjE3MDMyMjUz",
        "avatar_url": "https://avatars.githubusercontent.com/u/17032253?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/zkbot",
        "html_url": "https://github.com/zkbot",
        "followers_url": "https://api.github.com/users/zkbot/followers",
        "following_url": "https://api.github.com/users/zkbot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/zkbot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/zkbot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/zkbot/subscriptions",
        "organizations_url": "https://api.github.com/users/zkbot/orgs",
        "repos_url": "https://api.github.com/users/zkbot/repos",
        "events_url": "https://api.github.com/users/zkbot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/zkbot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "49ffee3f20b972dc3aa75e422c67523251cf088b",
      "commit_url": "https://api.github.com/repos/zcash/zcash/commits/49ffee3f20b972dc3aa75e422c67523251cf088b",
      "created_at": "2021-04-02T23:59:59Z"
    },
    {
      "event": "locked",
      "id": 5271586330,
      "node_id": "LOE_lADOABII584L5i_bzwAAAAE6NgYa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5271586330",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-09-08T11:09:41Z",
      "lock_reason": "resolved"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95224058",
      "pull_request_review_id": 15772203,
      "id": 95224058,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk1MjI0MDU4",
      "diff_hunk": "@@ -0,0 +1,395 @@\n+// Copyright (c) 2012-2015 The Bitcoin Core developers",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 1,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "7fd784a6345e929ac77c6ec7bd1796a77f1cf312",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "couple of years out of date :)",
      "created_at": "2017-01-09T19:09:29Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95224058",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95224058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95226580",
      "pull_request_review_id": 15774812,
      "id": 95226580,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk1MjI2NTgw",
      "diff_hunk": "@@ -0,0 +1,395 @@\n+// Copyright (c) 2012-2015 The Bitcoin Core developers",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 1,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "7fd784a6345e929ac77c6ec7bd1796a77f1cf312",
      "in_reply_to_id": 95224058,
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "will fix!",
      "created_at": "2017-01-09T19:22:04Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95226580",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95226580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95680199",
      "pull_request_review_id": 16244421,
      "id": 95680199,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk1NjgwMTk5",
      "diff_hunk": "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 21,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "f4f14263ad74cf612b9d948e304f0052254de6de",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe add a comment noting BasicTestingSetup can't be used because it doesn't set nScriptCheckThreads.",
      "created_at": "2017-01-11T21:51:00Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95680199",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95680199"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95680298",
      "pull_request_review_id": 16244421,
      "id": 95680298,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk1NjgwMjk4",
      "diff_hunk": "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 122,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "f4f14263ad74cf612b9d948e304f0052254de6de",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe declare 128 and any other common parameters as constants above.",
      "created_at": "2017-01-11T21:51:42Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95680298",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95680298"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95681211",
      "pull_request_review_id": 16244421,
      "id": 95681211,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk1NjgxMjEx",
      "diff_hunk": "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{small_queue->Thread();});\n+    }\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        {\n+            CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<FakeCheckCheckCompletion> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 135,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "f4f14263ad74cf612b9d948e304f0052254de6de",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe replace the loop with vCheck.resize(min(total, r)).",
      "created_at": "2017-01-11T21:56:34Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95681211",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95681211"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95682154",
      "pull_request_review_id": 16244421,
      "id": 95682154,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk1NjgyMTU0",
      "diff_hunk": "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 122,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "f4f14263ad74cf612b9d948e304f0052254de6de",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why is small_queue a shared pointer, not a unique pointer or just plain stack variable? Maybe add a comment explaining. Also, you could probably use make_shared if it does need to be a shared pointer.",
      "created_at": "2017-01-11T22:01:40Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95682154",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95682154"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95683341",
      "pull_request_review_id": 16244421,
      "id": 95683341,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk1NjgzMzQx",
      "diff_hunk": "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{small_queue->Thread();});\n+    }\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        {\n+            CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<FakeCheckCheckCompletion> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    vChecks.emplace_back();\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        std::array<bool, 2> result;\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                for (size_t k = 0; k < 100; ++k)\n+                    vChecks.emplace_back(k == 99 && end_fails);\n+                control.Add(vChecks);\n+            }\n+            result[end_fails ? 0 : 1] = control.Wait();\n+        }\n+        BOOST_CHECK(!result[0]);",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 241,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "f4f14263ad74cf612b9d948e304f0052254de6de",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would seem more direct to just BOOST_CHECK the control.Wait() call instead of putting the results in an intermediate array. This way is ok too, though.",
      "created_at": "2017-01-11T22:08:22Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95683341",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95683341"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95683957",
      "pull_request_review_id": 16244421,
      "id": 95683957,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk1NjgzOTU3",
      "diff_hunk": "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{small_queue->Thread();});",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 125,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "f4f14263ad74cf612b9d948e304f0052254de6de",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Replacing [=] with [&] might allow small_queue not to be a shared_ptr.",
      "created_at": "2017-01-11T22:11:31Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95683957",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95683957"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95685002",
      "pull_request_review_id": 16244421,
      "id": 95685002,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk1Njg1MDAy",
      "diff_hunk": "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{small_queue->Thread();});\n+    }\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        {\n+            CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<FakeCheckCheckCompletion> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    vChecks.emplace_back();\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        std::array<bool, 2> result;\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                for (size_t k = 0; k < 100; ++k)\n+                    vChecks.emplace_back(k == 99 && end_fails);\n+                control.Add(vChecks);\n+            }\n+            result[end_fails ? 0 : 1] = control.Wait();\n+        }\n+        BOOST_CHECK(!result[0]);\n+        BOOST_CHECK(result[1]);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::shared_ptr<Unique_Queue>(new Unique_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 275,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "f4f14263ad74cf612b9d948e304f0052254de6de",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe also check that UniqueCheck::results.size == COUNT.",
      "created_at": "2017-01-11T22:17:24Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95685002",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95685002"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95685133",
      "pull_request_review_id": 16244421,
      "id": 95685133,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk1Njg1MTMz",
      "diff_hunk": "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{small_queue->Thread();});\n+    }\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        {\n+            CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<FakeCheckCheckCompletion> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    vChecks.emplace_back();\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        std::array<bool, 2> result;\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                for (size_t k = 0; k < 100; ++k)\n+                    vChecks.emplace_back(k == 99 && end_fails);\n+                control.Add(vChecks);\n+            }\n+            result[end_fails ? 0 : 1] = control.Wait();\n+        }\n+        BOOST_CHECK(!result[0]);\n+        BOOST_CHECK(result[1]);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::shared_ptr<Unique_Queue>(new Unique_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathalogical case where by lazily freeing",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 283,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "f4f14263ad74cf612b9d948e304f0052254de6de",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "pathological (spelling)\r\n",
      "created_at": "2017-01-11T22:18:15Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95685133",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95685133"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95686968",
      "pull_request_review_id": 16244421,
      "id": 95686968,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk1Njg2OTY4",
      "diff_hunk": "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{small_queue->Thread();});\n+    }\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        {\n+            CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<FakeCheckCheckCompletion> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    vChecks.emplace_back();\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        std::array<bool, 2> result;\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                for (size_t k = 0; k < 100; ++k)\n+                    vChecks.emplace_back(k == 99 && end_fails);\n+                control.Add(vChecks);\n+            }\n+            result[end_fails ? 0 : 1] = control.Wait();\n+        }\n+        BOOST_CHECK(!result[0]);\n+        BOOST_CHECK(result[1]);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::shared_ptr<Unique_Queue>(new Unique_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathalogical case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+//\n+// This test (failing) is dependent on not being able to handle",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 287,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "f4f14263ad74cf612b9d948e304f0052254de6de",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Instead of having the test be nondeterministic in this way, would anything be lost if you had the MemoryCheck constructor increment a static counter when passed a true arg, and the MemoryCheck destructor decrement the counter if the object was constructed with a true arg. Then you could detect the error case explicitly by checking the counter, and not have to allocate big chunks of memory.",
      "created_at": "2017-01-11T22:28:56Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95686968",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95686968"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95688870",
      "pull_request_review_id": 16244421,
      "id": 95688870,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk1Njg4ODcw",
      "diff_hunk": "@@ -0,0 +1,402 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    std::vector<std::array<unsigned char, 1000000> > mb_memory;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b)\n+    {\n+        if (b)\n+            mb_memory.reserve(200);\n+    };\n+    void swap(MemoryCheck& x) { mb_memory.swap(x.mb_memory); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<bool> frozen;\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        while (frozen)\n+            ;\n+    }\n+    void swap(FrozenCleanupCheck& x){};\n+};\n+\n+// Static Allocations\n+std::atomic<bool> FrozenCleanupCheck::frozen{false};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::shared_ptr<Correct_Queue>(new Correct_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{small_queue->Thread();});\n+    }\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        {\n+            CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<FakeCheckCheckCompletion> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    vChecks.emplace_back();\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::shared_ptr<Failing_Queue>(new Failing_Queue {128});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        std::array<bool, 2> result;\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                for (size_t k = 0; k < 100; ++k)\n+                    vChecks.emplace_back(k == 99 && end_fails);\n+                control.Add(vChecks);\n+            }\n+            result[end_fails ? 0 : 1] = control.Wait();\n+        }\n+        BOOST_CHECK(!result[0]);\n+        BOOST_CHECK(result[1]);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::shared_ptr<Unique_Queue>(new Unique_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathalogical case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+//\n+// This test (failing) is dependent on not being able to handle\n+// 1000*200 MB of memory, and able to handle 600MB of memory\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::shared_ptr<Memory_Queue>(new Memory_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{queue->Thread();});\n+    }\n+    for (size_t i = 9999; i < 9999; --i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that a new verification cannot occur until all checks \n+// have been destructed\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n+{\n+    auto queue = std::shared_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue {128});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([=]{queue->Thread();});\n+    }\n+    std::atomic<bool> finished{false};\n+    std::thread t0([&]() {\n+        CCheckQueueControl<FrozenCleanupCheck> control(queue.get());\n+        FrozenCleanupCheck::frozen = true;\n+        std::vector<FrozenCleanupCheck> vChecks;\n+        vChecks.emplace_back();\n+        control.Add(vChecks);\n+        control.Wait(); // Hangs here\n+        finished = true;\n+    });\n+    // We should never read a finished status\n+    //\n+    // Try waiting a second (which should be plenty of time to reach the hang\n+    // point in t0)\n+    //\n+    // Note that this cannot cause a spurious failure, only could mean that\n+    // the test doesn't actually end up checking that control waited.\n+    MilliSleep(1000);",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 343,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "f4f14263ad74cf612b9d948e304f0052254de6de",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think you could easily make this test deterministic as well, eliminating the long sleep and the while (frozen) busy loops. Would just need to have ~FrozenCleanupCheck increment a counter and signal a conditional variable so you could wait here for enough jobs to be frozen, and then do the boost check. Then this could signal another condition variable to unfreeze the jobs. I think it would be worth changing this to make the test more efficient and reliable.",
      "created_at": "2017-01-11T22:39:50Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r95688870",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/95688870"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96090665",
      "pull_request_review_id": 16669547,
      "id": 96090665,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk2MDkwNjY1",
      "diff_hunk": "@@ -372,29 +381,40 @@ BOOST_AUTO_TEST_CASE(test_CheckQueueControl_Locks)\n     }\n     {\n         boost::thread_group tg;\n-        std::atomic<bool> has_lock {false};\n-        std::atomic<bool> done {false};\n-        std::atomic<bool> done_ack {false};\n-        tg.create_thread([&, queue]{\n-                CCheckQueueControl<FakeCheck> control(queue.get());\n-                has_lock = true;\n-                MilliSleep(1000);\n-                done = true;\n-                // Wait until the done is acknowledged\n-                while (!done_ack) {\n-                }\n-                });\n-        // Wait for thread to get the lock\n-        while (!has_lock) {}\n-        bool fails2 = false;\n-        // Agressively check that we can never aquire the lock, once\n-        // the thread has stopped check that we never got it.\n-        while (!done && !fails2) {\n-            fails2 = queue->ControlMutex.try_lock();\n+        std::mutex m;\n+        bool has_lock {false};",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 237,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "27b8cbaea84e8d31b4499e11340ed798c501c737",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It might be clearer to replace all these bools with an enum like { STARTED, TRY_LOCK, TRY_LOCK_DONE, DONE, DONE_ACK }.\r\n\r\n",
      "created_at": "2017-01-13T22:58:32Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r96090665",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96090665"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96304542",
      "pull_request_review_id": 16882485,
      "id": 96304542,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk2MzA0NTQy",
      "diff_hunk": "@@ -372,29 +381,40 @@ BOOST_AUTO_TEST_CASE(test_CheckQueueControl_Locks)\n     }\n     {\n         boost::thread_group tg;\n-        std::atomic<bool> has_lock {false};\n-        std::atomic<bool> done {false};\n-        std::atomic<bool> done_ack {false};\n-        tg.create_thread([&, queue]{\n-                CCheckQueueControl<FakeCheck> control(queue.get());\n-                has_lock = true;\n-                MilliSleep(1000);\n-                done = true;\n-                // Wait until the done is acknowledged\n-                while (!done_ack) {\n-                }\n-                });\n-        // Wait for thread to get the lock\n-        while (!has_lock) {}\n-        bool fails2 = false;\n-        // Agressively check that we can never aquire the lock, once\n-        // the thread has stopped check that we never got it.\n-        while (!done && !fails2) {\n-            fails2 = queue->ControlMutex.try_lock();\n+        std::mutex m;\n+        bool has_lock {false};",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 237,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "27b8cbaea84e8d31b4499e11340ed798c501c737",
      "in_reply_to_id": 96090665,
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Going to ignore this, I don't think it makes it more clear (to me, it's easier to debug several variables). If someone disagrees strongly, will change.",
      "created_at": "2017-01-16T21:03:50Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r96304542",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/96304542"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98392131",
      "pull_request_review_id": 19030165,
      "id": 98392131,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk4MzkyMTMx",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    };\n+    ~MemoryCheck(){\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    BOOST_REQUIRE(UniqueCheck::results.size() == COUNT);\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathological case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+    }\n+    for (size_t i = 9999; i < 9999; --i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        BOOST_REQUIRE(MemoryCheck::fake_allocated_memory == 0);",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 331,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "0949835100e60901f51ce2b7cd95d912d13241a5",
      "in_reply_to_id": null,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The MemoryCheck struct destructor does not --, so this should not be == 0 unless no MemoryCheck constructors are ever called.",
      "created_at": "2017-01-30T08:05:38Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r98392131",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98392131"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98395364",
      "pull_request_review_id": 19033484,
      "id": 98395364,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk4Mzk1MzY0",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    };\n+    ~MemoryCheck(){\n+        if (b) {\n+            fake_allocated_memory += 1;",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 93,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "0949835100e60901f51ce2b7cd95d912d13241a5",
      "in_reply_to_id": null,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`fake_allocated_memory -= 1`",
      "created_at": "2017-01-30T08:38:37Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r98395364",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98395364"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98395928",
      "pull_request_review_id": 19034083,
      "id": 98395928,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk4Mzk1OTI4",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    };\n+    ~MemoryCheck(){\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    std::array<FailingCheck, 100> checks;",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 246,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "0949835100e60901f51ce2b7cd95d912d13241a5",
      "in_reply_to_id": null,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Unused variable.",
      "created_at": "2017-01-30T08:43:30Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r98395928",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98395928"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98396352",
      "pull_request_review_id": 19034549,
      "id": 98396352,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk4Mzk2MzUy",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    };\n+    ~MemoryCheck(){\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    BOOST_REQUIRE(UniqueCheck::results.size() == COUNT);\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathological case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+    }\n+    for (size_t i = 9999; i < 9999; --i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        BOOST_REQUIRE(MemoryCheck::fake_allocated_memory == 0);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that a new verification cannot occur until all checks \n+// have been destructed\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n+{\n+    auto queue = std::unique_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    bool fails = false;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+        tg.create_thread([&]{queue->Thread();});\n+    }\n+    std::thread t0([&]() {\n+        CCheckQueueControl<FrozenCleanupCheck> control(queue.get());\n+        std::vector<FrozenCleanupCheck> vChecks(1);\n+        // Freezing can't be the default initialized behavior given how the queue\n+        // swaps in default initialized Checks (otherwise freezing destructor\n+        // would get called twice).\n+        vChecks[0].should_freeze = true;\n+        control.Add(vChecks);\n+        control.Wait(); // Hangs here\n+    });\n+    {\n+        std::unique_lock<std::mutex> l(FrozenCleanupCheck::m);\n+        // Wait until the queue has finished all jobs and frozen\n+        FrozenCleanupCheck::cv.wait(l, [](){return FrozenCleanupCheck::nFrozen == 1;});\n+        // Try to get control of the queue a bunch of times\n+        for (auto x = 0; x < 100; ++x) {",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 362,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "0949835100e60901f51ce2b7cd95d912d13241a5",
      "in_reply_to_id": null,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Doing `!fails && x < 100` here and simply `fails = queue->ControlMutex.try_lock();` would break iteration on first fail rather than iterate over all 100 (e.g. if first `try_lock()` fails).",
      "created_at": "2017-01-30T08:46:39Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r98396352",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98396352"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98396462",
      "pull_request_review_id": 19034660,
      "id": 98396462,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDk4Mzk2NDYy",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    };\n+    ~MemoryCheck(){\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    BOOST_REQUIRE(UniqueCheck::results.size() == COUNT);\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathological case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+    }\n+    for (size_t i = 9999; i < 9999; --i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        BOOST_REQUIRE(MemoryCheck::fake_allocated_memory == 0);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that a new verification cannot occur until all checks \n+// have been destructed\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n+{\n+    auto queue = std::unique_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    bool fails = false;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+        tg.create_thread([&]{queue->Thread();});\n+    }\n+    std::thread t0([&]() {\n+        CCheckQueueControl<FrozenCleanupCheck> control(queue.get());\n+        std::vector<FrozenCleanupCheck> vChecks(1);\n+        // Freezing can't be the default initialized behavior given how the queue\n+        // swaps in default initialized Checks (otherwise freezing destructor\n+        // would get called twice).\n+        vChecks[0].should_freeze = true;\n+        control.Add(vChecks);\n+        control.Wait(); // Hangs here\n+    });\n+    {\n+        std::unique_lock<std::mutex> l(FrozenCleanupCheck::m);\n+        // Wait until the queue has finished all jobs and frozen\n+        FrozenCleanupCheck::cv.wait(l, [](){return FrozenCleanupCheck::nFrozen == 1;});\n+        // Try to get control of the queue a bunch of times\n+        for (auto x = 0; x < 100; ++x) {\n+            fails = fails || queue->ControlMutex.try_lock();\n+        }\n+        // Unfreeze\n+        FrozenCleanupCheck::nFrozen = 0;\n+    }\n+    // Awaken frozen destructor\n+    FrozenCleanupCheck::cv.notify_one();\n+    // Wait for control to finish\n+    t0.join();\n+    tg.interrupt_all();\n+    tg.join_all();\n+    BOOST_REQUIRE(!fails);\n+}\n+\n+\n+/** Test that CCheckQueueControl is threadsafe */\n+BOOST_AUTO_TEST_CASE(test_CheckQueueControl_Locks)\n+{\n+    auto queue = std::unique_ptr<Standard_Queue>(new Standard_Queue{QUEUE_BATCH_SIZE});\n+    {\n+        boost::thread_group tg;\n+        std::atomic<int> nThreads {0};\n+        std::atomic<int> fails {0};\n+        for (size_t i = 0; i < 3; ++i) {\n+            tg.create_thread(\n+                    [&]{\n+                    CCheckQueueControl<FakeCheck> control(queue.get());\n+                    // While sleeping, no other thread should execute to this point\n+                    auto observed = ++nThreads;\n+                    MilliSleep(10);\n+                    fails += observed  != nThreads;\n+                    });\n+        }\n+        tg.join_all();\n+        BOOST_REQUIRE(fails == 0);\n+    }\n+    {\n+        boost::thread_group tg;\n+        std::mutex m;\n+        bool has_lock {false};\n+        bool has_tried {false};\n+        bool done {false};\n+        bool done_ack {false};\n+        std::condition_variable cv;\n+        {\n+            std::unique_lock<std::mutex> l(m);\n+            tg.create_thread([&]{\n+                    CCheckQueueControl<FakeCheck> control(queue.get());\n+                    std::unique_lock<std::mutex> l(m);\n+                    has_lock = true;\n+                    cv.notify_one();\n+                    cv.wait(l, [&]{return has_tried;});\n+                    done = true;\n+                    cv.notify_one();\n+                    // Wait until the done is acknowledged\n+                    //\n+                    cv.wait(l, [&]{return done_ack;});\n+                    });\n+            // Wait for thread to get the lock\n+            cv.wait(l, [&](){return has_lock;});\n+            bool fails = false;\n+            for (auto x = 0; x < 100; ++x) {",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 424,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "0949835100e60901f51ce2b7cd95d912d13241a5",
      "in_reply_to_id": null,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Same here with `!fails && x < 100` as above.",
      "created_at": "2017-01-30T08:47:30Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r98396462",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/98396462"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/101452594",
      "pull_request_review_id": 22180743,
      "id": 101452594,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwMTQ1MjU5NA==",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    };\n+    ~MemoryCheck(){\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    BOOST_REQUIRE(UniqueCheck::results.size() == COUNT);\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathological case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+    }\n+    for (size_t i = 9999; i < 9999; --i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        BOOST_REQUIRE(MemoryCheck::fake_allocated_memory == 0);",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 331,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "0949835100e60901f51ce2b7cd95d912d13241a5",
      "in_reply_to_id": 98392131,
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, it was the latter. The for loop never made anything (i = 9999; i<9999). Will fix :) ",
      "created_at": "2017-02-16T06:26:59Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r101452594",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/101452594"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/101452623",
      "pull_request_review_id": 22180772,
      "id": 101452623,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwMTQ1MjYyMw==",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    };\n+    ~MemoryCheck(){\n+        if (b) {\n+            fake_allocated_memory += 1;\n+        }\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE(FakeCheckCheckCompletion::n_calls == i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    std::array<FailingCheck, 100> checks;\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    BOOST_REQUIRE(UniqueCheck::results.size() == COUNT);\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathological case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+    }\n+    for (size_t i = 9999; i < 9999; --i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        BOOST_REQUIRE(MemoryCheck::fake_allocated_memory == 0);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that a new verification cannot occur until all checks \n+// have been destructed\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n+{\n+    auto queue = std::unique_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    bool fails = false;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+        tg.create_thread([&]{queue->Thread();});\n+    }\n+    std::thread t0([&]() {\n+        CCheckQueueControl<FrozenCleanupCheck> control(queue.get());\n+        std::vector<FrozenCleanupCheck> vChecks(1);\n+        // Freezing can't be the default initialized behavior given how the queue\n+        // swaps in default initialized Checks (otherwise freezing destructor\n+        // would get called twice).\n+        vChecks[0].should_freeze = true;\n+        control.Add(vChecks);\n+        control.Wait(); // Hangs here\n+    });\n+    {\n+        std::unique_lock<std::mutex> l(FrozenCleanupCheck::m);\n+        // Wait until the queue has finished all jobs and frozen\n+        FrozenCleanupCheck::cv.wait(l, [](){return FrozenCleanupCheck::nFrozen == 1;});\n+        // Try to get control of the queue a bunch of times\n+        for (auto x = 0; x < 100; ++x) {",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 362,
      "commit_id": "96c7f2c3458950061b057fcd3daaf47b57e6bac7",
      "original_commit_id": "0949835100e60901f51ce2b7cd95d912d13241a5",
      "in_reply_to_id": 98396352,
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "sure..\r\n",
      "created_at": "2017-02-16T06:27:10Z",
      "updated_at": "2017-02-16T06:38:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9497#discussion_r101452623",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/101452623"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9497"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    }
  ]
}