{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196",
    "id": 1458538966,
    "node_id": "PR_kwDOABII585W74nW",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/28196",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/28196.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/28196.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/db9888feec48c6220a2fcf92865503bbbdab02a4",
    "number": 28196,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "BIP324 connection support",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is part of #27634.\r\n\r\nThis implements the BIP324 v2 transport (which implements all of what the BIP calls transport layer *and* application layer), though in a non-exposed way. It is tested through an extensive fuzz test, which verifies that v2 transports can talk to v2 transports, and v1 transports can talk to v2 transports, and a unit test that exercises a number of unusual scenarios. The transport is functionally complete, including:\r\n* Autodetection of incoming V1 connections.\r\n* Garbage, both sending and receiving.\r\n* Short message type IDs, both sending and receiving.\r\n* Ignore packets (receiving only, but tested in a unit test).\r\n* Session IDs are visible in `getpeerinfo` output (for manual comparison).\r\n\r\nThings that are not included, left for future PRs, are:\r\n* Actually using the v2 transport for connections.\r\n* Support for the `NODE_P2P_V2` service flag.\r\n* Retrying downgrade to V1 when attempted outbound V2 connections immediately fail.\r\n* P2P functional and unit tests\r\n",
    "labels": [
      {
        "id": 98298007,
        "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
        "name": "P2P",
        "color": "006b75",
        "default": false
      }
    ],
    "created_at": "2023-08-01T17:56:58Z",
    "updated_at": "2024-09-12T20:45:03Z",
    "closed_at": "2023-09-08T09:24:15Z",
    "mergeable_state": "unknown",
    "merged_at": "2023-09-08T09:24:15Z",
    "merge_commit_sha": "4e1a38c6df91f96ca8a2ef07413ffdb1d59c30cc",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "sipa:202307_bip324_transport",
      "ref": "202307_bip324_transport",
      "sha": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 21,
        "stargazers_count": 87,
        "watchers_count": 87,
        "size": 248118,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-09-12T19:22:32Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2024-08-21T16:21:35Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "8e0d9796da8cfb6c4e918788a03eea125d0633a6",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36157,
        "stargazers_count": 78358,
        "watchers_count": 78358,
        "size": 268336,
        "default_branch": "master",
        "open_issues_count": 664,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-09-12T18:52:19Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-09-12T20:26:46Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 1558,
    "deletions": 59,
    "changed_files": 9,
    "commits": 10,
    "review_comments": 208,
    "comments": 16
  },
  "events": [
    {
      "event": "commented",
      "id": 1660822807,
      "node_id": "IC_kwDOABII585i_iUX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1660822807",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T17:57:01Z",
      "updated_at": "2023-09-08T09:02:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [theStack](https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1615577560), [mzumsande](https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1609918939), [naumenkogs](https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1711330681) |\n| Concept ACK | [Sjors](https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1616178583) |\n| Stale ACK | [vincenzopalazzo](https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1600273013), [vasild](https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1615162515) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1660822807",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "convert_to_draft",
      "id": 9979592876,
      "node_id": "CTDE_lADOABII585tLpVKzwAAAAJS1ICs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9979592876",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T17:57:23Z"
    },
    {
      "event": "renamed",
      "id": 9979614259,
      "node_id": "RTE_lADOABII585tLpVKzwAAAAJS1NQz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9979614259",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T17:59:49Z",
      "rename": {
        "from": "BIP324 transport support",
        "to": "BIP324 connection support"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9979718870,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJS1mzW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9979718870",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T18:12:06Z"
    },
    {
      "event": "labeled",
      "id": 9979723825,
      "node_id": "LE_lADOABII585tLpVKzwAAAAJS1oAx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9979723825",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T18:12:42Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9979969736,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJS2kDI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9979969736",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T18:43:05Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9980213971,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJS3frT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9980213971",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T19:06:18Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9980398938,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJS4M1a",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9980398938",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T19:30:24Z"
    },
    {
      "event": "unlabeled",
      "id": 9981318054,
      "node_id": "UNLE_lADOABII585tLpVKzwAAAAJS7tOm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9981318054",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T21:27:21Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10092803077,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJZk_QF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10092803077",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-15T00:36:17Z"
    },
    {
      "event": "labeled",
      "id": 10093881546,
      "node_id": "LE_lADOABII585tLpVKzwAAAAJZpGjK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10093881546",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-15T05:34:01Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unsubscribed",
      "id": 10096267324,
      "node_id": "UE_lADOABII585tLpVKzwAAAAJZyNA8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10096267324",
      "actor": {
        "login": "dellroy979",
        "id": 135130941,
        "node_id": "U_kgDOCA3vPQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/135130941?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dellroy979",
        "html_url": "https://github.com/dellroy979",
        "followers_url": "https://api.github.com/users/dellroy979/followers",
        "following_url": "https://api.github.com/users/dellroy979/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dellroy979/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dellroy979/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dellroy979/subscriptions",
        "organizations_url": "https://api.github.com/users/dellroy979/orgs",
        "repos_url": "https://api.github.com/users/dellroy979/repos",
        "events_url": "https://api.github.com/users/dellroy979/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dellroy979/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-15T11:51:52Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10102085579,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJaIZfL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10102085579",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-15T22:28:18Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10102800832,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJaLIHA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10102800832",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-16T01:09:07Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10112855260,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJaxezc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10112855260",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-16T21:22:10Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10113460725,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJazyn1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10113460725",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-16T23:21:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10114114786,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJa2STi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10114114786",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-17T02:08:34Z"
    },
    {
      "event": "unlabeled",
      "id": 10114529825,
      "node_id": "UNLE_lADOABII585tLpVKzwAAAAJa33oh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10114529825",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-17T03:44:20Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 10119762048,
      "node_id": "LE_lADOABII585tLpVKzwAAAAJbL1CA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10119762048",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-17T13:49:35Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10122604250,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJbWq7a",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10122604250",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-17T18:17:44Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10122954972,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJbYAjc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10122954972",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-17T18:58:43Z"
    },
    {
      "event": "unlabeled",
      "id": 10123450575,
      "node_id": "UNLE_lADOABII585tLpVKzwAAAAJbZ5jP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10123450575",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-17T20:02:22Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10125450444,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJbhhzM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10125450444",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T02:50:44Z"
    },
    {
      "event": "labeled",
      "id": 10125450773,
      "node_id": "LE_lADOABII585tLpVKzwAAAAJbhh4V",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10125450773",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T02:50:49Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10129989640,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJby2AI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10129989640",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T13:19:52Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10130400698,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJb0aW6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10130400698",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T14:03:27Z"
    },
    {
      "event": "unlabeled",
      "id": 10132578398,
      "node_id": "UNLE_lADOABII585tLpVKzwAAAAJb8uBe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10132578398",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-18T18:30:52Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10136660322,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJcMSli",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10136660322",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-19T16:57:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10149684358,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJc9-SG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10149684358",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-21T19:27:47Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10149726176,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJc-Ifg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10149726176",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-21T19:32:47Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10162208187,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJdtv27",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10162208187",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T19:13:28Z"
    },
    {
      "event": "labeled",
      "id": 10162663734,
      "node_id": "LE_lADOABII585tLpVKzwAAAAJdvfE2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10162663734",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T20:05:35Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1689980940,
      "node_id": "IC_kwDOABII585kuxAM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1689980940",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-23T13:36:40Z",
      "updated_at": "2023-08-23T13:43:42Z",
      "author_association": "MEMBER",
      "body": "Started doing review, out of order. Some quick initial questions and remarks...\r\n\r\nI tend to get spontaneous v2 connections eventually, both inbound and outbound. But are there any known reachable mainnet nodes folks can test against? (testnet and signet is fine too I suppose)\r\n\r\nI would be useful to have at least one log message in the lifetime of a peer to indicate it's a v2. E.g. `[net] Added v2 connection peer=â€¦` (haven't checked if we already know it's v2 at that point)\r\n\r\nDo I assume correctly that `0` refers to size of the message payload, i.e. ignoring the (short) message id (what was a header in v1)? `[net] sending verack (0 bytes)`",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1689980940",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "reviewed",
      "id": 1591588401,
      "node_id": "PRR_kwDOABII585e3bYx",
      "url": null,
      "actor": null,
      "commit_id": "163d93304dea08bf8f2ea79d79cabceec1a13d96",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1591588401",
      "submitted_at": "2023-08-23T13:43:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10175507637,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJegey1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10175507637",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-24T00:14:27Z"
    },
    {
      "event": "commented",
      "id": 1690811854,
      "node_id": "IC_kwDOABII585kx73O",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1690811854",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-24T00:28:26Z",
      "updated_at": "2023-08-24T00:28:26Z",
      "author_association": "MEMBER",
      "body": "I've dropped the last two commits here (which enabled rudimentary testing), as better testing is possible with #28331 now.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1690811854",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "unlabeled",
      "id": 10177663519,
      "node_id": "UNLE_lADOABII585tLpVKzwAAAAJeotIf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10177663519",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-24T07:05:45Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10181195334,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJe2LZG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10181195334",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-24T13:03:59Z"
    },
    {
      "event": "ready_for_review",
      "id": 10181200576,
      "node_id": "RFRE_lADOABII585tLpVKzwAAAAJe2MrA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10181200576",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-24T13:04:26Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10203209065,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJgKJ1p",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10203209065",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-28T01:10:26Z"
    },
    {
      "event": "commented",
      "id": 1694850508,
      "node_id": "IC_kwDOABII585lBV3M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1694850508",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-28T01:14:19Z",
      "updated_at": "2023-08-28T01:14:19Z",
      "author_association": "MEMBER",
      "body": "Added a commit adding unit tests for `V2Transport`, running through a number of valid and invalid scenarios (including overly-long garbage, decoy packets, ignore bits and non-empty garbage authentication, non-empty version packets, and bit errors).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1694850508",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10203258567,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJgKV7H",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10203258567",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-28T01:17:52Z"
    },
    {
      "event": "labeled",
      "id": 10203258899,
      "node_id": "LE_lADOABII585tLpVKzwAAAAJgKWAT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10203258899",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-28T01:17:56Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 10203903067,
      "node_id": "UNLE_lADOABII585tLpVKzwAAAAJgMzRb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10203903067",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-28T02:54:55Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1599275947,
      "node_id": "PRR_kwDOABII585fUwOr",
      "url": null,
      "actor": null,
      "commit_id": "f41a1a0ae49c3ada8073edb3c051deaa7534d494",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1599275947",
      "submitted_at": "2023-08-28T23:53:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10215753132,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJg6AWs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10215753132",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-29T03:00:46Z"
    },
    {
      "event": "labeled",
      "id": 10216174444,
      "node_id": "LE_lADOABII585tLpVKzwAAAAJg7nNs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10216174444",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-29T04:41:17Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1600253188,
      "node_id": "PRR_kwDOABII585fYe0E",
      "url": null,
      "actor": null,
      "commit_id": "aa1da1a0ef0504d4f30ab3b101b334e11b8868ac",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1600253188",
      "submitted_at": "2023-08-29T12:08:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "reviewed",
      "id": 1600273013,
      "node_id": "PRR_kwDOABII585fYjp1",
      "url": null,
      "actor": null,
      "commit_id": "d9344fd5c77e69a544c2d80aa6cbd20827f2e169",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "ACK https://github.com/bitcoin/bitcoin/pull/28196/commits/d9344fd5c77e69a544c2d80aa6cbd20827f2e169\r\n\r\nDoes CI failure look like an unlucky run? or unrelated\r\n\r\n\r\n```\r\n node2 2023-08-29T03:35:33.769000Z [httpworker.2] [wallet/wallet.h:832] [WalletLogPrintf] [w1] AddToWallet e930f400504216afbf78e3760d4f6730547258b8a453514d7b2b5bccd2432f9a \r\n node2 2023-08-29T03:35:33.769921Z [http] [httpserver.cpp:241] [http_request_cb] [http] Received a POST request for /wallet/w1 from 127.0.0.1:49136 \r\n node2 2023-08-29T03:35:33.769971Z [httpworker.3] [rpc/request.cpp:179] [parse] [rpc] ThreadRPCServer method=getwalletinfo user=__cookie__ \r\n node2 2023-08-29T03:35:33.770827Z [http] [httpserver.cpp:241] [http_request_cb] [http] Received a POST request for /wallet/w1 from 127.0.0.1:49136 \r\n node2 2023-08-29T03:35:33.770859Z [httpworker.0] [rpc/request.cpp:179] [parse] [rpc] ThreadRPCServer method=listtransactions user=__cookie__ \r\n test  2023-08-29T03:35:33.772000Z TestFramework (ERROR): Assertion failed \r\n                                   Traceback (most recent call last):\r\n                                     File \"/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/test/functional/test_framework/test_framework.py\", line 131, in main\r\n                                       self.run_test()\r\n                                     File \"/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/test/functional/wallet_backwards_compatibility.py\", line 201, in run_test\r\n                                       assert txs[3][\"abandoned\"]\r\n                                   AssertionError\r\n test  2023-08-29T03:35:33.773000Z TestFramework (DEBUG): Closing down network thread \r\n```",
      "user": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1600273013",
      "submitted_at": "2023-08-29T12:18:41Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "unlabeled",
      "id": 10220809839,
      "node_id": "UNLE_lADOABII585tLpVKzwAAAAJhNS5v",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10220809839",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-29T12:47:41Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10225367734,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJherq2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10225367734",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-29T20:08:32Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10225612587,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJhfncr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10225612587",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-29T20:39:35Z"
    },
    {
      "event": "reviewed",
      "id": 1601752363,
      "node_id": "PRR_kwDOABII585feM0r",
      "url": null,
      "actor": null,
      "commit_id": "0ccee83cb3b733320e70891bdc71eb50111e4d3a",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nLeft some nits regarding short message encoding below, planning to do a deeper review within the next days.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1601752363",
      "submitted_at": "2023-08-30T02:28:36Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10227708249,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJhnnFZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10227708249",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-30T02:48:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10234458679,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJiBXI3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10234458679",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-30T15:19:24Z"
    },
    {
      "event": "commented",
      "id": 1699574611,
      "node_id": "IC_kwDOABII585lTXNT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1699574611",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-30T17:27:29Z",
      "updated_at": "2023-08-31T03:50:55Z",
      "author_association": "MEMBER",
      "body": "For anyone wanting to review the inner commits of this PR, I recommend starting with the state definitions in \"net: add V2Transport class with subset of BIP324 functionality\": https://github.com/bitcoin/bitcoin/blob/1a8892201ef8ca6192348d15e25e50d1eabea986/src/net.h#L433L507\r\n\r\nThe idea is that both the sender side and receiver side of `V2Transport` are state machines that are transitioned through, with each state corresponding to the meaning of what is in the respective send/receive buffers. The receive state is changed by receiving bytes, or extracting completed messages. The send state is changed by receiving bytes, sending bytes, or being given a message to send.\r\n\r\nLater commits then extend this state machine with additional features, like detecting V1 connections, and sending garbage. If useful, I'm happy to split things up further (e.g. breaking out incoming garbage detection, or skipping of decoy packets, into separate commits), but I'd like to hear about this approach from reviewers first.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1699574611",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "reviewed",
      "id": 1601240500,
      "node_id": "PRR_kwDOABII585fcP20",
      "url": null,
      "actor": null,
      "commit_id": "1e2ee453ff469d5876fe070b1a0ef618b54c88e4",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK - I reviewed only the first two commits so far in-depth.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1601240500",
      "submitted_at": "2023-08-30T20:03:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10237183975,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJiLwfn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10237183975",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-30T20:38:00Z"
    },
    {
      "event": "labeled",
      "id": 10238590281,
      "node_id": "LE_lADOABII585tLpVKzwAAAAJiRH1J",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10238590281",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-31T00:57:17Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 10239513551,
      "node_id": "UNLE_lADOABII585tLpVKzwAAAAJiUpPP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10239513551",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-31T04:09:35Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1602648914,
      "node_id": "PRR_kwDOABII585fhntS",
      "url": null,
      "actor": null,
      "commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Reviewed up to 1a8892201e (incl). Posting review midway. Mostly minor stuff in the comments below.",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1602648914",
      "submitted_at": "2023-08-31T13:28:14Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10248880151,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJi4YAX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10248880151",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-31T19:06:59Z"
    },
    {
      "event": "commented",
      "id": 1701650532,
      "node_id": "IC_kwDOABII585lbSBk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1701650532",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-31T19:21:36Z",
      "updated_at": "2023-08-31T19:21:36Z",
      "author_association": "MEMBER",
      "body": "I've addressed most of @vasild's comments above, leading to some substantial changes in the \"net: add V2Transport class with subset of BIP324 functionality\" commit.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1701650532",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "mentioned",
      "id": 10249041778,
      "node_id": "MEE_lADOABII585tLpVKzwAAAAJi4_dy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10249041778",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-31T19:21:37Z"
    },
    {
      "event": "subscribed",
      "id": 10249041814,
      "node_id": "SE_lADOABII585tLpVKzwAAAAJi4_eW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10249041814",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-31T19:21:37Z"
    },
    {
      "event": "reviewed",
      "id": 1605372003,
      "node_id": "PRR_kwDOABII585fsAhj",
      "url": null,
      "actor": null,
      "commit_id": "6905f56a2ed01701f9d6d73f3e1a4ca8e0b1cddd",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1605372003",
      "submitted_at": "2023-08-31T20:32:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10249876299,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJi8LNL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10249876299",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-31T20:46:38Z"
    },
    {
      "event": "reviewed",
      "id": 1606655503,
      "node_id": "PRR_kwDOABII585fw54P",
      "url": null,
      "actor": null,
      "commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 8bd5aa1a1084c5f4c34cba85506661338e8e91ea (I need to re-review the unit test from the last commit more carefully)\r\n\r\nNon-blocker comments below.\r\n\r\n",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1606655503",
      "submitted_at": "2023-09-01T16:22:46Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "review_requested",
      "id": 10259058677,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJjfM_1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10259058677",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-01T16:22:51Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10259059105,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJjfNGh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10259059105",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-01T16:22:54Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10259059294,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJjfNJe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10259059294",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-01T16:22:55Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1602833673,
      "node_id": "PRR_kwDOABII585fiU0J",
      "url": null,
      "actor": null,
      "commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Studied the state machine a bit, which makes sense to me, except the `KEY -> KEY_GARBTERM_GARBAUTH_VERSION` transition.\r\n\r\nRunning the code (using the main PR). I also looked at the fallback mechanism.\r\n\r\nGeneral protocol question: why are `garbage` and `decoy packets` distinct concepts in BIP324? That is, why can't garbage just be a single instance of a decoy package? ",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1602833673",
      "submitted_at": "2023-09-01T19:06:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "review_request_removed",
      "id": 10260285852,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJjj4mc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10260285852",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-01T19:06:10Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10260285933,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJjj4nt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10260285933",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-01T19:06:11Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10260286262,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJjj4s2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10260286262",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-01T19:06:13Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10260286345,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJjj4uJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10260286345",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-01T19:06:14Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10260292676,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJjj6RE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10260292676",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-01T19:07:12Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10260292743,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJjj6SH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10260292743",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-01T19:07:12Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10260473684,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJjkmdU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10260473684",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-01T19:36:34Z"
    },
    {
      "event": "reviewed",
      "id": 1607368990,
      "node_id": "PRR_kwDOABII585fzoEe",
      "url": null,
      "actor": null,
      "commit_id": "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Addressed a number of comments by @vasild and @Sjors.\r\n\r\nI've also removed the Erlay messages from the short message id list, after observing that having them there makes no difference: if peers send us these, the messages will be ignored, whether they're in the list or not. After discussing with @mzumsande I think it may also be better to remove them from the BIP for now, but it's nice to realize that they can be dropped from the code regardless of what happens to the BIP.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1607368990",
      "submitted_at": "2023-09-01T19:53:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "commented",
      "id": 1703257925,
      "node_id": "IC_kwDOABII585lhadF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1703257925",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-01T19:57:28Z",
      "updated_at": "2023-09-01T20:06:34Z",
      "author_association": "MEMBER",
      "body": "@Sjors \r\n\r\n> General protocol question: why are garbage and decoy packets distinct concepts in BIP324? That is, why can't garbage just be a single instance of a decoy package?\r\n\r\nGood question. The answer is that decoy messages *can't* be used yet when garbage is sent, because the keys haven't been exchanged yet, so packets in general are not available yet. See also [BIP324 footnote 8](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#cite_note-why_garbage_8).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1703257925",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "mentioned",
      "id": 10260596621,
      "node_id": "MEE_lADOABII585tLpVKzwAAAAJjlEeN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10260596621",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-01T19:57:28Z"
    },
    {
      "event": "subscribed",
      "id": 10260596631,
      "node_id": "SE_lADOABII585tLpVKzwAAAAJjlEeX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10260596631",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-01T19:57:28Z"
    },
    {
      "event": "reviewed",
      "id": 1607831626,
      "node_id": "PRR_kwDOABII585f1ZBK",
      "url": null,
      "actor": null,
      "commit_id": "75b91740fdeb9ad14cc6cb073e75867b49875a00",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Reviewed up to 4810d69306ee214063386f9bfd40f89525482e8b so far, left some non-blocking nits on the way.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1607831626",
      "submitted_at": "2023-09-02T02:41:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10262833348,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJjtmjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10262833348",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-02T03:38:54Z"
    },
    {
      "event": "labeled",
      "id": 10273983984,
      "node_id": "LE_lADOABII585tLpVKzwAAAAJkYI3w",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10273983984",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-04T13:12:12Z",
      "label": {
        "name": "P2P",
        "color": "006b75"
      }
    },
    {
      "event": "reviewed",
      "id": 1609869928,
      "node_id": "PRR_kwDOABII585f9Kpo",
      "url": null,
      "actor": null,
      "commit_id": "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Some thoughts on d67be9ad3836bd19cc8ea71a0b99c7d60682dd32. It might make sense to directly track if we're blocked from sending pending the handshake, instead of the indirect approach of setting `more`. But I'm not convinced that would make things easier. ",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1609869928",
      "submitted_at": "2023-09-04T18:41:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "reviewed",
      "id": 1609921570,
      "node_id": "PRR_kwDOABII585f9XQi",
      "url": null,
      "actor": null,
      "commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1609921570",
      "submitted_at": "2023-09-04T20:05:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "commented",
      "id": 1705681791,
      "node_id": "IC_kwDOABII585lqqN_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1705681791",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-04T20:33:46Z",
      "updated_at": "2023-09-04T21:01:09Z",
      "author_association": "MEMBER",
      "body": "The recent discussion with @Sjors here made me realize that the send state machine is actually overkill, and could be replaced with a single boolean: are the ciphers initialized. It starts off false, gets set to true when the other side's key arrives. Whenever the send buffer is fully sent, it is wiped (without state change). A new message can be provided whenever the send buffer is empty and the keys are initialized. Stuff just gets concatenated to whatever is in the send buffer. There is no need for states that keep track of what's in there - we don't actually care about that.\r\n\r\nEDIT: the above works, until the V1 fallback detection is added, which complicates things enough that some kind of state machine on the sender side seems better. Going to leave things as-is for now.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1705681791",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "mentioned",
      "id": 10276933465,
      "node_id": "MEE_lADOABII585tLpVKzwAAAAJkjY9Z",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10276933465",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-04T20:33:47Z"
    },
    {
      "event": "subscribed",
      "id": 10276933472,
      "node_id": "SE_lADOABII585tLpVKzwAAAAJkjY9g",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10276933472",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-04T20:33:47Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10277212494,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJkkdFO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10277212494",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-04T21:51:18Z"
    },
    {
      "event": "commented",
      "id": 1705723891,
      "node_id": "IC_kwDOABII585lq0fz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1705723891",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-04T21:53:53Z",
      "updated_at": "2023-09-05T03:42:00Z",
      "author_association": "MEMBER",
      "body": "Ok, in the light of the above I have made some changes still. The former `KEY_GARB_GARBTERM_GARBAUTH_VERSION`, `APP`, and `APP_READY` states have all been merged into a `READY` state, and some other states have been renamed too.\r\n\r\nMy biggest takeaway here is really that the send state shouldn't (try to) correspond to the contents of what's in the send buffer, but to what can be *added* to it and *sent* from it.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1705723891",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10277319142,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJkk3Hm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10277319142",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-04T22:25:41Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10278154166,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJkoC-2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10278154166",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T02:19:28Z"
    },
    {
      "event": "reviewed",
      "id": 1610488221,
      "node_id": "PRR_kwDOABII585f_hmd",
      "url": null,
      "actor": null,
      "commit_id": "4f1900596940c7a2c7f641f2ffaa4ef51aded97a",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1610488221",
      "submitted_at": "2023-09-05T09:01:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "commented",
      "id": 1706489922,
      "node_id": "IC_kwDOABII585ltvhC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1706489922",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T12:01:14Z",
      "updated_at": "2023-09-05T12:01:14Z",
      "author_association": "MEMBER",
      "body": "Reviewed everything 4f1900596940c7a2c7f641f2ffaa4ef51aded97a, see comments.\r\n\r\nAs for the unit tests, it would be nice to know what other coverage could be useful here. In the form of a todo or something. Or do you consider it close to complete?",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1706489922",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "reviewed",
      "id": 1610862313,
      "node_id": "PRR_kwDOABII585gA87p",
      "url": null,
      "actor": null,
      "commit_id": "4f1900596940c7a2c7f641f2ffaa4ef51aded97a",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1610862313",
      "submitted_at": "2023-09-05T12:01:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "commented",
      "id": 1706552139,
      "node_id": "IC_kwDOABII585lt-tL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1706552139",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T12:44:21Z",
      "updated_at": "2023-09-05T19:31:51Z",
      "author_association": "MEMBER",
      "body": "> As for the unit tests, it would be nice to know what other coverage could be useful here. In the form of a todo or something. Or do you consider it close to complete?\r\n\r\nI consider the fuzz tests (`p2p_transport_bidirectional_v2` and `p2p_transport_bidirectional_v1v2`) to be the most important tests in this PR, as they test the direct functional requirement we have: can V2Transports talk to other V2Transports and V1Transports, if everyone is honest. The unit tests are there to cover the cases that are not testable by the fuzz test (like making sure errors cause disconnect, and receiving-side handling of BIP324 aspects that are unimplemented on the sender side like decoy packets).\r\n\r\nSo, yes, I consider this close to complete - but I'm obviously happy to hear ideas for more tests. A lot more becomes testable once integrated though (#28331), as functional tests aren't really possible before.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1706552139",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "reviewed",
      "id": 1611066021,
      "node_id": "PRR_kwDOABII585gBuql",
      "url": null,
      "actor": null,
      "commit_id": "4f1900596940c7a2c7f641f2ffaa4ef51aded97a",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 4f1900596940c7a2c7f641f2ffaa4ef51aded97a\r\n\r\nWould be happy to re-review if further improvements arise from the discussions :)",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1611066021",
      "submitted_at": "2023-09-05T13:45:41Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "review_request_removed",
      "id": 10283955977,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJk-LcJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10283955977",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T13:45:46Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10283956169,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJk-LfJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10283956169",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T13:45:46Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10283956894,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJk-Lqe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10283956894",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T13:45:49Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10283957085,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJk-Ltd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10283957085",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T13:45:50Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1609931621,
      "node_id": "PRR_kwDOABII585f9Ztl",
      "url": null,
      "actor": null,
      "commit_id": "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "(midway review)",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1609931621",
      "submitted_at": "2023-09-05T14:00:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "review_request_removed",
      "id": 10284147403,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJk-6LL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10284147403",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T14:00:57Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10284147585,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJk-6OB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10284147585",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T14:00:58Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10284148340,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJk-6Z0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10284148340",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T14:01:01Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10284148480,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJk-6cA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10284148480",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T14:01:02Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10284804775,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJlBaqn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10284804775",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T14:54:19Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10284804935,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJlBatH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10284804935",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T14:54:20Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10284825541,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJlBfvF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10284825541",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T14:56:03Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10284825666,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJlBfxC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10284825666",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T14:56:04Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10284838795,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJlBi-L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10284838795",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T14:57:08Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10284838958,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJlBjAu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10284838958",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T14:57:08Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10284852256,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJlBmQg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10284852256",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T14:58:08Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10284852407,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJlBmS3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10284852407",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T14:58:09Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10284995665,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJlCJRR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10284995665",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T15:10:00Z"
    },
    {
      "event": "reviewed",
      "id": 1611398428,
      "node_id": "PRR_kwDOABII585gC_0c",
      "url": null,
      "actor": null,
      "commit_id": "70298caec38f3a085532a6c43bc82a869481ee33",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1611398428",
      "submitted_at": "2023-09-05T16:01:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10286118759,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJlGbdn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10286118759",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T17:09:30Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10290388551,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJlWt5H",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10290388551",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-06T03:40:40Z"
    },
    {
      "event": "labeled",
      "id": 10291443962,
      "node_id": "LE_lADOABII585tLpVKzwAAAAJlavj6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10291443962",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-06T06:00:10Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1613048752,
      "node_id": "PRR_kwDOABII585gJSuw",
      "url": null,
      "actor": null,
      "commit_id": "2a5a7ffff72ee5cafae44ae814acbdfe128e7bb6",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1613048752",
      "submitted_at": "2023-09-06T11:26:54Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10295565957,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJlqd6F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10295565957",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-06T12:52:57Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10296048066,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJlsTnC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10296048066",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-06T13:32:45Z"
    },
    {
      "event": "reviewed",
      "id": 1611552610,
      "node_id": "PRR_kwDOABII585gDldi",
      "url": null,
      "actor": null,
      "commit_id": "7807761ab209e0e9587821ef4c7948c5f6b3d610",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "light review, comparing implementation with the BIP, did not review the tests",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1611552610",
      "submitted_at": "2023-09-06T15:16:10Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "unlabeled",
      "id": 10297420049,
      "node_id": "UNLE_lADOABII585tLpVKzwAAAAJlxikR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10297420049",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-06T15:17:31Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10299363762,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJl49Gy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10299363762",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-06T18:38:53Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10299652583,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJl6Dnn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10299652583",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-06T19:13:36Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10300408754,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJl88Oy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10300408754",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-06T20:43:17Z"
    },
    {
      "event": "labeled",
      "id": 10300409568,
      "node_id": "LE_lADOABII585tLpVKzwAAAAJl88bg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10300409568",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-06T20:43:23Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10300616995,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJl9vEj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10300616995",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-06T21:10:29Z"
    },
    {
      "event": "unlabeled",
      "id": 10304049012,
      "node_id": "UNLE_lADOABII585tLpVKzwAAAAJmK090",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10304049012",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T07:55:44Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1709708053,
      "node_id": "IC_kwDOABII585l6BMV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1709708053",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T08:32:52Z",
      "updated_at": "2023-09-07T08:32:52Z",
      "author_association": "MEMBER",
      "body": "ACK 15ea0ce587a334b647119fe65de2b305720c3eba",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1709708053",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "review_request_removed",
      "id": 10304438862,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJmMUJO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10304438862",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T08:32:58Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10304438987,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmMULL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10304438987",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T08:32:58Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10304439154,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmMUNy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10304439154",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T08:32:59Z",
      "requested_reviewer": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1615162515,
      "node_id": "PRR_kwDOABII585gRWyT",
      "url": null,
      "actor": null,
      "commit_id": "15ea0ce587a334b647119fe65de2b305720c3eba",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 15ea0ce587a334b647119fe65de2b305720c3eba\r\n\r\n[Coverage report](https://people.freebsd.org/~vd/pr28196_15ea0ce587_coverage/modified_and_not_covered.html) for modified lines by this PR and not covered by tests:\r\n```\r\n./src/test/test_bitcoin\r\n./src/qt/test/test_bitcoin-qt\r\n./test/functional/test_runner.py\r\nFUZZ=p2p_transport_bidirectional_v2   ./src/test/fuzz/fuzz -max_total_time=1800 /tmp/empty\r\nFUZZ=p2p_transport_bidirectional_v1v2 ./src/test/fuzz/fuzz -max_total_time=1800 /tmp/empty\r\n```",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1615162515",
      "submitted_at": "2023-09-07T12:23:16Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "review_request_removed",
      "id": 10306756792,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJmVKC4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10306756792",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T12:23:22Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10306756906,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmVKEq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10306756906",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T12:23:22Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10306757526,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJmVKOW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10306757526",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T12:23:27Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10306757663,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmVKQf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10306757663",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T12:23:27Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGMzZmFkMWYyOWRmMDkzZThmZDAzZDcwZWI0M2YyNWVlOWQ1MzFiZjc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c3fad1f29df093e8fd03d70eb43f25ee9d531bf7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c3fad1f29df093e8fd03d70eb43f25ee9d531bf7",
      "tree": {
        "sha": "9167136caf012096d498b9cdc71d80fb0156d3b2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9167136caf012096d498b9cdc71d80fb0156d3b2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8e0d9796da8cfb6c4e918788a03eea125d0633a6",
          "sha": "8e0d9796da8cfb6c4e918788a03eea125d0633a6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8e0d9796da8cfb6c4e918788a03eea125d0633a6"
        }
      ],
      "message": "net: add have_next_message argument to Transport::GetBytesToSend()\n\nBefore this commit, there are only two possibly outcomes for the \"more\" prediction\nin Transport::GetBytesToSend():\n* true: the transport itself has more to send, so the answer is certainly yes.\n* false: the transport has nothing further to send, but if vSendMsg has more message(s)\n         left, that still will result in more wire bytes after the next\n         SetMessageToSend().\n\nFor the BIP324 v2 transport, there will arguably be a third state:\n* definitely not: the transport has nothing further to send, but even if vSendMsg has\n                  more messages left, they can't be sent (right now). This happens\n                  before the handshake is complete.\n\nTo implement this, we move the entire decision logic to the Transport, by adding a\nboolean to GetBytesToSend(), called have_next_message, which informs the transport\nwhether more messages are available. The return values are still true and false, but\nthey mean \"definitely yes\" and \"definitely no\", rather than \"yes\" and \"maybe\".",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-09-07T12:53:45Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-16T17:21:35Z"
      },
      "sha": "c3fad1f29df093e8fd03d70eb43f25ee9d531bf7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDVmNGIyYzZkNzllODFlZTA0NDU3NTJhZDU1OGZjYzE3ODMxZjRiMmY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5f4b2c6d79e81ee0445752ad558fcc17831f4b2f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5f4b2c6d79e81ee0445752ad558fcc17831f4b2f",
      "tree": {
        "sha": "3a4465702fb1aad427283d23dbb28f157b20a24b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3a4465702fb1aad427283d23dbb28f157b20a24b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c3fad1f29df093e8fd03d70eb43f25ee9d531bf7",
          "sha": "c3fad1f29df093e8fd03d70eb43f25ee9d531bf7",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c3fad1f29df093e8fd03d70eb43f25ee9d531bf7"
        }
      ],
      "message": "net: remove unused Transport::SetReceiveVersion",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-09-07T12:53:45Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-30T20:10:58Z"
      },
      "sha": "5f4b2c6d79e81ee0445752ad558fcc17831f4b2f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGRjMmQ3ZWI4MTBlZjk1YjA2NjIwZjMzNGMxOTg2ODc1Nzk5MTY0MzU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dc2d7eb810ef95b06620f334c198687579916435",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/dc2d7eb810ef95b06620f334c198687579916435",
      "tree": {
        "sha": "785006d10a3cde8d9663ac7d2a11272b01893f44",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/785006d10a3cde8d9663ac7d2a11272b01893f44"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5f4b2c6d79e81ee0445752ad558fcc17831f4b2f",
          "sha": "5f4b2c6d79e81ee0445752ad558fcc17831f4b2f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5f4b2c6d79e81ee0445752ad558fcc17831f4b2f"
        }
      ],
      "message": "crypto: Spanify EllSwiftPubKey constructor",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-09-07T12:53:45Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-31T14:00:05Z"
      },
      "sha": "dc2d7eb810ef95b06620f334c198687579916435"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDEzYTdmMDE1NTcyNzJkYjY1MmIzZjMzM2FmM2YwNmFmNjg5NzI1M2Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/13a7f01557272db652b3f333af3f06af6897253f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/13a7f01557272db652b3f333af3f06af6897253f",
      "tree": {
        "sha": "6c3cbead248669af9da2fbfd246b183ba3e66d22",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6c3cbead248669af9da2fbfd246b183ba3e66d22"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dc2d7eb810ef95b06620f334c198687579916435",
          "sha": "dc2d7eb810ef95b06620f334c198687579916435",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/dc2d7eb810ef95b06620f334c198687579916435"
        }
      ],
      "message": "net: add V2Transport class with subset of BIP324 functionality\n\nThis introduces a V2Transport with a basic subset of BIP324 functionality:\n* no ability to send garbage (but receiving is supported)\n* no ability to send decoy packets (but receiving them is supported)\n* no support for short message id encoding (neither encoding or decoding)\n* no waiting until 12 non-V1 bytes have been received\n* (and thus) no detection of V1 connections on the responder side\n  (on the sender side, detecting V1 is not supported either, but that needs\n  to be dealt with at a higher layer, by reconnecting)",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-09-07T13:00:58Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-07-27T19:10:34Z"
      },
      "sha": "13a7f01557272db652b3f333af3f06af6897253f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDhkYTg2NDIwNjJmYTJjN2FhMmY0OTk5NWI4MzJjM2QwODk3ZTM3ZWQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8da8642062fa2c7aa2f49995b832c3d0897e37ed",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8da8642062fa2c7aa2f49995b832c3d0897e37ed",
      "tree": {
        "sha": "60052bc38273e2403a88d251192b1dde0f8214d0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/60052bc38273e2403a88d251192b1dde0f8214d0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/13a7f01557272db652b3f333af3f06af6897253f",
          "sha": "13a7f01557272db652b3f333af3f06af6897253f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/13a7f01557272db652b3f333af3f06af6897253f"
        }
      ],
      "message": "net: make V2Transport auto-detect incoming V1 and fall back to it",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-09-07T13:01:01Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-30T02:37:18Z"
      },
      "sha": "8da8642062fa2c7aa2f49995b832c3d0897e37ed"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDBiZTc1MmQ5ZjhjYTI3MzIwYmMzZTgyNDk4Yzc2NDBmYWJkN2U4ZGU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0be752d9f8ca27320bc3e82498c7640fabd7e8de",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0be752d9f8ca27320bc3e82498c7640fabd7e8de",
      "tree": {
        "sha": "44abf612ba05a21f356c7822b762e82c1a57a75a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/44abf612ba05a21f356c7822b762e82c1a57a75a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8da8642062fa2c7aa2f49995b832c3d0897e37ed",
          "sha": "8da8642062fa2c7aa2f49995b832c3d0897e37ed",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8da8642062fa2c7aa2f49995b832c3d0897e37ed"
        }
      ],
      "message": "net: add short message encoding/decoding support to V2Transport",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-09-07T13:04:51Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-07-31T01:25:10Z"
      },
      "sha": "0be752d9f8ca27320bc3e82498c7640fabd7e8de"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDNmZmE1ZmI0OWVlNGE2ZDk1MDJhYTk1NzA5M2JkOTQwNTg2MzAyODI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3ffa5fb49ee4a6d9502aa957093bd94058630282",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/3ffa5fb49ee4a6d9502aa957093bd94058630282",
      "tree": {
        "sha": "cea7c27f2bdab8293e2f8f2d2e8dd37a48715cd7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cea7c27f2bdab8293e2f8f2d2e8dd37a48715cd7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0be752d9f8ca27320bc3e82498c7640fabd7e8de",
          "sha": "0be752d9f8ca27320bc3e82498c7640fabd7e8de",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0be752d9f8ca27320bc3e82498c7640fabd7e8de"
        }
      ],
      "message": "net: make V2Transport send uniformly random number garbage bytes",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-09-07T13:04:55Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-07-30T15:43:10Z"
      },
      "sha": "3ffa5fb49ee4a6d9502aa957093bd94058630282"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI5N2M4ODg5OTc1YTE4MjU4ZDZjYzM5YjFlYzFlOTRmZWQ2NjMwZmI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/297c8889975a18258d6cc39b1ec1e94fed6630fb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/297c8889975a18258d6cc39b1ec1e94fed6630fb",
      "tree": {
        "sha": "d79c3b8f5018c20a5bdac01f972c9f7d1071db62",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d79c3b8f5018c20a5bdac01f972c9f7d1071db62"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3ffa5fb49ee4a6d9502aa957093bd94058630282",
          "sha": "3ffa5fb49ee4a6d9502aa957093bd94058630282",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/3ffa5fb49ee4a6d9502aa957093bd94058630282"
        }
      ],
      "message": "net: make V2Transport preallocate receive buffer space",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-09-07T13:04:55Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-07-30T14:51:12Z"
      },
      "sha": "297c8889975a18258d6cc39b1ec1e94fed6630fb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDkxZTFlZjg2ODQ5OTdmYjRiM2U4YjY0ZWYzOTM1YTkzNjQ0NTA2NmI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/91e1ef8684997fb4b3e8b64ef3935a936445066b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/91e1ef8684997fb4b3e8b64ef3935a936445066b",
      "tree": {
        "sha": "e84630646df88c66c24b42821e101ba14bbe6e93",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e84630646df88c66c24b42821e101ba14bbe6e93"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/297c8889975a18258d6cc39b1ec1e94fed6630fb",
          "sha": "297c8889975a18258d6cc39b1ec1e94fed6630fb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/297c8889975a18258d6cc39b1ec1e94fed6630fb"
        }
      ],
      "message": "test: add unit tests for V2Transport",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-09-07T13:04:55Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-08-28T01:08:56Z"
      },
      "sha": "91e1ef8684997fb4b3e8b64ef3935a936445066b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGRiOTg4OGZlZWM0OGM2MjIwYTJmY2Y5Mjg2NTUwM2JiYmRhYjAyYTQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/db9888feec48c6220a2fcf92865503bbbdab02a4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/db9888feec48c6220a2fcf92865503bbbdab02a4",
      "tree": {
        "sha": "8caab5c93e39ff31a57861941ec9c7411f3a1379",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8caab5c93e39ff31a57861941ec9c7411f3a1379"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/91e1ef8684997fb4b3e8b64ef3935a936445066b",
          "sha": "91e1ef8684997fb4b3e8b64ef3935a936445066b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/91e1ef8684997fb4b3e8b64ef3935a936445066b"
        }
      ],
      "message": "net: detect wrong-network V1 talking to V2Transport",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-09-07T13:04:55Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-09-06T03:38:15Z"
      },
      "sha": "db9888feec48c6220a2fcf92865503bbbdab02a4"
    },
    {
      "event": "reviewed",
      "id": 1615363627,
      "node_id": "PRR_kwDOABII585gSH4r",
      "url": null,
      "actor": null,
      "commit_id": "15ea0ce587a334b647119fe65de2b305720c3eba",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 15ea0ce587a334b647119fe65de2b305720c3eba\r\n\r\nLeft some nitty follow-up material below.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1615363627",
      "submitted_at": "2023-09-07T13:07:14Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "review_request_removed",
      "id": 10307207832,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJmW4KY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10307207832",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T13:07:19Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10307208007,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmW4NH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10307208007",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T13:07:20Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10307208823,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJmW4Z3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10307208823",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T13:07:25Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10307208937,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmW4bp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10307208937",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T13:07:26Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10307214229,
      "node_id": "HRFPE_lADOABII585tLpVKzwAAAAJmW5uV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10307214229",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T13:07:55Z"
    },
    {
      "event": "commented",
      "id": 1710224677,
      "node_id": "IC_kwDOABII585l7_Ul",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1710224677",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T14:09:39Z",
      "updated_at": "2023-09-07T14:13:25Z",
      "author_association": "MEMBER",
      "body": "Relevant changes since 15ea0ce587a334b647119fe65de2b305720c3eba (ignoring rebase):\r\n\r\n```diff\r\n--- a/src/net.cpp\r\n+++ b/src/net.cpp\r\n@@ -919,7 +920,7 @@ namespace {\r\n  * Only message types that are actually implemented in this codebase need to be listed, as other\r\n  * messages get ignored anyway - whether we know how to decode them or not.\r\n  */\r\n-const std::string V2_MESSAGE_IDS[] = {\r\n+const std::array<std::string, 33> V2_MESSAGE_IDS = {\r\n     \"\", // 12 bytes follow encoding the message type like in V1\r\n     NetMsgType::ADDR,\r\n     NetMsgType::BLOCK,\r\n@@ -956,8 +957,6 @@ const std::string V2_MESSAGE_IDS[] = {\r\n     \"\"\r\n };\r\n \r\n-static_assert(std::size(V2_MESSAGE_IDS) == 33);\r\n-\r\n class V2MessageMap\r\n {\r\n     std::unordered_map<std::string, uint8_t> m_map;\r\n--- a/src/test/fuzz/p2p_transport_serialization.cpp\r\n+++ b/src/test/fuzz/p2p_transport_serialization.cpp\r\n@@ -339,10 +339,7 @@ template<typename RNG>\r\n std::unique_ptr<Transport> MakeV2Transport(NodeId nodeid, bool initiator, RNG& rng, FuzzedDataProvider& provider)\r\n {\r\n     // Retrieve key\r\n-    auto key_data = provider.ConsumeBytes<unsigned char>(32);\r\n-    key_data.resize(32);\r\n-    CKey key;\r\n-    key.Set(key_data.begin(), key_data.end(), true);\r\n+    auto key = ConsumePrivateKey(provider);\r\n     if (!key.IsValid()) return {};\r\n     // Construct garbage\r\n     size_t garb_len = provider.ConsumeIntegralInRange<size_t>(0, V2Transport::MAX_GARBAGE_LEN);\r\n```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1710224677",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "reviewed",
      "id": 1615577560,
      "node_id": "PRR_kwDOABII585gS8HY",
      "url": null,
      "actor": null,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "re-ACK db9888feec48c6220a2fcf92865503bbbdab02a4",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1615577560",
      "submitted_at": "2023-09-07T14:23:35Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "review_request_removed",
      "id": 10308152349,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJmaewd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10308152349",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T14:23:41Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10308152468,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmaeyU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10308152468",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T14:23:42Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10308152659,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmae1T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10308152659",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T14:23:43Z",
      "requested_reviewer": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10308152832,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmae4A",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10308152832",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T14:23:44Z",
      "requested_reviewer": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10311157493,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJml8b1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10311157493",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T19:48:26Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10311157679,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJml8ev",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10311157679",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T19:48:27Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1616178583,
      "node_id": "PRR_kwDOABII585gVO2X",
      "url": null,
      "actor": null,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK.\r\n\r\nOverall this looks pretty solid.\r\n\r\nCommit c3fad1f29df093e8fd03d70eb43f25ee9d531bf7 looks good; there's no ideal way to do this, but at least it's now pretty well documented.\r\n\r\nThe state machine looks good too.\r\n\r\nOtherwise I only shallowly reviewed up to db9888feec48c6220a2fcf92865503bbbdab02a4, and without looking at test and fuzz code.\r\n\r\nTo better ensure decoy packages work, maybe you could add a (debug) rpc method to send decoy package to a given peer? Though that can wait for a followup.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1616178583",
      "submitted_at": "2023-09-07T20:22:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "review_request_removed",
      "id": 10311398455,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJmm3Q3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10311398455",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T20:22:18Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10311398533,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmm3SF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10311398533",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T20:22:19Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10311399195,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJmm3cb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10311399195",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T20:22:24Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10311399428,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmm3gE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10311399428",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T20:22:26Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10311420563,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJmm8qT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10311420563",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T20:25:19Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10311420743,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmm8tH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10311420743",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T20:25:20Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10311465660,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJmnHq8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10311465660",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T20:31:55Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10311465849,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmnHt5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10311465849",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T20:31:57Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 1710740467,
      "node_id": "IC_kwDOABII585l99Pz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1710740467",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T20:37:39Z",
      "updated_at": "2023-09-07T20:37:39Z",
      "author_association": "MEMBER",
      "body": "> To better ensure decoy packages work, maybe you could add a (debug) rpc method to send decoy package to a given peer? Though that can wait for a followup.\r\n\r\nThat's not possible in this PR, as `V2Transport` is not hooked up to anything except tests. This would be a possibility in #28331. Another way for testing decoys is through BIP324 support in the p2p functional test code, see #24748.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1710740467",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "review_request_removed",
      "id": 10311504416,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJmnRIg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10311504416",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T20:37:45Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10311504636,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmnRL8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10311504636",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T20:37:46Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1609918939,
      "node_id": "PRR_kwDOABII585f9Wnb",
      "url": null,
      "actor": null,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Code Review ACK db9888feec48c6220a2fcf92865503bbbdab02a4\r\n\r\nI reviewed the code again and did a little bit of manual mutation testing (checking that the fuzz test fails if I break things).\r\nThe nits can be ignored.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1609918939",
      "submitted_at": "2023-09-07T22:58:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "review_request_removed",
      "id": 10312296879,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJmqSmv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10312296879",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T22:58:22Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10312296918,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmqSnW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10312296918",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T22:58:22Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10312297294,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJmqStO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10312297294",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T22:58:27Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10312297391,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmqSuv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10312297391",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T22:58:29Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10312335478,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJmqcB2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10312335478",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T23:07:07Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10312335577,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJmqcDZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10312335577",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-07T23:07:09Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 1711330681,
      "node_id": "IC_kwDOABII585mANV5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1711330681",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-08T09:02:54Z",
      "updated_at": "2023-09-08T09:02:54Z",
      "author_association": "MEMBER",
      "body": "ACK db9888feec48c6220a2fcf92865503bbbdab02a4",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1711330681",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "review_request_removed",
      "id": 10315666005,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJm3JJV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10315666005",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-08T09:03:00Z",
      "requested_reviewer": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 10315666017,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJm3JJh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10315666017",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-08T09:03:00Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10315666178,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJm3JMC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10315666178",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-08T09:03:01Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 1711342695,
      "node_id": "IC_kwDOABII585mAQRn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1711342695",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-08T09:11:51Z",
      "updated_at": "2023-09-08T09:11:51Z",
      "author_association": "MEMBER",
      "body": "Outstanding/followup comments:\r\n\r\nhttps://github.com/bitcoin/bitcoin/pull/28196#discussion_r1318578731\r\nhttps://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315179378\r\nhttps://github.com/bitcoin/bitcoin/pull/28196#discussion_r1319134141\r\n",
      "user": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1711342695",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28196"
    },
    {
      "event": "review_request_removed",
      "id": 10315749252,
      "node_id": "RRRE_lADOABII585tLpVKzwAAAAJm3deE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10315749252",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-08T09:11:55Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10315749352,
      "node_id": "RRE_lADOABII585tLpVKzwAAAAJm3dfo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10315749352",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-08T09:11:56Z",
      "requested_reviewer": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "merged",
      "id": 10315866650,
      "node_id": "ME_lADOABII585tLpVKzwAAAAJm36Ia",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10315866650",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "4e1a38c6df91f96ca8a2ef07413ffdb1d59c30cc",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4e1a38c6df91f96ca8a2ef07413ffdb1d59c30cc",
      "created_at": "2023-09-08T09:24:15Z"
    },
    {
      "event": "closed",
      "id": 10315866677,
      "node_id": "CE_lADOABII585tLpVKzwAAAAJm36I1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10315866677",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-08T09:24:15Z"
    },
    {
      "event": "reviewed",
      "id": 1617068656,
      "node_id": "PRR_kwDOABII585gYoJw",
      "url": null,
      "actor": null,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK db9888feec48c6220a2fcf92865503bbbdab02a4",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1617068656",
      "submitted_at": "2023-09-08T09:31:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "referenced",
      "id": 10320465509,
      "node_id": "REFE_lADOABII585tLpVKzwAAAAJnJc5l",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10320465509",
      "actor": {
        "login": "Frank-GER",
        "id": 87550788,
        "node_id": "MDQ6VXNlcjg3NTUwNzg4",
        "avatar_url": "https://avatars.githubusercontent.com/u/87550788?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Frank-GER",
        "html_url": "https://github.com/Frank-GER",
        "followers_url": "https://api.github.com/users/Frank-GER/followers",
        "following_url": "https://api.github.com/users/Frank-GER/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Frank-GER/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Frank-GER/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Frank-GER/subscriptions",
        "organizations_url": "https://api.github.com/users/Frank-GER/orgs",
        "repos_url": "https://api.github.com/users/Frank-GER/repos",
        "events_url": "https://api.github.com/users/Frank-GER/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Frank-GER/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "087e38b9a59c57e782c91d3bc870f98daf31fae1",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/087e38b9a59c57e782c91d3bc870f98daf31fae1",
      "created_at": "2023-09-08T17:08:37Z"
    },
    {
      "event": "referenced",
      "id": 10331065190,
      "node_id": "REFE_lADOABII585tLpVKzwAAAAJnx4tm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10331065190",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "8f7b9eb8711fdb32e8bdb59d2a7462a46c7a8086",
      "commit_url": "https://api.github.com/repos/bitcoin-core/gui/commits/8f7b9eb8711fdb32e8bdb59d2a7462a46c7a8086",
      "created_at": "2023-09-11T08:44:46Z"
    },
    {
      "event": "reviewed",
      "id": 1623928164,
      "node_id": "PRR_kwDOABII585gyy1k",
      "url": null,
      "actor": null,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "re-ACK https://github.com/bitcoin/bitcoin/commit/db9888feec48c6220a2fcf92865503bbbdab02a4",
      "user": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#pullrequestreview-1623928164",
      "submitted_at": "2023-09-13T07:57:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
    },
    {
      "event": "referenced",
      "id": 10389517593,
      "node_id": "REFE_lADOABII585tLpVKzwAAAAJrQ3UZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10389517593",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "372e7b6510d14976dbc25f3d67f3e43247402385",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/372e7b6510d14976dbc25f3d67f3e43247402385",
      "created_at": "2023-09-16T11:15:25Z"
    },
    {
      "event": "referenced",
      "id": 10407010670,
      "node_id": "REFE_lADOABII585tLpVKzwAAAAJsTmFu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10407010670",
      "actor": {
        "login": "Frank-GER",
        "id": 87550788,
        "node_id": "MDQ6VXNlcjg3NTUwNzg4",
        "avatar_url": "https://avatars.githubusercontent.com/u/87550788?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Frank-GER",
        "html_url": "https://github.com/Frank-GER",
        "followers_url": "https://api.github.com/users/Frank-GER/followers",
        "following_url": "https://api.github.com/users/Frank-GER/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Frank-GER/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Frank-GER/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Frank-GER/subscriptions",
        "organizations_url": "https://api.github.com/users/Frank-GER/orgs",
        "repos_url": "https://api.github.com/users/Frank-GER/repos",
        "events_url": "https://api.github.com/users/Frank-GER/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Frank-GER/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "4bbfc7f0b95fa299d170671ab82e4a1f854d0cae",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/4bbfc7f0b95fa299d170671ab82e4a1f854d0cae",
      "created_at": "2023-09-19T07:53:35Z"
    },
    {
      "event": "referenced",
      "id": 10407011448,
      "node_id": "REFE_lADOABII585tLpVKzwAAAAJsTmR4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10407011448",
      "actor": {
        "login": "Frank-GER",
        "id": 87550788,
        "node_id": "MDQ6VXNlcjg3NTUwNzg4",
        "avatar_url": "https://avatars.githubusercontent.com/u/87550788?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Frank-GER",
        "html_url": "https://github.com/Frank-GER",
        "followers_url": "https://api.github.com/users/Frank-GER/followers",
        "following_url": "https://api.github.com/users/Frank-GER/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Frank-GER/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Frank-GER/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Frank-GER/subscriptions",
        "organizations_url": "https://api.github.com/users/Frank-GER/orgs",
        "repos_url": "https://api.github.com/users/Frank-GER/repos",
        "events_url": "https://api.github.com/users/Frank-GER/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Frank-GER/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "d3181ea3ca23f3fb21895713501692f403d2d153",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/d3181ea3ca23f3fb21895713501692f403d2d153",
      "created_at": "2023-09-19T07:53:39Z"
    },
    {
      "event": "referenced",
      "id": 12168513136,
      "node_id": "REFE_lADOABII585tLpVKzwAAAALVTMZw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12168513136",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "0f89e8651650de69f0da3d02de790159a5d148b3",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0f89e8651650de69f0da3d02de790159a5d148b3",
      "created_at": "2024-03-19T12:20:38Z"
    },
    {
      "event": "locked",
      "id": 14238741444,
      "node_id": "LOE_lADOABII585tLpVKzwAAAANQsfPE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14238741444",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-12T20:45:03Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303013011",
      "pull_request_review_id": 1591588401,
      "id": 1303013011,
      "node_id": "PRRC_kwDOABII585NqmaT",
      "diff_hunk": "@@ -595,12 +595,12 @@ def connect_nodes(self, a, b):\n         # * Must have a verack message before anything else\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in from_connection.getpeerinfo()) == from_num_peers)\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in to_connection.getpeerinfo()) == to_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in from_connection.getpeerinfo()) == from_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in to_connection.getpeerinfo()) == to_num_peers)\n+        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) >= 21 for peer in from_connection.getpeerinfo()) == from_num_peers)",
      "path": "test/functional/test_framework/test_framework.py",
      "position": null,
      "original_position": 6,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "163d93304dea08bf8f2ea79d79cabceec1a13d96",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "163d93304dea08bf8f2ea79d79cabceec1a13d96: I assume this is because of the short message ID's? Can you mention that in the commit message, so it's easy to find with `git blame`?",
      "created_at": "2023-08-23T13:21:16Z",
      "updated_at": "2023-08-23T13:43:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303013011",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303013011"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 598,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303026846",
      "pull_request_review_id": 1591588401,
      "id": 1303026846,
      "node_id": "PRRC_kwDOABII585Nqpye",
      "diff_hunk": "@@ -1434,6 +1435,20 @@ size_t V2Transport::GetSendMemoryUsage() const noexcept\n     return sizeof(m_send_buffer) + memusage::DynamicUsage(m_send_buffer);\n }\n \n+Span<const std::byte> V2Transport::GetSessionID() const noexcept\n+{\n+    if (m_use_v1) return m_v1_fallback.GetSessionID();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetSessionID();",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 16,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9c3159378658c4b1535ab6c546512f7d1b2b3979",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "9c3159378658c4b1535ab6c546512f7d1b2b3979: what's the difference between these two scenarios? `m_use_v1` vs `m_recv_state == RecvState::V1`?\r\n\r\nWhy not return `{}`? Unsafe / bad / not great?",
      "created_at": "2023-08-23T13:30:52Z",
      "updated_at": "2023-08-23T13:43:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303026846",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303026846"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1442,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303059175",
      "pull_request_review_id": 1591662321,
      "id": 1303059175,
      "node_id": "PRRC_kwDOABII585Nqxrn",
      "diff_hunk": "@@ -595,12 +595,12 @@ def connect_nodes(self, a, b):\n         # * Must have a verack message before anything else\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in from_connection.getpeerinfo()) == from_num_peers)\n         self.wait_until(lambda: sum(peer['version'] != 0 for peer in to_connection.getpeerinfo()) == to_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in from_connection.getpeerinfo()) == from_num_peers)\n-        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in to_connection.getpeerinfo()) == to_num_peers)\n+        self.wait_until(lambda: sum(peer['bytesrecv_per_msg'].pop('verack', 0) >= 21 for peer in from_connection.getpeerinfo()) == from_num_peers)",
      "path": "test/functional/test_framework/test_framework.py",
      "position": null,
      "original_position": 6,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "163d93304dea08bf8f2ea79d79cabceec1a13d96",
      "in_reply_to_id": 1303013011,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This commit will disappear eventually, when integration is done more properly.\n\nBut in short, yes, this is because when short IDs are in use, messages have a 21 byte overhead (on top of the payload) in V2 vs. 24 bytes in V1.",
      "created_at": "2023-08-23T13:52:50Z",
      "updated_at": "2023-08-23T13:52:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303059175",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303059175"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 598,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303071712",
      "pull_request_review_id": 1591682059,
      "id": 1303071712,
      "node_id": "PRRC_kwDOABII585Nq0vg",
      "diff_hunk": "@@ -1434,6 +1435,20 @@ size_t V2Transport::GetSendMemoryUsage() const noexcept\n     return sizeof(m_send_buffer) + memusage::DynamicUsage(m_send_buffer);\n }\n \n+Span<const std::byte> V2Transport::GetSessionID() const noexcept\n+{\n+    if (m_use_v1) return m_v1_fallback.GetSessionID();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetSessionID();",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 16,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9c3159378658c4b1535ab6c546512f7d1b2b3979",
      "in_reply_to_id": 1303026846,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The difference between these scenarios: nothing, but it's possible that the m_use_v1 atomic gets set in between it being checked here and the lock being grabbed. So the m_use_v1 is there as an optimization that almost always works, but the RecvState::V1 check is necessary to make it always work. For other Transport member functions the m_use_v1 is introduced in a separate commit, which hopefully explains it.\n\nThere's also nothing wrong with `return {};` here, but I thought it'd be more obviously correct to explicitly call the V1Transport function.",
      "created_at": "2023-08-23T14:01:35Z",
      "updated_at": "2023-08-23T14:01:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1303071712",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303071712"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1442,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308061759",
      "pull_request_review_id": 1599275947,
      "id": 1308061759,
      "node_id": "PRRC_kwDOABII585N93A_",
      "diff_hunk": "@@ -912,6 +912,351 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Can't read more than provided input.\n+        max_read = std::min<uint32_t>(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::WAITING:\n+            if (!m_recv_buffer.empty()) {\n+                m_recv_state = RecvState::KEY;\n+                LOCK(m_send_mutex);\n+                assert(m_send_state == SendState::KEY_WAITING);\n+                m_send_state = SendState::KEY;\n+            }\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() < 13 || contents[0] != 0) return std::nullopt; // Short encoding not yet supported\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < 12 && contents[1 + msg_type_len] != 0) {\n+        if (contents[1 + msg_type_len] < ' ' || contents[1 + msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data() + 1), msg_type_len};\n+    while (msg_type_len < 12) {\n+        if (contents[1 + msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    contents = contents.subspan(13);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    assert(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;",
      "path": "src/net.cpp",
      "position": 599,
      "original_position": 274,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "f41a1a0ae49c3ada8073edb3c051deaa7534d494",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In `V1Transport::GetReceivedMessage`, we call `RandAddEvent()` to harvest entropy from the time and checksum of the received messages. Should something similar be done for V2?",
      "created_at": "2023-08-28T23:53:59Z",
      "updated_at": "2023-08-28T23:53:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308061759",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308061759"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1483,
      "original_line": 1483,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308143623",
      "pull_request_review_id": 1599399238,
      "id": 1308143623,
      "node_id": "PRRC_kwDOABII585N-LAH",
      "diff_hunk": "@@ -912,6 +912,351 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Can't read more than provided input.\n+        max_read = std::min<uint32_t>(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::WAITING:\n+            if (!m_recv_buffer.empty()) {\n+                m_recv_state = RecvState::KEY;\n+                LOCK(m_send_mutex);\n+                assert(m_send_state == SendState::KEY_WAITING);\n+                m_send_state = SendState::KEY;\n+            }\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() < 13 || contents[0] != 0) return std::nullopt; // Short encoding not yet supported\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < 12 && contents[1 + msg_type_len] != 0) {\n+        if (contents[1 + msg_type_len] < ' ' || contents[1 + msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data() + 1), msg_type_len};\n+    while (msg_type_len < 12) {\n+        if (contents[1 + msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    contents = contents.subspan(13);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    assert(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;",
      "path": "src/net.cpp",
      "position": 599,
      "original_position": 274,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "f41a1a0ae49c3ada8073edb3c051deaa7534d494",
      "in_reply_to_id": 1308061759,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good idea. Done (in `V2Transport::ProcessReceivedPacket`, which sees the authentication tags).",
      "created_at": "2023-08-29T03:02:00Z",
      "updated_at": "2023-08-29T03:02:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308143623",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308143623"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1483,
      "original_line": 1483,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308716718",
      "pull_request_review_id": 1600253188,
      "id": 1308716718,
      "node_id": "PRRC_kwDOABII585OAW6u",
      "diff_hunk": "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 187,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "aa1da1a0ef0504d4f30ab3b101b334e11b8868ac",
      "in_reply_to_id": null,
      "user": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "maybe this is for a followup PR, but I think here it is better to print the status of the state, this makes trivial to debug the problem if happens.",
      "created_at": "2023-08-29T12:08:21Z",
      "updated_at": "2023-08-29T12:08:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308716718",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308716718"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1097,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1293,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308718127",
      "pull_request_review_id": 1600255297,
      "id": 1308718127,
      "node_id": "PRRC_kwDOABII585OAXQv",
      "diff_hunk": "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 187,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "aa1da1a0ef0504d4f30ab3b101b334e11b8868ac",
      "in_reply_to_id": 1308716718,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No, this code is unreachable. If it gets hit, it would be obvious what is wrong.",
      "created_at": "2023-08-29T12:09:37Z",
      "updated_at": "2023-08-29T12:09:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308718127",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308718127"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1097,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1293,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308731485",
      "pull_request_review_id": 1600275509,
      "id": 1308731485,
      "node_id": "PRRC_kwDOABII585OAahd",
      "diff_hunk": "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 187,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "aa1da1a0ef0504d4f30ab3b101b334e11b8868ac",
      "in_reply_to_id": 1308716718,
      "user": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I see now your point, ok make sense",
      "created_at": "2023-08-29T12:20:02Z",
      "updated_at": "2023-08-29T12:20:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1308731485",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1308731485"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1097,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1293,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309329927",
      "pull_request_review_id": 1601240500,
      "id": 1309329927,
      "node_id": "PRRC_kwDOABII585OCsoH",
      "diff_hunk": "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 33,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "f7c0be500adeeddba1671b6f4478ce369fc0c6b3",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Looks like `SetReceiveVersion` is never used anywhere, neither for V1 nor V2, because the version is set in the respective constructors. Should we just remove it from the `Transport` interface?",
      "created_at": "2023-08-29T20:38:08Z",
      "updated_at": "2023-08-30T20:03:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309329927",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309329927"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1020,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309344192",
      "pull_request_review_id": 1601240500,
      "id": 1309344192,
      "node_id": "PRRC_kwDOABII585OCwHA",
      "diff_hunk": "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 141,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "f7c0be500adeeddba1671b6f4478ce369fc0c6b3",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could put some of the magic numbers (13 here and in a few other places like `SetMessageToSend`, 12 in `GetMessageType()`) into  constants or maybe use `CMessageHeader::COMMAND_SIZE`.",
      "created_at": "2023-08-29T20:53:44Z",
      "updated_at": "2023-08-30T20:03:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309344192",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309344192"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1171,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309532823",
      "pull_request_review_id": 1601752363,
      "id": 1309532823,
      "node_id": "PRRC_kwDOABII585ODeKX",
      "diff_hunk": "@@ -1213,7 +1276,22 @@ bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n \n std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n {\n-    if (contents.size() < 13 || contents[0] != 0) return std::nullopt; // Short encoding not yet supported\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+\n+    if (first_byte != 0) {\n+        // Short (1 byte) encoding.\n+        if (first_byte < std::size(V2_MESSAGE_IDS)) {\n+            // Valid short message id.\n+            contents = contents.subspan(1);\n+            return V2_MESSAGE_IDS[first_byte];\n+        } else {\n+            // Unknown short message id.\n+            return std::nullopt;\n+        }\n+    }\n+\n+    if (contents.size() < 13) return std::nullopt; // Long encoding needs at least 13 bytes",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 90,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8a2e9f6fb909436f3c849c1088a3b79b2cfba119",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit-like: For the long encoding processing, it might be worthwhile to advance for one byte in the contents span first, to work with the remaining 12 bytes and avoid the plus ones everywhere below (especially for the array indices in the while loops)?\r\n```suggestion\r\n    contents = contents.subspan(1);\r\n    if (contents.size() < 12) return std::nullopt; // Long encoding needs at least 12 bytes (after the short message id)\r\n```\r\n",
      "created_at": "2023-08-30T02:06:04Z",
      "updated_at": "2023-08-30T02:28:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309532823",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309532823"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1310,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309537403",
      "pull_request_review_id": 1601752363,
      "id": 1309537403,
      "node_id": "PRRC_kwDOABII585ODfR7",
      "diff_hunk": "@@ -1270,9 +1348,17 @@ bool V2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n \n     if (m_send_state != SendState::APP_READY) return false;\n     // Construct contents (encoding message type + payload).\n-    std::vector<uint8_t> contents(13 + msg.data.size(), 0);\n-    std::copy(msg.m_type.begin(), msg.m_type.end(), reinterpret_cast<char*>(contents.data() + 1));\n-    std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 13);\n+    std::vector<uint8_t> contents;\n+    auto short_message_id = V2_MESSAGE_MAP(msg.m_type);\n+    if (short_message_id) {\n+        contents.resize(1 + msg.data.size());\n+        contents[0] = *short_message_id;\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1);\n+    } else {\n+        contents.resize(13 + msg.data.size());",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 108,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8a2e9f6fb909436f3c849c1088a3b79b2cfba119",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: though logically identical with the current code, could be explicit about the fill value of the resize (in contrast to the short message case above, not all of the new elments after the resize are overwritten):\r\n```suggestion\r\n        contents.resize(13 + msg.data.size(), 0);\r\n```",
      "created_at": "2023-08-30T02:12:58Z",
      "updated_at": "2023-08-30T02:28:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1309537403",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1309537403"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1374,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310237002",
      "pull_request_review_id": 1602648914,
      "id": 1310237002,
      "node_id": "PRRC_kwDOABII585OGKFK",
      "diff_hunk": "@@ -320,7 +328,7 @@ class Transport {\n      * Note that m_type and to_send refer to data that is internal to the transport, and calling\n      * any non-const function on this object may invalidate them.\n      */",
      "path": "src/net.h",
      "position": 71,
      "original_position": 34,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "040ea05dae05ef513ac79306dd560c8c1f228942",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: tell doxygen about the parameter (and maybe about the return value):\r\n\r\n```cpp\r\n/**\r\n * Title sentence up to first dot.\r\n * Further elaborate description. Many sentences whatever.\r\n * @param[in] have_next_message Controls whether the \"more\"...\r\n * @return The bytes returned by this function...\r\n */",
      "created_at": "2023-08-30T12:58:56Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310237002",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310237002"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 345,
      "original_line": 345,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310277982",
      "pull_request_review_id": 1602648914,
      "id": 1310277982,
      "node_id": "PRRC_kwDOABII585OGUFe",
      "diff_hunk": "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is",
      "path": "src/net.h",
      "position": null,
      "original_position": 94,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "040ea05dae05ef513ac79306dd560c8c1f228942",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP and the decrypted contents is\r\n```",
      "created_at": "2023-08-30T13:24:38Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310277982",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310277982"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 467,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310288598",
      "pull_request_review_id": 1602648914,
      "id": 1310288598,
      "node_id": "PRRC_kwDOABII585OGWrW",
      "diff_hunk": "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */\n+    enum class RecvState {",
      "path": "src/net.h",
      "position": null,
      "original_position": 62,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "040ea05dae05ef513ac79306dd560c8c1f228942",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```\r\nEnum 'RecvState' uses a larger base type ('int', size: 4 bytes) than necessary for its value set, consider using 'std::uint8_t' (1 byte) as the base type to reduce its size [performance-enum-size]\r\n```\r\n(same for `SendState`)",
      "created_at": "2023-08-30T13:31:33Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310288598",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310288598"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 435,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310305445",
      "pull_request_review_id": 1602648914,
      "id": 1310305445,
      "node_id": "PRRC_kwDOABII585OGayl",
      "diff_hunk": "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 61,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "040ea05dae05ef513ac79306dd560c8c1f228942",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It would be useful to have a diagram describing the possible state transitions of this state machine:\r\n\r\n```cpp\r\n    /** State type that defines the contents of the receive buffer. Possible transitions:\r\n     * KEY_MAYBE_V1 --> V1                                                   *--------<---------*\r\n     *            |                                                          v                  |\r\n     *            *---> KEY --> GARB_GARBTERM --> GARBAUTH --> VERSION --> APP --> APP_READY -->*\r\n     */\r\n```\r\n\r\n(same for `SendState`)",
      "created_at": "2023-08-30T13:42:58Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310305445",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310305445"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 443,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310362246",
      "pull_request_review_id": 1602833673,
      "id": 1310362246,
      "node_id": "PRRC_kwDOABII585OGoqG",
      "diff_hunk": "@@ -973,11 +987,44 @@ size_t V2Transport::GetMaxBytesToProcess() noexcept\n     case RecvState::APP_READY:\n         // No bytes can be processed until GetMessage() is called.\n         return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n     }\n     assert(false); // unreachable\n     return 0;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.",
      "path": "src/net.cpp",
      "position": 204,
      "original_position": 86,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "faf5af3f6b96488ebf9585c1558710545cde05a6",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "377ae15917dc460f589614ec33f567b523181dc3: do we want to be a bit more robust here and also check against all / some known other network magic values? Especially if we move away from being on port 8333 all the time. Ultimately the v2 handshake will fail anyway if e.g. a Signet node connects to us, but seems nicer to detect (and log) it.",
      "created_at": "2023-08-30T14:21:31Z",
      "updated_at": "2023-09-01T19:06:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310362246",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310362246"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1088,
      "original_line": 1088,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310367236",
      "pull_request_review_id": 1602833673,
      "id": 1310367236,
      "node_id": "PRRC_kwDOABII585OGp4E",
      "diff_hunk": "@@ -973,11 +987,44 @@ size_t V2Transport::GetMaxBytesToProcess() noexcept\n     case RecvState::APP_READY:\n         // No bytes can be processed until GetMessage() is called.\n         return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n     }\n     assert(false); // unreachable\n     return 0;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_MAYBE_V1 || m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 93,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "faf5af3f6b96488ebf9585c1558710545cde05a6",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "377ae15917dc460f589614ec33f567b523181dc3: `v1 prefix`",
      "created_at": "2023-08-30T14:25:02Z",
      "updated_at": "2023-09-01T19:06:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310367236",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310367236"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1152,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446507",
      "pull_request_review_id": 1602960483,
      "id": 1310446507,
      "node_id": "PRRC_kwDOABII585OG9Or",
      "diff_hunk": "@@ -1213,7 +1276,22 @@ bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n \n std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n {\n-    if (contents.size() < 13 || contents[0] != 0) return std::nullopt; // Short encoding not yet supported\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+\n+    if (first_byte != 0) {\n+        // Short (1 byte) encoding.\n+        if (first_byte < std::size(V2_MESSAGE_IDS)) {\n+            // Valid short message id.\n+            contents = contents.subspan(1);\n+            return V2_MESSAGE_IDS[first_byte];\n+        } else {\n+            // Unknown short message id.\n+            return std::nullopt;\n+        }\n+    }\n+\n+    if (contents.size() < 13) return std::nullopt; // Long encoding needs at least 13 bytes",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 90,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8a2e9f6fb909436f3c849c1088a3b79b2cfba119",
      "in_reply_to_id": 1309532823,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good idea, I've rewritten some part of the code here using that approach. Also added more comments.",
      "created_at": "2023-08-30T15:20:02Z",
      "updated_at": "2023-08-30T15:20:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310446507",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446507"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1310,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446699",
      "pull_request_review_id": 1602960755,
      "id": 1310446699,
      "node_id": "PRRC_kwDOABII585OG9Rr",
      "diff_hunk": "@@ -1270,9 +1348,17 @@ bool V2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n \n     if (m_send_state != SendState::APP_READY) return false;\n     // Construct contents (encoding message type + payload).\n-    std::vector<uint8_t> contents(13 + msg.data.size(), 0);\n-    std::copy(msg.m_type.begin(), msg.m_type.end(), reinterpret_cast<char*>(contents.data() + 1));\n-    std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 13);\n+    std::vector<uint8_t> contents;\n+    auto short_message_id = V2_MESSAGE_MAP(msg.m_type);\n+    if (short_message_id) {\n+        contents.resize(1 + msg.data.size());\n+        contents[0] = *short_message_id;\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1);\n+    } else {\n+        contents.resize(13 + msg.data.size());",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 108,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8a2e9f6fb909436f3c849c1088a3b79b2cfba119",
      "in_reply_to_id": 1309537403,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, and added a comment.",
      "created_at": "2023-08-30T15:20:10Z",
      "updated_at": "2023-08-30T15:20:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310446699",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310446699"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1374,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310647503",
      "pull_request_review_id": 1601240500,
      "id": 1310647503,
      "node_id": "PRRC_kwDOABII585OHuTP",
      "diff_hunk": "@@ -427,6 +429,160 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 33,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: this initially confused me a little; maybe stress that it defines what we are _expecting_ to retrieve from the receive buffer but not necessarily the current content of the receive buffer (which may be empty if we haven't received anything yet, or contain other data if the peer didn't follow the protocol) - this seems like a small difference to the send buffer, where it actually contains the given info when it's in the status.",
      "created_at": "2023-08-30T18:08:54Z",
      "updated_at": "2023-08-30T20:03:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310647503",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310647503"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 443,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310685384",
      "pull_request_review_id": 1601240500,
      "id": 1310685384,
      "node_id": "PRRC_kwDOABII585OH3jI",
      "diff_hunk": "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 60,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "maybe add a comment that `BIP324Cipher::EXPANSION` includes `BIP324Cipher::LENGTH_LEN` - I was wondering at first whether that needed to be accounted for too here until I looked it up.",
      "created_at": "2023-08-30T18:46:29Z",
      "updated_at": "2023-08-30T20:03:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310685384",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310685384"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1112,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310694585",
      "pull_request_review_id": 1601240500,
      "id": 1310694585,
      "node_id": "PRRC_kwDOABII585OH5y5",
      "diff_hunk": "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 160,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "typo: packet",
      "created_at": "2023-08-30T18:55:41Z",
      "updated_at": "2023-08-30T20:03:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310694585",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310694585"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1071,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310695744",
      "pull_request_review_id": 1601240500,
      "id": 1310695744,
      "node_id": "PRRC_kwDOABII585OH6FA",
      "diff_hunk": "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is",
      "path": "src/net.cpp",
      "position": 375,
      "original_position": 171,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "typo: content",
      "created_at": "2023-08-30T18:56:47Z",
      "updated_at": "2023-08-30T20:03:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310695744",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310695744"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1259,
      "original_line": 1259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794366",
      "pull_request_review_id": 1603457794,
      "id": 1310794366,
      "node_id": "PRRC_kwDOABII585OISJ-",
      "diff_hunk": "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is",
      "path": "src/net.cpp",
      "position": 375,
      "original_position": 171,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "in_reply_to_id": 1310695744,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "BIP324 calls it `contents`.",
      "created_at": "2023-08-30T20:38:05Z",
      "updated_at": "2023-08-30T20:38:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794366",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794366"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1259,
      "original_line": 1259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794510",
      "pull_request_review_id": 1603457938,
      "id": 1310794510,
      "node_id": "PRRC_kwDOABII585OISMO",
      "diff_hunk": "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 160,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "in_reply_to_id": 1310694585,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-08-30T20:38:12Z",
      "updated_at": "2023-08-30T20:38:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794510",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794510"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1071,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794587",
      "pull_request_review_id": 1603458045,
      "id": 1310794587,
      "node_id": "PRRC_kwDOABII585OISNb",
      "diff_hunk": "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 60,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "in_reply_to_id": 1310685384,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-08-30T20:38:18Z",
      "updated_at": "2023-08-30T20:38:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794587",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794587"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1112,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794782",
      "pull_request_review_id": 1603458343,
      "id": 1310794782,
      "node_id": "PRRC_kwDOABII585OISQe",
      "diff_hunk": "@@ -427,6 +429,160 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 33,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "in_reply_to_id": 1310647503,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Expanded the comment a bit.",
      "created_at": "2023-08-30T20:38:31Z",
      "updated_at": "2023-08-30T20:38:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310794782",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310794782"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 443,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795003",
      "pull_request_review_id": 1603458652,
      "id": 1310795003,
      "node_id": "PRRC_kwDOABII585OIST7",
      "diff_hunk": "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::WAITING:\n+        // One byte is enough to transition to KEY.\n+        return 1;\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 141,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "f7c0be500adeeddba1671b6f4478ce369fc0c6b3",
      "in_reply_to_id": 1309344192,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added `CMessageHeader::COMMAND_SIZE` in a bunch of places.",
      "created_at": "2023-08-30T20:38:45Z",
      "updated_at": "2023-08-30T20:38:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310795003",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795003"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1171,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795146",
      "pull_request_review_id": 1603458871,
      "id": 1310795146,
      "node_id": "PRRC_kwDOABII585OISWK",
      "diff_hunk": "@@ -912,6 +912,353 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::WAITING},\n+    m_send_state{initiating ? SendState::KEY : SendState::KEY_WAITING}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 33,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "f7c0be500adeeddba1671b6f4478ce369fc0c6b3",
      "in_reply_to_id": 1309329927,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a commit to remove it.",
      "created_at": "2023-08-30T20:38:55Z",
      "updated_at": "2023-08-30T20:38:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1310795146",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1310795146"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1020,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311222591",
      "pull_request_review_id": 1602648914,
      "id": 1311222591,
      "node_id": "PRRC_kwDOABII585OJ6s_",
      "diff_hunk": "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {",
      "path": "src/net.h",
      "position": null,
      "original_position": 87,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "From your comment https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1699574611\r\n\r\n> ... both the sender side and receiver side of V2Transport are state machines that are transitioned through, with each state corresponding to the meaning of what is in the respective send/receive buffers. The receive state is changed by receiving bytes, or extracting completed messages. The send state is changed by receiving bytes, sending bytes, or being given a message to send.\r\n\r\nThat would be useful to have as a comment in the source code, somewhere around `RecvState` or `SendState`.",
      "created_at": "2023-08-31T07:40:17Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311222591",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311222591"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 435,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311249370",
      "pull_request_review_id": 1602648914,
      "id": 1311249370,
      "node_id": "PRRC_kwDOABII585OKBPa",
      "diff_hunk": "@@ -300,7 +299,8 @@ class Transport {\n      *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n      *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n      *    all sent (as signaled by MarkBytesSent()).\n-     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     *  - const std::string& m_type: message type on behalf of which this is being sent\n+     *    (\"\" for bytes that are not on behalf of any message).",
      "path": "src/net.h",
      "position": 23,
      "original_position": 23,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What about using `std::optional` to represent \"not on behalf of any message\" instead of `\"\"`?\r\n\r\n```cpp\r\n    using BytesToSend = std::tuple<\r\n        Span<const uint8_t> /*to_send*/,\r\n        bool /*more*/,\r\n        const std::optional<std::string>& /*m_type*/\r\n    >;\r\n...\r\n    /** Type of the message being sent. */\r\n    std::optional<std::string> m_send_type GUARDED_BY(m_send_mutex);\r\n```",
      "created_at": "2023-08-31T08:02:43Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311249370",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311249370"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 303,
      "original_line": 303,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311376345",
      "pull_request_review_id": 1602648914,
      "id": 1311376345,
      "node_id": "PRRC_kwDOABII585OKgPZ",
      "diff_hunk": "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:",
      "path": "src/net.h",
      "position": 104,
      "original_position": 79,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Consider this: https://google.github.io/styleguide/cppguide#Declaration_Order, personally I find it easier to read the interface if that order is followed. Or at least I would avoid two `public:` sections.",
      "created_at": "2023-08-31T09:43:29Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311376345",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311376345"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 441,
      "original_line": 441,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311381100",
      "pull_request_review_id": 1602648914,
      "id": 1311381100,
      "node_id": "PRRC_kwDOABII585OKhZs",
      "diff_hunk": "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 207,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "typo and an extra `)`: \r\n```suggestion\r\n     *  m_recv_buffer.size() >= BIP324Cipher::LENGTH_LEN. Unspecified otherwise. */\r\n```",
      "created_at": "2023-08-31T09:47:43Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311381100",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311381100"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 555,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311393641",
      "pull_request_review_id": 1602648914,
      "id": 1311393641,
      "node_id": "PRRC_kwDOABII585OKkdp",
      "diff_hunk": "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);",
      "path": "src/net.h",
      "position": null,
      "original_position": 216,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can be `const`?\r\n```suggestion\r\n    const int m_recv_type GUARDED_BY(m_recv_mutex);\r\n```\r\n\r\nSame for `m_recv_version`.",
      "created_at": "2023-08-31T09:58:06Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311393641",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311393641"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 564,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311402373",
      "pull_request_review_id": 1602648914,
      "id": 1311402373,
      "node_id": "PRRC_kwDOABII585OKmmF",
      "diff_hunk": "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);\n+    /** Deserialization version number. */\n+    int m_recv_version GUARDED_BY(m_recv_mutex);\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. */\n+    mutable Mutex m_send_mutex;\n+    /** The send buffer; meaning is determined by m_send_state. */\n+    std::vector<uint8_t> m_send_buffer GUARDED_BY(m_send_mutex);\n+    /** How many bytes from the send buffer have been sent so far. */\n+    uint32_t m_send_pos GUARDED_BY(m_send_mutex) {0};\n+    /** Type of the message being sent. */\n+    std::string m_send_type GUARDED_BY(m_send_mutex);\n+    /** Current sender state. */\n+    SendState m_send_state GUARDED_BY(m_send_mutex);\n+\n+    /** Given a packet's contents, find the message type (if valid), and strip it from contents. */\n+    static std::optional<std::string> GetMessageType(Span<const uint8_t>& contents) noexcept;\n+    /** Determine how many received bytes can be processed in one go (not allowed in V1 state). */\n+    size_t GetMaxBytesToProcess() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in KEY_MAYBE_V1 state. */\n+    void ProcessReceivedMaybeV1() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in KEY state. */\n+    void ProcessReceivedKey() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in GARB_GARBTERM state. */\n+    bool ProcessReceivedGarbage() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in GARBAUTH/VERSION/APP state. */\n+    bool ProcessReceivedPacket() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+\n+public:\n+\n+    /** Construct a V2 transport with securely generated random keys. */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept;\n+    /** Construct a V2 transport with specified keys and garbage (test use only). */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept;",
      "path": "src/net.h",
      "position": 302,
      "original_position": 251,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In some places `uint8_t` is used and in some other `std::byte`. I guess they are used interchangeably? Maybe for consistency use just one of them everywhere.",
      "created_at": "2023-08-31T10:05:18Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311402373",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311402373"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 639,
      "original_line": 639,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311460423",
      "pull_request_review_id": 1602648914,
      "id": 1311460423,
      "node_id": "PRRC_kwDOABII585OK0xH",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 151,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It is not immediately obvious whether these subtractions can go negative. Should this be handled? Or if it cannot happen, then an assert/assume?",
      "created_at": "2023-08-31T10:59:13Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311460423",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311460423"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1029,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1096,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311500825",
      "pull_request_review_id": 1602648914,
      "id": 1311500825,
      "node_id": "PRRC_kwDOABII585OK-oZ",
      "diff_hunk": "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);\n+    /** Deserialization version number. */\n+    int m_recv_version GUARDED_BY(m_recv_mutex);\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. */\n+    mutable Mutex m_send_mutex;",
      "path": "src/net.h",
      "position": null,
      "original_position": 223,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe expand the comments with something like this:\r\n\r\nTo avoid deadlocks, if both `m_recv_mutex` and `m_send_mutex` have to be locked at the same time, always lock `m_recv_mutex` first. I.e. when locking `m_recv_mutex`, make sure that `m_send_mutex` is not already locked by the calling thread.",
      "created_at": "2023-08-31T11:39:13Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311500825",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311500825"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 571,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311508831",
      "pull_request_review_id": 1602648914,
      "id": 1311508831,
      "node_id": "PRRC_kwDOABII585OLAlf",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 223,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is doing an extra copy of the key - first from the buffer to the array and then from the array to ~`m_cipher.m_pubkey`~ `EllSwiftPubKey::m_pubkey`. Is it possible to avoid that? Is it possible to initialize `m_cipher.m_pubkey` directly from the buffer? I think it is ok to take vector in `EllSwiftPubKey` and document that its size must be `EllSwiftPubKey::size()` and assert that it is indeed.",
      "created_at": "2023-08-31T11:47:02Z",
      "updated_at": "2023-09-01T09:27:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311508831",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311508831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1103,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1106,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311514245",
      "pull_request_review_id": 1602648914,
      "id": 1311514245,
      "node_id": "PRRC_kwDOABII585OLB6F",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 226,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It would be good to enforce the state machine allowed transitions - in all places that change the state, assert that such transition is allowed. In this case: `assert(m_recv_state == RecvState::KEY)`. Or maybe have `m_recv_state` be a class that enforces correctness internally and is then called like:\r\n\r\n```cpp\r\nm_recv_state.ChangeTo(RecvState::GARB_GARBTERM);\r\n```",
      "created_at": "2023-08-31T11:52:16Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311514245",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311514245"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311548994",
      "pull_request_review_id": 1602648914,
      "id": 1311548994,
      "node_id": "PRRC_kwDOABII585OLKZC",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {",
      "path": "src/net.cpp",
      "position": 308,
      "original_position": 266,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What about changing that `==` to `>=`? Otherwise, if it somehow happens that the buffer is larger, then this safety check will never catch it and it will keep receiving \"forever\".",
      "created_at": "2023-08-31T12:24:14Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311548994",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311548994"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1192,
      "original_line": 1192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311553670",
      "pull_request_review_id": 1602648914,
      "id": 1311553670,
      "node_id": "PRRC_kwDOABII585OLLiG",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 265,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would be nice if at the start of the function, or just before `m_recv_state = ...` there is something like `assert(current state is xyz);`",
      "created_at": "2023-08-31T12:28:18Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311553670",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311553670"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1139,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311560086",
      "pull_request_review_id": 1602648914,
      "id": 1311560086,
      "node_id": "PRRC_kwDOABII585OLNGW",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 284,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\r\n        const auto max = std::min(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH) + 1 /* what is this? */ + CMessageHeader::COMMAND_SIZE;\r\n        if (m_recv_len > max) {\r\n            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes > %u), peer=%d\\n\", m_recv_len, max, m_nodeid);\r\n```",
      "created_at": "2023-08-31T12:33:51Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311560086",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311560086"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311568129",
      "pull_request_review_id": 1602648914,
      "id": 1311568129,
      "node_id": "PRRC_kwDOABII585OLPEB",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {",
      "path": "src/net.cpp",
      "position": 344,
      "original_position": 287,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is it possible that this branch executes before the one above? If the buffer is less than `LENGTH_LEN` (3) and then on the next invocation of this method, it is greater than `LENGTH_LEN` (3), equal to `EXPANSION` (20)?\r\n\r\nEdit: that's not possible currently. It relies on\r\n1. this method being called only if `m_recv_state` is one of `GARBAUTH`, `VERSION`, `APP` and\r\n2. `GetMaxBytesToProcess()` working correctly\r\n\r\nthat's a bit remote from the point of view inside this function. Maybe add assert or assume to ensure that?",
      "created_at": "2023-08-31T12:40:31Z",
      "updated_at": "2023-08-31T13:36:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311568129",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311568129"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1228,
      "original_line": 1228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311613938",
      "pull_request_review_id": 1602648914,
      "id": 1311613938,
      "node_id": "PRRC_kwDOABII585OLaPy",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 250000;\n+\n+    if (m_use_v1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Reserve space in the buffer.\n+        if (m_recv_state == RecvState::KEY_MAYBE_V1 || m_recv_state == RecvState::KEY ||\n+            m_recv_state == RecvState::GARB_GARBTERM) {\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        } else if (m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+            m_recv_state == RecvState::APP) {\n+            // During states where a packet is being received, as much as is expected but never\n+            // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+            size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+            m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);\n+        }\n+        // Can't read more than provided input.\n+        max_read = std::min<uint32_t>(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY_MAYBE_V1:\n+            ProcessReceivedMaybeV1();\n+            if (m_recv_state == RecvState::V1) return true;\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+\n+        case RecvState::V1:\n+            // We should have bailed out before.\n+            assert(false);\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+    contents = contents.subspan(1); // Strip first byte.\n+\n+    if (first_byte != 0) {\n+        // Short (1 byte) encoding.\n+        if (first_byte < std::size(V2_MESSAGE_IDS)) {\n+            // Valid short message id.\n+            return V2_MESSAGE_IDS[first_byte];\n+        } else {\n+            // Unknown short message id.\n+            return std::nullopt;\n+        }\n+    }\n+\n+    if (contents.size() < CMessageHeader::COMMAND_SIZE) {\n+        return std::nullopt; // Long encoding needs 12 message type bytes.\n+    }\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE && contents[msg_type_len] != 0) {\n+        // Verify that message type bytes before the first 0x00 are in range.\n+        if (contents[msg_type_len] < ' ' || contents[msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data()), msg_type_len};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE) {\n+        // Verify that message type bytes after the first 0x00 are also 0x00.\n+        if (contents[msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    // Strip message type bytes of contents.\n+    contents = contents.subspan(CMessageHeader::COMMAND_SIZE);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.GetReceivedMessage(time, reject_message);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetReceivedMessage(time, reject_message);\n+\n+    assert(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;\n+        msg.m_message_size = contents.size();\n+        msg.m_recv.resize(contents.size());\n+        std::copy(contents.begin(), contents.end(), UCharCast(msg.m_recv.data()));\n+    } else {\n+        LogPrint(BCLog::NET, \"V2 transport error: invalid message type (%u bytes contents), peer=%d\\n\", m_recv_decode_buffer.size(), m_nodeid);\n+        reject_message = true;\n+    }\n+    m_recv_decode_buffer = {};\n+    m_recv_state = RecvState::APP;\n+\n+    return msg;\n+}\n+\n+bool V2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_use_v1) return m_v1_fallback.SetMessageToSend(msg);\n+    LOCK(m_send_mutex);\n+    if (m_send_state == SendState::V1) return m_v1_fallback.SetMessageToSend(msg);\n+\n+    if (m_send_state != SendState::APP_READY) return false;\n+    // Construct contents (encoding message type + payload).\n+    std::vector<uint8_t> contents;\n+    auto short_message_id = V2_MESSAGE_MAP(msg.m_type);\n+    if (short_message_id) {\n+        contents.resize(1 + msg.data.size());\n+        contents[0] = *short_message_id;\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1);\n+    } else {\n+        // Initialize with zeroes, and then write the message type string starting at offset 0.\n+        // This means contents[0] and the unused positions in contents[1..13] remain 0x00.\n+        contents.resize(1 + CMessageHeader::COMMAND_SIZE + msg.data.size(), 0);\n+        std::copy(msg.m_type.begin(), msg.m_type.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1 + CMessageHeader::COMMAND_SIZE);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 495,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The cast seems unnecessary?\r\n```suggestion\r\n        std::copy(msg.m_type.begin(), msg.m_type.end(), contents.data() + 1);\r\n        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1 + CMessageHeader::COMMAND_SIZE);\r\n```",
      "created_at": "2023-08-31T13:16:22Z",
      "updated_at": "2023-08-31T13:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311613938",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311613938"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1377,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1518,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311986162",
      "pull_request_review_id": 1605335997,
      "id": 1311986162,
      "node_id": "PRRC_kwDOABII585OM1Hy",
      "diff_hunk": "@@ -300,7 +299,8 @@ class Transport {\n      *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n      *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n      *    all sent (as signaled by MarkBytesSent()).\n-     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     *  - const std::string& m_type: message type on behalf of which this is being sent\n+     *    (\"\" for bytes that are not on behalf of any message).",
      "path": "src/net.h",
      "position": 23,
      "original_position": 23,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": 1311249370,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The `m_type` value is really only used to control the breakdown statistics of bytes sent/received per message type in the `getpeerinfo` RPC. We need string categories there, so it seems to me really the question is what category name to use for bytes not assignable to a specific message type. `\"\"` seems to be as good as any, so all this suggestion would entail is having a more complex `m_type` in `BytesToSend`, and logic in the RPC code to turn `std::nullopt` into `\"\"`. I don't think that improves much.",
      "created_at": "2023-08-31T17:45:22Z",
      "updated_at": "2023-08-31T17:45:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1311986162",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1311986162"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 303,
      "original_line": 303,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312001695",
      "pull_request_review_id": 1605369802,
      "id": 1312001695,
      "node_id": "PRRC_kwDOABII585OM46f",
      "diff_hunk": "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);\n+    /** Deserialization version number. */\n+    int m_recv_version GUARDED_BY(m_recv_mutex);\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. */\n+    mutable Mutex m_send_mutex;\n+    /** The send buffer; meaning is determined by m_send_state. */\n+    std::vector<uint8_t> m_send_buffer GUARDED_BY(m_send_mutex);\n+    /** How many bytes from the send buffer have been sent so far. */\n+    uint32_t m_send_pos GUARDED_BY(m_send_mutex) {0};\n+    /** Type of the message being sent. */\n+    std::string m_send_type GUARDED_BY(m_send_mutex);\n+    /** Current sender state. */\n+    SendState m_send_state GUARDED_BY(m_send_mutex);\n+\n+    /** Given a packet's contents, find the message type (if valid), and strip it from contents. */\n+    static std::optional<std::string> GetMessageType(Span<const uint8_t>& contents) noexcept;\n+    /** Determine how many received bytes can be processed in one go (not allowed in V1 state). */\n+    size_t GetMaxBytesToProcess() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in KEY_MAYBE_V1 state. */\n+    void ProcessReceivedMaybeV1() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in KEY state. */\n+    void ProcessReceivedKey() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in GARB_GARBTERM state. */\n+    bool ProcessReceivedGarbage() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in GARBAUTH/VERSION/APP state. */\n+    bool ProcessReceivedPacket() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+\n+public:\n+\n+    /** Construct a V2 transport with securely generated random keys. */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept;\n+    /** Construct a V2 transport with specified keys and garbage (test use only). */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept;",
      "path": "src/net.h",
      "position": 302,
      "original_position": 251,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": 1311402373,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The conflict is due to the fact that most of the cryptography code (at least the part used by V2Transport, directly and indirectly) has been converted to be entirely `Span<std::byte>`-based, while the network/serialization code is still mostly (`Span<uint8_t>` and `(uint8_t* data, size_t size)`-based). In `V2Transport` we interact with both, which means some silly conversions.\r\n\r\nI've opted not to try to convert the network/serialize code here to `Span<std::byte>` (as that's a bigger, and probably longer-term effort, though I do expect that to happen eventually), and as a result the internal `V2Transport` variables that are closer to that side also use `uint8_t*`. They're indeed interchangeable (even by the C++ spec: specifically only `char`, `unsigned char`, and `std::byte` pointers are allowed to be used to access data of any data type), but until the whole codebase this interacts with is `std::byte`-based, there will be some conversions.",
      "created_at": "2023-08-31T17:57:59Z",
      "updated_at": "2023-08-31T17:57:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312001695",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312001695"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 639,
      "original_line": 639,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312003077",
      "pull_request_review_id": 1605372003,
      "id": 1312003077,
      "node_id": "PRRC_kwDOABII585OM5QF",
      "diff_hunk": "@@ -538,6 +540,9 @@ class V2Transport final : public Transport\n     const bool m_initiating;\n     /** NodeId (for debug logging). */\n     const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 25,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "c3902f3f1dec2368b7e7b6ec77019324ae915b31",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "name changed: m_recv_mutex / m_send_mutex - same a few lines above for the V1 states.",
      "created_at": "2023-08-31T17:58:30Z",
      "updated_at": "2023-08-31T20:32:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312003077",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312003077"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 572,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312036062",
      "pull_request_review_id": 1605372003,
      "id": 1312036062,
      "node_id": "PRRC_kwDOABII585ONBTe",
      "diff_hunk": "@@ -538,6 +540,9 @@ class V2Transport final : public Transport\n     const bool m_initiating;\n     /** NodeId (for debug logging). */\n     const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};",
      "path": "src/net.h",
      "position": null,
      "original_position": 26,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "c3902f3f1dec2368b7e7b6ec77019324ae915b31",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Does the `m_use_v1` optimization result in a meaningful speedup? \r\nMy first thought was that the V1 functions are so similar to the respective V2 functions in terms of locking (have analogous `m_recv_mutex`/`m_send_mutex` locks for  analogous functions) so if there would be lock contention at the V2 level that `m_use_v1` avoids, we'd now just have the same contention for the analogous locks one level below at V1Transport instead, resulting in no real performance improvement.",
      "created_at": "2023-08-31T18:18:06Z",
      "updated_at": "2023-08-31T20:32:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312036062",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312036062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 573,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092279",
      "pull_request_review_id": 1605515528,
      "id": 1312092279,
      "node_id": "PRRC_kwDOABII585ONPB3",
      "diff_hunk": "@@ -320,7 +328,7 @@ class Transport {\n      * Note that m_type and to_send refer to data that is internal to the transport, and calling\n      * any non-const function on this object may invalidate them.\n      */",
      "path": "src/net.h",
      "position": 71,
      "original_position": 34,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "040ea05dae05ef513ac79306dd560c8c1f228942",
      "in_reply_to_id": 1310237002,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-08-31T19:07:23Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312092279",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092279"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 345,
      "original_line": 345,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092953",
      "pull_request_review_id": 1605515528,
      "id": 1312092953,
      "node_id": "PRRC_kwDOABII585ONPMZ",
      "diff_hunk": "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:",
      "path": "src/net.h",
      "position": 104,
      "original_position": 79,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": 1311376345,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've merged the two `public:` sections.",
      "created_at": "2023-08-31T19:07:52Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312092953",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312092953"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 441,
      "original_line": 441,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312106070",
      "pull_request_review_id": 1605515528,
      "id": 1312106070,
      "node_id": "PRRC_kwDOABII585ONSZW",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {",
      "path": "src/net.cpp",
      "position": 308,
      "original_position": 266,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": 1311548994,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is something I learned in college, though I've never seen it repeated elsewhere: when you have conditional code, make the conditional as narrow as necessary. The reason is that in general, if you let conditionals apply to states that shouldn't be hit at all, they'll hide the issue; the alternative generally leads to more obvious failures.\r\n\r\nI think it applies here: if we'd use `>=`, and we ever ended up in a `>` state, that would imply we're not actually testing for the garbage terminator after every byte, possibly leading to hard-to-discover connection failures. With just `==`, it'll keep receiving forever, likely stalling, or crashing, with an obvious too-large receive buffer.\r\n\r\nOf course, we can do even better: add an Assume that the receive buffer size never exceeds `MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN` in this state, which is what I've added here.",
      "created_at": "2023-08-31T19:12:17Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312106070",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312106070"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1192,
      "original_line": 1192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312108759",
      "pull_request_review_id": 1605515528,
      "id": 1312108759,
      "node_id": "PRRC_kwDOABII585ONTDX",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {",
      "path": "src/net.cpp",
      "position": 344,
      "original_position": 287,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": 1311568129,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm not sure how I'd assert for it, but I've added a comment.",
      "created_at": "2023-08-31T19:12:57Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312108759",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312108759"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1228,
      "original_line": 1228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312111598",
      "pull_request_review_id": 1605515528,
      "id": 1312111598,
      "node_id": "PRRC_kwDOABII585ONTvu",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                m_recv_state = RecvState::APP;\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                m_recv_state = RecvState::APP_READY;\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 250000;\n+\n+    if (m_use_v1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Reserve space in the buffer.\n+        if (m_recv_state == RecvState::KEY_MAYBE_V1 || m_recv_state == RecvState::KEY ||\n+            m_recv_state == RecvState::GARB_GARBTERM) {\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        } else if (m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+            m_recv_state == RecvState::APP) {\n+            // During states where a packet is being received, as much as is expected but never\n+            // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+            size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+            m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);\n+        }\n+        // Can't read more than provided input.\n+        max_read = std::min<uint32_t>(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY_MAYBE_V1:\n+            ProcessReceivedMaybeV1();\n+            if (m_recv_state == RecvState::V1) return true;\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+\n+        case RecvState::V1:\n+            // We should have bailed out before.\n+            assert(false);\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+    contents = contents.subspan(1); // Strip first byte.\n+\n+    if (first_byte != 0) {\n+        // Short (1 byte) encoding.\n+        if (first_byte < std::size(V2_MESSAGE_IDS)) {\n+            // Valid short message id.\n+            return V2_MESSAGE_IDS[first_byte];\n+        } else {\n+            // Unknown short message id.\n+            return std::nullopt;\n+        }\n+    }\n+\n+    if (contents.size() < CMessageHeader::COMMAND_SIZE) {\n+        return std::nullopt; // Long encoding needs 12 message type bytes.\n+    }\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE && contents[msg_type_len] != 0) {\n+        // Verify that message type bytes before the first 0x00 are in range.\n+        if (contents[msg_type_len] < ' ' || contents[msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data()), msg_type_len};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE) {\n+        // Verify that message type bytes after the first 0x00 are also 0x00.\n+        if (contents[msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    // Strip message type bytes of contents.\n+    contents = contents.subspan(CMessageHeader::COMMAND_SIZE);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.GetReceivedMessage(time, reject_message);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetReceivedMessage(time, reject_message);\n+\n+    assert(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;\n+        msg.m_message_size = contents.size();\n+        msg.m_recv.resize(contents.size());\n+        std::copy(contents.begin(), contents.end(), UCharCast(msg.m_recv.data()));\n+    } else {\n+        LogPrint(BCLog::NET, \"V2 transport error: invalid message type (%u bytes contents), peer=%d\\n\", m_recv_decode_buffer.size(), m_nodeid);\n+        reject_message = true;\n+    }\n+    m_recv_decode_buffer = {};\n+    m_recv_state = RecvState::APP;\n+\n+    return msg;\n+}\n+\n+bool V2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_use_v1) return m_v1_fallback.SetMessageToSend(msg);\n+    LOCK(m_send_mutex);\n+    if (m_send_state == SendState::V1) return m_v1_fallback.SetMessageToSend(msg);\n+\n+    if (m_send_state != SendState::APP_READY) return false;\n+    // Construct contents (encoding message type + payload).\n+    std::vector<uint8_t> contents;\n+    auto short_message_id = V2_MESSAGE_MAP(msg.m_type);\n+    if (short_message_id) {\n+        contents.resize(1 + msg.data.size());\n+        contents[0] = *short_message_id;\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1);\n+    } else {\n+        // Initialize with zeroes, and then write the message type string starting at offset 0.\n+        // This means contents[0] and the unused positions in contents[1..13] remain 0x00.\n+        contents.resize(1 + CMessageHeader::COMMAND_SIZE + msg.data.size(), 0);\n+        std::copy(msg.m_type.begin(), msg.m_type.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1 + CMessageHeader::COMMAND_SIZE);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 495,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": 1311613938,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-08-31T19:13:37Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312111598",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312111598"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1377,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1518,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312112870",
      "pull_request_review_id": 1605515528,
      "id": 1312112870,
      "node_id": "PRRC_kwDOABII585ONUDm",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 1 + CMessageHeader::COMMAND_SIZE ||\n+            m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 1 + CMessageHeader::COMMAND_SIZE) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 284,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": 1311560086,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done (using a `static constexpr size_t` constant with comments higher up).",
      "created_at": "2023-08-31T19:14:05Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312112870",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312112870"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113220",
      "pull_request_review_id": 1605515528,
      "id": 1312113220,
      "node_id": "PRRC_kwDOABII585ONUJE",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 265,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": 1311553670,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, at the beginning of all `ProcessReceived*` functions.",
      "created_at": "2023-08-31T19:14:25Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113220",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113220"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1139,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113425",
      "pull_request_review_id": 1605515528,
      "id": 1312113425,
      "node_id": "PRRC_kwDOABII585ONUMR",
      "diff_hunk": "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is",
      "path": "src/net.h",
      "position": null,
      "original_position": 94,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "040ea05dae05ef513ac79306dd560c8c1f228942",
      "in_reply_to_id": 1310277982,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-08-31T19:14:40Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113425",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113425"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 467,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113516",
      "pull_request_review_id": 1605515528,
      "id": 1312113516,
      "node_id": "PRRC_kwDOABII585ONUNs",
      "diff_hunk": "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */\n+    enum class RecvState {",
      "path": "src/net.h",
      "position": null,
      "original_position": 62,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "040ea05dae05ef513ac79306dd560c8c1f228942",
      "in_reply_to_id": 1310288598,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-08-31T19:14:46Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113516",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113516"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 435,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113605",
      "pull_request_review_id": 1605515528,
      "id": 1312113605,
      "node_id": "PRRC_kwDOABII585ONUPF",
      "diff_hunk": "@@ -416,7 +424,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the contents of the receive buffer. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 61,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "040ea05dae05ef513ac79306dd560c8c1f228942",
      "in_reply_to_id": 1310305445,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-08-31T19:14:50Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113605",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113605"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 443,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113901",
      "pull_request_review_id": 1605515528,
      "id": 1312113901,
      "node_id": "PRRC_kwDOABII585ONUTt",
      "diff_hunk": "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {",
      "path": "src/net.h",
      "position": null,
      "original_position": 87,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": 1311222591,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added an overall comment above `enum class RecvState`.",
      "created_at": "2023-08-31T19:15:09Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312113901",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312113901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 435,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114126",
      "pull_request_review_id": 1605515528,
      "id": 1312114126,
      "node_id": "PRRC_kwDOABII585ONUXO",
      "diff_hunk": "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 207,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": 1311381100,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-08-31T19:15:16Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312114126",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114126"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 555,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114721",
      "pull_request_review_id": 1605515528,
      "id": 1312114721,
      "node_id": "PRRC_kwDOABII585ONUgh",
      "diff_hunk": "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);",
      "path": "src/net.h",
      "position": null,
      "original_position": 216,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": 1311393641,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done. Also dropped the `GUARDED_BY(m_recv_mutex)` which is not needed for immutable variables.",
      "created_at": "2023-08-31T19:15:45Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312114721",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312114721"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 564,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312115309",
      "pull_request_review_id": 1605515528,
      "id": 1312115309,
      "node_id": "PRRC_kwDOABII585ONUpt",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 151,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": 1311460423,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's impossible to hit, because `GetMaxBytesToProcess` only lets in as much as needed to reach the end of the buffer. I've added comments and Assumes.",
      "created_at": "2023-08-31T19:16:27Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312115309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312115309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1029,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1096,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116243",
      "pull_request_review_id": 1605515528,
      "id": 1312116243,
      "node_id": "PRRC_kwDOABII585ONU4T",
      "diff_hunk": "@@ -416,7 +414,198 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted. */\n+    enum class RecvState {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, its contents is\n+         * interpreted as version negotiation (currently, that means ignoring it, but it can be\n+         * used for negotiating future extensions). If it fails, the connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. m_use_v1 is also set in this\n+         * state, so this redirection can usually happen without needing the m_cs_recv lock. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer. */\n+    enum class SendState {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. m_use_v1 is also set in this state,\n+         * so this redirection can usually happen without needing the m_cs_send lock. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex;\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if\n+     *  m_recv_buffer.size() >= BIP324::LENGTH_LEN). Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    int m_recv_type GUARDED_BY(m_recv_mutex);\n+    /** Deserialization version number. */\n+    int m_recv_version GUARDED_BY(m_recv_mutex);\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. */\n+    mutable Mutex m_send_mutex;",
      "path": "src/net.h",
      "position": null,
      "original_position": 223,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": 1311500825,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It turns out that we actually have locking annotations for that. I've added `ACQUIRED_BEFORE(m_send_mutex)` to `m_recv_mutex`, and `ACQUIRED_AFTER(m_recv_mutex)` to `m_send_mutex`, together with a shortened version of your suggested comment.",
      "created_at": "2023-08-31T19:17:21Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312116243",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116243"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 571,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116773",
      "pull_request_review_id": 1605515528,
      "id": 1312116773,
      "node_id": "PRRC_kwDOABII585ONVAl",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 223,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": 1311508831,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in an extra preparatory commit (allowing `Span<const std::byte>` argument for `EllSwiftPubKey` constructor.",
      "created_at": "2023-08-31T19:17:54Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312116773",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312116773"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1103,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1106,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312117427",
      "pull_request_review_id": 1605515528,
      "id": 1312117427,
      "node_id": "PRRC_kwDOABII585ONVKz",
      "diff_hunk": "@@ -910,24 +912,557 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    if (m_use_v1) return m_v1_fallback.ReceivedMessageComplete();\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1 || m_send_state == SendState::KEY_GARB);\n+        m_send_state = SendState::KEY_GARB;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        m_send_state = SendState::V1;\n+        m_recv_state = RecvState::V1;\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+        // Set atomic to allow quick dispatch to fallback transport.\n+        m_use_v1 = true;\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 226,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "9d496e2d53ff42f6276493925988e1e98bcc4259",
      "in_reply_to_id": 1311514245,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A wrapper felt like overkill to me, but I've added `SetReceiveState` and `SetSendState` functions for effecting state transitions, which enforce the allowed ones.",
      "created_at": "2023-08-31T19:18:34Z",
      "updated_at": "2023-08-31T19:18:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312117427",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312117427"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312201855",
      "pull_request_review_id": 1605676924,
      "id": 1312201855,
      "node_id": "PRRC_kwDOABII585ONpx_",
      "diff_hunk": "@@ -538,6 +540,9 @@ class V2Transport final : public Transport\n     const bool m_initiating;\n     /** NodeId (for debug logging). */\n     const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */\n+    std::atomic<bool> m_use_v1{false};",
      "path": "src/net.h",
      "position": null,
      "original_position": 26,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "c3902f3f1dec2368b7e7b6ec77019324ae915b31",
      "in_reply_to_id": 1312036062,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That sounds right; there will really only be contention on one of the two levels, and uncontended mutex grabs are in the 10s of nanonseconds I believe. I'll just drop this commit.",
      "created_at": "2023-08-31T20:37:21Z",
      "updated_at": "2023-08-31T20:37:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312201855",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312201855"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 573,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312212320",
      "pull_request_review_id": 1605693293,
      "id": 1312212320,
      "node_id": "PRRC_kwDOABII585ONsVg",
      "diff_hunk": "@@ -912,6 +912,347 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::SetReceiveVersion(int nVersionIn) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    m_recv_version = nVersionIn;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        std::array<std::byte, EllSwiftPubKey::size()> ellswift_data;\n+        std::copy(m_recv_buffer.begin(), m_recv_buffer.end(), UCharCast(ellswift_data.data()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(EllSwiftPubKey{ellswift_data}, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        m_recv_state = RecvState::GARB_GARBTERM;\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        assert(m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY_GARBTERM_GARBAUTH_VERSION;\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            m_recv_state = RecvState::GARBAUTH;\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_SIZE + 13 || m_recv_len > MAX_PROTOCOL_MESSAGE_LENGTH + 13) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packed decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            m_recv_state = RecvState::VERSION;\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is",
      "path": "src/net.cpp",
      "position": 375,
      "original_position": 171,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "de705988c330fc5b3c006337bd72ca0f0c8e2750",
      "in_reply_to_id": 1310695744,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "okay then, can be resolved.",
      "created_at": "2023-08-31T20:48:31Z",
      "updated_at": "2023-08-31T20:48:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312212320",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312212320"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1259,
      "original_line": 1259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312213945",
      "pull_request_review_id": 1605695923,
      "id": 1312213945,
      "node_id": "PRRC_kwDOABII585ONsu5",
      "diff_hunk": "@@ -538,6 +540,9 @@ class V2Transport final : public Transport\n     const bool m_initiating;\n     /** NodeId (for debug logging). */\n     const NodeId m_nodeid;\n+    /** Whether the send/receive states are V1. This is an optimization allowing fallback to\n+     *  (typically) work without the m_cs_send or m_cs_recv locks. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 25,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "c3902f3f1dec2368b7e7b6ec77019324ae915b31",
      "in_reply_to_id": 1312003077,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Resolved by dropping the commit.",
      "created_at": "2023-08-31T20:50:00Z",
      "updated_at": "2023-08-31T20:50:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1312213945",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1312213945"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 572,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313012119",
      "pull_request_review_id": 1606655503,
      "id": 1313012119,
      "node_id": "PRRC_kwDOABII585OQvmX",
      "diff_hunk": "@@ -416,7 +414,226 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start(responder)\n+     *        |\n+     *        |  start(initiator)                                       /---------\\\n+     *        |          |                                              |         |\n+     *        v          v                                              v         |\n+     *  KEY_MAYBE_V1 -> KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     *        |\n+     *        \\-> V1\n+     */\n+    enum class RecvState : uint8_t {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *  start(responder)  start(initiator)                                        /----------\\\n+     *        |                  |                                                |          |\n+     *        v                  v                                                v          |\n+     *  KEY_GARB_MAYBE_V1 -> KEY_GARB -> KEY_GARB_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     *        |\n+     *        \\-> V1\n+     */\n+    enum class SendState : uint8_t {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};",
      "path": "src/net.h",
      "position": null,
      "original_position": 235,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe this is a bit more readable and easy to verify that it is correct:\r\n\r\n```suggestion\r\n    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 'v', 'e', 'r', 's', 'i', 'o', 'n', 0x00};\r\n```",
      "created_at": "2023-09-01T13:14:28Z",
      "updated_at": "2023-09-01T16:22:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313012119",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313012119"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 572,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313028412",
      "pull_request_review_id": 1606655503,
      "id": 1313028412,
      "node_id": "PRRC_kwDOABII585OQzk8",
      "diff_hunk": "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 262,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Here we assume that a public key will never start with magic+\"version\". Can it? If the pubkey is completely random bytes, then the chance of that happening is 1 in 256<sup>12</sup> = 2<sup>96</sup>.",
      "created_at": "2023-09-01T13:26:49Z",
      "updated_at": "2023-09-01T16:22:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313028412",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313028412"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1142,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1085,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313034598",
      "pull_request_review_id": 1606655503,
      "id": 1313034598,
      "node_id": "PRRC_kwDOABII585OQ1Fm",
      "diff_hunk": "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 168,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is that allowed only for `KEY_GARB` -> `KEY_GARB` for sender? And no `X` -> `X` for the receive state?",
      "created_at": "2023-09-01T13:31:50Z",
      "updated_at": "2023-09-01T16:22:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313034598",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313034598"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1053,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313037669",
      "pull_request_review_id": 1606655503,
      "id": 1313037669,
      "node_id": "PRRC_kwDOABII585OQ11l",
      "diff_hunk": "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::KEY_GARB);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 269,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        // Full match with the v1 prefix, so fall back to v1 behavior.\r\n```",
      "created_at": "2023-09-01T13:34:33Z",
      "updated_at": "2023-09-01T16:22:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313037669",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313037669"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1152,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313079175",
      "pull_request_review_id": 1606655503,
      "id": 1313079175,
      "node_id": "PRRC_kwDOABII585OQ_-H",
      "diff_hunk": "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::KEY_GARB);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 274,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This looks too dangerous/fragile to me. `feedback` is constructed from `m_recv_buffer` which is provided by the peer and if `ReceivedBytes()` does not like it, then we will crash. Earlier we have checked that its size equals `m_v1_prefix.size()` and even earlier we have checked that the first bytes of `m_recv_buffer` and `m_v1_prefix` equal. Or if `m_v1_fallback` has been used before, it may dislike a legit magic+\"version\".\r\n\r\nMaybe construct `feedback` from `m_v1_prefix` which has been constructed by us? I know they are equal, but still...\r\n\r\n@sdaftuar had some concerns elsewhere about asserts in the networking code: https://github.com/bitcoin/bitcoin/pull/27374#discussion_r1154508362. Following that should all asserts in this PR be replaced by dropping the connection? If there is a rare bug in e.g. `V2Transport` is it better to crash the node or close the connection and continue operation?",
      "created_at": "2023-09-01T14:09:58Z",
      "updated_at": "2023-09-01T16:22:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313079175",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313079175"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1155,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1157,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313194800",
      "pull_request_review_id": 1606655503,
      "id": 1313194800,
      "node_id": "PRRC_kwDOABII585ORcMw",
      "diff_hunk": "@@ -320,6 +335,43 @@ std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n     return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n }\n \n+template<typename RNG>\n+std::unique_ptr<Transport> MakeV2Transport(NodeId nodeid, bool initiator, RNG& rng, FuzzedDataProvider& provider)\n+{\n+    // Retrieve key\n+    auto key_data = provider.ConsumeBytes<unsigned char>(32);\n+    key_data.resize(32);\n+    CKey key;\n+    key.Set(key_data.begin(), key_data.end(), true);\n+    if (!key.IsValid()) return {};\n+    // Construct garbage\n+    size_t garb_len = provider.ConsumeIntegralInRange<size_t>(0, 4095);",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 107,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    size_t garb_len = provider.ConsumeIntegralInRange<size_t>(0, V2Transport::MAX_GARBAGE_LEN);\r\n```",
      "created_at": "2023-09-01T15:39:57Z",
      "updated_at": "2023-09-01T16:22:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313194800",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313194800"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 348,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313198040",
      "pull_request_review_id": 1606655503,
      "id": 1313198040,
      "node_id": "PRRC_kwDOABII585ORc_Y",
      "diff_hunk": "@@ -320,6 +335,43 @@ std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n     return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n }\n \n+template<typename RNG>\n+std::unique_ptr<Transport> MakeV2Transport(NodeId nodeid, bool initiator, RNG& rng, FuzzedDataProvider& provider)\n+{\n+    // Retrieve key\n+    auto key_data = provider.ConsumeBytes<unsigned char>(32);\n+    key_data.resize(32);\n+    CKey key;\n+    key.Set(key_data.begin(), key_data.end(), true);\n+    if (!key.IsValid()) return {};\n+    // Construct garbage\n+    size_t garb_len = provider.ConsumeIntegralInRange<size_t>(0, 4095);\n+    std::vector<uint8_t> garb;\n+    if (garb_len <= 64) {\n+        // When the garbage length is up to 64 bytes, read it directly from the fuzzer input.\n+        garb = provider.ConsumeBytes<uint8_t>(garb_len);\n+        garb.resize(garb_len);\n+    } else {\n+        // If it's longer, generate it from the RNG. This avoids having large amounts of\n+        // (hopefully) irrelevant data needing to be stored in the fuzzer data.\n+        for (auto& v : garb) v = uint8_t(rng());\n+    }\n+    // Retrieve entropy\n+    auto ent = provider.ConsumeBytes<std::byte>(32);\n+    ent.resize(32);\n+    // Use as entropy SHA256(ent || garbage). This prevents a situation where the fuzzer manages to\n+    // include the garbage terminator (which is a function of both ellswift keys) in the garbage.\n+    // This is entremely unlikely (~2^-116) with random keys/garbage, but the fuzzer can choose",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 123,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    // This is extremely unlikely (~2^-116) with random keys/garbage, but the fuzzer can choose\r\n```",
      "created_at": "2023-09-01T15:43:09Z",
      "updated_at": "2023-09-01T16:22:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313198040",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313198040"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 364,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313209038",
      "pull_request_review_id": 1606655503,
      "id": 1313209038,
      "node_id": "PRRC_kwDOABII585ORfrO",
      "diff_hunk": "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::KEY_GARB);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        SetReceiveState(RecvState::V1);\n+        SetSendState(SendState::V1);\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            SetReceiveState(RecvState::VERSION);\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                SetReceiveState(RecvState::APP);\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                SetReceiveState(RecvState::APP_READY);\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 250000;\n+\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Reserve space in the buffer.\n+        if (m_recv_state == RecvState::KEY_MAYBE_V1 || m_recv_state == RecvState::KEY ||\n+            m_recv_state == RecvState::GARB_GARBTERM) {\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        } else if (m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+            m_recv_state == RecvState::APP) {\n+            // During states where a packet is being received, as much as is expected but never\n+            // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+            size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+            m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 443,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why do this? To reduce the amount of `m_recv_buffer` resizes?\r\n\r\nHow did you choose `250000`?\r\n\r\nWhen would `max_read` be larger than `msg_bytes.size() + MAX_RESERVE_AHEAD`?",
      "created_at": "2023-09-01T15:53:43Z",
      "updated_at": "2023-09-01T16:22:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313209038",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313209038"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1307,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1346,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313242620",
      "pull_request_review_id": 1606655503,
      "id": 1313242620,
      "node_id": "PRRC_kwDOABII585ORn38",
      "diff_hunk": "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());",
      "path": "src/test/net_tests.cpp",
      "position": null,
      "original_position": 282,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would be nice to avoid the magic numbers 12 and 13.",
      "created_at": "2023-09-01T16:16:24Z",
      "updated_at": "2023-09-01T16:22:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313242620",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313242620"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1265,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313245167",
      "pull_request_review_id": 1606655503,
      "id": 1313245167,
      "node_id": "PRRC_kwDOABII585ORofv",
      "diff_hunk": "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 13);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.SendKey();\n+        tester.SendGarbage();\n+        tester.ReceiveKey();\n+        tester.SendGarbageTermAuth();\n+        tester.SendVersion();\n+        ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.ReceiveGarbage();\n+        tester.ReceiveVersion();\n+        auto msg_data_1 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(100000));",
      "path": "src/test/net_tests.cpp",
      "position": 343,
      "original_position": 326,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Since this unit test uses random numbers, it may happen that if it fails/crashes, then it does not do that if run again. How would one go to reproduce a test failure?",
      "created_at": "2023-09-01T16:19:22Z",
      "updated_at": "2023-09-01T16:22:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313245167",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313245167"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1340,
      "original_line": 1340,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313307383",
      "pull_request_review_id": 1607368990,
      "id": 1313307383,
      "node_id": "PRRC_kwDOABII585OR3r3",
      "diff_hunk": "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 168,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313034598,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's possible to outlaw those `X` -> `X` transitions, but I don't think that accomplishes much. Conceptually, staying in the same state is always allowed; it just so happens that in many cases the current code never invokes this function in cases where no state change is needed.",
      "created_at": "2023-09-01T17:13:58Z",
      "updated_at": "2023-09-01T19:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313307383",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313307383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1053,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313308489",
      "pull_request_review_id": 1607368990,
      "id": 1313308489,
      "node_id": "PRRC_kwDOABII585OR39J",
      "diff_hunk": "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 262,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313028412,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed, exactly. See also [footnote 9 in BIP324](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#cite_ref-why_no_prefix_check_9-0).",
      "created_at": "2023-09-01T17:15:03Z",
      "updated_at": "2023-09-01T19:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313308489",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313308489"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1142,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1085,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313337429",
      "pull_request_review_id": 1607368990,
      "id": 1313337429,
      "node_id": "PRRC_kwDOABII585OR_BV",
      "diff_hunk": "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::KEY_GARB);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);\n+        SetReceiveState(RecvState::V1);\n+        SetSendState(SendState::V1);\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARB_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // already there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            SetReceiveState(RecvState::VERSION);\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                SetReceiveState(RecvState::APP);\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                SetReceiveState(RecvState::APP_READY);\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            assert(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 250000;\n+\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Reserve space in the buffer.\n+        if (m_recv_state == RecvState::KEY_MAYBE_V1 || m_recv_state == RecvState::KEY ||\n+            m_recv_state == RecvState::GARB_GARBTERM) {\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        } else if (m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+            m_recv_state == RecvState::APP) {\n+            // During states where a packet is being received, as much as is expected but never\n+            // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+            size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+            m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 443,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313209038,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Why do this? To reduce the amount of `m_recv_buffer` resizes?\r\n\r\nMost `std::vector` implementations will double their memory when they resize beyond their bounds. That's a problem, because without explicitly controlling the preallocation to prevent that it means peers can trivially cause multiple megabytes of allocated but unused memory, without even needing to send bytes to fill them.\r\n\r\nI've added some extra comments to the code.\r\n\r\n> How did you choose `250000`?\r\n\r\nSame as `V1Transport` (see `V1Transport::readData`). I just realized it's `256 * 1024` there, I'll use the same here.\r\n\r\n> When would `max_read` be larger than `msg_bytes.size() + MAX_RESERVE_AHEAD`?\r\n\r\nFor example, when after receiving the first 1000 bytes of a 2 MB packet. `max_read` will be ~2000000, but `msg_bytes.size() + MAX_RESERVE_AHEAD` will be 251000.",
      "created_at": "2023-09-01T17:39:59Z",
      "updated_at": "2023-09-01T19:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313337429",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313337429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1307,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1346,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313344260",
      "pull_request_review_id": 1607368990,
      "id": 1313344260,
      "node_id": "PRRC_kwDOABII585OSAsE",
      "diff_hunk": "@@ -416,7 +414,226 @@ class V1Transport final : public Transport\n     CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) override EXCLUSIVE_LOCKS_REQUIRED(!m_recv_mutex);\n \n     bool SetMessageToSend(CSerializedNetMsg& msg) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n-    BytesToSend GetBytesToSend() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    BytesToSend GetBytesToSend(bool have_next_message) const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    void MarkBytesSent(size_t bytes_sent) noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+    size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n+};\n+\n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start(responder)\n+     *        |\n+     *        |  start(initiator)                                       /---------\\\n+     *        |          |                                              |         |\n+     *        v          v                                              v         |\n+     *  KEY_MAYBE_V1 -> KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     *        |\n+     *        \\-> V1\n+     */\n+    enum class RecvState : uint8_t {\n+        /** (Responder only) either v2 public key or v1 header.\n+         *\n+         * This is the initial state for responders, before data has been received to distinguish\n+         * v1 from v2 connections. When that happens, the state becomes either KEY (for v2) or V1\n+         * (for v1). */\n+        KEY_MAYBE_V1,\n+\n+        /** Public key.\n+         *\n+         * This is the initial state for initiators, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All receive operations are redirected to m_v1_fallback. */\n+        V1,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *  start(responder)  start(initiator)                                        /----------\\\n+     *        |                  |                                                |          |\n+     *        v                  v                                                v          |\n+     *  KEY_GARB_MAYBE_V1 -> KEY_GARB -> KEY_GARB_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     *        |\n+     *        \\-> V1\n+     */\n+    enum class SendState : uint8_t {\n+        /** (Responder only) Public key and garbage.\n+         *\n+         * This is the initial state for responders. The send buffer contains the public key and\n+         * garbage to send, but nothing is sent in this state yet. When the receiver determines\n+         * whether this is a V1 or V2 connection, the sender state becomes KEY_GARB (for v2) or V1\n+         * (for v1) as well.\n+         */\n+        KEY_GARB_MAYBE_V1,\n+\n+        /** Public key and garbage.\n+         *\n+         * This is the initial state for initiators. The public key plus garbage are sent out. When\n+         * the receiver receives the other side's public key and transitions to GARB_GARBTERM, the\n+         * sender state becomes KEY_GARB_GARBTERM_GARBAUTH_VERSION. The key and garbage are left in\n+         * the send buffer when this happens, because they may not have been fully sent out yet. */\n+        KEY_GARB,\n+\n+        /** Public key + garbage + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key and garbage are sent, plus garbage terminator,\n+         * authentication packet, and version packet. When all of that is sent, the sender state\n+         * becomes APP_READY. */\n+        KEY_GARB_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+\n+        /** Nothing (this transport is using v1 fallback).\n+         *\n+         * All send operations are redirected to m_v1_fallback. */\n+        V1,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+    /** Encapsulate a V1Transport to fall back to. */\n+    V1Transport m_v1_fallback;\n+    /** V1 prefix to look for (4-byte network magic + \"version\\x00\"; magic will be filled in). */\n+    std::array<uint8_t, 12> m_v1_prefix = {0, 0, 0, 0, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00};",
      "path": "src/net.h",
      "position": null,
      "original_position": 235,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313012119,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-09-01T17:45:55Z",
      "updated_at": "2023-09-01T19:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313344260",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313344260"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 572,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313367688",
      "pull_request_review_id": 1602833673,
      "id": 1313367688,
      "node_id": "PRRC_kwDOABII585OSGaI",
      "diff_hunk": "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                       /----------\\\n+     *     |                                         |          |\n+     *     v                                         v          |\n+     *    KEY -> KEY_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     */\n+    enum class SendState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state. The public key is sent out. When the receiver\n+         * receives the other side's public key and transitions to GARB_GARBTERM, the sender state\n+         * becomes KEY_GARBTERM_GARBAUTH_VERSION. The key is left in the send buffer when this\n+         * happens, because it may not have been fully sent out yet. */\n+        KEY,\n+\n+        /** Public key + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key is sent, plus garbage terminator, authentication\n+         * packet, and version packet. When all of that is sent, the sender state becomes\n+         * APP_READY. */\n+        KEY_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex ACQUIRED_BEFORE(m_send_mutex);\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if m_recv_buffer.size() >=\n+     *  BIP324Cipher::LENGTH_LEN. Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    const int m_recv_type;\n+    /** Deserialization version number. */\n+    const int m_recv_version;\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. If both sending and receiving fields are accessed,\n+     *  m_recv_mutex must be acquired before m_send_mutex. */\n+    mutable Mutex m_send_mutex ACQUIRED_AFTER(m_recv_mutex);\n+    /** The send buffer; meaning is determined by m_send_state. */\n+    std::vector<uint8_t> m_send_buffer GUARDED_BY(m_send_mutex);\n+    /** How many bytes from the send buffer have been sent so far. */\n+    uint32_t m_send_pos GUARDED_BY(m_send_mutex) {0};\n+    /** Type of the message being sent. */\n+    std::string m_send_type GUARDED_BY(m_send_mutex);\n+    /** Current sender state. */\n+    SendState m_send_state GUARDED_BY(m_send_mutex);\n+\n+    /** Change the receive state. */\n+    void SetReceiveState(RecvState recv_state) noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Change the send state. */\n+    void SetSendState(SendState send_state) noexcept EXCLUSIVE_LOCKS_REQUIRED(m_send_mutex);\n+    /** Given a packet's contents, find the message type (if valid), and strip it from contents. */\n+    static std::optional<std::string> GetMessageType(Span<const uint8_t>& contents) noexcept;\n+    /** Determine how many received bytes can be processed in one go (not allowed in V1 state). */\n+    size_t GetMaxBytesToProcess() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in KEY state. */\n+    void ProcessReceivedKey() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in GARB_GARBTERM state. */\n+    bool ProcessReceivedGarbage() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in GARBAUTH/VERSION/APP state. */\n+    bool ProcessReceivedPacket() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+    /** Construct a V2 transport with securely generated random keys. */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept;",
      "path": "src/net.h",
      "position": 299,
      "original_position": 187,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff: Maybe repeat here, in the public interface, that `initiating` means `Whether we are the initiator side.`.\r\n\r\nI'm a bit confused about the other two arguments. These refer to our internal `DataStream` types and versions? Not something related to the v2 protocol?",
      "created_at": "2023-09-01T18:10:36Z",
      "updated_at": "2023-09-01T19:06:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313367688",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313367688"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 636,
      "original_line": 636,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313369431",
      "pull_request_review_id": 1607368990,
      "id": 1313369431,
      "node_id": "PRRC_kwDOABII585OSG1X",
      "diff_hunk": "@@ -320,6 +335,43 @@ std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n     return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n }\n \n+template<typename RNG>\n+std::unique_ptr<Transport> MakeV2Transport(NodeId nodeid, bool initiator, RNG& rng, FuzzedDataProvider& provider)\n+{\n+    // Retrieve key\n+    auto key_data = provider.ConsumeBytes<unsigned char>(32);\n+    key_data.resize(32);\n+    CKey key;\n+    key.Set(key_data.begin(), key_data.end(), true);\n+    if (!key.IsValid()) return {};\n+    // Construct garbage\n+    size_t garb_len = provider.ConsumeIntegralInRange<size_t>(0, 4095);\n+    std::vector<uint8_t> garb;\n+    if (garb_len <= 64) {\n+        // When the garbage length is up to 64 bytes, read it directly from the fuzzer input.\n+        garb = provider.ConsumeBytes<uint8_t>(garb_len);\n+        garb.resize(garb_len);\n+    } else {\n+        // If it's longer, generate it from the RNG. This avoids having large amounts of\n+        // (hopefully) irrelevant data needing to be stored in the fuzzer data.\n+        for (auto& v : garb) v = uint8_t(rng());\n+    }\n+    // Retrieve entropy\n+    auto ent = provider.ConsumeBytes<std::byte>(32);\n+    ent.resize(32);\n+    // Use as entropy SHA256(ent || garbage). This prevents a situation where the fuzzer manages to\n+    // include the garbage terminator (which is a function of both ellswift keys) in the garbage.\n+    // This is entremely unlikely (~2^-116) with random keys/garbage, but the fuzzer can choose",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 123,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313198040,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-09-01T18:12:54Z",
      "updated_at": "2023-09-01T19:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313369431",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313369431"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 364,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313369484",
      "pull_request_review_id": 1607368990,
      "id": 1313369484,
      "node_id": "PRRC_kwDOABII585OSG2M",
      "diff_hunk": "@@ -320,6 +335,43 @@ std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n     return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n }\n \n+template<typename RNG>\n+std::unique_ptr<Transport> MakeV2Transport(NodeId nodeid, bool initiator, RNG& rng, FuzzedDataProvider& provider)\n+{\n+    // Retrieve key\n+    auto key_data = provider.ConsumeBytes<unsigned char>(32);\n+    key_data.resize(32);\n+    CKey key;\n+    key.Set(key_data.begin(), key_data.end(), true);\n+    if (!key.IsValid()) return {};\n+    // Construct garbage\n+    size_t garb_len = provider.ConsumeIntegralInRange<size_t>(0, 4095);",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 107,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313194800,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-09-01T18:12:59Z",
      "updated_at": "2023-09-01T19:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313369484",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313369484"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 348,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313370086",
      "pull_request_review_id": 1607368990,
      "id": 1313370086,
      "node_id": "PRRC_kwDOABII585OSG_m",
      "diff_hunk": "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::KEY_GARB);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 269,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313037669,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-09-01T18:13:46Z",
      "updated_at": "2023-09-01T19:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313370086",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313370086"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1152,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313380691",
      "pull_request_review_id": 1602833673,
      "id": 1313380691,
      "node_id": "PRRC_kwDOABII585OSJlT",
      "diff_hunk": "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,",
      "path": "src/net.h",
      "position": null,
      "original_position": 25,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff: `stipulates that senders should leave this empty, and receivers should ignore it`.",
      "created_at": "2023-09-01T18:27:57Z",
      "updated_at": "2023-09-01T19:06:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313380691",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313380691"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 425,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313385211",
      "pull_request_review_id": 1607368990,
      "id": 1313385211,
      "node_id": "PRRC_kwDOABII585OSKr7",
      "diff_hunk": "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());",
      "path": "src/test/net_tests.cpp",
      "position": null,
      "original_position": 282,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313242620,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed (in the code; I've left them in the comments as I think making the actual values known is also useful for the reader).",
      "created_at": "2023-09-01T18:34:25Z",
      "updated_at": "2023-09-01T19:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313385211",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313385211"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1265,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313408730",
      "pull_request_review_id": 1602833673,
      "id": 1313408730,
      "node_id": "PRRC_kwDOABII585OSQba",
      "diff_hunk": "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                       /----------\\\n+     *     |                                         |          |\n+     *     v                                         v          |\n+     *    KEY -> KEY_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     */\n+    enum class SendState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state. The public key is sent out. When the receiver\n+         * receives the other side's public key and transitions to GARB_GARBTERM, the sender state\n+         * becomes KEY_GARBTERM_GARBAUTH_VERSION. The key is left in the send buffer when this\n+         * happens, because it may not have been fully sent out yet. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 107,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff: why not remain in the `KEY` state until we've completely sent out the public key? And only then transition to `GARBTERM_GARBAUTH_VERSION`?",
      "created_at": "2023-09-01T19:02:32Z",
      "updated_at": "2023-09-01T19:06:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313408730",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313408730"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 507,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313431150",
      "pull_request_review_id": 1607368990,
      "id": 1313431150,
      "node_id": "PRRC_kwDOABII585OSV5u",
      "diff_hunk": "@@ -973,11 +987,44 @@ size_t V2Transport::GetMaxBytesToProcess() noexcept\n     case RecvState::APP_READY:\n         // No bytes can be processed until GetMessage() is called.\n         return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n     }\n     assert(false); // unreachable\n     return 0;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        m_recv_state = RecvState::KEY; // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY state (if not already).\n+        LOCK(m_send_mutex);\n+        assert(m_send_state == SendState::KEY_MAYBE_V1 || m_send_state == SendState::KEY);\n+        m_send_state = SendState::KEY;\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 93,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "faf5af3f6b96488ebf9585c1558710545cde05a6",
      "in_reply_to_id": 1310367236,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed (you're not the first one to notice).",
      "created_at": "2023-09-01T19:30:27Z",
      "updated_at": "2023-09-01T19:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313431150",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313431150"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1152,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313432012",
      "pull_request_review_id": 1607368990,
      "id": 1313432012,
      "node_id": "PRRC_kwDOABII585OSWHM",
      "diff_hunk": "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                       /----------\\\n+     *     |                                         |          |\n+     *     v                                         v          |\n+     *    KEY -> KEY_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     */\n+    enum class SendState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state. The public key is sent out. When the receiver\n+         * receives the other side's public key and transitions to GARB_GARBTERM, the sender state\n+         * becomes KEY_GARBTERM_GARBAUTH_VERSION. The key is left in the send buffer when this\n+         * happens, because it may not have been fully sent out yet. */\n+        KEY,\n+\n+        /** Public key + garbage terminator + garbage authenticator + version packet.\n+         *\n+         * This is the state the sender is in after the other side's public key has been received.\n+         * Whatever remains of the public key is sent, plus garbage terminator, authentication\n+         * packet, and version packet. When all of that is sent, the sender state becomes\n+         * APP_READY. */\n+        KEY_GARBTERM_GARBAUTH_VERSION,\n+\n+        /** Nothing (an application message to send can be provided).\n+         *\n+         * We're ready to start sending an application message at this point, but none are\n+         * currently provided. Upon SetMessageToSend() the sender state becomes APP. */\n+        APP_READY,\n+\n+        /** Application packet.\n+         *\n+         * There is an encrypted packet encoding an application message in the send buffer right now.\n+         * When it is fully sent, the sender state becomes APP_READY. */\n+        APP,\n+    };\n+\n+    /** Cipher state. */\n+    BIP324Cipher m_cipher;\n+    /** Whether we are the initiator side. */\n+    const bool m_initiating;\n+    /** NodeId (for debug logging). */\n+    const NodeId m_nodeid;\n+\n+    /** Lock for receiver-side fields. */\n+    mutable Mutex m_recv_mutex ACQUIRED_BEFORE(m_send_mutex);\n+    /** In {GARBAUTH, VERSION, APP}, the decrypted packet length, if m_recv_buffer.size() >=\n+     *  BIP324Cipher::LENGTH_LEN. Unspecified otherwise. */\n+    uint32_t m_recv_len GUARDED_BY(m_recv_mutex) {0};\n+    /** Receive buffer; meaning is determined by m_recv_state. */\n+    std::vector<uint8_t> m_recv_buffer GUARDED_BY(m_recv_mutex);\n+    /** During GARBAUTH, the garbage received during GARB_GARBTERM. */\n+    std::vector<uint8_t> m_recv_garbage GUARDED_BY(m_recv_mutex);\n+    /** Buffer to put decrypted contents in, for converting to CNetMessage. */\n+    std::vector<uint8_t> m_recv_decode_buffer GUARDED_BY(m_recv_mutex);\n+    /** Deserialization type. */\n+    const int m_recv_type;\n+    /** Deserialization version number. */\n+    const int m_recv_version;\n+    /** Current receiver state. */\n+    RecvState m_recv_state GUARDED_BY(m_recv_mutex);\n+\n+    /** Lock for sending-side fields. If both sending and receiving fields are accessed,\n+     *  m_recv_mutex must be acquired before m_send_mutex. */\n+    mutable Mutex m_send_mutex ACQUIRED_AFTER(m_recv_mutex);\n+    /** The send buffer; meaning is determined by m_send_state. */\n+    std::vector<uint8_t> m_send_buffer GUARDED_BY(m_send_mutex);\n+    /** How many bytes from the send buffer have been sent so far. */\n+    uint32_t m_send_pos GUARDED_BY(m_send_mutex) {0};\n+    /** Type of the message being sent. */\n+    std::string m_send_type GUARDED_BY(m_send_mutex);\n+    /** Current sender state. */\n+    SendState m_send_state GUARDED_BY(m_send_mutex);\n+\n+    /** Change the receive state. */\n+    void SetReceiveState(RecvState recv_state) noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Change the send state. */\n+    void SetSendState(SendState send_state) noexcept EXCLUSIVE_LOCKS_REQUIRED(m_send_mutex);\n+    /** Given a packet's contents, find the message type (if valid), and strip it from contents. */\n+    static std::optional<std::string> GetMessageType(Span<const uint8_t>& contents) noexcept;\n+    /** Determine how many received bytes can be processed in one go (not allowed in V1 state). */\n+    size_t GetMaxBytesToProcess() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in KEY state. */\n+    void ProcessReceivedKey() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex, !m_send_mutex);\n+    /** Process m_recv_buffer in GARB_GARBTERM state. */\n+    bool ProcessReceivedGarbage() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+    /** Process m_recv_buffer in GARBAUTH/VERSION/APP state. */\n+    bool ProcessReceivedPacket() noexcept EXCLUSIVE_LOCKS_REQUIRED(m_recv_mutex);\n+\n+public:\n+    static constexpr uint32_t MAX_GARBAGE_LEN = 4095;\n+\n+    /** Construct a V2 transport with securely generated random keys. */\n+    V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept;",
      "path": "src/net.h",
      "position": 299,
      "original_position": 187,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "in_reply_to_id": 1313367688,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added doxygen comments about the parameters.\r\n\r\nThe type/version thing will hopefully go away everywhere soon (see #25284).",
      "created_at": "2023-09-01T19:31:15Z",
      "updated_at": "2023-09-01T19:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313432012",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313432012"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 636,
      "original_line": 636,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313437343",
      "pull_request_review_id": 1607368990,
      "id": 1313437343,
      "node_id": "PRRC_kwDOABII585OSXaf",
      "diff_hunk": "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,",
      "path": "src/net.h",
      "position": null,
      "original_position": 25,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "in_reply_to_id": 1313380691,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done; that's more concise.",
      "created_at": "2023-09-01T19:36:39Z",
      "updated_at": "2023-09-01T19:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313437343",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313437343"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 425,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313439087",
      "pull_request_review_id": 1607368990,
      "id": 1313439087,
      "node_id": "PRRC_kwDOABII585OSX1v",
      "diff_hunk": "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                       /----------\\\n+     *     |                                         |          |\n+     *     v                                         v          |\n+     *    KEY -> KEY_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     */\n+    enum class SendState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state. The public key is sent out. When the receiver\n+         * receives the other side's public key and transitions to GARB_GARBTERM, the sender state\n+         * becomes KEY_GARBTERM_GARBAUTH_VERSION. The key is left in the send buffer when this\n+         * happens, because it may not have been fully sent out yet. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 107,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "in_reply_to_id": 1313408730,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There's nothing wrong with that approach, but it's a bit more complex I think. Because it'd mean the transition can happen under two possible events (the last bytes of the peer's key are received while our key is sent already, and the last bytes of our key get sent while all bytes of the peer's key are received already).",
      "created_at": "2023-09-01T19:38:26Z",
      "updated_at": "2023-09-01T19:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313439087",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313439087"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 507,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313441493",
      "pull_request_review_id": 1607368990,
      "id": 1313441493,
      "node_id": "PRRC_kwDOABII585OSYbV",
      "diff_hunk": "@@ -973,11 +987,44 @@ size_t V2Transport::GetMaxBytesToProcess() noexcept\n     case RecvState::APP_READY:\n         // No bytes can be processed until GetMessage() is called.\n         return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n     }\n     assert(false); // unreachable\n     return 0;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.",
      "path": "src/net.cpp",
      "position": 204,
      "original_position": 86,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "faf5af3f6b96488ebf9585c1558710545cde05a6",
      "in_reply_to_id": 1310362246,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've toyed with this idea already actually, and think it's quite doable. We could instead of just looking at the first 12 bytes, wait until we have the first 16, and if the 12 bytes after the first 4 match \"version\\x00\\x00\\x00\\x00\\x00\" but the magic doesn't match, disconnect instead of treating it as V2.\r\n\r\nI don't think it's strictly needed, as the 64+ bytes sent by the initiator should cause instant disconnection anyway by any v1 receiver, even ones of the wrong network.\r\n\r\nWDYT? This PR, or for a follow-up?",
      "created_at": "2023-09-01T19:40:46Z",
      "updated_at": "2023-09-01T19:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313441493",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313441493"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1088,
      "original_line": 1088,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313444923",
      "pull_request_review_id": 1607368990,
      "id": 1313444923,
      "node_id": "PRRC_kwDOABII585OSZQ7",
      "diff_hunk": "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 13);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.SendKey();\n+        tester.SendGarbage();\n+        tester.ReceiveKey();\n+        tester.SendGarbageTermAuth();\n+        tester.SendVersion();\n+        ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.ReceiveGarbage();\n+        tester.ReceiveVersion();\n+        auto msg_data_1 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(100000));",
      "path": "src/test/net_tests.cpp",
      "position": 343,
      "original_position": 326,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313245167,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The test RNG seed is printed out, and can be provided back using the `RANDOM_CTX_SEED` env variable. The ellswift keys used in the unit test come from the high-quality RNG and not the test RNG though, but I don't expect those to actually influence the kind of failures this type of test would trigger.",
      "created_at": "2023-09-01T19:44:17Z",
      "updated_at": "2023-09-01T19:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313444923",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313444923"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1340,
      "original_line": 1340,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313449447",
      "pull_request_review_id": 1607368990,
      "id": 1313449447,
      "node_id": "PRRC_kwDOABII585OSaXn",
      "diff_hunk": "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY_GARB_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case SendState::KEY_GARB:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    case SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION:\n+        assert(m_send_state == SendState::KEY_GARB);\n+        break;\n+    case SendState::APP_READY:\n+        assert(m_send_state == SendState::KEY_GARB_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        assert(m_send_state == SendState::APP_READY);\n+        break;\n+    case SendState::V1:\n+        assert(m_send_state == SendState::KEY_GARB_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n+    }\n+    assert(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to KEY_GARB state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::KEY_GARB);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v2 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback); // Feed already received bytes to v1 transport.\n+        assert(feedback.empty());\n+        assert(ret);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 274,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313079175,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Maybe construct feedback from m_v1_prefix which has been constructed by us? I know they are equal, but still...\r\n\r\nI think that's overkill. I've added some comments explaining why the v1 fallback should always accept this prefix.\r\n\r\n> ... concerns elsewhere about asserts in the networking code ...\r\n\r\nI have changed all the `assert`s to `Assume`s. I didn't do so initially, because I wasn't aware that `Assume`s are treated like assertions in fuzz tests, and wanted to make sure the fuzz tests actually had a chance of triggering them. As that doesn't seem to be the case, there is little reason to keep asserts.\r\n\r\nI've also gone over the code added in this PR, trying to find possible places where actually dangerous (e.g. out of bounds access) behavior is guarded by assertions (as those are worthwhile to keep as assertions in production, crashing is better than possibly remotely-triggerable OOB-based UB), but I can't actually find any. Nearly code I can find that accesses buffers is in conditional branches that test actually the right buffer sizes beforehand.\r\n\r\nChanging some/all of them to instead disconnect would require a bunch of code changes, and because of the above, I don't think it's worth it. Keeping a connection open in a weird state, where it'll very likely not do anything and time out isn't all that bad compared to disconnecting in case of a bug (and may actually be easier to notice).",
      "created_at": "2023-09-01T19:48:52Z",
      "updated_at": "2023-09-01T19:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313449447",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313449447"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1155,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1157,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313686515",
      "pull_request_review_id": 1607831626,
      "id": 1313686515,
      "node_id": "PRRC_kwDOABII585OTUPz",
      "diff_hunk": "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(m_send_state == SendState::KEY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(m_send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(m_send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 135,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: as `m_recv_buffer` has exactly the size of an ellswift pubkey at this point (ensured by the if a few lines above), the `.first` call isn't needed:\r\n```suggestion\r\n        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\r\n```\r\n",
      "created_at": "2023-09-02T02:05:55Z",
      "updated_at": "2023-09-02T02:41:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313686515",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313686515"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1046,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313686655",
      "pull_request_review_id": 1607831626,
      "id": 1313686655,
      "node_id": "PRRC_kwDOABII585OTUR_",
      "diff_hunk": "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(m_send_state == SendState::KEY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(m_send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(m_send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));",
      "path": "src/net.cpp",
      "position": 362,
      "original_position": 225,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "~nit:~\r\n```suggestion\r\n        RandAddEvent(ReadLE32(m_recv_buffer.end() - 4));\r\n```\r\n(EDIT: oh nevermind, end() returns an iterator, not a pointer, so this won't work.)",
      "created_at": "2023-09-02T02:06:48Z",
      "updated_at": "2023-09-02T03:02:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313686655",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313686655"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1246,
      "original_line": 1246,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313692208",
      "pull_request_review_id": 1607831626,
      "id": 1313692208,
      "node_id": "PRRC_kwDOABII585OTVow",
      "diff_hunk": "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(m_send_state == SendState::KEY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(m_send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(m_send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            SetReceiveState(RecvState::VERSION);\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                SetReceiveState(RecvState::APP);\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                SetReceiveState(RecvState::APP_READY);\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            Assume(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Can't read more than provided input.\n+        max_read = std::min(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+    contents = contents.subspan(1); // Strip first byte.\n+\n+    if (first_byte != 0) return std::nullopt; // TODO: implement short encoding\n+\n+    if (contents.size() < CMessageHeader::COMMAND_SIZE) {\n+        return std::nullopt; // Long encoding needs 12 message type bytes.\n+    }\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE && contents[msg_type_len] != 0) {\n+        // Verify that message type bytes before the first 0x00 are in range.\n+        if (contents[msg_type_len] < ' ' || contents[msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data()), msg_type_len};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE) {\n+        // Verify that message type bytes after the first 0x00 are also 0x00.\n+        if (contents[msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    // Strip message type bytes of contents.\n+    contents = contents.subspan(CMessageHeader::COMMAND_SIZE);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;",
      "path": "src/net.cpp",
      "position": 595,
      "original_position": 338,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should the size of the 3-byte length descriptor also be added here? (at least that would come close to what happens for v1, where HEADER_SIZE is accounted for).",
      "created_at": "2023-09-02T02:19:55Z",
      "updated_at": "2023-09-02T02:41:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313692208",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313692208"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1479,
      "original_line": 1479,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313692979",
      "pull_request_review_id": 1607831626,
      "id": 1313692979,
      "node_id": "PRRC_kwDOABII585OTV0z",
      "diff_hunk": "@@ -417,6 +419,194 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 that senders should leave this empty, and",
      "path": "src/net.h",
      "position": null,
      "original_position": 25,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "missing verb after \"BIP324\":\r\n```suggestion\r\n    /** Contents of the version packet to send. BIP324 stipulates that senders should leave this empty, and\r\n```",
      "created_at": "2023-09-02T02:24:59Z",
      "updated_at": "2023-09-02T02:41:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313692979",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313692979"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 425,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313695214",
      "pull_request_review_id": 1607831626,
      "id": 1313695214,
      "node_id": "PRRC_kwDOABII585OTWXu",
      "diff_hunk": "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 63,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: in `Set{Send,Receive}State`, at least for my brain the state transition checks would be slightly easier to grasp if the current state is switch/case-d and the allowed next state(s) are `Assume`d (i.e. asserting \"where can I go to?\" rather than \"where could I have come from?\").",
      "created_at": "2023-09-02T02:31:56Z",
      "updated_at": "2023-09-02T02:41:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313695214",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313695214"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 973,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 974,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708390",
      "pull_request_review_id": 1607869598,
      "id": 1313708390,
      "node_id": "PRRC_kwDOABII585OTZlm",
      "diff_hunk": "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(m_send_state == SendState::KEY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(m_send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(m_send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 135,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "in_reply_to_id": 1313686515,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nice, done.",
      "created_at": "2023-09-02T03:39:01Z",
      "updated_at": "2023-09-02T03:39:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313708390",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708390"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1046,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708398",
      "pull_request_review_id": 1607869614,
      "id": 1313708398,
      "node_id": "PRRC_kwDOABII585OTZlu",
      "diff_hunk": "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(m_send_state == SendState::KEY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(m_send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(m_send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));",
      "path": "src/net.cpp",
      "position": 362,
      "original_position": 225,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "in_reply_to_id": 1313686655,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sadly, indeed.",
      "created_at": "2023-09-02T03:39:10Z",
      "updated_at": "2023-09-02T03:39:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313708398",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708398"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1246,
      "original_line": 1246,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708417",
      "pull_request_review_id": 1607869649,
      "id": 1313708417,
      "node_id": "PRRC_kwDOABII585OTZmB",
      "diff_hunk": "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {\n+    case SendState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(m_send_state == SendState::KEY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(m_send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION ||\n+               m_send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(m_send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer).first(EllSwiftPubKey::size()));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            SetReceiveState(RecvState::VERSION);\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                SetReceiveState(RecvState::APP);\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                SetReceiveState(RecvState::APP_READY);\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            Assume(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Can't read more than provided input.\n+        max_read = std::min(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+    contents = contents.subspan(1); // Strip first byte.\n+\n+    if (first_byte != 0) return std::nullopt; // TODO: implement short encoding\n+\n+    if (contents.size() < CMessageHeader::COMMAND_SIZE) {\n+        return std::nullopt; // Long encoding needs 12 message type bytes.\n+    }\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE && contents[msg_type_len] != 0) {\n+        // Verify that message type bytes before the first 0x00 are in range.\n+        if (contents[msg_type_len] < ' ' || contents[msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data()), msg_type_len};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE) {\n+        // Verify that message type bytes after the first 0x00 are also 0x00.\n+        if (contents[msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    // Strip message type bytes of contents.\n+    contents = contents.subspan(CMessageHeader::COMMAND_SIZE);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;",
      "path": "src/net.cpp",
      "position": 595,
      "original_position": 338,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "in_reply_to_id": 1313692208,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's included in EXPANSION. I've added a comment to clarify that.",
      "created_at": "2023-09-02T03:39:30Z",
      "updated_at": "2023-09-02T03:39:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313708417",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1479,
      "original_line": 1479,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708498",
      "pull_request_review_id": 1607869703,
      "id": 1313708498,
      "node_id": "PRRC_kwDOABII585OTZnS",
      "diff_hunk": "@@ -417,6 +419,194 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 that senders should leave this empty, and",
      "path": "src/net.h",
      "position": null,
      "original_position": 25,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "in_reply_to_id": 1313692979,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-09-02T03:39:39Z",
      "updated_at": "2023-09-02T03:39:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313708498",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708498"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 425,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708718",
      "pull_request_review_id": 1607870108,
      "id": 1313708718,
      "node_id": "PRRC_kwDOABII585OTZqu",
      "diff_hunk": "@@ -912,6 +912,420 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY:\n+        // Initial state, cannot be transitioned into.\n+        Assume(false);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(m_recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (send_state) {",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 63,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "ab9d292e3fa61824870bfcd31b0fb6f649eafa2d",
      "in_reply_to_id": 1313695214,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agreed, changed. It's also a bit simpler now actually.",
      "created_at": "2023-09-02T03:40:26Z",
      "updated_at": "2023-09-02T03:40:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1313708718",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1313708718"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 973,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 974,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315025895",
      "pull_request_review_id": 1609674963,
      "id": 1315025895,
      "node_id": "PRRC_kwDOABII585OYbPn",
      "diff_hunk": "@@ -973,11 +987,44 @@ size_t V2Transport::GetMaxBytesToProcess() noexcept\n     case RecvState::APP_READY:\n         // No bytes can be processed until GetMessage() is called.\n         return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n     }\n     assert(false); // unreachable\n     return 0;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.",
      "path": "src/net.cpp",
      "position": 204,
      "original_position": 86,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "faf5af3f6b96488ebf9585c1558710545cde05a6",
      "in_reply_to_id": 1310362246,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No strong preference here, but I imagine it's useful early on for debugging to tell the difference between a truly failed v2 connection and some other network failing to make a v1 connection. Though I have no idea how often the latter actually happens these days.",
      "created_at": "2023-09-04T14:43:12Z",
      "updated_at": "2023-09-04T14:43:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315025895",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315025895"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1088,
      "original_line": 1088,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315028241",
      "pull_request_review_id": 1609678498,
      "id": 1315028241,
      "node_id": "PRRC_kwDOABII585OYb0R",
      "diff_hunk": "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 13);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.SendKey();\n+        tester.SendGarbage();\n+        tester.ReceiveKey();\n+        tester.SendGarbageTermAuth();\n+        tester.SendVersion();\n+        ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.ReceiveGarbage();\n+        tester.ReceiveVersion();\n+        auto msg_data_1 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(100000));",
      "path": "src/test/net_tests.cpp",
      "position": 343,
      "original_position": 326,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313245167,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right, I see now. To print the seed one has to use `-printtoconsole=1`:\r\n\r\n```sh\r\n$ ./src/test/test_bitcoin --run_test=net_tests/v2transport_test -- -printtoconsole=1\r\nRunning 1 test case...\r\n2023-09-04T13:44:27Z Seed: Setting random seed for current tests to RANDOM_CTX_SEED=e99d422b1c8107ef36cbf5bdb18326ebfbe0e3d311d31f0b5a74fb50ada6d18e\r\n...\r\n```\r\n\r\n`-printtoconsole=1` seems to not be used on CI: https://cirrus-ci.com/task/5714938337951744?logs=ci#L3390\r\n\r\nWhat about non-deterministic failure that happens on CI?",
      "created_at": "2023-09-04T14:45:40Z",
      "updated_at": "2023-09-04T14:45:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315028241",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315028241"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1340,
      "original_line": 1340,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315042194",
      "pull_request_review_id": 1609699967,
      "id": 1315042194,
      "node_id": "PRRC_kwDOABII585OYfOS",
      "diff_hunk": "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                       /----------\\\n+     *     |                                         |          |\n+     *     v                                         v          |\n+     *    KEY -> KEY_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     */\n+    enum class SendState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state. The public key is sent out. When the receiver\n+         * receives the other side's public key and transitions to GARB_GARBTERM, the sender state\n+         * becomes KEY_GARBTERM_GARBAUTH_VERSION. The key is left in the send buffer when this\n+         * happens, because it may not have been fully sent out yet. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 107,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "in_reply_to_id": 1313408730,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I found the description quite hard to understand. Conceptually it seems easier to understand \"We sent our key AND we have their key\", i.e. it's waiting for both to finish.\r\n\r\nThough I might be understanding that wrong, given https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1703257925",
      "created_at": "2023-09-04T15:00:54Z",
      "updated_at": "2023-09-04T15:03:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315042194",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315042194"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 507,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315093860",
      "pull_request_review_id": 1609785559,
      "id": 1315093860,
      "node_id": "PRRC_kwDOABII585OYr1k",
      "diff_hunk": "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                       /----------\\\n+     *     |                                         |          |\n+     *     v                                         v          |\n+     *    KEY -> KEY_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     */\n+    enum class SendState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state. The public key is sent out. When the receiver\n+         * receives the other side's public key and transitions to GARB_GARBTERM, the sender state\n+         * becomes KEY_GARBTERM_GARBAUTH_VERSION. The key is left in the send buffer when this\n+         * happens, because it may not have been fully sent out yet. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 107,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "in_reply_to_id": 1313408730,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@Sjors I've coded it up (removing the key and garbage from the send buffer after sending them, so the next state only has garbage terminator, garbage authentication, version): https://github.com/sipa/bitcoin/commits/202309_bip324_split_sendstate. Having done so, the code complexity increase isn't too bad, but there is one significant other downside I had not anticipated: it makes `GetBytesToSend` and `MarkBytesSent` additionally grab the receive lock (instead of just the send lock). On that basis alone, I think the current approach is better.\r\n\r\n> Though I might be understanding that wrong, given https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1703257925\r\n\r\nPerhaps the difficulty lies here: the *garbage* is sent before the other side's key is received, but the garbage *terminator* (and authentication) are only sent afterwards. At the time the garbage is sent (after sending our key, but potentially before receiving the other side's key), the encryption ciphers are not initialized yet, and thus a decoy packet can't be sent yet.",
      "created_at": "2023-09-04T16:10:30Z",
      "updated_at": "2023-09-04T16:40:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315093860",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315093860"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 507,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315101015",
      "pull_request_review_id": 1609799789,
      "id": 1315101015,
      "node_id": "PRRC_kwDOABII585OYtlX",
      "diff_hunk": "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 13);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.SendKey();\n+        tester.SendGarbage();\n+        tester.ReceiveKey();\n+        tester.SendGarbageTermAuth();\n+        tester.SendVersion();\n+        ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.ReceiveGarbage();\n+        tester.ReceiveVersion();\n+        auto msg_data_1 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(100000));",
      "path": "src/test/net_tests.cpp",
      "position": 343,
      "original_position": 326,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313245167,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@vasild Heh, that sounds like a problem we may want to fix in general outside this PR.",
      "created_at": "2023-09-04T16:19:19Z",
      "updated_at": "2023-09-04T16:19:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315101015",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315101015"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1340,
      "original_line": 1340,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315134809",
      "pull_request_review_id": 1609851973,
      "id": 1315134809,
      "node_id": "PRRC_kwDOABII585OY11Z",
      "diff_hunk": "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                       /----------\\\n+     *     |                                         |          |\n+     *     v                                         v          |\n+     *    KEY -> KEY_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     */\n+    enum class SendState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state. The public key is sent out. When the receiver\n+         * receives the other side's public key and transitions to GARB_GARBTERM, the sender state\n+         * becomes KEY_GARBTERM_GARBAUTH_VERSION. The key is left in the send buffer when this\n+         * happens, because it may not have been fully sent out yet. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 107,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "in_reply_to_id": 1313408730,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Perhaps a more natural border would be `KEY_GARB` -> `GARBTERM_GARBAUTH_VERSION` then? But that sounds like what you implemented in the branch. Maybe just leave it as is, I might revisit this after I've looked at more of the code.",
      "created_at": "2023-09-04T17:30:04Z",
      "updated_at": "2023-09-04T17:30:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315134809",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315134809"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 507,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315146744",
      "pull_request_review_id": 1609869928,
      "id": 1315146744,
      "node_id": "PRRC_kwDOABII585OY4v4",
      "diff_hunk": "@@ -308,19 +308,25 @@ class Transport {\n         const std::string& /*m_type*/\n     >;\n \n-    /** Get bytes to send on the wire.\n+    /** Get bytes to send on the wire, if any, along with other information about it.\n      *\n      * As a const function, it does not modify the transport's observable state, and is thus safe\n      * to be called multiple times.\n      *\n-     * The bytes returned by this function act as a stream which can only be appended to. This\n-     * means that with the exception of MarkBytesSent, operations on the transport can only append\n-     * to what is being returned.\n+     * @param[in] have_next_message controls whether the \"more\" return value indicates more bytes\n+     *            to be sent before (have_next_message=false) or after (have_next_message=true) a\n+     *            potential SetMessageToSend immediately afterwards. It is set by the caller when\n+     *            they know they have another message ready to send. The have_next_message\n+     *            argument only affects this \"more\" return value and nothing else.",
      "path": "src/net.h",
      "position": null,
      "original_position": 17,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "d67be9ad3836bd19cc8ea71a0b99c7d60682dd32",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "d67be9ad3836bd19cc8ea71a0b99c7d60682dd32: alternative explanation, which I think is more clear (but perhaps wrong):\r\n\r\n> have_next_message: the caller knows it has another message ready to send. The have_next_message argument (only) affects the \"more\" return value, which is used to set the `MSG_MORE` TCP flag and to trigger optimistic send. With v2 transport more can be false even if vSendMsg has more messages left. This happens before the handshake is complete.\r\n\r\nI found this part confusing: \"indicates more bytes to be sent before (have_next_message=false) or after (have_next_message=true) a potential SetMessageToSend immediately afterwards\"",
      "created_at": "2023-09-04T18:04:59Z",
      "updated_at": "2023-09-04T18:41:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315146744",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315146744"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 320,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315149774",
      "pull_request_review_id": 1609869928,
      "id": 1315149774,
      "node_id": "PRRC_kwDOABII585OY5fO",
      "diff_hunk": "@@ -3006,7 +3013,7 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\n+        const auto& [to_send, more, _msg_type] = pnode->m_transport->GetBytesToSend(true);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "d67be9ad3836bd19cc8ea71a0b99c7d60682dd32",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "d67be9ad3836bd19cc8ea71a0b99c7d60682dd32 maybe add a comment:\r\n\r\n```\r\n// Check if the transport still has unsent bytes,\r\n// and indicate to it that we're about to give it a message to send.\r\n```\r\n\r\n`/*have_next_message=*/true`",
      "created_at": "2023-09-04T18:13:56Z",
      "updated_at": "2023-09-04T18:41:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315149774",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315149774"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3609,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315150766",
      "pull_request_review_id": 1609875707,
      "id": 1315150766,
      "node_id": "PRRC_kwDOABII585OY5uu",
      "diff_hunk": "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                       /----------\\\n+     *     |                                         |          |\n+     *     v                                         v          |\n+     *    KEY -> KEY_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     */\n+    enum class SendState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state. The public key is sent out. When the receiver\n+         * receives the other side's public key and transitions to GARB_GARBTERM, the sender state\n+         * becomes KEY_GARBTERM_GARBAUTH_VERSION. The key is left in the send buffer when this\n+         * happens, because it may not have been fully sent out yet. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 107,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "in_reply_to_id": 1313408730,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right, that's exactly what my branch there does: `GARBTERM_GARBAUTH_VERSION` instead of `KEY_GARB_GARBTERM_GARBAUTH_VERSION`. The issue is that to determine if the transition can be made when sending out the last of `KEY_GARB` there we need to check if the other side's key has been received already, necessitating `m_recv_mutex` in `MarkBytesSent` (and in `GetBytesToSend` for the `more` result; the latter being something I only noticed because the fuzz test failed without).",
      "created_at": "2023-09-04T18:16:56Z",
      "updated_at": "2023-09-04T18:16:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315150766",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315150766"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 507,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315151725",
      "pull_request_review_id": 1609869928,
      "id": 1315151725,
      "node_id": "PRRC_kwDOABII585OY59t",
      "diff_hunk": "@@ -3015,10 +3022,11 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         // Move message to vSendMsg queue.\n         pnode->vSendMsg.push_back(std::move(msg));\n \n-        // If there was nothing to send before, attempt \"optimistic write\":\n+        // If there was nothing to send before, and there is now (predicted by the \"more\" value\n+        // returned by the GetBytesToSend call above), attempt \"optimistic write\":\n         // because the poll/select loop may pause for SELECT_TIMEOUT_MILLISECONDS before actually\n         // doing a send, try sending from the calling thread if the queue was empty before.\n-        if (queue_was_empty) {\n+        if (queue_was_empty && more) {",
      "path": "src/net.cpp",
      "position": 770,
      "original_position": 94,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "d67be9ad3836bd19cc8ea71a0b99c7d60682dd32",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "d67be9ad3836bd19cc8ea71a0b99c7d60682dd32: an alternative approach could be to have the v2 transport tell us that it's `blocked` (in the pre-handshake scenario): `&& !blocked`.",
      "created_at": "2023-09-04T18:19:48Z",
      "updated_at": "2023-09-04T18:41:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315151725",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315151725"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3695,
      "original_line": 3695,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315156612",
      "pull_request_review_id": 1609869928,
      "id": 1315156612,
      "node_id": "PRRC_kwDOABII585OY7KE",
      "diff_hunk": "@@ -1322,9 +1328,10 @@ Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\n         {\n             LOCK(pnode->cs_vSend);\n             // Sending is possible if either there are bytes to send right now, or if there will be\n-            // once a potential message from vSendMsg is handed to the transport.\n-            const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\n-            select_send = !to_send.empty() || !pnode->vSendMsg.empty();\n+            // once a potential message from vSendMsg is handed to the transport. GetBytesToSend\n+            // determines both of these in a single call.\n+            const auto& [to_send, more, _msg_type] = pnode->m_transport->GetBytesToSend(!pnode->vSendMsg.empty());\n+            select_send = !to_send.empty() || more;",
      "path": "src/net.cpp",
      "position": 741,
      "original_position": 71,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "d67be9ad3836bd19cc8ea71a0b99c7d60682dd32",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "d67be9ad3836bd19cc8ea71a0b99c7d60682dd32: if we were to switch to an approach of asking if the transport is blocked, this would change to:\r\n\r\n```cpp\r\nselect_send = !to_send.empty() || (!blocked && !pnode->vSendMsg.empty());\r\n```\r\n\r\nNot sure if that's really more clear.",
      "created_at": "2023-09-04T18:35:17Z",
      "updated_at": "2023-09-04T18:41:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315156612",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315156612"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1994,
      "original_line": 1994,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315161425",
      "pull_request_review_id": 1609891391,
      "id": 1315161425,
      "node_id": "PRRC_kwDOABII585OY8VR",
      "diff_hunk": "@@ -3015,10 +3022,11 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         // Move message to vSendMsg queue.\n         pnode->vSendMsg.push_back(std::move(msg));\n \n-        // If there was nothing to send before, attempt \"optimistic write\":\n+        // If there was nothing to send before, and there is now (predicted by the \"more\" value\n+        // returned by the GetBytesToSend call above), attempt \"optimistic write\":\n         // because the poll/select loop may pause for SELECT_TIMEOUT_MILLISECONDS before actually\n         // doing a send, try sending from the calling thread if the queue was empty before.\n-        if (queue_was_empty) {\n+        if (queue_was_empty && more) {",
      "path": "src/net.cpp",
      "position": 770,
      "original_position": 94,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "d67be9ad3836bd19cc8ea71a0b99c7d60682dd32",
      "in_reply_to_id": 1315151725,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "So the alternative I considered here is to make `GetBytesToSend` return a tristate \"more\":\n* definitely: the transport itself has more to send after what it's returning now\n* maybe: the transport has nothing to send after what it's returning now, but will if you give it another message\n* definitely not: nothing can be sent after what it's returning now, even if there were another message.\n\nBut I believe that this does not result in simpler code (neither inside GetBytesToSend, nor in SocketSendBytes).",
      "created_at": "2023-09-04T18:49:58Z",
      "updated_at": "2023-09-04T18:49:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315161425",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315161425"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3695,
      "original_line": 3695,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315179378",
      "pull_request_review_id": 1609918939,
      "id": 1315179378,
      "node_id": "PRRC_kwDOABII585OZAty",
      "diff_hunk": "@@ -1008,4 +1009,498 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would not permit scenarios that involve sending\n+ * invalid data, or ones scenarios using BIP324 features that are not implemented on the sending",
      "path": "src/test/net_tests.cpp",
      "position": 19,
      "original_position": 19,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "typo: either \"ones\" or \"scenarios\"",
      "created_at": "2023-09-04T19:50:01Z",
      "updated_at": "2023-09-07T22:58:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315179378",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315179378"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1016,
      "original_line": 1016,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315181053",
      "pull_request_review_id": 1609921570,
      "id": 1315181053,
      "node_id": "PRRC_kwDOABII585OZBH9",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);",
      "path": "src/net.cpp",
      "position": 232,
      "original_position": 127,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "25b0668c72f762df474c29e678e4baf69cff506c: maybe also `Assume(m_recv_buffer.size() <= EllSwiftPubKey::size())`",
      "created_at": "2023-09-04T19:56:11Z",
      "updated_at": "2023-09-04T20:05:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315181053",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315181053"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1116,
      "original_line": 1116,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315182195",
      "pull_request_review_id": 1609921570,
      "id": 1315182195,
      "node_id": "PRRC_kwDOABII585OZBZz",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 129,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "25b0668c72f762df474c29e678e4baf69cff506c `// , and can now be Diffieâ€“Hellman combined with our key.`",
      "created_at": "2023-09-04T19:59:55Z",
      "updated_at": "2023-09-04T20:05:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315182195",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315182195"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315184166",
      "pull_request_review_id": 1609921570,
      "id": 1315184166,
      "node_id": "PRRC_kwDOABII585OZB4m",
      "diff_hunk": "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                       /----------\\\n+     *     |                                         |          |\n+     *     v                                         v          |\n+     *    KEY -> KEY_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     */\n+    enum class SendState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state. The public key is sent out. When the receiver\n+         * receives the other side's public key and transitions to GARB_GARBTERM, the sender state\n+         * becomes KEY_GARBTERM_GARBAUTH_VERSION. The key is left in the send buffer when this\n+         * happens, because it may not have been fully sent out yet. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 107,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "in_reply_to_id": 1313408730,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I suppose the big conceptual difference between our send and receive state machines is that the latter has a clearly defined moment when the key exchange is complete, i.e. once it received the public key bytes. That's when it performs a Diff-Hellman exchange and sets m_cipher. From the `send` state machine point of view this happens in the background at some unpredictable point. So it does make sense that's represented by a state transition there (to `KEY_GARBTERM_GARBAUTH_VERSION`).",
      "created_at": "2023-09-04T20:05:39Z",
      "updated_at": "2023-09-04T20:11:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315184166",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315184166"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 507,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315187609",
      "pull_request_review_id": 1609931621,
      "id": 1315187609,
      "node_id": "PRRC_kwDOABII585OZCuZ",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());",
      "path": "src/net.cpp",
      "position": 111,
      "original_position": 12,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "25b0668c72f762df474c29e678e4baf69cff506c: is this the right moment to set garbage to send? Since we might receive the other public key any time, at which point the receiver sets the garbage terminator.",
      "created_at": "2023-09-04T20:18:08Z",
      "updated_at": "2023-09-05T14:00:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315187609",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315187609"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 995,
      "original_line": 995,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315188531",
      "pull_request_review_id": 1609931621,
      "id": 1315188531,
      "node_id": "PRRC_kwDOABII585OZC8z",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+",
      "path": "src/net.cpp",
      "position": 263,
      "original_position": 139,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "25b0668c72f762df474c29e678e4baf69cff506c: this is the very last possible moment to insert some more garbage, but it seems better to have done that at initialisation time.",
      "created_at": "2023-09-04T20:21:28Z",
      "updated_at": "2023-09-05T14:00:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315188531",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315188531"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1147,
      "original_line": 1147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315189334",
      "pull_request_review_id": 1609931621,
      "id": 1315189334,
      "node_id": "PRRC_kwDOABII585OZDJW",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);",
      "path": "src/net.cpp",
      "position": 311,
      "original_position": 179,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "25b0668c72f762df474c29e678e4baf69cff506c: could add `fLogIPs` handling, but that can wait for a followup.",
      "created_at": "2023-09-04T20:24:28Z",
      "updated_at": "2023-09-05T14:00:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315189334",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315189334"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1195,
      "original_line": 1195,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315190513",
      "pull_request_review_id": 1609931621,
      "id": 1315190513,
      "node_id": "PRRC_kwDOABII585OZDbx",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 194,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "25b0668c72f762df474c29e678e4baf69cff506c: what does `1` refer to? The short encoding byte?",
      "created_at": "2023-09-04T20:29:09Z",
      "updated_at": "2023-09-05T14:00:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315190513",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315190513"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315191628",
      "pull_request_review_id": 1609931621,
      "id": 1315191628,
      "node_id": "PRRC_kwDOABII585OZDtM",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 105,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "25b0668c72f762df474c29e678e4baf69cff506c\r\n\r\n```cpp\r\n// Process the length descriptor first, so we don't process\r\n// bytes that belong to the next message or a decoy. Then\r\n// process the known-length ciphertext.\r\n```",
      "created_at": "2023-09-04T20:33:03Z",
      "updated_at": "2023-09-05T14:00:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315191628",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315191628"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315194137",
      "pull_request_review_id": 1609931621,
      "id": 1315194137,
      "node_id": "PRRC_kwDOABII585OZEUZ",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            SetReceiveState(RecvState::VERSION);\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                SetReceiveState(RecvState::APP);",
      "path": "src/net.cpp",
      "position": 377,
      "original_position": 237,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "25b0668c72f762df474c29e678e4baf69cff506c: so what happens if we receive a version message with ignore set? We just get stuck? (unless they send it again with ignore unset) Or should we return `false` in that case (resulting in a disconnect)?",
      "created_at": "2023-09-04T20:42:39Z",
      "updated_at": "2023-09-05T14:00:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315194137",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315194137"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1261,
      "original_line": 1261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315218184",
      "pull_request_review_id": 1609979575,
      "id": 1315218184,
      "node_id": "PRRC_kwDOABII585OZKMI",
      "diff_hunk": "@@ -308,19 +308,25 @@ class Transport {\n         const std::string& /*m_type*/\n     >;\n \n-    /** Get bytes to send on the wire.\n+    /** Get bytes to send on the wire, if any, along with other information about it.\n      *\n      * As a const function, it does not modify the transport's observable state, and is thus safe\n      * to be called multiple times.\n      *\n-     * The bytes returned by this function act as a stream which can only be appended to. This\n-     * means that with the exception of MarkBytesSent, operations on the transport can only append\n-     * to what is being returned.\n+     * @param[in] have_next_message controls whether the \"more\" return value indicates more bytes\n+     *            to be sent before (have_next_message=false) or after (have_next_message=true) a\n+     *            potential SetMessageToSend immediately afterwards. It is set by the caller when\n+     *            they know they have another message ready to send. The have_next_message\n+     *            argument only affects this \"more\" return value and nothing else.",
      "path": "src/net.h",
      "position": null,
      "original_position": 17,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "d67be9ad3836bd19cc8ea71a0b99c7d60682dd32",
      "in_reply_to_id": 1315146744,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've rephrased things a bit, but I don't like documenting what the caller will be doing with that value, that's not what the interface cares about.",
      "created_at": "2023-09-04T22:26:35Z",
      "updated_at": "2023-09-04T22:26:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315218184",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315218184"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 320,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315218195",
      "pull_request_review_id": 1609979596,
      "id": 1315218195,
      "node_id": "PRRC_kwDOABII585OZKMT",
      "diff_hunk": "@@ -3006,7 +3013,7 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\n+        const auto& [to_send, more, _msg_type] = pnode->m_transport->GetBytesToSend(true);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "d67be9ad3836bd19cc8ea71a0b99c7d60682dd32",
      "in_reply_to_id": 1315149774,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-09-04T22:26:41Z",
      "updated_at": "2023-09-04T22:26:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315218195",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315218195"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3609,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315218230",
      "pull_request_review_id": 1609979637,
      "id": 1315218230,
      "node_id": "PRRC_kwDOABII585OZKM2",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);",
      "path": "src/net.cpp",
      "position": 232,
      "original_position": 127,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": 1315181053,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sure, done.",
      "created_at": "2023-09-04T22:26:51Z",
      "updated_at": "2023-09-04T22:26:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315218230",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315218230"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1116,
      "original_line": 1116,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315218248",
      "pull_request_review_id": 1609979665,
      "id": 1315218248,
      "node_id": "PRRC_kwDOABII585OZKNI",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 129,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": 1315182195,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-09-04T22:26:56Z",
      "updated_at": "2023-09-04T22:26:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315218248",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315218248"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315543995",
      "pull_request_review_id": 1610488221,
      "id": 1315543995,
      "node_id": "PRRC_kwDOABII585OaZu7",
      "diff_hunk": "@@ -3015,10 +3025,11 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         // Move message to vSendMsg queue.\n         pnode->vSendMsg.push_back(std::move(msg));\n \n-        // If there was nothing to send before, attempt \"optimistic write\":\n+        // If there was nothing to send before, and there is now (predicted by the \"more\" value\n+        // returned by the GetBytesToSend call above), attempt \"optimistic write\":\n         // because the poll/select loop may pause for SELECT_TIMEOUT_MILLISECONDS before actually\n         // doing a send, try sending from the calling thread if the queue was empty before.\n-        if (queue_was_empty) {\n+        if (queue_was_empty && more) {",
      "path": "src/net.cpp",
      "position": 770,
      "original_position": 97,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "c51369a186e563fb83452fed055d9f28775c644d",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c51369a186e563fb83452fed055d9f28775c644d\r\n\r\nIsn't `more` always gonna be true here? At least in this commit :)",
      "created_at": "2023-09-05T08:16:49Z",
      "updated_at": "2023-09-05T09:01:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315543995",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315543995"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3695,
      "original_line": 3695,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315562543",
      "pull_request_review_id": 1610488221,
      "id": 1315562543,
      "node_id": "PRRC_kwDOABII585OaeQv",
      "diff_hunk": "@@ -912,6 +912,406 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::AWAITING_KEY:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+        Assume(false); // Final state\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received, and can now be Diffie-Hellman combined with\n+        // our key to initialize the encryption ciphers.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to READY.\n+        SetSendState(SendState::READY);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;",
      "path": "src/net.cpp",
      "position": 320,
      "original_position": 179,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "5cb433948b050913d22914905c7db510e9ef48d2",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "5cb433948b050913d22914905c7db510e9ef48d2\r\nWhat would `return true` mean here? What if it happens?",
      "created_at": "2023-09-05T08:31:47Z",
      "updated_at": "2023-09-05T09:01:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315562543",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315562543"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1204,
      "original_line": 1204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315580897",
      "pull_request_review_id": 1610488221,
      "id": 1315580897,
      "node_id": "PRRC_kwDOABII585Oaivh",
      "diff_hunk": "@@ -912,6 +912,406 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::AWAITING_KEY:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+        Assume(false); // Final state\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received, and can now be Diffie-Hellman combined with\n+        // our key to initialize the encryption ciphers.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to READY.\n+        SetSendState(SendState::READY);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {",
      "path": "src/net.cpp",
      "position": 344,
      "original_position": 200,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "5cb433948b050913d22914905c7db510e9ef48d2",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "5cb433948b050913d22914905c7db510e9ef48d2\r\n\r\ncould both branches be skipped? What would that indicate then?",
      "created_at": "2023-09-05T08:46:30Z",
      "updated_at": "2023-09-05T09:01:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315580897",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315580897"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1228,
      "original_line": 1228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315599806",
      "pull_request_review_id": 1610488221,
      "id": 1315599806,
      "node_id": "PRRC_kwDOABII585OanW-",
      "diff_hunk": "@@ -417,6 +419,179 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates that senders should leave this\n+     *  empty, and receivers should ignore it. Future extensions can change what is sent as long as\n+     *  an empty version packet contents is interpreted as no extensions supported. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are state machines that are transitioned\n+    // through, based on what has been received. The receive state corresponds to the contents of,\n+    // and bytes received to, the receive buffer. The send state controls what can be appended to\n+    // the send buffer.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage",
      "path": "src/net.h",
      "position": 150,
      "original_position": 55,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "5cb433948b050913d22914905c7db510e9ef48d2",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "5cb433948b050913d22914905c7db510e9ef48d2\r\nShould be extra careful with not keeping 4kb in memory waiting here i guess... After staring at the code for a few minutes I struggle to find this logic :) So perhaps worth adding a comment for it?\r\n\r\nThis question possibly applies to the whole transport thing. Or maybe I'm just confused with how it goes through spans in the first place...",
      "created_at": "2023-09-05T09:01:38Z",
      "updated_at": "2023-09-05T09:01:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315599806",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315599806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 487,
      "original_line": 487,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315778515",
      "pull_request_review_id": 1610862313,
      "id": 1315778515,
      "node_id": "PRRC_kwDOABII585ObS_T",
      "diff_hunk": "@@ -1020,11 +1045,46 @@ size_t V2Transport::GetMaxBytesToProcess() noexcept\n     case RecvState::APP_READY:\n         // No bytes can be processed until GetMessage() is called.\n         return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        Assume(false);\n+        return 0;\n     }\n     Assume(false); // unreachable\n     return 0;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to AWAITING_KEY state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::AWAITING_KEY);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v1 prefix, so fall back to v1 behavior.",
      "path": "src/net.cpp",
      "position": 210,
      "original_position": 125,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "a69b92b7c2faf0f301e88e5c6e9eef8f8dbab24a",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "a69b92b7c2faf0f301e88e5c6e9eef8f8dbab24a\r\n\r\nWhy not handle a partial match too? At least a comment about how it's resolved at the caller site.",
      "created_at": "2023-09-05T11:45:27Z",
      "updated_at": "2023-09-05T12:01:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315778515",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315778515"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1094,
      "original_line": 1094,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315787989",
      "pull_request_review_id": 1610862313,
      "id": 1315787989,
      "node_id": "PRRC_kwDOABII585ObVTV",
      "diff_hunk": "@@ -1296,12 +1296,31 @@ bool V2Transport::ProcessReceivedPacket() noexcept\n bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n {\n     AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 256 * 1024;\n+\n     LOCK(m_recv_mutex);\n     if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n \n     while (!msg_bytes.empty()) {\n         // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n         size_t max_read = GetMaxBytesToProcess();\n+        // Reserve space in the buffer.\n+        if (m_recv_state == RecvState::KEY_MAYBE_V1 || m_recv_state == RecvState::KEY ||",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 14,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "256eb4ba2f6e3827ec5920a5ed4616636fd59310",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "256eb4ba2f6e3827ec5920a5ed4616636fd59310\r\n\r\nnit: switch will look better here i think? And it would also force to do something about the extra state (like in a potential `else` here)",
      "created_at": "2023-09-05T11:54:58Z",
      "updated_at": "2023-09-05T12:01:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315787989",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315787989"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1309,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315790088",
      "pull_request_review_id": 1610880844,
      "id": 1315790088,
      "node_id": "PRRC_kwDOABII585ObV0I",
      "diff_hunk": "@@ -417,6 +419,179 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates that senders should leave this\n+     *  empty, and receivers should ignore it. Future extensions can change what is sent as long as\n+     *  an empty version packet contents is interpreted as no extensions supported. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are state machines that are transitioned\n+    // through, based on what has been received. The receive state corresponds to the contents of,\n+    // and bytes received to, the receive buffer. The send state controls what can be appended to\n+    // the send buffer.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage",
      "path": "src/net.h",
      "position": 150,
      "original_position": 55,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "5cb433948b050913d22914905c7db510e9ef48d2",
      "in_reply_to_id": 1315599806,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Later communication is subject to ping timeout, e.g. if the peer starts sending us a new block, sends 1MB and stops any sends to us, the peer will eventually be disconnected due to ping timeout. I guess this handshake should be subject to the same. Is it? I guess that is in some later PR which will engage the V2 transport.",
      "created_at": "2023-09-05T11:57:02Z",
      "updated_at": "2023-09-05T11:57:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315790088",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315790088"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 487,
      "original_line": 487,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315827259",
      "pull_request_review_id": 1610942780,
      "id": 1315827259,
      "node_id": "PRRC_kwDOABII585Obe47",
      "diff_hunk": "@@ -912,6 +912,406 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::AWAITING_KEY:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+        Assume(false); // Final state\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received, and can now be Diffie-Hellman combined with\n+        // our key to initialize the encryption ciphers.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to READY.\n+        SetSendState(SendState::READY);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;",
      "path": "src/net.cpp",
      "position": 320,
      "original_position": 179,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "5cb433948b050913d22914905c7db510e9ef48d2",
      "in_reply_to_id": 1315562543,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That would mean there is more garbage/garbage terminator to receive still. Perhaps the name of the function is confusing; it doesn't mean all the garbage has been received, it's just processing received garbage bytes.",
      "created_at": "2023-09-05T12:30:38Z",
      "updated_at": "2023-09-05T12:30:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315827259",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315827259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1204,
      "original_line": 1204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315828569",
      "pull_request_review_id": 1610944779,
      "id": 1315828569,
      "node_id": "PRRC_kwDOABII585ObfNZ",
      "diff_hunk": "@@ -912,6 +912,406 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::AWAITING_KEY:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+        Assume(false); // Final state\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received, and can now be Diffie-Hellman combined with\n+        // our key to initialize the encryption ciphers.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to READY.\n+        SetSendState(SendState::READY);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {",
      "path": "src/net.cpp",
      "position": 344,
      "original_position": 200,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "5cb433948b050913d22914905c7db510e9ef48d2",
      "in_reply_to_id": 1315580897,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It would mean the packet is not fully received yet.",
      "created_at": "2023-09-05T12:31:41Z",
      "updated_at": "2023-09-05T12:31:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315828569",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315828569"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1228,
      "original_line": 1228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315834081",
      "pull_request_review_id": 1610953662,
      "id": 1315834081,
      "node_id": "PRRC_kwDOABII585Obgjh",
      "diff_hunk": "@@ -417,6 +419,179 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates that senders should leave this\n+     *  empty, and receivers should ignore it. Future extensions can change what is sent as long as\n+     *  an empty version packet contents is interpreted as no extensions supported. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are state machines that are transitioned\n+    // through, based on what has been received. The receive state corresponds to the contents of,\n+    // and bytes received to, the receive buffer. The send state controls what can be appended to\n+    // the send buffer.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage",
      "path": "src/net.h",
      "position": 150,
      "original_position": 55,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "5cb433948b050913d22914905c7db510e9ef48d2",
      "in_reply_to_id": 1315599806,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Or maybe I'm just confused with how it goes through spans in the first place...\r\n\r\nThe overall logic is that when bytes are received, they are given (as a Span) to `ReceivedBytes`. That function then processes these bytes in a loop, consisting of:\r\n* Calling `GetMaxBytesToProcess`\r\n* Chopping (up to) that number of bytes from the input Span, and concatenating them to `m_recv_buffer`.\r\n* Calling the appropriate function to process whatever is in `m_recv_buffer`, depending on the state:\r\n  * `ProcessReceivedKey` if they are ellswift pubkey bytes\r\n  * `ProcessReceivedGarbage` if they are garbage + garbage terminator\r\n  * `ProcessReceivedPacket` if they are packet bytes (whether from the garbage authentication packet, version packet, or an application packet).\r\n\r\nI'm happy to make any changes to make this clearer. Suggestions:\r\n* Adding the above description as a comment in `ReceivedBytes`\r\n* Inlining `GetMaxBytesToProcess` in `ReceivedBytes`\r\n* Renaming the `ProcessReceived*` functions to `ProcessReceived*Bytes`\r\n* ...\r\n\r\nWhat do you think would help?",
      "created_at": "2023-09-05T12:36:30Z",
      "updated_at": "2023-09-05T12:40:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315834081",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315834081"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 487,
      "original_line": 487,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315835862",
      "pull_request_review_id": 1610956571,
      "id": 1315835862,
      "node_id": "PRRC_kwDOABII585Obg_W",
      "diff_hunk": "@@ -1020,11 +1045,46 @@ size_t V2Transport::GetMaxBytesToProcess() noexcept\n     case RecvState::APP_READY:\n         // No bytes can be processed until GetMessage() is called.\n         return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        Assume(false);\n+        return 0;\n     }\n     Assume(false); // unreachable\n     return 0;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to AWAITING_KEY state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::AWAITING_KEY);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v1 prefix, so fall back to v1 behavior.",
      "path": "src/net.cpp",
      "position": 210,
      "original_position": 125,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "a69b92b7c2faf0f301e88e5c6e9eef8f8dbab24a",
      "in_reply_to_id": 1315778515,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Similar to your other comments on these functions, it means not enough has been received, and it'll be dealt with on a future call to this function, when either there is a full match, or a definite mismatch.",
      "created_at": "2023-09-05T12:37:59Z",
      "updated_at": "2023-09-05T12:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315835862",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315835862"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1094,
      "original_line": 1094,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315903319",
      "pull_request_review_id": 1611066021,
      "id": 1315903319,
      "node_id": "PRRC_kwDOABII585ObxdX",
      "diff_hunk": "@@ -910,24 +912,625 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short messages as defined in BIP324, in order.\n+ *\n+ * Only message types that are actually implemented in this codebase need to be listed, as other\n+ * messages get ignored anyway - whether we know how to decode them or not.\n+ */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::AWAITING_KEY : SendState::MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::AWAITING_KEY : SendState::MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        Assume(recv_state == RecvState::KEY || recv_state == RecvState::V1);\n+        break;\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        Assume(false); // V1 state cannot be left\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::MAYBE_V1:\n+        Assume(send_state == SendState::V1 || send_state == SendState::AWAITING_KEY);\n+        break;\n+    case SendState::AWAITING_KEY:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+    case SendState::V1:\n+        Assume(false); // Final states\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        Assume(false);\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to AWAITING_KEY state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::AWAITING_KEY);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v1 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        // Feed already received bytes to v1 transport. It should always accept these, because it's\n+        // less than the size of a v1 header, and these are the first bytes fed to m_v1_fallback.\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback);\n+        Assume(feedback.empty());\n+        Assume(ret);\n+        SetReceiveState(RecvState::V1);\n+        SetSendState(SendState::V1);\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received, and can now be Diffie-Hellman combined with\n+        // our key to initialize the encryption ciphers.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to READY.\n+        SetSendState(SendState::READY);\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // is still there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            SetReceiveState(RecvState::VERSION);\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                SetReceiveState(RecvState::APP);\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                SetReceiveState(RecvState::APP_READY);\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            Assume(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 256 * 1024;\n+\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Reserve space in the buffer.\n+        if (m_recv_state == RecvState::KEY_MAYBE_V1 || m_recv_state == RecvState::KEY ||\n+            m_recv_state == RecvState::GARB_GARBTERM) {\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        } else if (m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+            m_recv_state == RecvState::APP) {\n+            // During states where a packet is being received, as much as is expected but never\n+            // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+            // This means attackers that want to cause us to waste allocated memory are limited\n+            // to MAX_RESERVE_AHEAD above the largest allowed message contents size, and to\n+            // MAX_RESERVE_AHEAD more than they've actually sent us.\n+            size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+            m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);\n+        }\n+        // Can't read more than provided input.\n+        max_read = std::min(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY_MAYBE_V1:\n+            ProcessReceivedMaybeV1();\n+            if (m_recv_state == RecvState::V1) return true;\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+\n+        case RecvState::V1:\n+            // We should have bailed out before.\n+            Assume(false);\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+    contents = contents.subspan(1); // Strip first byte.\n+\n+    if (first_byte != 0) {\n+        // Short (1 byte) encoding.\n+        if (first_byte < std::size(V2_MESSAGE_IDS)) {\n+            // Valid short message id.\n+            return V2_MESSAGE_IDS[first_byte];\n+        } else {\n+            // Unknown short message id.\n+            return std::nullopt;\n+        }\n+    }\n+\n+    if (contents.size() < CMessageHeader::COMMAND_SIZE) {\n+        return std::nullopt; // Long encoding needs 12 message type bytes.\n+    }\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE && contents[msg_type_len] != 0) {\n+        // Verify that message type bytes before the first 0x00 are in range.\n+        if (contents[msg_type_len] < ' ' || contents[msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data()), msg_type_len};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE) {\n+        // Verify that message type bytes after the first 0x00 are also 0x00.\n+        if (contents[msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    // Strip message type bytes of contents.\n+    contents = contents.subspan(CMessageHeader::COMMAND_SIZE);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetReceivedMessage(time, reject_message);\n+\n+    Assume(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    // Note that BIP324Cipher::EXPANSION also includes the length descriptor size.\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;\n+        msg.m_message_size = contents.size();\n+        msg.m_recv.resize(contents.size());\n+        std::copy(contents.begin(), contents.end(), UCharCast(msg.m_recv.data()));\n+    } else {\n+        LogPrint(BCLog::NET, \"V2 transport error: invalid message type (%u bytes contents), peer=%d\\n\", m_recv_decode_buffer.size(), m_nodeid);\n+        reject_message = true;\n+    }\n+    m_recv_decode_buffer = {};\n+    SetReceiveState(RecvState::APP);\n+\n+    return msg;\n+}\n+\n+bool V2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_send_state == SendState::V1) return m_v1_fallback.SetMessageToSend(msg);\n+    if (m_send_state != SendState::READY) return false;\n+    if (!m_send_buffer.empty()) return false;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 557,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "4f1900596940c7a2c7f641f2ffaa4ef51aded97a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: both conditions can be combined, they are not terribly long:\r\n```suggestion\r\n    if (m_send_state != SendState::READY || !m_send_buffer.empty()) return false;\r\n```",
      "created_at": "2023-09-05T13:30:40Z",
      "updated_at": "2023-09-05T13:45:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315903319",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315903319"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1439,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1440,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315921749",
      "pull_request_review_id": 1611066021,
      "id": 1315921749,
      "node_id": "PRRC_kwDOABII585Ob19V",
      "diff_hunk": "@@ -1008,4 +1009,498 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would not permit scenarios that involve sending\n+ * invalid data, or ones scenarios using BIP324 features that are not implemented on the sending\n+ * side (like decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            BOOST_CHECK(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1 + CMessageHeader::COMMAND_SIZE);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(1 + CMessageHeader::COMMAND_SIZE) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(1 + CMessageHeader::COMMAND_SIZE + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1 + CMessageHeader::COMMAND_SIZE);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());",
      "path": "src/test/net_tests.cpp",
      "position": null,
      "original_position": 317,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "4f1900596940c7a2c7f641f2ffaa4ef51aded97a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I changed something in the test (to make it fail deliberately) and it caused a flood of error reports from boost. I am not sure how useful is this. Does it make sense to continue the test if one of these checks fails? If not, then consider replacing `BOOST_CHECK()` with `BOOST_REQUIRE()` which would stop the test on the first failure.",
      "created_at": "2023-09-05T13:44:08Z",
      "updated_at": "2023-09-05T13:45:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1315921749",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1315921749"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1317,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316020937",
      "pull_request_review_id": 1611256685,
      "id": 1316020937,
      "node_id": "PRRC_kwDOABII585OcOLJ",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());",
      "path": "src/net.cpp",
      "position": 111,
      "original_position": 12,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": 1315187609,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think so. For responders, the setting of garbage could be delayed until leaving the `MAYBE_V1` state, but it's more convenient to just put it there at initialization time (otherwise we need to buffer it somewhere else when provided for testing purposes, necessitating a separate field etc.).",
      "created_at": "2023-09-05T14:54:13Z",
      "updated_at": "2023-09-05T19:54:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316020937",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316020937"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 995,
      "original_line": 995,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316023401",
      "pull_request_review_id": 1611260541,
      "id": 1316023401,
      "node_id": "PRRC_kwDOABII585OcOxp",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+",
      "path": "src/net.cpp",
      "position": 263,
      "original_position": 139,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": 1315188531,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No, this is too late. Garbage needs to be sent immediately after sending the key, and possibly before the other side's key arrives. Its purpose is obscuring the \"always sending 64 bytes exactly\" pattern. After the other side's key has been received, we can use decoy packets for traffic shaping (which is a cheaper and more flexible mechanism, but isn't available before the ciphers are initialized).",
      "created_at": "2023-09-05T14:55:58Z",
      "updated_at": "2023-09-05T14:55:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316023401",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316023401"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1147,
      "original_line": 1147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316024967",
      "pull_request_review_id": 1611262900,
      "id": 1316024967,
      "node_id": "PRRC_kwDOABII585OcPKH",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 194,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": 1315190513,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It refers to the 0x00 that precedes the long encoding.",
      "created_at": "2023-09-05T14:57:01Z",
      "updated_at": "2023-09-05T14:57:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316024967",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316024967"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316026430",
      "pull_request_review_id": 1611265150,
      "id": 1316026430,
      "node_id": "PRRC_kwDOABII585OcPg-",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            SetReceiveState(RecvState::VERSION);\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                SetReceiveState(RecvState::APP);",
      "path": "src/net.cpp",
      "position": 377,
      "original_position": 237,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": 1315194137,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Well, if it has the ignore bit set, it is not the version packet but a decoy. So in this case, the peer simply hasn't sent us the version message yet, and we still have to wait for it. It is identical to them not having sent anything at all: in both cases we need to wait until they do.",
      "created_at": "2023-09-05T14:58:03Z",
      "updated_at": "2023-09-05T14:58:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316026430",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316026430"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1261,
      "original_line": 1261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316043044",
      "pull_request_review_id": 1611291809,
      "id": 1316043044,
      "node_id": "PRRC_kwDOABII585OcTkk",
      "diff_hunk": "@@ -3015,10 +3025,11 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         // Move message to vSendMsg queue.\n         pnode->vSendMsg.push_back(std::move(msg));\n \n-        // If there was nothing to send before, attempt \"optimistic write\":\n+        // If there was nothing to send before, and there is now (predicted by the \"more\" value\n+        // returned by the GetBytesToSend call above), attempt \"optimistic write\":\n         // because the poll/select loop may pause for SELECT_TIMEOUT_MILLISECONDS before actually\n         // doing a send, try sending from the calling thread if the queue was empty before.\n-        if (queue_was_empty) {\n+        if (queue_was_empty && more) {",
      "path": "src/net.cpp",
      "position": 770,
      "original_position": 97,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "c51369a186e563fb83452fed055d9f28775c644d",
      "in_reply_to_id": 1315543995,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed it is. I've added a comment.",
      "created_at": "2023-09-05T15:10:10Z",
      "updated_at": "2023-09-05T15:10:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316043044",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316043044"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3695,
      "original_line": 3695,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316043768",
      "pull_request_review_id": 1611292955,
      "id": 1316043768,
      "node_id": "PRRC_kwDOABII585OcTv4",
      "diff_hunk": "@@ -912,6 +912,406 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::AWAITING_KEY:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+        Assume(false); // Final state\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received, and can now be Diffie-Hellman combined with\n+        // our key to initialize the encryption ciphers.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to READY.\n+        SetSendState(SendState::READY);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;",
      "path": "src/net.cpp",
      "position": 320,
      "original_position": 179,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "5cb433948b050913d22914905c7db510e9ef48d2",
      "in_reply_to_id": 1315562543,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added (empty) branches for these cases with comments.",
      "created_at": "2023-09-05T15:10:42Z",
      "updated_at": "2023-09-05T15:10:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316043768",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316043768"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1204,
      "original_line": 1204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316044004",
      "pull_request_review_id": 1611293320,
      "id": 1316044004,
      "node_id": "PRRC_kwDOABII585OcTzk",
      "diff_hunk": "@@ -912,6 +912,406 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::AWAITING_KEY:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+        Assume(false); // Final state\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received, and can now be Diffie-Hellman combined with\n+        // our key to initialize the encryption ciphers.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to READY.\n+        SetSendState(SendState::READY);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {",
      "path": "src/net.cpp",
      "position": 344,
      "original_position": 200,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "5cb433948b050913d22914905c7db510e9ef48d2",
      "in_reply_to_id": 1315580897,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added empty branches with comments.",
      "created_at": "2023-09-05T15:10:53Z",
      "updated_at": "2023-09-05T15:10:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316044004",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316044004"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1228,
      "original_line": 1228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316045959",
      "pull_request_review_id": 1611296393,
      "id": 1316045959,
      "node_id": "PRRC_kwDOABII585OcUSH",
      "diff_hunk": "@@ -417,6 +419,179 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates that senders should leave this\n+     *  empty, and receivers should ignore it. Future extensions can change what is sent as long as\n+     *  an empty version packet contents is interpreted as no extensions supported. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are state machines that are transitioned\n+    // through, based on what has been received. The receive state corresponds to the contents of,\n+    // and bytes received to, the receive buffer. The send state controls what can be appended to\n+    // the send buffer.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage",
      "path": "src/net.h",
      "position": 150,
      "original_position": 55,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "5cb433948b050913d22914905c7db510e9ef48d2",
      "in_reply_to_id": 1315599806,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@naumenkogs \r\n\r\nI've renamed the functions to `ProcessReceived*Bytes`, and added comments. Please have a look.\r\n\r\nRegarding the 4 kB, it's wiped in` ProcessReceivedGarbageBytes` now: when the full garbage + terminator has been processed, `m_recv_buffer.clear();` is called.\r\n\r\n@vasild \r\n\r\nThat's all done by CNode and the higher-level network receive logic, not the transport. There is nothing V2-specific about it; if we don't receive stuff for a while, the connection will be considered inactive and closed, regardless of what transport is in use.",
      "created_at": "2023-09-05T15:12:23Z",
      "updated_at": "2023-09-05T16:02:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316045959",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316045959"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 487,
      "original_line": 487,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316046213",
      "pull_request_review_id": 1611296813,
      "id": 1316046213,
      "node_id": "PRRC_kwDOABII585OcUWF",
      "diff_hunk": "@@ -1020,11 +1045,46 @@ size_t V2Transport::GetMaxBytesToProcess() noexcept\n     case RecvState::APP_READY:\n         // No bytes can be processed until GetMessage() is called.\n         return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        Assume(false);\n+        return 0;\n     }\n     Assume(false); // unreachable\n     return 0;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to AWAITING_KEY state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::AWAITING_KEY);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v1 prefix, so fall back to v1 behavior.",
      "path": "src/net.cpp",
      "position": 210,
      "original_position": 125,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "a69b92b7c2faf0f301e88e5c6e9eef8f8dbab24a",
      "in_reply_to_id": 1315778515,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added empty branches with comments.",
      "created_at": "2023-09-05T15:12:35Z",
      "updated_at": "2023-09-05T15:12:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316046213",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316046213"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1094,
      "original_line": 1094,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316046419",
      "pull_request_review_id": 1611297165,
      "id": 1316046419,
      "node_id": "PRRC_kwDOABII585OcUZT",
      "diff_hunk": "@@ -1296,12 +1296,31 @@ bool V2Transport::ProcessReceivedPacket() noexcept\n bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n {\n     AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 256 * 1024;\n+\n     LOCK(m_recv_mutex);\n     if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n \n     while (!msg_bytes.empty()) {\n         // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n         size_t max_read = GetMaxBytesToProcess();\n+        // Reserve space in the buffer.\n+        if (m_recv_state == RecvState::KEY_MAYBE_V1 || m_recv_state == RecvState::KEY ||",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 14,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "256eb4ba2f6e3827ec5920a5ed4616636fd59310",
      "in_reply_to_id": 1315787989,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've changed it to a switch case.",
      "created_at": "2023-09-05T15:12:45Z",
      "updated_at": "2023-09-05T15:12:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316046419",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316046419"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1309,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316046662",
      "pull_request_review_id": 1611297574,
      "id": 1316046662,
      "node_id": "PRRC_kwDOABII585OcUdG",
      "diff_hunk": "@@ -910,24 +912,625 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short messages as defined in BIP324, in order.\n+ *\n+ * Only message types that are actually implemented in this codebase need to be listed, as other\n+ * messages get ignored anyway - whether we know how to decode them or not.\n+ */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::AWAITING_KEY : SendState::MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::AWAITING_KEY : SendState::MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        Assume(recv_state == RecvState::KEY || recv_state == RecvState::V1);\n+        break;\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        Assume(false); // V1 state cannot be left\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::MAYBE_V1:\n+        Assume(send_state == SendState::V1 || send_state == SendState::AWAITING_KEY);\n+        break;\n+    case SendState::AWAITING_KEY:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+    case SendState::V1:\n+        Assume(false); // Final states\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the\n+        // receive buffer.\n+        Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+        // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what\n+        // is strictly necessary to distinguish the two (12 bytes). If we permitted more than\n+        // the v1 header size (24 bytes), we may not be able to feed the already-received bytes\n+        // back into the m_v1_fallback V1 transport.\n+        return m_v1_prefix.size() - m_recv_buffer.size();\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        Assume(false);\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    Assume(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to AWAITING_KEY state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::AWAITING_KEY);\n+    } else if (m_recv_buffer.size() == m_v1_prefix.size()) {\n+        // Full match with the v1 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        // Feed already received bytes to v1 transport. It should always accept these, because it's\n+        // less than the size of a v1 header, and these are the first bytes fed to m_v1_fallback.\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback);\n+        Assume(feedback.empty());\n+        Assume(ret);\n+        SetReceiveState(RecvState::V1);\n+        SetSendState(SendState::V1);\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+    }\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received, and can now be Diffie-Hellman combined with\n+        // our key to initialize the encryption ciphers.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to READY.\n+        SetSendState(SendState::READY);\n+        // Append the garbage terminator to the send buffer.\n+        size_t garbage_len = m_send_buffer.size() - EllSwiftPubKey::size();\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer (using the garbage data which\n+        // is still there).\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            MakeByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size(), garbage_len),\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.\n+        std::min<size_t>(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH); // The maximum payload.\n+\n+    if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {\n+        // Length descriptor received.\n+        m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));\n+        if (m_recv_len > MAX_CONTENTS_LEN) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet too large (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+    } else if (m_recv_buffer.size() > BIP324Cipher::LENGTH_LEN && m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {\n+        // Ciphertext received, decrypt it into m_recv_decode_buffer.\n+        // Note that it is impossible to reach this branch without hitting the branch above first,\n+        // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.\n+        m_recv_decode_buffer.resize(m_recv_len);\n+        bool ignore{false};\n+        Span<const std::byte> aad;\n+        if (m_recv_state == RecvState::GARBAUTH) aad = MakeByteSpan(m_recv_garbage);\n+        bool ret = m_cipher.Decrypt(\n+            MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),\n+            aad,\n+            ignore,\n+            MakeWritableByteSpan(m_recv_decode_buffer));\n+        if (!ret) {\n+            LogPrint(BCLog::NET, \"V2 transport error: packet decryption failure (%u bytes), peer=%d\\n\", m_recv_len, m_nodeid);\n+            return false;\n+        }\n+        // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.\n+        RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));\n+\n+        // At this point we have a valid packet decrypted into m_recv_decode_buffer. Depending on\n+        // the current state, decide what to do with it.\n+        switch (m_recv_state) {\n+        case RecvState::GARBAUTH:\n+            // Ignore flag does not matter for garbage authentication. Any valid packet functions\n+            // as authentication. Receive and process the version packet next.\n+            SetReceiveState(RecvState::VERSION);\n+            m_recv_garbage = {};\n+            break;\n+        case RecvState::VERSION:\n+            if (!ignore) {\n+                // Version message received; transition to application phase. The contents is\n+                // ignored, but can be used for future extensions.\n+                SetReceiveState(RecvState::APP);\n+            }\n+            break;\n+        case RecvState::APP:\n+            if (!ignore) {\n+                // Application message decrypted correctly. It can be extracted using GetMessage().\n+                SetReceiveState(RecvState::APP_READY);\n+            }\n+            break;\n+        default:\n+            // Any other state is invalid (this function should not have been called).\n+            Assume(false);\n+        }\n+        // Wipe the receive buffer where the next packet will be received into.\n+        m_recv_buffer = {};\n+        // In all but APP_READY state, we can wipe the decoded contents.\n+        if (m_recv_state != RecvState::APP_READY) m_recv_decode_buffer = {};\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    /** How many bytes to allocate in the receive buffer at most above what is received so far. */\n+    static constexpr size_t MAX_RESERVE_AHEAD = 256 * 1024;\n+\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedBytes(msg_bytes);\n+\n+    while (!msg_bytes.empty()) {\n+        // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n+        size_t max_read = GetMaxBytesToProcess();\n+        // Reserve space in the buffer.\n+        if (m_recv_state == RecvState::KEY_MAYBE_V1 || m_recv_state == RecvState::KEY ||\n+            m_recv_state == RecvState::GARB_GARBTERM) {\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        } else if (m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+            m_recv_state == RecvState::APP) {\n+            // During states where a packet is being received, as much as is expected but never\n+            // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+            // This means attackers that want to cause us to waste allocated memory are limited\n+            // to MAX_RESERVE_AHEAD above the largest allowed message contents size, and to\n+            // MAX_RESERVE_AHEAD more than they've actually sent us.\n+            size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+            m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);\n+        }\n+        // Can't read more than provided input.\n+        max_read = std::min(msg_bytes.size(), max_read);\n+        // Copy data to buffer.\n+        m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));\n+        msg_bytes = msg_bytes.subspan(max_read);\n+\n+        // Process data in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY_MAYBE_V1:\n+            ProcessReceivedMaybeV1();\n+            if (m_recv_state == RecvState::V1) return true;\n+            break;\n+\n+        case RecvState::KEY:\n+            ProcessReceivedKey();\n+            break;\n+\n+        case RecvState::GARB_GARBTERM:\n+            if (!ProcessReceivedGarbage()) return false;\n+            break;\n+\n+        case RecvState::GARBAUTH:\n+        case RecvState::VERSION:\n+        case RecvState::APP:\n+            if (!ProcessReceivedPacket()) return false;\n+            break;\n+\n+        case RecvState::APP_READY:\n+            return true;\n+\n+        case RecvState::V1:\n+            // We should have bailed out before.\n+            Assume(false);\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+std::optional<std::string> V2Transport::GetMessageType(Span<const uint8_t>& contents) noexcept\n+{\n+    if (contents.size() == 0) return std::nullopt; // Empty contents\n+    uint8_t first_byte = contents[0];\n+    contents = contents.subspan(1); // Strip first byte.\n+\n+    if (first_byte != 0) {\n+        // Short (1 byte) encoding.\n+        if (first_byte < std::size(V2_MESSAGE_IDS)) {\n+            // Valid short message id.\n+            return V2_MESSAGE_IDS[first_byte];\n+        } else {\n+            // Unknown short message id.\n+            return std::nullopt;\n+        }\n+    }\n+\n+    if (contents.size() < CMessageHeader::COMMAND_SIZE) {\n+        return std::nullopt; // Long encoding needs 12 message type bytes.\n+    }\n+\n+    size_t msg_type_len{0};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE && contents[msg_type_len] != 0) {\n+        // Verify that message type bytes before the first 0x00 are in range.\n+        if (contents[msg_type_len] < ' ' || contents[msg_type_len] > 0x7F) {\n+            return {};\n+        }\n+        ++msg_type_len;\n+    }\n+    std::string ret{reinterpret_cast<const char*>(contents.data()), msg_type_len};\n+    while (msg_type_len < CMessageHeader::COMMAND_SIZE) {\n+        // Verify that message type bytes after the first 0x00 are also 0x00.\n+        if (contents[msg_type_len] != 0) return {};\n+        ++msg_type_len;\n+    }\n+    // Strip message type bytes of contents.\n+    contents = contents.subspan(CMessageHeader::COMMAND_SIZE);\n+    return {std::move(ret)};\n+}\n+\n+CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.GetReceivedMessage(time, reject_message);\n+\n+    Assume(m_recv_state == RecvState::APP_READY);\n+    Span<const uint8_t> contents{m_recv_decode_buffer};\n+    auto msg_type = GetMessageType(contents);\n+    CDataStream ret(m_recv_type, m_recv_version);\n+    CNetMessage msg{std::move(ret)};\n+    // Note that BIP324Cipher::EXPANSION also includes the length descriptor size.\n+    msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;\n+    if (msg_type) {\n+        reject_message = false;\n+        msg.m_type = std::move(*msg_type);\n+        msg.m_time = time;\n+        msg.m_message_size = contents.size();\n+        msg.m_recv.resize(contents.size());\n+        std::copy(contents.begin(), contents.end(), UCharCast(msg.m_recv.data()));\n+    } else {\n+        LogPrint(BCLog::NET, \"V2 transport error: invalid message type (%u bytes contents), peer=%d\\n\", m_recv_decode_buffer.size(), m_nodeid);\n+        reject_message = true;\n+    }\n+    m_recv_decode_buffer = {};\n+    SetReceiveState(RecvState::APP);\n+\n+    return msg;\n+}\n+\n+bool V2Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_send_state == SendState::V1) return m_v1_fallback.SetMessageToSend(msg);\n+    if (m_send_state != SendState::READY) return false;\n+    if (!m_send_buffer.empty()) return false;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 557,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "4f1900596940c7a2c7f641f2ffaa4ef51aded97a",
      "in_reply_to_id": 1315903319,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done. Also added a comment.",
      "created_at": "2023-09-05T15:12:57Z",
      "updated_at": "2023-09-05T15:12:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316046662",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316046662"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1439,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1440,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316047145",
      "pull_request_review_id": 1611298369,
      "id": 1316047145,
      "node_id": "PRRC_kwDOABII585OcUkp",
      "diff_hunk": "@@ -1008,4 +1009,498 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would not permit scenarios that involve sending\n+ * invalid data, or ones scenarios using BIP324 features that are not implemented on the sending\n+ * side (like decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            BOOST_CHECK(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1 + CMessageHeader::COMMAND_SIZE);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(1 + CMessageHeader::COMMAND_SIZE) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(1 + CMessageHeader::COMMAND_SIZE + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1 + CMessageHeader::COMMAND_SIZE);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());",
      "path": "src/test/net_tests.cpp",
      "position": null,
      "original_position": 317,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "4f1900596940c7a2c7f641f2ffaa4ef51aded97a",
      "in_reply_to_id": 1315921749,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've changed some of the `BOOST_CHECK`s into `BOOST_REQUIRE`s.",
      "created_at": "2023-09-05T15:13:16Z",
      "updated_at": "2023-09-05T15:13:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316047145",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316047145"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1317,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316047558",
      "pull_request_review_id": 1611299063,
      "id": 1316047558,
      "node_id": "PRRC_kwDOABII585OcUrG",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);",
      "path": "src/net.cpp",
      "position": 311,
      "original_position": 179,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": 1315189334,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Want to suggest some code? I've tried to mimick the amount of logging the `V1Transport` has. If it's not V2-specific, it's probably better for a follow-up that adds it to all transports.",
      "created_at": "2023-09-05T15:13:32Z",
      "updated_at": "2023-09-05T15:15:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316047558",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316047558"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1195,
      "original_line": 1195,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316047712",
      "pull_request_review_id": 1611299351,
      "id": 1316047712,
      "node_id": "PRRC_kwDOABII585OcUtg",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool V2Transport::ProcessReceivedPacket() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARBAUTH || m_recv_state == RecvState::VERSION ||\n+           m_recv_state == RecvState::APP);\n+\n+    // The maximum permitted contents length for a packet.\n+    static constexpr size_t MAX_CONTENTS_LEN =\n+        1 + CMessageHeader::COMMAND_SIZE + // The maximum length for encoding the message type.",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 194,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": 1315190513,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've expanded the comment.",
      "created_at": "2023-09-05T15:13:40Z",
      "updated_at": "2023-09-05T15:13:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316047712",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316047712"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316111729",
      "pull_request_review_id": 1611398428,
      "id": 1316111729,
      "node_id": "PRRC_kwDOABII585OckVx",
      "diff_hunk": "@@ -1321,6 +1324,38 @@ bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n     while (!msg_bytes.empty()) {\n         // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n         size_t max_read = GetMaxBytesToProcess();\n+\n+        // Reserve space in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY_MAYBE_V1:\n+        case RecvState::KEY:\n+        case RecvState::GARB_GARBTERM:\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 22,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "70298caec38f3a085532a6c43bc82a869481ee33",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is it intended that those `.reserve` methods could potentially be called multiple times for the same receive state? Maybe it's more a theoretical thought, but let's say we are in `RecvState::KEY_MAYBE_V1` and for whatever reason (e.g. slow connection), the key is received in multiple small chunks of 16 bytes, i.e. `V2Transport::ReceivedBytes` is called four times with spans of size 16. This line would then also be executed 4 times, as the receive state never changed in-between.\r\n\r\nTo phrase it differently: if a TCP-peer sends us `N` bytes in one call, is there any guarantee that we receive those `N` bytes here all at once? (I don't think so.)\r\n\r\nOn the other hand, I assume calling `reserve` repeatedly is not really expensive (I guess it immediately returns if the passed size is equal to the currently reserved size), so it's probably not a big deal.",
      "created_at": "2023-09-05T16:01:53Z",
      "updated_at": "2023-09-05T16:01:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316111729",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316111729"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316121233",
      "pull_request_review_id": 1611413170,
      "id": 1316121233,
      "node_id": "PRRC_kwDOABII585OcmqR",
      "diff_hunk": "@@ -1321,6 +1324,38 @@ bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n     while (!msg_bytes.empty()) {\n         // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n         size_t max_read = GetMaxBytesToProcess();\n+\n+        // Reserve space in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY_MAYBE_V1:\n+        case RecvState::KEY:\n+        case RecvState::GARB_GARBTERM:\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 22,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "70298caec38f3a085532a6c43bc82a869481ee33",
      "in_reply_to_id": 1316111729,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's a good point. `reserve`, when it is a no-op, is fast, and I'm not worried about calling `reserve` repeatedly in this case.\r\n\r\nHowever, when say someone announces to us a 4 MB packet, and then starts sending the bytes one by one, the currently-implemented logic will first preallocate 256 KiB of buffer space, then when a byte arrives, we'll reallocate to (256 KiB + 1 B), and so on. That could actually amount to a substantial amount of reallocation work.\r\n\r\nI'll change this to only calling `reserve` when the current buffer size is actually too little for the bytes received right now.\r\n",
      "created_at": "2023-09-05T16:08:56Z",
      "updated_at": "2023-09-05T16:08:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316121233",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316121233"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316168924",
      "pull_request_review_id": 1611561533,
      "id": 1316168924,
      "node_id": "PRRC_kwDOABII585OcyTc",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 105,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": 1315191628,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've expanded this comment a bit.",
      "created_at": "2023-09-05T17:09:41Z",
      "updated_at": "2023-09-05T17:09:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316168924",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316168924"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316169051",
      "pull_request_review_id": 1611561779,
      "id": 1316169051,
      "node_id": "PRRC_kwDOABII585OcyVb",
      "diff_hunk": "@@ -1321,6 +1324,38 @@ bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n     while (!msg_bytes.empty()) {\n         // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n         size_t max_read = GetMaxBytesToProcess();\n+\n+        // Reserve space in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY_MAYBE_V1:\n+        case RecvState::KEY:\n+        case RecvState::GARB_GARBTERM:\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 22,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "70298caec38f3a085532a6c43bc82a869481ee33",
      "in_reply_to_id": 1316111729,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-09-05T17:09:48Z",
      "updated_at": "2023-09-05T17:09:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316169051",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316169051"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316190690",
      "pull_request_review_id": 1611597266,
      "id": 1316190690,
      "node_id": "PRRC_kwDOABII585Oc3ni",
      "diff_hunk": "@@ -417,6 +419,187 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates this is supposed to be empty,\n+     *  and ignored by receivers. If extensions are defined, they can change what is sent as long\n+     *  as an empty version packet contents is interpreted as no extensions present. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are largely independent state machines that\n+    // are transitioned through, where each state corresponds to the meaning of the data in (or to\n+    // be received to) the respective (send/receive) buffer. The sender side is primarily\n+    // controlled by send-side functions (SetMessageToSend, MarkBytesSent), while the received side\n+    // is primarily controlled by receiver-side functions (ReceivedBytes, GetReceivedMessage),\n+    // though in some cases the sender state can also change as a result of receiving bytes.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage\n+         * terminator. When that happens, the state becomes GARBAUTH. If no matching terminator is\n+         * received in 4111 bytes (4095 for the maximum garbage length, and 16 bytes for the\n+         * terminator), the connection aborts. */\n+        GARB_GARBTERM,\n+\n+        /** Garbage authentication packet.\n+         *\n+         * A packet is received, and decrypted/verified with AAD set to the garbage received during\n+         * the GARB_GARBTERM state. If that succeeds, the state becomes VERSION. If it fails the\n+         * connection aborts. */\n+        GARBAUTH,\n+\n+        /** Version packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes APP,\n+         * and the decrypted contents is interpreted as version negotiation (currently, that means\n+         * ignoring it, but it can be used for negotiating future extensions). If it fails, the\n+         * connection aborts. */\n+        VERSION,\n+\n+        /** Application packet.\n+         *\n+         * A packet is received, and decrypted/verified. If that succeeds, the state becomes\n+         * APP_READY and the decrypted contents is kept in m_recv_decode_buffer until it is\n+         * retrieved as a message by GetMessage(). */\n+        APP,\n+\n+        /** Nothing (an application packet is available for GetMessage()).\n+         *\n+         * Nothing can be received in this state. When the message is retrieved by GetMessage,\n+         * the state becomes APP again. */\n+        APP_READY,\n+    };\n+\n+    /** State type that defines the contents of the send buffer.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                       /----------\\\n+     *     |                                         |          |\n+     *     v                                         v          |\n+     *    KEY -> KEY_GARBTERM_GARBAUTH_VERSION -> APP_READY -> APP\n+     */\n+    enum class SendState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state. The public key is sent out. When the receiver\n+         * receives the other side's public key and transitions to GARB_GARBTERM, the sender state\n+         * becomes KEY_GARBTERM_GARBAUTH_VERSION. The key is left in the send buffer when this\n+         * happens, because it may not have been fully sent out yet. */",
      "path": "src/net.h",
      "position": null,
      "original_position": 107,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "fb3ec8fd9e96f6c2d16db02fd2d683ea097a90ff",
      "in_reply_to_id": 1313408730,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Marking this as addressed because of https://github.com/bitcoin/bitcoin/pull/28196#issuecomment-1705723891",
      "created_at": "2023-09-05T17:29:50Z",
      "updated_at": "2023-09-05T17:29:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316190690",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316190690"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 507,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316316591",
      "pull_request_review_id": 1611552610,
      "id": 1316316591,
      "node_id": "PRRC_kwDOABII585OdWWv",
      "diff_hunk": "@@ -912,6 +912,69 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short messages as defined in BIP324, in order.\n+ *\n+ * Only message types that are actually implemented in this codebase need to be listed, as other\n+ * messages get ignored anyway - whether we know how to decode them or not.\n+ */\n+const std::string V2_MESSAGE_IDS[] = {",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 11,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "ff64d9e6ddc209842ed1d317eab4c50436947a7b",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "short of mechanically generating these directly off the spec, I think statically asserting this list is 29 long would be good for hand-checking the bip\r\n\r\nbip and implementation-related question: how do we keep the message ids in sync? The BIP has erlay-related messages allocated, but they aren't implemented here. If in a future PR these were added, wouldn't the two versions be out of sync? Newer peer would send erlay-related messages with message ids(or perhaps something we actually use!) and older peer would simply ignore them. Is there a coordination mechanism for this?",
      "created_at": "2023-09-05T19:34:28Z",
      "updated_at": "2023-09-06T15:16:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316316591",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316316591"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 922,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316678715",
      "pull_request_review_id": 1612349823,
      "id": 1316678715,
      "node_id": "PRRC_kwDOABII585Oeuw7",
      "diff_hunk": "@@ -973,11 +987,44 @@ size_t V2Transport::GetMaxBytesToProcess() noexcept\n     case RecvState::APP_READY:\n         // No bytes can be processed until GetMessage() is called.\n         return 0;\n+    case RecvState::V1:\n+        // Not allowed (must be dealt with by the caller).\n+        assert(false);\n+        return 0;\n     }\n     assert(false); // unreachable\n     return 0;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public key.\n+    assert(m_recv_buffer.size() <= m_v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), m_v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.",
      "path": "src/net.cpp",
      "position": 204,
      "original_position": 86,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "faf5af3f6b96488ebf9585c1558710545cde05a6",
      "in_reply_to_id": 1310362246,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added a commit for detecting wrong-network V1 incoming connections, and log + disconnect them.",
      "created_at": "2023-09-06T03:42:00Z",
      "updated_at": "2023-09-06T03:42:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316678715",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316678715"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1088,
      "original_line": 1088,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316679352",
      "pull_request_review_id": 1612351034,
      "id": 1316679352,
      "node_id": "PRRC_kwDOABII585Oeu64",
      "diff_hunk": "@@ -3015,10 +3022,11 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         // Move message to vSendMsg queue.\n         pnode->vSendMsg.push_back(std::move(msg));\n \n-        // If there was nothing to send before, attempt \"optimistic write\":\n+        // If there was nothing to send before, and there is now (predicted by the \"more\" value\n+        // returned by the GetBytesToSend call above), attempt \"optimistic write\":\n         // because the poll/select loop may pause for SELECT_TIMEOUT_MILLISECONDS before actually\n         // doing a send, try sending from the calling thread if the queue was empty before.\n-        if (queue_was_empty) {\n+        if (queue_was_empty && more) {",
      "path": "src/net.cpp",
      "position": 770,
      "original_position": 94,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "d67be9ad3836bd19cc8ea71a0b99c7d60682dd32",
      "in_reply_to_id": 1315151725,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added an explanation to the `GetBytesToSend` comment in the `have_next_message` commit that explains the behavior in terms of a tristate, as it may help some readers who have not followed the discussion here.",
      "created_at": "2023-09-06T03:43:42Z",
      "updated_at": "2023-09-06T03:43:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316679352",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316679352"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3695,
      "original_line": 3695,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316787126",
      "pull_request_review_id": 1612559277,
      "id": 1316787126,
      "node_id": "PRRC_kwDOABII585OfJO2",
      "diff_hunk": "@@ -417,6 +419,179 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates that senders should leave this\n+     *  empty, and receivers should ignore it. Future extensions can change what is sent as long as\n+     *  an empty version packet contents is interpreted as no extensions supported. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are state machines that are transitioned\n+    // through, based on what has been received. The receive state corresponds to the contents of,\n+    // and bytes received to, the receive buffer. The send state controls what can be appended to\n+    // the send buffer.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage",
      "path": "src/net.h",
      "position": 150,
      "original_position": 55,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "5cb433948b050913d22914905c7db510e9ef48d2",
      "in_reply_to_id": 1315599806,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">Regarding the 4 kB, it's wiped in ProcessReceivedGarbageBytes now: when the full garbage + terminator has been processed, m_recv_buffer.clear(); is called.\r\n\r\nWhat will happen if we're at 3.99 Kb of garbage and no terminator? Am i right that the caller would be responsible for terminating this after a timeout?",
      "created_at": "2023-09-06T06:18:24Z",
      "updated_at": "2023-09-06T06:18:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316787126",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316787126"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 487,
      "original_line": 487,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316970036",
      "pull_request_review_id": 1612853636,
      "id": 1316970036,
      "node_id": "PRRC_kwDOABII585Of140",
      "diff_hunk": "@@ -1321,6 +1324,38 @@ bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n     while (!msg_bytes.empty()) {\n         // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n         size_t max_read = GetMaxBytesToProcess();\n+\n+        // Reserve space in the buffer.\n+        switch (m_recv_state) {\n+        case RecvState::KEY_MAYBE_V1:\n+        case RecvState::KEY:\n+        case RecvState::GARB_GARBTERM:\n+            // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+            // bytes).\n+            m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 22,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "70298caec38f3a085532a6c43bc82a869481ee33",
      "in_reply_to_id": 1316111729,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> if a TCP-peer sends us N bytes in one call, is there any guarantee that we receive those N bytes here all at once?\r\n\r\nNo.",
      "created_at": "2023-09-06T09:01:09Z",
      "updated_at": "2023-09-06T09:01:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1316970036",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1316970036"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317102038",
      "pull_request_review_id": 1613048752,
      "id": 1317102038,
      "node_id": "PRRC_kwDOABII585OgWHW",
      "diff_hunk": "@@ -1008,4 +1009,498 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would not permit scenarios that involve sending\n+ * invalid data, or ones scenarios using BIP324 features that are not implemented on the sending\n+ * side (like decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_REQUIRE(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_REQUIRE(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_REQUIRE(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            BOOST_REQUIRE(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_REQUIRE(ret.size() == payload.size() + 1 + CMessageHeader::COMMAND_SIZE);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(1 + CMessageHeader::COMMAND_SIZE) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(1 + CMessageHeader::COMMAND_SIZE + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1 + CMessageHeader::COMMAND_SIZE);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_REQUIRE(ret && ret->empty());\n+        tester.SendKey();\n+        tester.SendGarbage();\n+        tester.ReceiveKey();\n+        tester.SendGarbageTermAuth();\n+        tester.SendVersion();\n+        ret = tester.Interact();\n+        BOOST_REQUIRE(ret && ret->empty());\n+        tester.ReceiveGarbage();\n+        tester.ReceiveVersion();\n+        auto msg_data_1 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(100000));\n+        auto msg_data_2 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(1000));\n+        tester.SendMessage(uint8_t(4), msg_data_1); // cmpctblock short id\n+        tester.SendMessage(0, {}); // Invalidly encoded message\n+        tester.SendMessage(\"tx\", msg_data_2); // 12-character encoded message type\n+        ret = tester.Interact();\n+        BOOST_REQUIRE(ret && ret->size() == 3 &&\n+                      (*ret)[0] && (*ret)[0]->m_type == \"cmpctblock\" && Span{(*ret)[0]->m_recv} == MakeByteSpan(msg_data_1) &&\n+                      !(*ret)[1] &&\n+                      (*ret)[2] && (*ret)[2]->m_type == \"tx\" && Span{(*ret)[2]->m_recv} == MakeByteSpan(msg_data_2));",
      "path": "src/test/net_tests.cpp",
      "position": null,
      "original_position": 336,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "2a5a7ffff72ee5cafae44ae814acbdfe128e7bb6",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If this fails then it is not clear from the message which condition was false. In general, `assert(A && B)` is equivalent to `assert(A); assert(B);` but the latter gives more descriptive message in case of failure.",
      "created_at": "2023-09-06T10:52:19Z",
      "updated_at": "2023-09-06T11:26:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1317102038",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317102038"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1333,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1336,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317138347",
      "pull_request_review_id": 1613048752,
      "id": 1317138347,
      "node_id": "PRRC_kwDOABII585Oge-r",
      "diff_hunk": "@@ -910,24 +912,685 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short messages as defined in BIP324, in order.\n+ *\n+ * Only message types that are actually implemented in this codebase need to be listed, as other\n+ * messages get ignored anyway - whether we know how to decode them or not.\n+ */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::AWAITING_KEY : SendState::MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::AWAITING_KEY : SendState::MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        Assume(recv_state == RecvState::KEY || recv_state == RecvState::V1);\n+        break;\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        Assume(false); // V1 state cannot be left\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::MAYBE_V1:\n+        Assume(send_state == SendState::V1 || send_state == SendState::AWAITING_KEY);\n+        break;\n+    case SendState::AWAITING_KEY:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+    case SendState::V1:\n+        Assume(false); // Final states\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1Bytes() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public\n+    // key. BIP324 specifies that a mismatch with this 12-byte string should trigger sending of the\n+    // key.\n+    std::array<uint8_t, V1_PREFIX_LEN> v1_prefix = {0, 0, 0, 0, 'v', 'e', 'r', 's', 'i', 'o', 'n', 0};\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), v1_prefix.begin());\n+    Assume(m_recv_buffer.size() <= v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to AWAITING_KEY state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::AWAITING_KEY);\n+    } else if (m_recv_buffer.size() == v1_prefix.size()) {\n+        // Full match with the v1 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        // Feed already received bytes to v1 transport. It should always accept these, because it's\n+        // less than the size of a v1 header, and these are the first bytes fed to m_v1_fallback.\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback);\n+        Assume(feedback.empty());\n+        Assume(ret);\n+        SetReceiveState(RecvState::V1);\n+        SetSendState(SendState::V1);\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+    } else {\n+        // We have not received enough to distinguish v1 from v2 yet. Wait until more bytes come.\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedKeyBytes() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received, and can now be Diffie-Hellman combined with\n+        // our key to initialize the encryption ciphers.\n+\n+        // As a special exception, if bytes 4-16 of the key on a responder connection match the\n+        // corresponding bytes of a V1 version message, but bytes 0-4 don't match the network magic\n+        // (if they did, we'd have switched to V1 state already), assume this is a peer from\n+        // another network, and disconnect them. They will almost certainly disconnect us too when\n+        // they receive our uniformly random key and garbage, but detecting this case specially\n+        // means we can log it.\n+        static constexpr std::array<uint8_t, 12> MATCH = {'v', 'e', 'r', 's', 'i', 'o', 'n', 0, 0, 0, 0, 0};\n+        static constexpr size_t OFFSET = sizeof(CMessageHeader::MessageStartChars);\n+        if (!m_initiating) {\n+            Assume(m_recv_buffer.size() <= OFFSET + MATCH.size());",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 246,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "2a5a7ffff72ee5cafae44ae814acbdfe128e7bb6",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This looks wrong, the condition on the `if` on line 1116 means that `m_recv_buffer` is exactly 64 bytes. Here we assert that it is less than 4 + 12 = 16. I think this is causing the CI failure.\r\n\r\nEdit: I guess it should be:\r\n\r\n```cpp\r\nAssume(m_recv_buffer.size() >= OFFSET + MATCH.size());\r\n```",
      "created_at": "2023-09-06T11:26:51Z",
      "updated_at": "2023-09-06T11:31:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1317138347",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317138347"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1116,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317149400",
      "pull_request_review_id": 1613123313,
      "id": 1317149400,
      "node_id": "PRRC_kwDOABII585OghrY",
      "diff_hunk": "@@ -417,6 +419,179 @@ class V1Transport final : public Transport\n     size_t GetSendMemoryUsage() const noexcept override EXCLUSIVE_LOCKS_REQUIRED(!m_send_mutex);\n };\n \n+class V2Transport final : public Transport\n+{\n+private:\n+    /** Contents of the version packet to send. BIP324 stipulates that senders should leave this\n+     *  empty, and receivers should ignore it. Future extensions can change what is sent as long as\n+     *  an empty version packet contents is interpreted as no extensions supported. */\n+    static constexpr std::array<std::byte, 0> VERSION_CONTENTS = {};\n+\n+    // The sender side and receiver side of V2Transport are state machines that are transitioned\n+    // through, based on what has been received. The receive state corresponds to the contents of,\n+    // and bytes received to, the receive buffer. The send state controls what can be appended to\n+    // the send buffer.\n+\n+    /** State type that defines the current contents of the receive buffer and/or how the next\n+     *  received bytes added to it will be interpreted.\n+     *\n+     * Diagram:\n+     *\n+     *   start                                            /---------\\\n+     *     |                                              |         |\n+     *     v                                              v         |\n+     *    KEY -> GARB_GARBTERM -> GARBAUTH -> VERSION -> APP -> APP_READY\n+     */\n+    enum class RecvState : uint8_t {\n+        /** Public key.\n+         *\n+         * This is the initial state, during which the other side's public key is\n+         * received. When that information arrives, the ciphers get initialized and the state\n+         * becomes GARB_GARBTERM. */\n+        KEY,\n+\n+        /** Garbage and garbage terminator.\n+         *\n+         * Whenever a byte is received, the last 16 bytes are compared with the expected garbage",
      "path": "src/net.h",
      "position": 150,
      "original_position": 55,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "5cb433948b050913d22914905c7db510e9ef48d2",
      "in_reply_to_id": 1315599806,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, if the connection times out, the CNode along with its m_transport member is automatically deleted. This is no different than with V1 transports today (which also have a send and receive buffer that uses memory until deleted).",
      "created_at": "2023-09-06T11:37:26Z",
      "updated_at": "2023-09-06T11:37:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1317149400",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317149400"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 487,
      "original_line": 487,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317159785",
      "pull_request_review_id": 1613140153,
      "id": 1317159785,
      "node_id": "PRRC_kwDOABII585OgkNp",
      "diff_hunk": "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 13);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.SendKey();\n+        tester.SendGarbage();\n+        tester.ReceiveKey();\n+        tester.SendGarbageTermAuth();\n+        tester.SendVersion();\n+        ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.ReceiveGarbage();\n+        tester.ReceiveVersion();\n+        auto msg_data_1 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(100000));",
      "path": "src/test/net_tests.cpp",
      "position": 343,
      "original_position": 326,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313245167,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "(offtopic)\r\n\r\nin `multiprocess, i686, DEBUG` the seed it printed: https://cirrus-ci.com/task/5770424366137344?logs=ci#L3855\r\n```\r\n/bin/bash: line 1: 25146 Aborted                 (core dumped) test/test_bitcoin --catch_system_errors=no -l test_suite -t \"$( cat test/net_tests.cpp | grep -E \"(BOOST_FIXTURE_TEST_SUITE\\\\(|BOOST_AUTO_TEST_SUITE\\\\()\" | cut -d '(' -f 2 | cut -d ',' -f 1 | cut -d ')' -f 1 )\" -- DEBUG_LOG_OUT > \"$TEST_LOGFILE\" 2>&1\r\n...\r\ntest/net_tests.cpp(1311): Entering test case \"v2transport_test\"\r\n2023-09-06T04:19:04.842541Z [test] [test/util/random.cpp:31] [Seed] Seed: Setting random seed for current tests to RANDOM_CTX_SEED=c36f0537baafdf3bc691d89186094681ace7c42292794ea4d00fa784c3b4957b\r\n...\r\n2023-09-06T04:19:05.182858Z [test] [net.cpp:1237] [ProcessReceivedPacketBytes] [net]net.cpp:1129 ProcessReceivedKeyBytes: Assertion `m_recv_buffer.size() <= OFFSET + MATCH.size()' failed.\r\n```\r\n\r\nIn `previous releases, qt5 dev package and depends packages, DEBUG` it is not: https://cirrus-ci.com/task/4785261947650048?logs=ci#L3042\r\n```\r\nbash -c ' DIR_UNIT_TEST_DATA=/ci_container_base/ci/scratch/qa-assets/unit_test_data/ LD_LIBRARY_PATH=/ci_container_base/depends/x86_64-pc-linux-gnu/lib /ci_container_base/ci/scratch/out/bin/test_bitcoin --catch_system_errors=no -l test_suite'\r\n...\r\ntest/net_tests.cpp(1311): Entering test case \"v2transport_test\"\r\nnet.cpp:1129 ProcessReceivedKeyBytes: Assertion `m_recv_buffer.size() <= OFFSET + MATCH.size()' failed.\r\n/ci_container_base/ci/test/06_script_b.sh: line 170: 22342 Aborted                 bash -c \"${TEST_RUNNER_ENV} DIR_UNIT_TEST_DATA=${DIR_UNIT_TEST_DATA} LD_LIBRARY_PATH=${DEPENDS_DIR}/${HOST}/lib ${BASE_OUTDIR}/bin/test_bitcoin --catch_system_errors=no -l test_suite\"\r\n```\r\n\r\n@MarcoFalke do you have an idea if this is intentional? Any downsides to also use `DEBUG_LOG_OUT` in `previous releases, qt5 dev package and depends packages, DEBUG`?",
      "created_at": "2023-09-06T11:47:20Z",
      "updated_at": "2023-09-06T11:47:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1317159785",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317159785"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1340,
      "original_line": 1340,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317185255",
      "pull_request_review_id": 1613181865,
      "id": 1317185255,
      "node_id": "PRRC_kwDOABII585Ogqbn",
      "diff_hunk": "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 13);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.SendKey();\n+        tester.SendGarbage();\n+        tester.ReceiveKey();\n+        tester.SendGarbageTermAuth();\n+        tester.SendVersion();\n+        ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.ReceiveGarbage();\n+        tester.ReceiveVersion();\n+        auto msg_data_1 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(100000));",
      "path": "src/test/net_tests.cpp",
      "position": 343,
      "original_position": 326,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313245167,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, could be an oversight in `RUN_UNIT_TESTS_SEQUENTIAL`. Should be easy to fix there.",
      "created_at": "2023-09-06T12:11:04Z",
      "updated_at": "2023-09-06T12:11:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1317185255",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317185255"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1340,
      "original_line": 1340,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317187409",
      "pull_request_review_id": 1613185471,
      "id": 1317187409,
      "node_id": "PRRC_kwDOABII585Ogq9R",
      "diff_hunk": "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 13);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.SendKey();\n+        tester.SendGarbage();\n+        tester.ReceiveKey();\n+        tester.SendGarbageTermAuth();\n+        tester.SendVersion();\n+        ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.ReceiveGarbage();\n+        tester.ReceiveVersion();\n+        auto msg_data_1 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(100000));",
      "path": "src/test/net_tests.cpp",
      "position": 343,
      "original_position": 326,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313245167,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The basic idea is that the two files must specify the same config:\r\n\r\n```\r\n$ git grep catch_syst src/Makefile.test.include ./ci/\r\nci/test/06_script_b.sh:  bash -c \"${TEST_RUNNER_ENV} DIR_UNIT_TEST_DATA=${DIR_UNIT_TEST_DATA} LD_LIBRARY_PATH=${DEPENDS_DIR}/${HOST}/lib ${BASE_OUTDIR}/bin/test_bitcoin --catch_system_errors=no -l test_suite\"\r\nsrc/Makefile.test.include:      $(TEST_BINARY) --catch_system_errors=no -l test_suite -t \"$$(\\\r\n",
      "created_at": "2023-09-06T12:13:11Z",
      "updated_at": "2023-09-06T12:13:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1317187409",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317187409"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1340,
      "original_line": 1340,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317239183",
      "pull_request_review_id": 1613265638,
      "id": 1317239183,
      "node_id": "PRRC_kwDOABII585Og3mP",
      "diff_hunk": "@@ -910,24 +912,685 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short messages as defined in BIP324, in order.\n+ *\n+ * Only message types that are actually implemented in this codebase need to be listed, as other\n+ * messages get ignored anyway - whether we know how to decode them or not.\n+ */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::AWAITING_KEY : SendState::MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::AWAITING_KEY : SendState::MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        Assume(recv_state == RecvState::KEY || recv_state == RecvState::V1);\n+        break;\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        Assume(false); // V1 state cannot be left\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::MAYBE_V1:\n+        Assume(send_state == SendState::V1 || send_state == SendState::AWAITING_KEY);\n+        break;\n+    case SendState::AWAITING_KEY:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+    case SendState::V1:\n+        Assume(false); // Final states\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::ProcessReceivedMaybeV1Bytes() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public\n+    // key. BIP324 specifies that a mismatch with this 12-byte string should trigger sending of the\n+    // key.\n+    std::array<uint8_t, V1_PREFIX_LEN> v1_prefix = {0, 0, 0, 0, 'v', 'e', 'r', 's', 'i', 'o', 'n', 0};\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), v1_prefix.begin());\n+    Assume(m_recv_buffer.size() <= v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to AWAITING_KEY state (if not already).\n+        LOCK(m_send_mutex);\n+        SetSendState(SendState::AWAITING_KEY);\n+    } else if (m_recv_buffer.size() == v1_prefix.size()) {\n+        // Full match with the v1 prefix, so fall back to v1 behavior.\n+        LOCK(m_send_mutex);\n+        Span<const uint8_t> feedback{m_recv_buffer};\n+        // Feed already received bytes to v1 transport. It should always accept these, because it's\n+        // less than the size of a v1 header, and these are the first bytes fed to m_v1_fallback.\n+        bool ret = m_v1_fallback.ReceivedBytes(feedback);\n+        Assume(feedback.empty());\n+        Assume(ret);\n+        SetReceiveState(RecvState::V1);\n+        SetSendState(SendState::V1);\n+        // Reset v2 transport buffers to save memory.\n+        m_recv_buffer = {};\n+        m_send_buffer = {};\n+    } else {\n+        // We have not received enough to distinguish v1 from v2 yet. Wait until more bytes come.\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedKeyBytes() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received, and can now be Diffie-Hellman combined with\n+        // our key to initialize the encryption ciphers.\n+\n+        // As a special exception, if bytes 4-16 of the key on a responder connection match the\n+        // corresponding bytes of a V1 version message, but bytes 0-4 don't match the network magic\n+        // (if they did, we'd have switched to V1 state already), assume this is a peer from\n+        // another network, and disconnect them. They will almost certainly disconnect us too when\n+        // they receive our uniformly random key and garbage, but detecting this case specially\n+        // means we can log it.\n+        static constexpr std::array<uint8_t, 12> MATCH = {'v', 'e', 'r', 's', 'i', 'o', 'n', 0, 0, 0, 0, 0};\n+        static constexpr size_t OFFSET = sizeof(CMessageHeader::MessageStartChars);\n+        if (!m_initiating) {\n+            Assume(m_recv_buffer.size() <= OFFSET + MATCH.size());",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 246,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "2a5a7ffff72ee5cafae44ae814acbdfe128e7bb6",
      "in_reply_to_id": 1317138347,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed. I added a test, and noticed there was more wrong with this logic.",
      "created_at": "2023-09-06T12:54:28Z",
      "updated_at": "2023-09-06T12:54:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1317239183",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317239183"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1116,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317239365",
      "pull_request_review_id": 1613265936,
      "id": 1317239365,
      "node_id": "PRRC_kwDOABII585Og3pF",
      "diff_hunk": "@@ -1008,4 +1009,498 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would not permit scenarios that involve sending\n+ * invalid data, or ones scenarios using BIP324 features that are not implemented on the sending\n+ * side (like decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_REQUIRE(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_REQUIRE(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_REQUIRE(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            BOOST_REQUIRE(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_REQUIRE(ret.size() == payload.size() + 1 + CMessageHeader::COMMAND_SIZE);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(1 + CMessageHeader::COMMAND_SIZE) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(1 + CMessageHeader::COMMAND_SIZE + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1 + CMessageHeader::COMMAND_SIZE);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_REQUIRE(ret && ret->empty());\n+        tester.SendKey();\n+        tester.SendGarbage();\n+        tester.ReceiveKey();\n+        tester.SendGarbageTermAuth();\n+        tester.SendVersion();\n+        ret = tester.Interact();\n+        BOOST_REQUIRE(ret && ret->empty());\n+        tester.ReceiveGarbage();\n+        tester.ReceiveVersion();\n+        auto msg_data_1 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(100000));\n+        auto msg_data_2 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(1000));\n+        tester.SendMessage(uint8_t(4), msg_data_1); // cmpctblock short id\n+        tester.SendMessage(0, {}); // Invalidly encoded message\n+        tester.SendMessage(\"tx\", msg_data_2); // 12-character encoded message type\n+        ret = tester.Interact();\n+        BOOST_REQUIRE(ret && ret->size() == 3 &&\n+                      (*ret)[0] && (*ret)[0]->m_type == \"cmpctblock\" && Span{(*ret)[0]->m_recv} == MakeByteSpan(msg_data_1) &&\n+                      !(*ret)[1] &&\n+                      (*ret)[2] && (*ret)[2]->m_type == \"tx\" && Span{(*ret)[2]->m_recv} == MakeByteSpan(msg_data_2));",
      "path": "src/test/net_tests.cpp",
      "position": null,
      "original_position": 336,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "2a5a7ffff72ee5cafae44ae814acbdfe128e7bb6",
      "in_reply_to_id": 1317102038,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-09-06T12:54:37Z",
      "updated_at": "2023-09-06T12:54:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1317239365",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317239365"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 1333,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1336,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317373828",
      "pull_request_review_id": 1611552610,
      "id": 1317373828,
      "node_id": "PRRC_kwDOABII585OhYeE",
      "diff_hunk": "@@ -912,6 +912,428 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 30,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "c23640d313b2dade8a4349540738d64e4ce06bb0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in what cases do we want to set the state again? Might be good to `Assume` here too if it's not expected",
      "created_at": "2023-09-06T14:26:34Z",
      "updated_at": "2023-09-06T15:16:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1317373828",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317373828"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1017,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317376179",
      "pull_request_review_id": 1611552610,
      "id": 1317376179,
      "node_id": "PRRC_kwDOABII585OhZCz",
      "diff_hunk": "@@ -912,6 +912,428 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::AWAITING_KEY:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+        Assume(false); // Final state\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::ProcessReceivedKeyBytes() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received, and can now be Diffie-Hellman combined with\n+        // our key to initialize the encryption ciphers.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to READY.\n+        SetSendState(SendState::READY);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 110,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "c23640d313b2dade8a4349540738d64e4ce06bb0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could we annotate these args for reading clarity?",
      "created_at": "2023-09-06T14:28:04Z",
      "updated_at": "2023-09-06T15:16:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1317376179",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317376179"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1021,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317683430",
      "pull_request_review_id": 1613985410,
      "id": 1317683430,
      "node_id": "PRRC_kwDOABII585OikDm",
      "diff_hunk": "@@ -912,6 +912,428 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::AWAITING_KEY:\n+        Assume(send_state == SendState::READY);\n+        break;\n+    case SendState::READY:\n+        Assume(false); // Final state\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+void V2Transport::ProcessReceivedKeyBytes() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received, and can now be Diffie-Hellman combined with\n+        // our key to initialize the encryption ciphers.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to READY.\n+        SetSendState(SendState::READY);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 110,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "c23640d313b2dade8a4349540738d64e4ce06bb0",
      "in_reply_to_id": 1317376179,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-09-06T18:38:54Z",
      "updated_at": "2023-09-06T18:38:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1317683430",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317683430"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1021,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317684218",
      "pull_request_review_id": 1613986726,
      "id": 1317684218,
      "node_id": "PRRC_kwDOABII585OikP6",
      "diff_hunk": "@@ -912,6 +912,428 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 30,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "c23640d313b2dade8a4349540738d64e4ce06bb0",
      "in_reply_to_id": 1317373828,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We set the state any time the state changes. The conditions for that are in the `ProcessReceived*Bytes` functions. I'm not sure I understand the question here.",
      "created_at": "2023-09-06T18:39:47Z",
      "updated_at": "2023-09-06T18:39:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1317684218",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317684218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1017,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317685923",
      "pull_request_review_id": 1613989430,
      "id": 1317685923,
      "node_id": "PRRC_kwDOABII585Oikqj",
      "diff_hunk": "@@ -912,6 +912,69 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short messages as defined in BIP324, in order.\n+ *\n+ * Only message types that are actually implemented in this codebase need to be listed, as other\n+ * messages get ignored anyway - whether we know how to decode them or not.\n+ */\n+const std::string V2_MESSAGE_IDS[] = {",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 11,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "ff64d9e6ddc209842ed1d317eab4c50436947a7b",
      "in_reply_to_id": 1316316591,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The two lists need to match in all implemented messages. My thinking was that if messages get added after the Erlay ones in the BIP, before Erlay being implemented in this codebase, we'd introduce dummies for the Erlay ones.\r\n\r\nBut it's probably clearer to do that right now already, so I've done so here. I've also added an assert that the total length is 33.",
      "created_at": "2023-09-06T18:41:40Z",
      "updated_at": "2023-09-06T18:41:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1317685923",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317685923"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 922,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317709089",
      "pull_request_review_id": 1614025193,
      "id": 1317709089,
      "node_id": "PRRC_kwDOABII585OiqUh",
      "diff_hunk": "@@ -912,6 +912,428 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 30,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "c23640d313b2dade8a4349540738d64e4ce06bb0",
      "in_reply_to_id": 1317373828,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "to rephrase, this?\r\n\r\n```suggestion\r\n    if (recv_state == m_recv_state) { Assume(false); return; }\r\n```",
      "created_at": "2023-09-06T19:04:32Z",
      "updated_at": "2023-09-06T19:04:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1317709089",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317709089"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1017,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317719741",
      "pull_request_review_id": 1614041448,
      "id": 1317719741,
      "node_id": "PRRC_kwDOABII585Ois69",
      "diff_hunk": "@@ -912,6 +912,428 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 30,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "c23640d313b2dade8a4349540738d64e4ce06bb0",
      "in_reply_to_id": 1317373828,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh, I see, you meant \"tell me, when do we set the state **again** to the same state?\", not \"tell me **again**, when do we set the state?\".\r\n\r\nThis wasn't the case in earlier iterations of this PR, but currently we indeed never set a state to its current value again. Enforced that by just dropping the \"if (recv_state == m_recv_state)\" conditional entirely (for both receiving and sending).",
      "created_at": "2023-09-06T19:14:23Z",
      "updated_at": "2023-09-06T19:14:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1317719741",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1317719741"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1017,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318433224",
      "pull_request_review_id": 1615162515,
      "id": 1318433224,
      "node_id": "PRRC_kwDOABII585OlbHI",
      "diff_hunk": "@@ -910,24 +912,691 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short messages as defined in BIP324, in order.\n+ *\n+ * Only message types that are actually implemented in this codebase need to be listed, as other\n+ * messages get ignored anyway - whether we know how to decode them or not.\n+ */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    // Unimplemented message types that are assigned in BIP324:\n+    \"\",\n+    \"\",\n+    \"\",\n+    \"\"\n+};\n+\n+static_assert(std::size(V2_MESSAGE_IDS) == 33);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 76,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "15ea0ce587a334b647119fe65de2b305720c3eba",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit:\r\n\r\n```cpp\r\nconst std::string V2_MESSAGE_IDS[] = {...};\r\nstatic_assert(std::size(V2_MESSAGE_IDS) == 33);\r\n```\r\n\r\nWhat the following instead:\r\n\r\n```cpp\r\nstd::array<std::string, 33> V2_MESSAGE_IDS[] = {...};\r\n```",
      "created_at": "2023-09-07T10:52:33Z",
      "updated_at": "2023-09-07T12:23:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1318433224",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318433224"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 959,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318561404",
      "pull_request_review_id": 1615363627,
      "id": 1318561404,
      "node_id": "PRRC_kwDOABII585Ol6Z8",
      "diff_hunk": "@@ -982,9 +992,48 @@ bool V2Transport::ReceivedMessageComplete() const noexcept\n {\n     AssertLockNotHeld(m_recv_mutex);\n     LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n     return m_recv_state == RecvState::APP_READY;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1Bytes() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public\n+    // key. BIP324 specifies that a mismatch with this 12-byte string should trigger sending of the\n+    // key.\n+    std::array<uint8_t, V1_PREFIX_LEN> v1_prefix = {0, 0, 0, 0, 'v', 'e', 'r', 's', 'i', 'o', 'n', 0};\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), v1_prefix.begin());\n+    Assume(m_recv_buffer.size() <= v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to AWAITING_KEY state (if not already).",
      "path": "src/net.cpp",
      "position": 206,
      "original_position": 87,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "6227597da11b79331904b6a82c5e8994fe5a4163",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "small nit:\r\n```suggestion\r\n        // Transition the sender to AWAITING_KEY state.\r\n```\r\nTo my understanding, no-op state transitions are not possible anymore (otherwise, one of the assertions in `SetSendState` would fail), and we could only hit this path if the sender state is MAYBE_V1.",
      "created_at": "2023-09-07T12:54:40Z",
      "updated_at": "2023-09-07T13:07:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1318561404",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318561404"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1090,
      "original_line": 1090,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318563625",
      "pull_request_review_id": 1615363627,
      "id": 1318563625,
      "node_id": "PRRC_kwDOABII585Ol68p",
      "diff_hunk": "@@ -334,6 +335,22 @@ std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n     return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n }\n \n+template<typename RNG>\n+std::unique_ptr<Transport> MakeV2Transport(NodeId nodeid, bool initiator, RNG& rng, FuzzedDataProvider& provider)\n+{\n+    // Retrieve key\n+    auto key_data = provider.ConsumeBytes<unsigned char>(32);\n+    key_data.resize(32);\n+    CKey key;\n+    key.Set(key_data.begin(), key_data.end(), true);",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "7371d7a1a57aaf0f6add3922ae7753fe9b598552",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "potential follow-up: after rebase, could now use `ConsumePrivateKey` (#28419 was merged today).",
      "created_at": "2023-09-07T12:56:35Z",
      "updated_at": "2023-09-07T13:07:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1318563625",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318563625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 342,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 345,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318573111",
      "pull_request_review_id": 1615363627,
      "id": 1318573111,
      "node_id": "PRRC_kwDOABII585Ol9Q3",
      "diff_hunk": "@@ -912,6 +912,427 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "7371d7a1a57aaf0f6add3922ae7753fe9b598552",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "follow-up consideration: the two V2Transport constructors have a lot of code in common, is it somehow possible to deduplicate their implementation (e.g. with another private constructor)?",
      "created_at": "2023-09-07T13:04:18Z",
      "updated_at": "2023-09-07T13:07:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1318573111",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318573111"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 926,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 930,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318578731",
      "pull_request_review_id": 1615391325,
      "id": 1318578731,
      "node_id": "PRRC_kwDOABII585Ol-or",
      "diff_hunk": "@@ -982,9 +992,48 @@ bool V2Transport::ReceivedMessageComplete() const noexcept\n {\n     AssertLockNotHeld(m_recv_mutex);\n     LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n     return m_recv_state == RecvState::APP_READY;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1Bytes() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public\n+    // key. BIP324 specifies that a mismatch with this 12-byte string should trigger sending of the\n+    // key.\n+    std::array<uint8_t, V1_PREFIX_LEN> v1_prefix = {0, 0, 0, 0, 'v', 'e', 'r', 's', 'i', 'o', 'n', 0};\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), v1_prefix.begin());\n+    Assume(m_recv_buffer.size() <= v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to AWAITING_KEY state (if not already).",
      "path": "src/net.cpp",
      "position": 206,
      "original_position": 87,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "6227597da11b79331904b6a82c5e8994fe5a4163",
      "in_reply_to_id": 1318561404,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agree. Will address if I push again.",
      "created_at": "2023-09-07T13:08:48Z",
      "updated_at": "2023-09-07T13:08:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1318578731",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318578731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1090,
      "original_line": 1090,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318579194",
      "pull_request_review_id": 1615392011,
      "id": 1318579194,
      "node_id": "PRRC_kwDOABII585Ol-v6",
      "diff_hunk": "@@ -334,6 +335,22 @@ std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n     return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n }\n \n+template<typename RNG>\n+std::unique_ptr<Transport> MakeV2Transport(NodeId nodeid, bool initiator, RNG& rng, FuzzedDataProvider& provider)\n+{\n+    // Retrieve key\n+    auto key_data = provider.ConsumeBytes<unsigned char>(32);\n+    key_data.resize(32);\n+    CKey key;\n+    key.Set(key_data.begin(), key_data.end(), true);",
      "path": "src/test/fuzz/p2p_transport_serialization.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "7371d7a1a57aaf0f6add3922ae7753fe9b598552",
      "in_reply_to_id": 1318563625,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-09-07T13:09:09Z",
      "updated_at": "2023-09-07T13:09:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1318579194",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318579194"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 342,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 345,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318581810",
      "pull_request_review_id": 1615396388,
      "id": 1318581810,
      "node_id": "PRRC_kwDOABII585Ol_Yy",
      "diff_hunk": "@@ -912,6 +912,427 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "7371d7a1a57aaf0f6add3922ae7753fe9b598552",
      "in_reply_to_id": 1318573111,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've considered that, but I like that the \"production\" constructor here can use the default `BIP324Cipher` constructor (leaving the random key generation there). Unfortunately that does mean some duplication, because the other constructor can't be written that way.\r\n\r\nMaybe the solution is only having explicit constructors on `BIP324Cipher` and doing the random key generation here. Perhaps something for a follow-up?",
      "created_at": "2023-09-07T13:11:17Z",
      "updated_at": "2023-09-07T13:11:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1318581810",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318581810"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 926,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 930,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318582008",
      "pull_request_review_id": 1615396896,
      "id": 1318582008,
      "node_id": "PRRC_kwDOABII585Ol_b4",
      "diff_hunk": "@@ -910,24 +912,691 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short messages as defined in BIP324, in order.\n+ *\n+ * Only message types that are actually implemented in this codebase need to be listed, as other\n+ * messages get ignored anyway - whether we know how to decode them or not.\n+ */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    // Unimplemented message types that are assigned in BIP324:\n+    \"\",\n+    \"\",\n+    \"\",\n+    \"\"\n+};\n+\n+static_assert(std::size(V2_MESSAGE_IDS) == 33);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 76,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "15ea0ce587a334b647119fe65de2b305720c3eba",
      "in_reply_to_id": 1318433224,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good idea, done.",
      "created_at": "2023-09-07T13:11:28Z",
      "updated_at": "2023-09-07T13:11:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1318582008",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1318582008"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 959,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1319051315",
      "pull_request_review_id": 1616138470,
      "id": 1319051315,
      "node_id": "PRRC_kwDOABII585OnyAz",
      "diff_hunk": "@@ -912,6 +912,418 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        Assume(recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        Assume(recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::GARBAUTH:\n+        Assume(recv_state == RecvState::VERSION);\n+        break;\n+    case RecvState::VERSION:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    case RecvState::APP:\n+        Assume(recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        Assume(recv_state == RecvState::APP);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;\n+    // Enforce allowed state transitions.\n+    switch (m_send_state) {\n+    case SendState::KEY:\n+        Assume(send_state == SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        break;\n+    case SendState::KEY_GARBTERM_GARBAUTH_VERSION:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    case SendState::APP_READY:\n+        Assume(send_state == SendState::APP);\n+        break;\n+    case SendState::APP:\n+        Assume(send_state == SendState::APP_READY);\n+        break;\n+    }\n+    // Change state.\n+    m_send_state = send_state;\n+}\n+\n+bool V2Transport::ReceivedMessageComplete() const noexcept\n+{\n+    AssertLockNotHeld(m_recv_mutex);\n+    LOCK(m_recv_mutex);\n+    return m_recv_state == RecvState::APP_READY;\n+}\n+\n+size_t V2Transport::GetMaxBytesToProcess() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    switch (m_recv_state) {\n+    case RecvState::KEY:\n+        // During the KEY state, we only allow the 64-byte key into the receive buffer.\n+        Assume(m_recv_buffer.size() <= EllSwiftPubKey::size());\n+        // As long as we have not received the other side's public key, don't receive more than\n+        // that (64 bytes), as garbage follows, and locating the garbage terminator requires the\n+        // key exchange first.\n+        return EllSwiftPubKey::size() - m_recv_buffer.size();\n+    case RecvState::GARB_GARBTERM:\n+        // Process garbage bytes one by one (because terminator may appear anywhere).\n+        return 1;\n+    case RecvState::GARBAUTH:\n+    case RecvState::VERSION:\n+    case RecvState::APP:\n+        // These three states all involve decoding a packet. Process the length descriptor first,\n+        // followed by the ciphertext.\n+        if (m_recv_buffer.size() < BIP324Cipher::LENGTH_LEN) {\n+            return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();\n+        } else {\n+            // Note that BIP324Cipher::EXPANSION is the total difference between contents size\n+            // and encoded packet size, which includes the 3 bytes due to the packet length.\n+            // When transitioning from receiving the packet length to receiving its ciphertext,\n+            // the encrypted packet length is left in the receive buffer.\n+            return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();\n+        }\n+    case RecvState::APP_READY:\n+        // No bytes can be processed until GetMessage() is called.\n+        return 0;\n+    }\n+    Assume(false); // unreachable\n+    return 0;\n+}\n+\n+void V2Transport::ProcessReceivedKey() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY);\n+    if (m_recv_buffer.size() == EllSwiftPubKey::size()) {\n+        // Other side's key has been fully received.\n+\n+        // Initialize the ciphers.\n+        EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));\n+        LOCK(m_send_mutex);\n+        m_cipher.Initialize(ellswift, m_initiating);\n+\n+        // Switch receiver state to GARB_GARBTERM.\n+        SetReceiveState(RecvState::GARB_GARBTERM);\n+        m_recv_buffer.clear();\n+\n+        // Switch sender state to KEY_GARBTERM_GARBAUTH_VERSION.\n+        SetSendState(SendState::KEY_GARBTERM_GARBAUTH_VERSION);\n+        // Append the garbage terminator to the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        std::copy(m_cipher.GetSendGarbageTerminator().begin(),\n+                  m_cipher.GetSendGarbageTerminator().end(),\n+                  MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\n+        // Construct garbage authentication packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(\n+            {},\n+            {}, /* empty garbage for now */\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION));\n+        // Construct version packet in the send buffer.\n+        m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());\n+        m_cipher.Encrypt(\n+            VERSION_CONTENTS,\n+            {},\n+            false,\n+            MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));\n+    }\n+}\n+\n+bool V2Transport::ProcessReceivedGarbage() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    Assume(m_recv_state == RecvState::GARB_GARBTERM);\n+    Assume(m_recv_buffer.size() <= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+    if (m_recv_buffer.size() >= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+        if (MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN) == m_cipher.GetReceiveGarbageTerminator()) {\n+            // Garbage terminator received. Switch to receiving garbage authentication packet.\n+            m_recv_garbage = std::move(m_recv_buffer);\n+            m_recv_garbage.resize(m_recv_garbage.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            m_recv_buffer.clear();\n+            SetReceiveState(RecvState::GARBAUTH);\n+        } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {\n+            // We've reached the maximum length for garbage + garbage terminator, and the\n+            // terminator still does not match. Abort.\n+            LogPrint(BCLog::NET, \"V2 transport error: missing garbage terminator, peer=%d\\n\", m_nodeid);",
      "path": "src/net.cpp",
      "position": 311,
      "original_position": 179,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "25b0668c72f762df474c29e678e4baf69cff506c",
      "in_reply_to_id": 1315189334,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I used this in #27826, but it requires having access to the whole `CNode&`, not just `m_nodeid`:\r\n\r\n```\r\nfLogIPs ? strprintf(\" peeraddr=%s\", peer.addr.ToStringAddrPort()) : \"\"\r\n```\r\n\r\nCan wait for followup (and at some point should be a helper function).",
      "created_at": "2023-09-07T19:48:20Z",
      "updated_at": "2023-09-07T19:48:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1319051315",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1319051315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1195,
      "original_line": 1195,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1319078297",
      "pull_request_review_id": 1616178583,
      "id": 1319078297,
      "node_id": "PRRC_kwDOABII585On4mZ",
      "diff_hunk": "@@ -1327,6 +1330,40 @@ bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n     while (!msg_bytes.empty()) {\n         // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n         size_t max_read = GetMaxBytesToProcess();\n+\n+        // Reserve space in the buffer if there is not enough.\n+        if (m_recv_buffer.size() + std::min(msg_bytes.size(), max_read) > m_recv_buffer.capacity()) {\n+            switch (m_recv_state) {\n+            case RecvState::KEY_MAYBE_V1:\n+            case RecvState::KEY:\n+            case RecvState::GARB_GARBTERM:\n+                // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+                // bytes).\n+                m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+                break;\n+            case RecvState::GARBAUTH:\n+            case RecvState::VERSION:\n+            case RecvState::APP: {\n+                // During states where a packet is being received, as much as is expected but never\n+                // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+                // This means attackers that want to cause us to waste allocated memory are limited\n+                // to MAX_RESERVE_AHEAD above the largest allowed message contents size, and to\n+                // MAX_RESERVE_AHEAD more than they've actually sent us.\n+                size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+                m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);",
      "path": "src/net.cpp",
      "position": 487,
      "original_position": 34,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "297c8889975a18258d6cc39b1ec1e94fed6630fb",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "297c8889975a18258d6cc39b1ec1e94fed6630fb: since the code worked before this commit, what happens we don't call `reserve`? Does that result in de worst case where the operating system allocates one byte at a time?",
      "created_at": "2023-09-07T20:15:49Z",
      "updated_at": "2023-09-07T20:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1319078297",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1319078297"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1371,
      "original_line": 1353,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1319091876",
      "pull_request_review_id": 1616199643,
      "id": 1319091876,
      "node_id": "PRRC_kwDOABII585On76k",
      "diff_hunk": "@@ -1327,6 +1330,40 @@ bool V2Transport::ReceivedBytes(Span<const uint8_t>& msg_bytes) noexcept\n     while (!msg_bytes.empty()) {\n         // Decide how many bytes to copy from msg_bytes to m_recv_buffer.\n         size_t max_read = GetMaxBytesToProcess();\n+\n+        // Reserve space in the buffer if there is not enough.\n+        if (m_recv_buffer.size() + std::min(msg_bytes.size(), max_read) > m_recv_buffer.capacity()) {\n+            switch (m_recv_state) {\n+            case RecvState::KEY_MAYBE_V1:\n+            case RecvState::KEY:\n+            case RecvState::GARB_GARBTERM:\n+                // During the initial states (key/garbage), allocate once to fit the maximum (4111\n+                // bytes).\n+                m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+                break;\n+            case RecvState::GARBAUTH:\n+            case RecvState::VERSION:\n+            case RecvState::APP: {\n+                // During states where a packet is being received, as much as is expected but never\n+                // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.\n+                // This means attackers that want to cause us to waste allocated memory are limited\n+                // to MAX_RESERVE_AHEAD above the largest allowed message contents size, and to\n+                // MAX_RESERVE_AHEAD more than they've actually sent us.\n+                size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);\n+                m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);",
      "path": "src/net.cpp",
      "position": 487,
      "original_position": 34,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "297c8889975a18258d6cc39b1ec1e94fed6630fb",
      "in_reply_to_id": 1319078297,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Most std::vector implementations double their memory usage whenever they don't have enough, I believe. So without this code, you'd actually get fewer reallocations for large messages actually, but also more easily wasted (allocated but unused) memory.",
      "created_at": "2023-09-07T20:31:49Z",
      "updated_at": "2023-09-07T20:31:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1319091876",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1319091876"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1371,
      "original_line": 1353,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1319134141",
      "pull_request_review_id": 1609918939,
      "id": 1319134141,
      "node_id": "PRRC_kwDOABII585OoGO9",
      "diff_hunk": "@@ -1490,7 +1498,10 @@ void V2Transport::MarkBytesSent(size_t bytes_sent) noexcept\n \n     m_send_pos += bytes_sent;\n     Assume(m_send_pos <= m_send_buffer.size());\n-    if (m_send_pos == m_send_buffer.size()) {\n+    // Only wipe the buffer when everything is sent in the READY state. In the AWAITING_KEY state\n+    // we still need the garbage that's in the send buffer to construct the garbage authentication\n+    // packet.\n+    if (m_send_state == SendState::READY && m_send_pos == m_send_buffer.size()) {",
      "path": "src/net.cpp",
      "position": 675,
      "original_position": 61,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "3ffa5fb49ee4a6d9502aa957093bd94058630282",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "While this shortcut works, I wonder if it would be conceptually clearer to not have this special case and instead save the garbage in a `m_send_garbage` vector, similar to the existing `m_recv_garbage` on the receive side.",
      "created_at": "2023-09-07T21:27:07Z",
      "updated_at": "2023-09-07T22:58:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1319134141",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1319134141"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1559,
      "original_line": 1504,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1319196783",
      "pull_request_review_id": 1616353457,
      "id": 1319196783,
      "node_id": "PRRC_kwDOABII585OoVhv",
      "diff_hunk": "@@ -1490,7 +1498,10 @@ void V2Transport::MarkBytesSent(size_t bytes_sent) noexcept\n \n     m_send_pos += bytes_sent;\n     Assume(m_send_pos <= m_send_buffer.size());\n-    if (m_send_pos == m_send_buffer.size()) {\n+    // Only wipe the buffer when everything is sent in the READY state. In the AWAITING_KEY state\n+    // we still need the garbage that's in the send buffer to construct the garbage authentication\n+    // packet.\n+    if (m_send_state == SendState::READY && m_send_pos == m_send_buffer.size()) {",
      "path": "src/net.cpp",
      "position": 675,
      "original_position": 61,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "3ffa5fb49ee4a6d9502aa957093bd94058630282",
      "in_reply_to_id": 1319134141,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'll do this if I make further changes to the PR, or as a follow-up. It would also simplify something else: getting rid of the \"don't send in MABE_V1 state\" exception, by only putting stuff in the send buffer when leaving that state.",
      "created_at": "2023-09-07T23:07:02Z",
      "updated_at": "2023-09-07T23:07:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1319196783",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1319196783"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1559,
      "original_line": 1504,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1319605884",
      "pull_request_review_id": 1617061232,
      "id": 1319605884,
      "node_id": "PRRC_kwDOABII585Op5Z8",
      "diff_hunk": "@@ -912,6 +912,427 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "7371d7a1a57aaf0f6add3922ae7753fe9b598552",
      "in_reply_to_id": 1318573111,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I played with this some time ago. I used a private constructor that is called by the other two public constructors (see [delegating constructor](https://stroustrup.com/C++11FAQ.html#delegating-ctor)). One problem was that `BIP324Cipher` is not movable, so I involved `std::forward` to pass the arguments from the public ctors to the private one which would construct the `BIP324Cipher` object. It worked. Also the private ctor had to have different arguments than the public ones, so I added a dummy `nullptr_t` first arg (:disappointed:). Then in a later commit of this PR the two public ctors diverged and were not identical anymore, so I decided to ditch the idea.",
      "created_at": "2023-09-08T09:26:49Z",
      "updated_at": "2023-09-08T09:26:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1319605884",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1319605884"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 926,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 930,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320246543",
      "pull_request_review_id": 1618111474,
      "id": 1320246543,
      "node_id": "PRRC_kwDOABII585OsV0P",
      "diff_hunk": "@@ -910,24 +912,632 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+namespace {\n+\n+/** List of short message IDs as defined in BIP324, in order. */\n+const std::string V2_MESSAGE_IDS[] = {\n+    \"\", // 12 bytes follow encoding the message type like in V1\n+    NetMsgType::ADDR,\n+    NetMsgType::BLOCK,\n+    NetMsgType::BLOCKTXN,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::GETDATA,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::HEADERS,\n+    NetMsgType::INV,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::TX,\n+    NetMsgType::GETCFILTERS,\n+    NetMsgType::CFILTER,\n+    NetMsgType::GETCFHEADERS,\n+    NetMsgType::CFHEADERS,\n+    NetMsgType::GETCFCHECKPT,\n+    NetMsgType::CFCHECKPT,\n+    NetMsgType::ADDRV2,\n+    \"reqrecon\",\n+    \"sketch\",\n+    \"reqsketchext\",\n+    \"reconcildiff\",\n+};\n+\n+class V2MessageMap\n+{\n+    std::unordered_map<std::string, uint8_t> m_map;\n+\n+public:\n+    V2MessageMap() noexcept\n+    {\n+        for (size_t i = 1; i < std::size(V2_MESSAGE_IDS); ++i) {\n+            m_map.emplace(V2_MESSAGE_IDS[i], i);\n+        }\n+    }\n+\n+    std::optional<uint8_t> operator()(const std::string& message_name) const noexcept\n+    {\n+        auto it = m_map.find(message_name);\n+        if (it == m_map.end()) return std::nullopt;\n+        return it->second;\n+    }\n+};\n+\n+const V2MessageMap V2_MESSAGE_MAP;\n+\n+} // namespace\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    // Construct garbage (including its length) using a FastRandomContext.\n+    FastRandomContext rng;\n+    size_t garbage_len = rng.randrange(MAX_GARBAGE_LEN + 1);\n+    // Initialize the send buffer with ellswift pubkey + garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage_len);\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    rng.fillrand(MakeWritableByteSpan(m_send_buffer).subspan(EllSwiftPubKey::size()));\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32, Span<const uint8_t> garbage) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_v1_fallback{nodeid, type_in, version_in}, m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},\n+    m_send_state{initiating ? SendState::KEY_GARB : SendState::KEY_GARB_MAYBE_V1}\n+{\n+    assert(garbage.size() <= MAX_GARBAGE_LEN);\n+    // Initialize the send buffer with ellswift pubkey + provided garbage.\n+    m_send_buffer.resize(EllSwiftPubKey::size() + garbage.size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+    std::copy(garbage.begin(), garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());\n+    // Determine v1 prefix\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_v1_prefix.begin());\n+}\n+\n+void V2Transport::SetReceiveState(RecvState recv_state) noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    // No-op if no change is desired.\n+    if (recv_state == m_recv_state) return;\n+    // Enforce allowed state transitions.\n+    switch (recv_state) {\n+    case RecvState::KEY_MAYBE_V1:\n+        // Initial state, cannot be transitioned into.\n+        assert(false);\n+        break;\n+    case RecvState::KEY:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    case RecvState::GARB_GARBTERM:\n+        assert(m_recv_state == RecvState::KEY);\n+        break;\n+    case RecvState::GARBAUTH:\n+        assert(m_recv_state == RecvState::GARB_GARBTERM);\n+        break;\n+    case RecvState::VERSION:\n+        assert(m_recv_state == RecvState::GARBAUTH);\n+        break;\n+    case RecvState::APP:\n+        assert(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP_READY);\n+        break;\n+    case RecvState::APP_READY:\n+        assert(m_recv_state == RecvState::APP);\n+        break;\n+    case RecvState::V1:\n+        assert(m_recv_state == RecvState::KEY_MAYBE_V1);\n+        break;\n+    }\n+    // Change state.\n+    m_recv_state = recv_state;\n+}\n+\n+void V2Transport::SetSendState(SendState send_state) noexcept\n+{\n+    AssertLockHeld(m_send_mutex);\n+    // No-op if no change is desired.\n+    if (send_state == m_send_state) return;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 168,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313034598,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For posterity, the ability to transition from a state to itself is gone entirely.",
      "created_at": "2023-09-08T19:14:08Z",
      "updated_at": "2023-09-08T19:14:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1320246543",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320246543"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1053,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320257893",
      "pull_request_review_id": 1618131367,
      "id": 1320257893,
      "node_id": "PRRC_kwDOABII585OsYll",
      "diff_hunk": "@@ -982,9 +992,48 @@ bool V2Transport::ReceivedMessageComplete() const noexcept\n {\n     AssertLockNotHeld(m_recv_mutex);\n     LOCK(m_recv_mutex);\n+    if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();\n+\n     return m_recv_state == RecvState::APP_READY;\n }\n \n+void V2Transport::ProcessReceivedMaybeV1Bytes() noexcept\n+{\n+    AssertLockHeld(m_recv_mutex);\n+    AssertLockNotHeld(m_send_mutex);\n+    Assume(m_recv_state == RecvState::KEY_MAYBE_V1);\n+    // We still have to determine if this is a v1 or v2 connection. The bytes being received could\n+    // be the beginning of either a v1 packet (network magic + \"version\\x00\"), or of a v2 public\n+    // key. BIP324 specifies that a mismatch with this 12-byte string should trigger sending of the\n+    // key.\n+    std::array<uint8_t, V1_PREFIX_LEN> v1_prefix = {0, 0, 0, 0, 'v', 'e', 'r', 's', 'i', 'o', 'n', 0};\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), v1_prefix.begin());\n+    Assume(m_recv_buffer.size() <= v1_prefix.size());\n+    if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), v1_prefix.begin())) {\n+        // Mismatch with v1 prefix, so we can assume a v2 connection.\n+        SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.\n+        // Transition the sender to AWAITING_KEY state (if not already).",
      "path": "src/net.cpp",
      "position": 206,
      "original_position": 87,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "6227597da11b79331904b6a82c5e8994fe5a4163",
      "in_reply_to_id": 1318561404,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done in #28433.",
      "created_at": "2023-09-08T19:29:16Z",
      "updated_at": "2023-09-08T19:29:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1320257893",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320257893"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1090,
      "original_line": 1090,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320258024",
      "pull_request_review_id": 1618131566,
      "id": 1320258024,
      "node_id": "PRRC_kwDOABII585OsYno",
      "diff_hunk": "@@ -912,6 +912,427 @@ size_t V1Transport::GetSendMemoryUsage() const noexcept\n     return m_message_to_send.GetMemoryUsage();\n }\n \n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in) noexcept :\n+    m_cipher{}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}\n+{\n+    // Initialize the send buffer with ellswift pubkey.\n+    m_send_buffer.resize(EllSwiftPubKey::size());\n+    std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());\n+}\n+\n+V2Transport::V2Transport(NodeId nodeid, bool initiating, int type_in, int version_in, const CKey& key, Span<const std::byte> ent32) noexcept :\n+    m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},\n+    m_recv_type{type_in}, m_recv_version{version_in},\n+    m_recv_state{RecvState::KEY},\n+    m_send_state{SendState::AWAITING_KEY}",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "7371d7a1a57aaf0f6add3922ae7753fe9b598552",
      "in_reply_to_id": 1318573111,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done in #28433.",
      "created_at": "2023-09-08T19:29:27Z",
      "updated_at": "2023-09-08T19:29:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1320258024",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320258024"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": 926,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 930,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320258165",
      "pull_request_review_id": 1618131808,
      "id": 1320258165,
      "node_id": "PRRC_kwDOABII585OsYp1",
      "diff_hunk": "@@ -1008,4 +1009,498 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would not permit scenarios that involve sending\n+ * invalid data, or ones scenarios using BIP324 features that are not implemented on the sending",
      "path": "src/test/net_tests.cpp",
      "position": 19,
      "original_position": 19,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "59f1dd13958ab76ff9ea34a47b60bb73f336c81e",
      "in_reply_to_id": 1315179378,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done in #28433.",
      "created_at": "2023-09-08T19:29:39Z",
      "updated_at": "2023-09-08T19:29:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1320258165",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320258165"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1016,
      "original_line": 1016,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320258309",
      "pull_request_review_id": 1618132015,
      "id": 1320258309,
      "node_id": "PRRC_kwDOABII585OsYsF",
      "diff_hunk": "@@ -1490,7 +1498,10 @@ void V2Transport::MarkBytesSent(size_t bytes_sent) noexcept\n \n     m_send_pos += bytes_sent;\n     Assume(m_send_pos <= m_send_buffer.size());\n-    if (m_send_pos == m_send_buffer.size()) {\n+    // Only wipe the buffer when everything is sent in the READY state. In the AWAITING_KEY state\n+    // we still need the garbage that's in the send buffer to construct the garbage authentication\n+    // packet.\n+    if (m_send_state == SendState::READY && m_send_pos == m_send_buffer.size()) {",
      "path": "src/net.cpp",
      "position": 675,
      "original_position": 61,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "3ffa5fb49ee4a6d9502aa957093bd94058630282",
      "in_reply_to_id": 1319134141,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done in #28433.",
      "created_at": "2023-09-08T19:29:50Z",
      "updated_at": "2023-09-08T19:29:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1320258309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320258309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1559,
      "original_line": 1504,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320321145",
      "pull_request_review_id": 1618235042,
      "id": 1320321145,
      "node_id": "PRRC_kwDOABII585OsoB5",
      "diff_hunk": "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 13);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.SendKey();\n+        tester.SendGarbage();\n+        tester.ReceiveKey();\n+        tester.SendGarbageTermAuth();\n+        tester.SendVersion();\n+        ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.ReceiveGarbage();\n+        tester.ReceiveVersion();\n+        auto msg_data_1 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(100000));",
      "path": "src/test/net_tests.cpp",
      "position": 343,
      "original_position": 326,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313245167,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In #28433 I'm making part of the unit tests' key material be generated by the test RNG (as a side-effect of other changes, but it's relevant here).",
      "created_at": "2023-09-08T20:38:30Z",
      "updated_at": "2023-09-08T20:38:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1320321145",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320321145"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1340,
      "original_line": 1340,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320787718",
      "pull_request_review_id": 1618843661,
      "id": 1320787718,
      "node_id": "PRRC_kwDOABII585OuZ8G",
      "diff_hunk": "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 13);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.SendKey();\n+        tester.SendGarbage();\n+        tester.ReceiveKey();\n+        tester.SendGarbageTermAuth();\n+        tester.SendVersion();\n+        ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.ReceiveGarbage();\n+        tester.ReceiveVersion();\n+        auto msg_data_1 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(100000));",
      "path": "src/test/net_tests.cpp",
      "position": 343,
      "original_position": 326,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313245167,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> The basic idea is that the two files must specify the same config:\r\n\r\nFWIW, I won't be working on this fix. Maybe something to keep in mind for the cmake migration and fix there?",
      "created_at": "2023-09-10T15:17:43Z",
      "updated_at": "2023-09-10T15:17:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1320787718",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320787718"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1340,
      "original_line": 1340,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1324117579",
      "pull_request_review_id": 1623916284,
      "id": 1324117579,
      "node_id": "PRRC_kwDOABII585O7G5L",
      "diff_hunk": "@@ -1008,4 +1009,496 @@ BOOST_AUTO_TEST_CASE(advertise_local_address)\n     RemoveLocal(addr_cjdns);\n }\n \n+namespace {\n+\n+/** A class for scenario-based tests of V2Transport\n+ *\n+ * Each V2TransportTester encapsulates a V2Transport (the one being tested), and can be told to\n+ * interact with it. To do so, it also encapsulates a BIP324Cipher to act as the other side. A\n+ * second V2Transport is not used, as doing so would prevent scenarios that are permitted by BIP324\n+ * but not implemented (such as the sending of decoy packets).\n+ */\n+class V2TransportTester\n+{\n+    V2Transport m_transport; //!< V2Transport being tested\n+    BIP324Cipher m_cipher; //!< Cipher to help with the other side\n+    bool m_test_initiator; //!< Whether m_transport is the initiator (true) or responder (false)\n+\n+    std::vector<uint8_t> m_sent_garbage; //!< The garbage we've sent to m_transport.\n+    std::vector<uint8_t> m_to_send; //!< Bytes we have queued up to send to m_transport.\n+    std::vector<uint8_t> m_received; //!< Bytes we have received from m_transport.\n+    std::deque<CSerializedNetMsg> m_msg_to_send; //!< Messages to be sent *by* m_transport to us.\n+\n+public:\n+    /** Construct a tester object. test_initiator: whether the tested transport is initiator. */\n+    V2TransportTester(bool test_initiator) :\n+        m_transport(0, test_initiator, SER_NETWORK, INIT_PROTO_VERSION),\n+        m_test_initiator(test_initiator) {}\n+\n+    /** Data type returned by Interact:\n+     *\n+     * - std::nullopt: transport error occurred\n+     * - otherwise: a vector of\n+     *   - std::nullopt: invalid message received\n+     *   - otherwise: a CNetMessage retrieved\n+     */\n+    using InteractResult = std::optional<std::vector<std::optional<CNetMessage>>>;\n+\n+    /** Send/receive scheduled/available bytes and messages.\n+     *\n+     * This is the only function that interacts with the transport being tested; everything else is\n+     * scheduling things done by Interact(), or processing things learned by it.\n+     */\n+    InteractResult Interact()\n+    {\n+        std::vector<std::optional<CNetMessage>> ret;\n+        while (true) {\n+            bool progress{false};\n+            // Send bytes from m_to_send to the transport.\n+            if (!m_to_send.empty()) {\n+                Span<const uint8_t> to_send = Span{m_to_send}.first(1 + InsecureRandRange(m_to_send.size()));\n+                size_t old_len = to_send.size();\n+                if (!m_transport.ReceivedBytes(to_send)) {\n+                    return std::nullopt; // transport error occurred\n+                }\n+                if (old_len != to_send.size()) {\n+                    progress = true;\n+                    m_to_send.erase(m_to_send.begin(), m_to_send.begin() + (old_len - to_send.size()));\n+                }\n+            }\n+            // Retrieve messages received by the transport.\n+            if (m_transport.ReceivedMessageComplete() && (!progress || InsecureRandBool())) {\n+                bool reject{false};\n+                auto msg = m_transport.GetReceivedMessage({}, reject);\n+                if (reject) {\n+                    ret.push_back(std::nullopt);\n+                } else {\n+                    ret.push_back(std::move(msg));\n+                }\n+                progress = true;\n+            }\n+            // Enqueue a message to be sent by the transport to us.\n+            if (!m_msg_to_send.empty() && (!progress || InsecureRandBool())) {\n+                if (m_transport.SetMessageToSend(m_msg_to_send.front())) {\n+                    m_msg_to_send.pop_front();\n+                    progress = true;\n+                }\n+            }\n+            // Receive bytes from the transport.\n+            const auto& [recv_bytes, _more, _msg_type] = m_transport.GetBytesToSend(!m_msg_to_send.empty());\n+            if (!recv_bytes.empty() && (!progress || InsecureRandBool())) {\n+                size_t to_receive = 1 + InsecureRandRange(recv_bytes.size());\n+                m_received.insert(m_received.end(), recv_bytes.begin(), recv_bytes.begin() + to_receive);\n+                progress = true;\n+                m_transport.MarkBytesSent(to_receive);\n+            }\n+            if (!progress) break;\n+        }\n+        return ret;\n+    }\n+\n+    /** Expose the cipher. */\n+    BIP324Cipher& GetCipher() { return m_cipher; }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const uint8_t> data)\n+    {\n+        m_to_send.insert(m_to_send.end(), data.begin(), data.end());\n+    }\n+\n+    /** Schedule bytes to be sent to the transport. */\n+    void Send(Span<const std::byte> data) { Send(MakeUCharSpan(data)); }\n+\n+    /** Schedule our ellswift key to be sent to the transport. */\n+    void SendKey() { Send(m_cipher.GetOurPubKey()); }\n+\n+    /** Schedule specified garbage to be sent to the transport. */\n+    void SendGarbage(Span<const uint8_t> garbage)\n+    {\n+        // Remember the specified garbage (so we can use it for constructing the garbage\n+        // authentication packet).\n+        m_sent_garbage.assign(garbage.begin(), garbage.end());\n+        // Schedule it for sending.\n+        Send(m_sent_garbage);\n+    }\n+\n+    /** Schedule garbage (of specified length) to be sent to the transport. */\n+    void SendGarbage(size_t garbage_len)\n+    {\n+        // Generate random garbage and send it.\n+        SendGarbage(g_insecure_rand_ctx.randbytes<uint8_t>(garbage_len));\n+    }\n+\n+    /** Schedule garbage (with valid random length) to be sent to the transport. */\n+    void SendGarbage()\n+    {\n+         SendGarbage(InsecureRandRange(V2Transport::MAX_GARBAGE_LEN + 1));\n+    }\n+\n+    /** Schedule a message to be sent to us by the transport. */\n+    void AddMessage(std::string m_type, std::vector<uint8_t> payload)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.m_type = std::move(m_type);\n+        msg.data = std::move(payload);\n+        m_msg_to_send.push_back(std::move(msg));\n+    }\n+\n+    /** Expect ellswift key to have been received from transport and process it.\n+     *\n+     * Many other V2TransportTester functions cannot be called until after ReceiveKey() has been\n+     * called, as no encryption keys are set up before that point.\n+     */\n+    void ReceiveKey()\n+    {\n+        // When processing a key, enough bytes need to have been received already.\n+        BOOST_CHECK(m_received.size() >= EllSwiftPubKey::size());\n+        // Initialize the cipher using it (acting as the opposite side of the tested transport).\n+        m_cipher.Initialize(MakeByteSpan(m_received).first(EllSwiftPubKey::size()), !m_test_initiator);\n+        // Strip the processed bytes off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + EllSwiftPubKey::size());\n+    }\n+\n+    /** Schedule an encrypted packet with specified content/aad/ignore to be sent to transport\n+     *  (only after ReceiveKey). */\n+    void SendPacket(Span<const uint8_t> content, Span<const uint8_t> aad = {}, bool ignore = false)\n+    {\n+        // Use cipher to construct ciphertext.\n+        std::vector<std::byte> ciphertext;\n+        ciphertext.resize(content.size() + BIP324Cipher::EXPANSION);\n+        m_cipher.Encrypt(MakeByteSpan(content), MakeByteSpan(aad), ignore, ciphertext);\n+        // Schedule it for sending.\n+        Send(ciphertext);\n+    }\n+\n+    /** Schedule garbage terminator and authentication packet to be sent to the transport (only\n+     *  after ReceiveKey). */\n+    void SendGarbageTermAuth(size_t garb_auth_data_len = 0, bool garb_auth_ignore = false)\n+    {\n+        // Generate random data to include in the garbage authentication packet (ignored by peer).\n+        auto garb_auth_data = g_insecure_rand_ctx.randbytes<uint8_t>(garb_auth_data_len);\n+        // Schedule the garbage terminator to be sent.\n+        Send(m_cipher.GetSendGarbageTerminator());\n+        // Schedule the garbage authentication packet to be sent.\n+        SendPacket(/*content=*/garb_auth_data, /*aad=*/m_sent_garbage, /*ignore=*/garb_auth_ignore);\n+    }\n+\n+    /** Schedule version packet to be sent to the transport (only after ReceiveKey). */\n+    void SendVersion(Span<const uint8_t> version_data = {}, bool vers_ignore = false)\n+    {\n+        SendPacket(/*content=*/version_data, /*aad=*/{}, /*ignore=*/vers_ignore);\n+    }\n+\n+    /** Expect a packet to have been received from transport, process it, and return its contents\n+     *  (only after ReceiveKey). By default, decoys are skipped. */\n+    std::vector<uint8_t> ReceivePacket(Span<const std::byte> aad = {}, bool skip_decoy = true)\n+    {\n+        std::vector<uint8_t> contents;\n+        // Loop as long as there are ignored packets that are to be skipped.\n+        while (true) {\n+            // When processing a packet, at least enough bytes for its length descriptor must be received.\n+            BOOST_CHECK(m_received.size() >= BIP324Cipher::LENGTH_LEN);\n+            // Decrypt the content length.\n+            size_t size = m_cipher.DecryptLength(MakeByteSpan(Span{m_received}.first(BIP324Cipher::LENGTH_LEN)));\n+            // Check that the full packet is in the receive buffer.\n+            BOOST_CHECK(m_received.size() >= size + BIP324Cipher::EXPANSION);\n+            // Decrypt the packet contents.\n+            contents.resize(size);\n+            bool ignore{false};\n+            bool ret = m_cipher.Decrypt(\n+                MakeByteSpan(Span{m_received}.first(size + BIP324Cipher::EXPANSION).subspan(BIP324Cipher::LENGTH_LEN)),\n+                aad, ignore, MakeWritableByteSpan(contents));\n+            BOOST_CHECK(ret);\n+            // Strip the processed packet's bytes off the front of the receive buffer.\n+            m_received.erase(m_received.begin(), m_received.begin() + size + BIP324Cipher::EXPANSION);\n+            // Stop if the ignore bit is not set on this packet, or if we choose to not honor it.\n+            if (!ignore || !skip_decoy) break;\n+        }\n+        return contents;\n+    }\n+\n+    /** Expect garbage, garbage terminator, and garbage auth packet to have been received, and\n+     *  process them (only after ReceiveKey). */\n+    void ReceiveGarbage()\n+    {\n+        // Figure out the garbage length.\n+        size_t garblen;\n+        for (garblen = 0; garblen <= V2Transport::MAX_GARBAGE_LEN; ++garblen) {\n+            assert(m_received.size() >= garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+            auto term_span = MakeByteSpan(Span{m_received}.subspan(garblen, BIP324Cipher::GARBAGE_TERMINATOR_LEN));\n+            if (term_span == m_cipher.GetReceiveGarbageTerminator()) break;\n+        }\n+        // Copy the garbage to a buffer.\n+        std::vector<uint8_t> garbage(m_received.begin(), m_received.begin() + garblen);\n+        // Strip garbage + garbage terminator off the front of the receive buffer.\n+        m_received.erase(m_received.begin(), m_received.begin() + garblen + BIP324Cipher::GARBAGE_TERMINATOR_LEN);\n+        // Process the expected garbage authentication packet. Such a packet still functions as one\n+        // even when its ignore bit is set to true, so we do not skip decoy packets here.\n+        ReceivePacket(/*aad=*/MakeByteSpan(garbage), /*skip_decoy=*/false);\n+    }\n+\n+    /** Expect version packet to have been received, and process it (only after ReceiveKey). */\n+    void ReceiveVersion()\n+    {\n+        auto contents = ReceivePacket();\n+        // Version packets from real BIP324 peers are expected to be empty, despite the fact that\n+        // this class supports *sending* non-empty version packets (to test that BIP324 peers\n+        // correctly ignore version packet contents).\n+        BOOST_CHECK(contents.empty());\n+    }\n+\n+    /** Expect application packet to have been received, with specified short id and payload.\n+     *  (only after ReceiveKey). */\n+    void ReceiveMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 1);\n+        BOOST_CHECK(ret[0] == short_id);\n+        BOOST_CHECK(Span{ret}.subspan(1) == payload);\n+    }\n+\n+    /** Expect application packet to have been received, with specified 12-char message type and\n+     *  payload (only after ReceiveKey). */\n+    void ReceiveMessage(const std::string& m_type, Span<const uint8_t> payload)\n+    {\n+        auto ret = ReceivePacket();\n+        BOOST_CHECK(ret.size() == payload.size() + 13);\n+        BOOST_CHECK(ret[0] == 0);\n+        for (unsigned i = 0; i < 12; ++i) {\n+            if (i < m_type.size()) {\n+                BOOST_CHECK(ret[1 + i] == m_type[i]);\n+            } else {\n+                BOOST_CHECK(ret[1 + i] == 0);\n+            }\n+        }\n+        BOOST_CHECK(Span{ret}.subspan(13) == payload);\n+    }\n+\n+    /** Schedule an encrypted packet with specified message type and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(std::string mtype, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of 0x00 + 12-byte message type + payload.\n+        std::vector<uint8_t> contents(13 + payload.size());\n+        std::copy(mtype.begin(), mtype.end(), reinterpret_cast<char*>(contents.data() + 1));\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 13);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Schedule an encrypted packet with specified short message id and payload to be sent to\n+     *  transport (only after ReceiveKey). */\n+    void SendMessage(uint8_t short_id, Span<const uint8_t> payload)\n+    {\n+        // Construct contents consisting of short_id + payload.\n+        std::vector<uint8_t> contents(1 + payload.size());\n+        contents[0] = short_id;\n+        std::copy(payload.begin(), payload.end(), contents.begin() + 1);\n+        // Send a packet with that as contents.\n+        SendPacket(contents);\n+    }\n+\n+    /** Introduce a bit error in the data scheduled to be sent. */\n+    void Damage()\n+    {\n+        m_to_send[InsecureRandRange(m_to_send.size())] ^= (uint8_t{1} << InsecureRandRange(8));\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(v2transport_test)\n+{\n+    // A mostly normal scenario, testing a transport in initiator mode.\n+    for (int i = 0; i < 10; ++i) {\n+        V2TransportTester tester(true);\n+        auto ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.SendKey();\n+        tester.SendGarbage();\n+        tester.ReceiveKey();\n+        tester.SendGarbageTermAuth();\n+        tester.SendVersion();\n+        ret = tester.Interact();\n+        BOOST_CHECK(ret && ret->empty());\n+        tester.ReceiveGarbage();\n+        tester.ReceiveVersion();\n+        auto msg_data_1 = g_insecure_rand_ctx.randbytes<uint8_t>(InsecureRandRange(100000));",
      "path": "src/test/net_tests.cpp",
      "position": 343,
      "original_position": 326,
      "commit_id": "db9888feec48c6220a2fcf92865503bbbdab02a4",
      "original_commit_id": "8bd5aa1a1084c5f4c34cba85506661338e8e91ea",
      "in_reply_to_id": 1313245167,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Opened https://github.com/bitcoin/bitcoin/issues/28466 so that this does not get forgotten.",
      "created_at": "2023-09-13T07:50:33Z",
      "updated_at": "2023-09-13T07:50:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28196#discussion_r1324117579",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1324117579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28196"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1340,
      "original_line": 1340,
      "side": "RIGHT"
    }
  ]
}